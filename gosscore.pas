unit gosscore;
//Note: To compile program correctly the following compiler conditionals are
//      required (Delphi 3 > Project > Options > Directories/Conditionals):
//      D3 jpeg mm chimes gif ico

//#######################################################################################################################################
//## Global Compiler Directive Usage ####################################################################################################
//-- Delphi 3 --
//Select "Project > Options" from dialog select "Directories/Conditionals" and select/enter ONE of the compiler directives listed below
//into the "Conditional defines" drop down box:
//
// "D3"       = Delphi 3 + Windows 32bit support
// "D10"      = Delphi 10 + Windows and Android 32bit support (unfinished)
// "DEBUG"    = System wide debugging systems, slows down performance but displays integrated debugging information
// "mm"       = Engage "gossmm" multimedia support (midi / wave / snd32 / media support)
// "chimes"   = Engage chimes support -> Note: requires "mm" support as well
// "jpeg"     = Engage jpeg image Support
// "gif"      = Engage gif image Support
// "ico"      = Engage ico/cur/ani image Support
// "tbt"      = Engage tbt support - TBT Encryption/Decryption - 13jun2022
// "man"      = Engage management "man__*" class of procs for managing objects automatically in a pdlobject array - 09feb2022
// "mfile"    = Engage memfile/link1 "memfile__*" and "link1*" class of procs for linking to external programs using memory mapped files etc
// "storeapp" = Engage store app mode (if not used, program checks for "sys-<programname>.app" in settings folder to trigger app mode - 02may2022
// "plus"     = Engage plus support (programplus=true) for multi-tab versions - 27jun2022
  //## Debugging switches #################################################################################################################
//{$D+}
//{$L+}
//{$Y+}
//#######################################################################################################################################


//## D3 Complier History -> Known errors and fatal failings #############################################################################
//ERROR: Unknown exception error -> sometimes consistent, other times no sign of an error!!!!!!!!!!!!

//ERROR: 30jul2021 -> FATAL Compiler error MAP257 or MA234 or DBG2428 on Delphi 4 Pro or Delphi 7 Enterprise
//                    and RANDOM error messaging/program crash/failure on Delphi 3 due to one or more corrupted
//                    return codes.  Proper return code is (13+10) but the error is caused when there is one or more
//                    (10+10) style return codes -> this really messes Delphi's compiler up.  Simply load the .pas
//                    file into "Just Does Text" and save over the top using (13+10) Windows return codes.  Delphi will
//                    now compile the program properly and the program will run without crashing or unpredictable results.
//                    Use "low__checkfilebadchars('c:\123blaiz\layers\layers1.pas');" to check source files.
//#######################################################################################################################################


//#######################################################################################################################################
//## Name......... Gossamer - lightweight Windows / Android 32bit GUI system
//## Type......... System Core -> replaces 98%+ of host OS and host programming language functions and API support load
//## Desciption... Replaces the "Blaiz Enterprises Software Platform v4.0" R&D platform of User Management
//## Items........ 25
//## Version...... 4.00.32446 (+2955)
//## Date......... 15nov2022, 06nov2022, 11oct2022, 28sep2022, 05jul2022, 29jun2022, 14jun2022, 31may2022, 14may2022, 30apr2022, 30mar2022, 27feb2022, 08feb2022, 31jan2021, 30dec2021, 19dec2021, 30sep2021, 29aug2021, 09aug2021, 27jul2021, 07jul2021, 20jun2021, 02jun2021, 30may2021, 12may2021, 10may2021, 30apr2021, 19apr2021, 14apr2021, 03apr2021, 31mar2021, 20mar2021, 08mar2021, 26feb2021, 01feb2021, 28jan2021, 11oct2020, 25sep2020, 07sep2020, 26aug2020, 22aug2020, 28jul2020, 23may2020, 10may2020
//## Lines........ 99,952 [74,555 lines without multimedia support - 19feb2022]
//## Translation.. No Support for Languages other than English
//## Fast Timer .. Non-threaded, high-speed timer - 07jul2021 (updated more paint procs and low level system drawing procs)
//##
//## ==========================================================================================================================================================================================================================
//## | Name                   | Hierarchy         | Version   | Date        | Desciption
//## |------------------------|-------------------|-----------|-------------|--------------------------------------------------------
//## | low level procs        | n/a               | 1.00.1600 | 11oct2022   | 27sep2022, 14may2022, 21may2020, Collection of basic procedures and functions to support platform and it's controls etc
//## | mis class of procs     | n/a               | 1.00.800  | 22may2022   | 26apr2022, 23may2020, Multi-image subsystem -> work with different image handlers
//## | tbasicprg1             | tobject           | 1.00.023  | 05mar2022   | 01jan2021, 05oct2020, Root level program outline
//## | tbasicprg2             | tbasicprg2        | 1.00.020  | 05oct2020   | Semi-managed program outline -> manages "system:tbasicsystem" and "rootwin:tbasicscroll" on host "xhost:tform1"
//## | tobjectex              | tobject           | 1.00.001  | 10may2020   | Reserved - to track number of objects in use
//## | tbasicthreadstop       | tthread           | 1.00.050  | 24may2021   | Simple outline of a stoppable thread - safe to stop->shutdown using "freeobj()"
//## | tbasictimer            | tthread           | 1.00.450  | 10may2021   | High speed (15ms) timer with thread safe locking and optional synchronize mode for easy threaded timer support
//## | tbitmapenhanced        | tbitmap           | 1.00.020  | 10may2020   | Supports additional information for animation and reading/writing formats
//## | tstr8                  | tobject           | 1.00.680  | 20mar2022   | 27dec2021, 28jul2021, 30apr2021, 14feb2021, 28jan2021, 21aug2020, 8bit binary string replacement for Delphi 10's lack of native 8bit string support
//## | tvars8                 | tobject           | 1.00.220  | 31jan2022   | 02jan2022, 16aug2020, 8bit binary replacement for "tdynamicvars" and "tdynamictext" -> simple, fast, and lighter with full binary support (no string used)
//## | tmask8                 | tobject           | 1.00.360  | 07jul2021   | 10may2020, Rapid 8bit graphic mask for tracking onscreen window areas (square and rounded) at speed: WRITE: 101x[1920x1080] mask redraws in under 500ms ~ 5ms/mask and READ: 101x[1920x1080] mask scans in under 1,100ms ~11ms/mask on Intel Atom 1.1Ghz
//## | tbasicsystem           | tobject           | 1.00.2682 | 20may2022   | 27mar2022, Updated onaccept proc for deep drag and drop support, 26feb2022, Fixed ibuffer.w/h mismatch with mustmask - 21sep2021, 29aug2021, 28jul2021, 07jul2021, 18jun2021, 29may2021, 14apr2021, 03apr2021, 08mar2021, 25feb2021, 11oct2020, 28jul2020, 20may2020, GUI manager - handles all GUI related work -> connect to a form easily with little code on the form side required
//## | tbasiccontrol          | tobject           | 1.00.970  | 12jan2022   | 09sep2021, 27mar2021, 11oct2020, 20may2020, 12apr2020, 14mar2020, flicker free base control with buffer, _ontimer and _onpaint support
//## | tbasichead             | tbasiccontrol     | 1.00.653  | 06nov2022   | 11oct2022, 16sep2022, 30apr2022, 28may2021, 26apr2021, 27mar2021, 24feb2021, 06oct2020, 12apr2020,14mar2020, form head
//## | tbasichelp             | tbasiccontrol     | 1.00.082  | 12apr2020   | 25mar2020, realtime help scroller
//## | tbasicscrollbar        | tbasiccontrol     | 1.00.470  | 04oct2022   | 03mar2022, 08feb2022, 25jul2021, 13apr2020, streamlined scrollbar with full and partial keyboard/wheel handling -> can pass critical handling to parent control for consistent operation
//## | tbasicscroll           | tbasiccontrol     | 1.00.525  | 04oct2022   | 02jun2021, 29may2021, 08mar2021, 25feb2021, 14aug2020, 05apr2020, vertical scrollbox
//## | tbasiccols             | tbasiccontrol     | 1.00.300  | 07mar2022   | 26feb2021, Multi-column handler - supports upto 10 columns
//## | tbasiccolor            | tbasiccontrol     | 1.00.350  | 01mar2021   | Color picker with optional shade ranges
//## | tbasiccolors           | tbasiccontrol     | 1.00.540  | 15mar2022   | 19mar2021, Multi-color picker with system and static colors support
//## | tbasicsetcolor         | tbasicscroll      | 1.00.700  | 01mar2021   | Advanced color picker and support for "popcolor" dlg
//## | tbasicsplash           | tbasicscroll      | 1.00.488  | 27apr2022   | style=2=IconArt, 24feb2022, 21sep2021, 18jun2021, 05oct2020, System splash screen and about window
//## | tbasicinfo             | tbasiccontrol     | 1.00.130  | 13apr2020   | 16mar2020, simple information list
//## | tbasicstatus           | tbasiccontrol     | 1.00.130  | 29dec2021   | 07jul2021, 02jun2021, 05oct2020, 12apr2020, 15mar2020, simple statusbar
//## | tbasictitle            | tbasiccontrol     | 1.00.052  | 24feb2021   | 11oct2020, Standard title -> supports both small and large modes -> exactly matches tbasictoolbar.maketitle() display output
//## | tbasictoolbar          | tbasiccontrol     | 1.00.2150 | 26sep2022   | 28jun2022, 25mar2022, 19dec2021, 21sep2021, 07jul2021, 30may2021, 27mar2021, 21feb2021, 11oct2020, 22sep2020, 23apr2020, 29mar2020, advanced toolbar with "title + links" support
//## | tbasictick             | tbasiccontrol     | 1.00.170  | 11apr2020   | 06apr2020, simple tick
//## | tbasicedit             | tbasiccontrol     | 1.00.1101 | 19jun2022   | 03mar2022, 31mar2021, 07apr2020, advanced edit box, supports makers for edit/password/drop/dropstatic/progress -> simulates 5 controls in one with many useful features and functions
//## | tbasicjump             | tbasiccontrol     | 1.00.066  | 06mar2022   | 21feb2022, 22mar2021, 10mar2021, realtime jumpto panel for millisecond precision position jumping for song/midi playback
//## | tbasicmenu             | tbasiccontrol     | 1.00.2810 | 28sep2022   | 20mar2022, 26feb2022, 08jun2021, 27mar2021, 11oct2020, 13apr2020, advanced menu handler
//## | tbasicnav              | tbasiccontrol     | 1.00.1085 | 11oct2022   | 27sep2022, 28jun2022, 22may2022, 23mar2022, 12jan2022, 09aug2021, 28jul2021, 18jun2021, 06apr2021, 25mar2021, 22sep2020, Advanced, multi-purpose favouries/files/folders/open/save navigation control
//## | low__wordcore          | procedure         | 1.00.4967 | 27sep2022   | 05jul2022, 29jun2022, 02may2022, 22apr2022 09mar2022, 05feb2022, 11jan2022, 28dec2021, 28aug2021, 15may2021, 31mar2021, 12mar2021, 11oct2020, 26aug2020, 29feb2020 Ultra-low-level text box subsystem for 1) plain text (txt), enhanced text with styles (bwd) and advanced text (bwp) with image support, text styles, fonts, colors and text alignment
//## | tbasicbwp              | tbasiccontrol     | 1.00.460  | 04oct2022   | 24sep2022, 18jun2022, 29may2021, 12mar2021, gui front-end for low__wordcore text box -> supports txt,bwd and bwp text documents - original IP of BlaizEnterprises.com
//## | tbasicint              | tbasiccontrol     | 1.00.425  | 12nov2022   | 27mar2022, 27feb2022, 28jul2021, 27mar2021, 26feb2021, 17aug2020, Fast and responsive slide bar -> compact and easy to use
//## | tbasicset              | tbasiccontrol     | 1.00.275  | 27mar2022   | 30mar2021, 18aug2020, Upto 32 "yes/no" slots with boolean in/out for each slot -> compact multiple option chooser control
//## | tbasicsel              | tbasiccontrol     | 1.00.153  | 18sep2022   | 27mar2022, 29aug2021, 27mar2021, 19aug2020, Upto 32 "choose" positions with a value range of 0..31 -> each choice has help/caption for select a value range for a specific setting e.g. Text Feather 0=off, 1=mild, 2=strong
//## | tdynamiclist           | tbasiccontrol     | 1.00.112  | 07feb2021   | 08aug2017, Base class for dynamic arrays/lists of differing structures: byte, word, integer, currency, pointer. Can be useed with user-defined records/structures/objects
//## | tdynamicvars           | tobject           | 1.00.185  | 15jun2019   | 20oct2018, 13apr2018, 04JUL2013, Dynamic set of named variables with rapid lookup system (e.g. fred=some value)
//## | tdynamictext           | tobject           | 1.00.070  | 21dec2019   | 19SEP2010, Name-Value variables (single lines) for client-server communication
//## | tmainhelp              | tbasicscroll      | 1.00.233  | 27apr2022   | 30mar2022, 08jan2022, 22sep2021, 24jul2021, 29may2021, 26aug2020, Floating help window with BWP file support
//## | tbasicmidi             | tobjectex         | 1.00.5370 | 16mar2022   | 23feb2022, 30sep2021, 21may2021, 21may2021: thread safe version -> all attempts to use high level thread safe locking and syncing failed, tried Windows message qeueues also failed, instead built a managed thread system for rock-soild thread communication via "systhread__start" family of procs - 19feb2022, 10may2021, error hunt begins - 20apr2021, 15apr2021, 04apr2021, 30mar2021, 22feb2021, Realtime midi playback (format 0/1 in tick mode only) for .mid, .midi and .rmi
//## | tbasicchimes           | tobjectex         | 1.00.2000 | 15nov2022   | Centralised system chiming + audio alerts support via midi
//## | tsnd32                 | tobjectex         | 1.00.220  | 30sep2021   | 14jul2021, 32bit slot based audio stream storage and manipulation handler
//## | tplaylist              | tobjectex         | 1.00.350  | 20mar2022   | Integrated m3u playlist manager - syncs with list for seamless playlist handling
//## | taudiobasic            | tobjectex         | 1.00.300  | 19feb2022   | 14apr2017, Playback and Recording systems now fully operational as at 25JUN2009
//## | tbasicimage            | tobject           | 1.00.157  | 09may2022   | 27jul2021, 25jan2021, ??jan2020 Lightweight, fast, variable bit system independent image handler
//## | tbmp                   | tobject           | 1.00.120  | 05feb2022   | 08jun2021, 25jan2021, ??jan2020 Bitmap to system image conversion and handler with Android and Windows lock/unlock support for Mobile phone and 32bit support
//## | tframe                 | tobject           | 1.00.450  | 01feb2021   | Enhanced framer drawer, compatible with Framer Plus frames (*.fps)
//## | low__nav               | n/a               | 1.00.230  | 25mar2021   | 20feb2021, Advanced file list/sorting/organised function
//## | plus__* support        | family of procs   | 1.00.050  | 27jun2022   | Collection of proc for swift multi-tab "PLUS" version support
//## ==========================================================================================================================================================================================================================
//##
//## Verification: (none) 10may2020
//## Language NOT enabled
//## Copyright (c) 1997-2022 Blaiz Enterprises / BlaizEnterprises.com
//#######################################################################################################################################

interface

uses
{$ifdef D3}
   Windows, Forms, Controls, SysUtils, Classes, ShellApi, ShlObj, Graphics, Clipbrd,
   messages, math, extctrls{timer}, filectrl{tdrivetype}, ActiveX, ComObj, registry,
   printers, syncobjs, {$ifdef jpeg}jpeg,{$endif} gossdat;//23feb2022
{$endif}
{$ifdef D10}
   System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,
   FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.surfaces,
   system.dateutils, gossdat;
{$endif}

const
//special program support ------------------------------------------------------
{$ifdef plus}
   programplus=true;
   programpluscount=7;
   programplusmax=programpluscount-1;
{$else}
   programplus=false;
   programpluscount=1;
   programplusmax=programpluscount-1;
{$endif}

   //.Program Name -> used in code for FILENAMES and WEB addresses -> website always lowercase, files and folders as is -> set as required -> e.g. "Synthesiser"
   programwebname=programname;//'Secure Message';
   programwebname_check=programname_check;//16771570;

//debug support ----------------------------------------------------------------
{$ifdef debug}
   system_debug         =true;//turn on system wide debug systems -> slows down performance and counts critical controls and other vital information sets - 06may2021
   system_debugFAST     =true;//false;//true;//force GUI to continuously paint at full speed and timers to run at full pace - 06may2021
   system_debugRESIZE   =false;//true;//randomly resize the main window to stress it
   system_debugFASTSTAT =true;//false;//false=draw dbstatus() slowly "1 fps" on screen, true=at high speed
{$else}
   system_debug         =false;
   system_debugFAST     =false;
   system_debugRESIZE   =false;
   system_debugFASTSTAT =false;
{$endif}

//jpeg support -----------------------------------------------------------------
{$ifdef jpeg}
   system_jpeg          =true;
{$else}
   system_jpeg          =false;
{$endif}

{$ifdef tbt}
  tbtFeedback =0;
  tbtEncode   =1;
  tbtDecode   =2;
{$endif}


   //security checkid 1 of 2 -> put it here to space it out inside the EXE - harder to track - 11oct2022
   programcode_checkid:array[0..103] of byte=(44,50,108,119,16,181,130,87,73,239,74,55,206,75,168,25,115,142,124,70,204,9,12,103,127,198,110,246,163,40,238,47,31,113,70,136,56,48,31,98,177,159,88,124,54,81,211,78,232,199,238,108,88,216,215,124,53,243,96,117,127,171,11,37,13,18,112,55,162,217,46,56,250,68,10,91,127,62,253,234,126,79,67,179,44,42,165,221,191,11,177,229,107,41,121,207,15,238,18,165,27,91,72,169);

   //system references
   WM_USER              =$0400;//anything below this is reserved
   WM_MULTIMEDIA_TIMER  =WM_USER + 127;
   mmsyst               ='winmm.dll';
   kernel32             ='kernel32.dll';
   user32               ='user32.dll';

   //max's
   maxcore        =999;//number of GUI controls the tbasicsystem can handle - 28jun2022
   minwinsize     =32;//32px
   onemb          =1024000;
   maxheight      =1000000;//1m -> used for max clientheight calculations - 21feb2021
   maxpointer     =(maxint div sizeof(pointer))-1;
   maxpixel       =maxint div 50;//safe even for large color sets such as "tcolor96" - 29apr2020
   maxrow         =(high(word)*10);//safe range (0..655,360) - 11OCT2008
   maxword        =high(word);
   minint         =low(longint);
   mincur         =-922337203685477.5807;//note: 0.5808 exceeds range
   maxcur         =922337203685477.5807;
   maxcmp32       =4294967294.0;//actual max is 4294967295, but ".0" rounds it up, hence the "..294.0" - 16dec2016
   max64          = 999999999999999999.0;//18 whole digits - 1 million terabytes
   min64          =-999999999999999999.0;//18 whole digits - 1 million terabytes
   clnone         =255+(255*256)+(255*256*256)+(31*256*256*256);
   clTopLeft      =-1;
   osRed          =0;
   osGreen        =256;
   osBlue         =256*256;
   rcode          =#13#10;//Warning: Unicode string under Delphi 10
   pcSymSafe      ='-';//used to replace unsafe filename characters
   pcRefsep       ='_';
   systepHeight20 =20;//standard tep height - 19mar2021
   teaMaxsize20x20=1613;//400 colors at 20w x 20h = 1,612 bytes - 06apr2021
   tepSysstart20  =100000;//start of dynamically allocated TEA's (max dimensions 20w x 20h) - 06apr2021
   tepSysstop20   =199999;//end of dynamically allocated TEA's  -> total of 100,000 images allowed
   //system links - 29mar2021
   syslink_none      =0;
   syslink_gossmm    =1;
   syslink_max       =1;

   //System Color Names
   //.reference
   cnCustomLimit  =10;
   cnFileEXT      ='bcs';//Blaiz Color Scheme
   //.common
   cnFrame        =1;
   cnFrame2       =2;
   cnMin          =1;
   cnMax          =2;
   //.standard colors
   cnBack1        =50;
   cnBorder1      =51;
   cnHigh1        =52;
   cnHover1       =53;
   cnText1        =54;
   cnTexthigh1    =55;
   cnTextdis1     =56;
   cnDis1         =57;
   cnDisbr1       =58;
   cnMin1         =50;
   cnMax1         =58;
   //.title colors
   cnBack2        =100;
   cnBorder2      =101;
   cnHigh2        =102;
   cnHover2       =103;
   cnText2        =104;
   cnTexthigh2    =105;
   cnTextdis2     =106;
   cnDis2         =107;
   cnDisbr2       =108;
   cnMin2         =100;
   cnMax2         =108;
   //.special colors
   cnsSpecialStart=200;
   cnsFrame       =200;
   cnsTitle       =201;
   cnsStandard    =202;
   cnsAllinone    =203;
   cnsDark_light  =204;
   cnsLight_dark  =205;

   //Tab column alignment
   taL            =0;//left
   taC            =1;//center
   taR            =2;//right
   taMax          =2;
   tbFontheight   =14;//base fontheight by which all tabs are scaled from - 24feb2021
   //Tab Codes
   tbnone              =0;
   tbL100_L            =1;
   tbL100_L120         =2;
   tbL100_R120         =3;
   tbL100_L500         =4;
   tbL120_L120_L300    =5;
   tbL120_R120_L300    =6;
   tbL250_L300         =7;
   tbL250_L400         =8;
   tbL250_R100_L300    =9;
   tbMax               =9;
   tbDefault           =1;
   //File Extension Codes
   fesep          =';';//main separator -> "bat;bmp;exe;txt+bwd+bwp;ico;"
   fesepX         ='+';//sub-separator for instances where multiple extensions are specified for a single type e.g. "txt+bwd+bwp"
   feany          ='*';//special
   febat          ='bat';
   fec2p          ='c2p';//Claude 2 product - 12jan2022
   fec2v          ='c2v';//Claude 2 values - 24jan2022
   feini          ='ini';//24jan2022
   fetxt          ='txt';
   febwd          ='bwd';
   febwp          ='bwp';
   fesfef         ='sfef';//small file encrypter file
   fehtml         ='html';
   fexml          ='xml';
   fetep          ='tep';
   fetea          ='tea';
   febmp          ='bmp';
   fegif          ='gif';
   fejpg          ='jpg';
   fejif          ='jif';
   fejpeg         ='jpeg';
   fepng          ='png';
   feico          ='ico';//15feb2022
   fecur          ='cur';
   feani          ='ani';
   febcs          ='bcs';//blaiz color scheme
   febvid         ='bvid';//basic video
   feAU22         ='au22';//raw audio
   feAU44         ='au44';//raw audio
   feAU48         ='au48';//raw audio
   fevmt          ='vmt';//video magic track - 06jul2021
   fevmp          ='vmp';//video magic project - 06jul2021
   femjpeg        ='mjpeg';//motion jpeg - supported by VLC - 20jun2021
   feabr          ='abr';//Abra Cadabra project - 01aug2021
   feaccp         ='accp';//Animated Cursor Creator Project - 07feb2022
   feAlarms       ='alarms';//08mar2022
   feReminders    ='reminders';//09mar2022
   feM3U          ='m3u';//20mar2022 - playlist
   feFootnote     ='footnote';//21mar2022
   feCursorScript ='cscript';//17may2022
   //.combinations
   feallfiles     =feany;
   fealldocs      =fetxt+fesepX+febwd+fesepX+febwp;
   feallimgs      =fepng+fesepX+{$ifdef gif}fegif+fesepX+{$endif} {$ifdef jpeg}fejpg+fesepX+fejif+fesepX+fejpeg+fesepX+{$endif} febmp+fesepX+fetea;//no GIF support as of yet - 12apr2021
   feallcurs      =fecur+fesepX+feani;
   feallcurs2     =fecur+fesepX+feani{$ifdef ico}+fesepX+feico{$endif}+fesepX+fepng{$ifdef gif}+fesepX+fegif{$endif};//22may2022
   fealljpgs      ={$ifdef jpeg}fejpg+fesepX+fejif+fesepX+fejpeg+{$endif} '';
   //Preformatted File Extension Codes
   peany          =feany+fesep;//special
   pebat          =febat+fesep;
   pec2p          =fec2p+fesep;
   pec2v          =fec2v+fesep;
   peini          =feini+fesep;
   petxt          =fetxt+fesep;
   pebwd          =febwd+fesep;
   pebwp          =febwp+fesep;
   pesfef         =fesfef+fesep;
   pexml          =fexml+fesep;
   pehtml         =fehtml+fesep;
   petep          =fetep+fesep;
   petea          =fetea+fesep;
   pebmp          =febmp+fesep;
   pegif          =fegif+fesep;
   pejpg          =fejpg+fesep;
   pejif          =fejif+fesep;
   pejpeg         =fejpeg+fesep;
   pepng          =fepng+fesep;
   peico          =feico+fesep;
   pecur          =fecur+fesep;
   peani          =feani+fesep;
   pebvid         =febvid+fesep;
   peAU44_48_22   =feAU44+fesep+feAU48+fesep+feAU22;
   pevmt          =fevmt+fesep;
   pevmp          =fevmp+fesep;
   peabr          =feabr+fesep;
   peaccp         =feaccp+fesep;
   peAlarms       =feAlarms+fesep;//08mar2022
   peReminders    =feReminders+fesep;//09mar2022
   peM3U          =feM3U+fesep;//20mar2022
   peFootnote     =feFootnote+fesep;//21mar2022
   peCursorScript =feCursorScript+fesep;//17may2022
   pemjpeg        =femjpeg+fesep;
   peallfiles     =feallfiles+fesep;
   pealldocs      =fealldocs+fesep;
   peallimgs      =feallimgs+fesep;
   peallcurs      =feallcurs+fesep;
   peallcurs2     =feallcurs2+fesep;
   pealljpgs      =fealljpgs+fesep;
   pebcs          =febcs+fesep;

   //Color Format
   cfNone         =0;
   cfRGB24        =1;
   cfBGR24        =2;
   cfRGBA32       =3;
   cfBGRA32       =4;
   cfRGB16        =5;//16bit color
   cfRGB15        =6;//15bit color
   cfRGB8         =7;//8bit grey/color
   //Popmenu Styles
   pmNormal       =0;
   pmNarrow       =1;
   pmLast         =1;
   //Image Align Styles (popmenu/list)
   iaNormal       =1;//center by default
   iaLeft         =0;
   iaCenter       =1;
   iaRight        =2;
   iaMax          =2;

   //resize border modes - 25feb2021
   sbnone         =0;
   sbleft         =1;
   sbright        =2;
   sbtop          =3;
   sbbottom       =4;

   //-- Easy access chars and symbols for use with BYTE arrays -----------------
   //numbers 0-9
   nn0 = 48;
   nn1 = 49;
   nn2 = 50;
   nn3 = 51;
   nn4 = 52;
   nn5 = 53;
   nn6 = 54;
   nn7 = 55;
   nn8 = 56;
   nn9 = 57;
   //uppercase letters A-Z
   uuA = 65;
   uuB = 66;
   uuC = 67;
   uuD = 68;
   uuE = 69;
   uuF = 70;
   uuG = 71;
   uuH = 72;
   uuI = 73;
   uuJ = 74;
   uuK = 75;
   uuL = 76;
   uuM = 77;
   uuN = 78;
   uuO = 79;
   uuP = 80;
   uuQ = 81;
   uuR = 82;
   uuS = 83;
   uuT = 84;
   uuU = 85;
   uuV = 86;
   uuW = 87;
   uuX = 88;
   uuY = 89;
   uuZ = 90;
   //lowercase letters a-z
   lla = 97;
   llb = 98;
   llc = 99;
   lld = 100;
   lle = 101;
   llf = 102;
   llg = 103;
   llh = 104;
   lli = 105;
   llj = 106;
   llk = 107;
   lll = 108;
   llm = 109;
   lln = 110;
   llo = 111;
   llp = 112;
   llq = 113;
   llr = 114;
   lls = 115;
   llt = 116;
   llu = 117;
   llv = 118;
   llw = 119;
   llx = 120;
   lly = 121;
   llz = 122;
   //common symbols
   sshash = 35;
   ssAsterisk = 42;
   ssdash =45;
   ssslash = 47;
   ssbackslash = 92;
   sscolon = 58;
   sssemicolon = 59;
   sscomma = 44;
   ssminus = 45;//06jul2022
   ssat = 64;
   ssdot = 46;
   ssexclaim = 33;
   ssmorethan = 62;
   sslessthan = 60;
   ssequal    = 61;
   ssquestion = 63;
   ssunderscore =  95;
   ssspace = 32;
   ss10 = 10;
   ss13 = 13;
   ss9 = 9;
   ssTab = 9;
   ssdoublequote=34;
   sssinglequote=39;
   ssLSquarebracket=91;//"["
   ssRSquarebracket=93;//"]"
   ssLRoundbracket=40;//"("
   ssRRoundbracket=41;//")"
   ssLCurlyBracket=123;//"{"
   ssRCurlyBracket=125;//"}"
   ssSquiggle=126;//"~"

   //special values
   vvUppertolower = llA-uuA;//difference to shift an uppercase char to a lowercase one

   //base64 - references
   //was: base64:array[0..64] of char=('A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7','8','9','+','/','=');
   //was: base64r:array[0..255] of char='qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqnqqqodefghijklmqqqpqqq0123456789:;<=>?@ABCDEFGHIqqqqqqJKLMNOPQRSTUVWXYZ[\]^_`abcqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq'+'qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq';
   base64:array[0..64] of byte=(65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,48,49,50,51,52,53,54,55,56,57,43,47,61);
   base64r:array[0..255] of byte=(113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,110,113,113,113,111,100,101,102,103,104,105,106,107,108,109,113,113,113,112,113,113,113,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,113,113,113,113,113,113,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113);

   //months
   system_month:array[1..12] of string=('January','February','March','April','May','June','July','August','September','October','November','December');
   system_month_abrv:array[1..12] of string=('Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec');
   //days
   system_dayOfweek:array[1..7] of string=('Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday');
   system_dayOfweek_abrv:array[1..7] of string=('Sun','Mon','Tue','Wed','Thu','Fri','Sat');

   //special code2 internally processed links
   scPage         ='page:';//show a page
   scDlg          ='dlg:';//set a dlg reply
   scOptions      ='sys:options';//14aug2020
   scHelp         ='sys:help';
   scSplash       ='sys:splash';//2aug2020
   scAbout        ='sys:about';
   scMixer        ='sys:mixer';//07mar2022
   scMax          ='sys:max';//15mar2022
   scOntop        ='sys:ontop';//15mar2022
   scPlus         ='plus~';//used to signal a plus orientated page control

   //own list -> special mode
   omfree         =maxword;
   //window modes
   wmControl      =0;//control is not a window
   wmFullwin      =1;//control is a window that "must" occupy entire screen always (e.g. app root form like Clic) and sits at bottom of window stack
   wmWindow       =2;//control is a window -> e.g. normal window or a tool window that sits above wmFullwin but below wmOntop
   wmOntop        =3;//control is an ontop window -> e.g. window sits above wmWindow but below wmDialog
   wmDialog       =4;//control is a dialog window -> e.g. sits above all other window types
   wmMax          =4;
   //window buttons
   wuNone         =0;
   wuClose        =1;
   wuAll          =2;
   wuMax          =2;
   //corner styles
   corNone        =0;//same as square - 29aug2020
   corRound       =1;
   corSlight      =2;
   corToSquare    =3;//finished with inner area as a perfect square
   corSlight2     =4;
   corMax         =4;
   //borderstyles
   bsInternal     =0;
   bsSystem100    =1;
   bsSystem50     =2;
   bsSystem20     =3;
   bsMax          =4;
   //-- WordCore Consts --------------------------------------------------------
   //.word wrap styles -> basicbwp and low__wordcore
   wwsNone        =0;
   wwsWindow      =1;
   wwsPage        =2;
   wwsMax         =2;
   //.multi-undo styles -> low__wordcore - 02jul2022
   musNone        =0;
   musDelL        =1;
   musDelR        =2;
   musIns         =3;
   musSel         =4;
   musSelKeep     =5;
   musRangeKeep   =6;//datastream size remains same, byte from1..xlen is replaced
   musRecovered   =7;
   musInsImg      =8;
   musMax         =8;
   //.musRecovered - actions
   muaRep         =0;
   muaAdd         =1;
   muaSub         =2;
   muaMax         =2;
   //.align styles
   wcaLeft        =0;
   wcaCenter      =1;
   wcaRight       =2;
   wcaMax         =2;

   //page sizes -> basicbwp and low__wordcore
   psA4           =0;
   psA3           =1;
   psA5           =2;
   psLetter       =3;
   psLegal        =4;
   psMax          =4;

   //OS Codes
   osMax          =6;
   osNone         =0;
   osW32          =1;//Windows 32bit
   osW64          =2;//Windows 64bit
   osA32          =1;//Android 32bit
   osA64          =2;//Android 64bit
   osL32          =3;//Linux 32bit
   osL64          =4;//Linux 64bit
   osM32          =5;//Apple Mac 32bit
   osM64          =6;//Apple Mac 64bit
   //System Stats Codes
   satMax              =199;
   satEndof_overview   =9;
   satEndof_core       =69;
   satEndof_gui        =satmax;
   //.overview
   satErrors           =0;
   satMaskcapture      =1;
   satPartpaint        =2;
   satFullpaint        =3;
   satDragstart        =4;
   satDragcapture      =5;
   satDragpaint        =6;
   satSizestart        =7;
   satSizecapture      =8;
   satSizepaint        =9;

   //.core
   satBasicprg         =13;
   satObjectex         =14;
   satStr8             =15;
   satMask8            =16;
   satBmp              =17;
   satBasicimage       =18;
   satBWP              =19;
   //.dynamic
   satDynlist          =20;
   satDynbyte          =21;
   satDynint           =22;
   satDynstr           =23;
   satFrame            =24;//31jan2021
   satStringlist       =25;//02feb2021
   satBitmap           =26;
   satMidi             =27;//07feb2021
   satMidiopen         =28;//07feb2021
   satMidiblocks       =29;
   satThread           =30;
   satTimer            =31;//19feb2021
   satVars8            =32;//01may2021
   satJpegimage        =33;//01may2021
   satFilestream       =34;
   satPstring          =35;
   satWave             =36;
   satWaveopen         =37;
   satAny              =38;//09feb2022

   //.gui
   satSystem           =70;
   satControl          =71;
   satTitle            =72;
   satEdit             =73;
   satHead             =74;
   satTick             =75;
   satToolbar          =76;
   satScroll           =77;
   satNav              =78;
   satSplash           =79;
   satHelp             =80;
   satColmatrix        =81;
   satColor            =82;
   satInfo             =83;
   satMenu             =84;
   satCols             =85;
   satSetcolor         =86;

   //tbasicccols -> styles
   bcVertical          =0;//all vertical columns
   bcVertical2         =1;
   bcHorizontal        =2;
   bcHorizontal2       =3;
   bcMax               =3;

   //tbasicsystem -> application.mainform.windowstate -> gui window state -> is windowstate, but we use independant codes - 28apr2020
   gsNormal            =0;
   gsMin               =1;
   gsMax               =2;
   gsUpperlimit        =2;

   //tbasicmenu -> menu styles
   lsmenu              =0;
   lslist              =1;
   lsmany              =2;

   //tbasicnav.styles
   bnNil               =0;
   bnFav               =1;
   bnFavlist           =2;
   bnNav               =3;
   bnNavlist           =4;
   bnFolder            =5;
   bnOpen              =6;
   bnSave              =7;
   bnNamelist          =8;//11jan2022
   bnMax               =8;

   //low__navlist.sortstyle
   nlName              =0;//sort by name - ascending
   nlSize              =1;
   nlDate              =2;
   nlType              =3;
   nlAsis              =4;
   nlNameD             =5;//sort by name - descending
   nlSizeD             =6;
   nlDateD             =7;
   nlTypeD             =8;
   nlAsisD             =9;
   nlMax               =9;
   //low__navlist.style
   nltNav              =0;
   nltFolder           =1;
   nltFile             =2;
   nltSysFolder        =3;//fully specified folder (complete drive/folder info)
   nltTitle            =4;
   nltNone             =5;
   nltMax              =5;

   //chime styles (storage)
   chmsTitle                    =0;
   chmsStandard                 =1;//Melody + Dong OR Dong only
   chmsBells                    =2;//Ships Bells OR Ships Bells - British Royal
   chmsSonnerie                 =3;//Grande Sonnerie OR Petite Sonnerie

   //wordcore -> char style codes
   wc_n                =0;//no style
   wc_t                =1;//text
   wc_i                =2;//image

   //special maker codes -> used by controls to detect what type of modified control they are running -> used when required - 23mar2022
   made_none           =0;
   made_wavevol        =1;
   made_midivol        =2;

   //low__stdencrypt() modes - 19aug2020
   glseEncrypt         =0;
   glseDecrypt         =1;
   glseTextEncrypt     =2;
   glseTextDecrypt     =3;

   //G.E.C. -->> General Error Codes v1.00.028, 22jun2005
   gecFailedtoencrypt        ='Failed to encrypt';//20jun2016
   gecFileInUse              ='File in use / access denied';//translate('File in use / access denied')
   gecNotFound               ='Not found';//translate('Not found')
   gecBadFileName            ='Bad file name';//translate('Bad file name')
   gecFileNotFound           ='File not found';//translate('File not found')
   gecUnknownFormat          ='Unknown format';//translate('Unknown format')
   gecTaskCancelled          ='Task cancelled';//translate('Task cancelled')
   gecPathNotFound           ='Path not found';//translate('Path not found')
   gecOutOfMemory            ='Out of memory';//translate('Out of memory')
   gecIndexOutOfRange        ='Index out of range';//translate('Index out of range')
   gecUnexpectedError        ='Unexpected error';//translate('Unexpected error')
   gecDataCorrupt            ='Data corrupt';//translate('Data corrupt')
   gecUnsupportedFormat      ='Unsupported format';//translate('Unsupported format')
   gecAccessDenied           ='Access Denied';{04/11/2002}//translate('Access Denied')
   gecOutOfDiskSpace         ='Out of disk space';//translate('Out of disk space')
   gecAProgramExistsWithThatName='A program exists with that name';//translate('A program exists with that name')
   gecUseAnother             ='Use another';//translate('Use another')
   gecSendToFailed           ='Send to failed';//translate('Send to failed')
   gecCapacityReached        ='Capacity reached';//translate('Capacity reached')
   gecNoFilesFound           ='No files found';//translate('No files found')
   gecUnsupportedEncoding    ='Unsupported encoding';//translate('Unsupported encoding')
   gecUnsupportedDecoding    ='Unsupported decoding';//translate('Unsupported decoding')
   gecEmpty                  ='Empty';//translate('Empty')
   gecLocked                 ='Locked';//translate('Locked')
   gecTaskFailed             ='Task failed';//translate('Task failed')
   gecTaskSuccessful         ='Task successful';//translate('Task successful')
   //.New 16/08/2002
   gecVirusWarning           ='Virus Warning - Tampering detected';//translate('Virus Warning - Tampering detected')
   gecTaskTimedOut           ='Task Timed Out';//translate('Task Timed Out')
   gecIncorrectUnlockInformation='Incorrect Unlock Information';//Translate('Incorrect Unlock Information');
   gecOk                     ='OK';//translate('OK');
   gecReadOnly               ='Read Only';//translate('Read Only');
   gecRepeat                 ='Repeat';//translte('Repeat');
   gecBusy                   ='Busy';//translate('Busy');
   gecReady                  ='Ready';//translate('Ready');
   gecWorking                ='Working';//translate('Working');
   gecSearching              ='Searching';//translate('Searching');
   gecNoFurtherMatchesFound  ='No further matches found';//translate('No further matches found');
   gecAccessGranted          ='Access Granted';//Translate('Access Granted') - [bait]
   gecFailed                 ='Failed';//Translate('Failed') - [bait]
   gecDeleted                ='Deleted';//Translate('Deleted') - [bait]
   gecSkipped                ='Skipped';//Translate('Skipped') - [bait]
   gecEXTnotAllowed          ='Extension not allowed';//Translate('Extension not allowed') - [bait]
   gecSaved                  ='Saved';//Translate('Saved')
   gecNoContent              ='No content';//Translate('No content present') - [bait]
   gecSyntaxError            ='Invalid syntax';//translate('Invalid syntax') - [bait]
   gecUnterminatedLine       ='Unterminated line';//translate('Unterminated line') - [bait]
   gecUnterminatedString     ='Unterminated string';//translate('Unterminated string') - [bait]
   gecUndefinedObject        ='Undefined Object';//translate('Undefined Object') - [bait]
   gecPrivilegesModified     ='Privileges Modified';//Translate('Privileges Modified') - [bait]
   gecConnectionFailed       ='Connection Failed';//translate('Connection Failed');
   gecTimedOut               ='Timed Out';//translate('Timed Out');
   //.new 03DEC2009
   gecNoPrinter              ='No Printer';

   //system images -------------------------------------------------------------
   //.system "nil" image -> indicates there is no image to work with
   tepNone                 =0;

   //.static height of 20px
   tepUnknown20            =1;
   tepNew20                =2;
   tepHome20               =3;
   tepYesBLANK20           =4;
   tepYes20                =5;
   tepOK20                 =6;
   tepOpen20               =7;
   tepSave20               =8;
   tepDisk20               =9;
   tepCut20                =10;
   tepCopy20               =11;
   tepPaste20              =12;
   tepDelete20             =13;
   tepClose20              =14;
   tepEdit20               =15;
   tepUndo20               =16;
   tepRedo20               =17;
   tepOptions20            =18;//14aug2020
   tepNav20                =19;//06oct2020
   tepInvert20             =20;
   tepUpper20              =21;
   tepLower20              =22;
   tepName20               =23;//name case
   tepLess20               =24;
   tepMore20               =25;
   tepBW20                 =26;
   tepHelp20               =30;
   tepUM20                 =31;
   tepMax20                =32;
   tepSettings20           =33;
   tepAbout20              =34;
   tepBE20                 =35;
   tepRefresh20            =36;
   tepFolder20             =37;
   tepColor20              =38;
   tepFont20               =39;
   tepDesktop20            =40;
   tepPrograms20           =41;
   tepMenu20               =42;
   tepPlay20               =43;
   tepColors20             =44;
   tepColormatrix20        =45;
   tepColorPal20           =46;//wide (20px H x 40px W) and replaces black pixels with custom color
   tepPrev20               =47;
   tepNext20               =48;
   tepUpone20              =49;
   tepFav20                =50;
   tepNewfolder20          =51;
   tepAdd20                =52;
   tepStop20               =53;
   tepVol20                =54;
   tepRewind20             =55;
   tepFastforward20        =56;
   tepSelectAll20          =57;
   tepFavEdit20            =58;
   tepFavAdd20             =59;
   tepColorHistory20       =60;
   tepTick20               =61;
   tepUntick20             =62;
   tepEye20                =63;
   tepHelpdoc20            =64;
   tepBook20               =65;
   tepUp20                 =66;
   tepCD20                 =67;
   tepRemovable20          =68;
   tepFolderimage20        =69;
   tepStartmenu20          =70;
   tepSchemes20            =71;
   tepSub20                =72;
   tepZoom20               =73;
   tepSizeto20             =74;
   tepTicktwo20            =75;
   tepUnticktwo20          =76;
   tepTickthree20          =77;
   tepUntickthree20        =78;
   tepRec20                =79;
   tepScreen20             =80;
   tepOntop20              =81;
   tepHide20               =82;
   tepWrap20               =83;
   tepWine20               =84;
   tepFrame20              =85;
   tepLeft20               =86;
   tepRight20              =87;
   tepTop20                =88;
   tepBottom20             =89;
   tepBlank20              =90;
   tepClock20              =91;
   tepAlert20              =92;
   tepBell20               =93;
   tepSonnerie20           =94;
   tepNotes20              =95;
   tepFNew20               =96;//uses font color - 23mar2022
   tepBack20               =97;
   tepForw20               =98;
   tepPower20              =99;//14jun2022
   tepAddL20               =100;//14jun2022
   tepSubL20               =101;//14jun2022
   tepPanel20              =102;//05jul2022

   //.file format teps
   tepXXX20                =170;
   tepBMP20                =171;
   tepWMA20                =172;
   tepTXT20                =173;
   tepEXE20                =174;
   tepBWD20                =175;
   tepBWP20                =176;
   tepMID20                =177;//20feb2021
   tepBCS20                =178;//10mar2021
   tepR20                  =179;//30dec2021
   tepXML20                =180;//30dec2021
   tepHTM20                =181;//30dec2021
   tepC2P20                =182;//12jan2022
   tepC2V20                =183;//24jan2022
   tepZIP20                =184;
   tep7Z20                 =185;
   tepINI20                =186;
   tepCUR20                =187;//23may2022, 17may2022
   tepRTF20                =188;//22jun2022
   tepSFEF20               =189;//05oct2022

   //.duplicates
   tepRun20                =tepEXE20;

   //.variable height
   tepmin                  =200;
   tepmax                  =201;
   tepnor                  =202;
   tepclo                  =203;
   tepNormal               =204;
   tepMaximise             =205;
   tepinf                  =206;
   tepUp                   =210;
   tepDown                 =211;
   tepLeft                 =212;
   tepRight                =213;
   tepOn                   =220;
   tepOff                  =221;
   tepHelpHint             =222;
   tepBullet               =223;
   tepSep                  =224;
   tepHelpBanner           =225;//medium sized banner

   //.large 32x32 images
   tepIcon32               =500;//actual program icon -> program specific - 11oct2020
   tepIcon32B              =501;//optional cell 2 - 30apr2022
   tepIcon32C              =502;//optional cell 3
   tepIcon32D              =504;//optional cell 4
   tepInfo32               =505;
   tepQuery32              =506;
   tepError32              =507;
   tepColor32              =508;
   tepFolderimage32        =509;
   tepNewfolder32          =510;
   tepIcon20               =511;//actual program icon at 20h - 26sep2022

{$ifdef D3}//D3 patch support -------------------------------------------------
   vkescape   =vk_escape;
   vkreturn   =vk_return;
   vkdelete   =vk_delete;
   vkback     =vk_back;
   vkleft     =vk_left;
   vkright    =vk_right;
   vkup       =vk_up;
   vkdown     =vk_down;
   vkprior    =vk_prior;
   vknext     =vk_next;
   vkhome     =vk_home;
   vkend      =vk_end;
   vktab      =vk_tab;
   vkf1       =vk_f1;
   vkf2       =vk_f2;
   vkf3       =vk_f3;
   vkf4       =vk_f4;
   vkf5       =vk_f5;
   vkf6       =vk_f6;
   vkf7       =vk_f7;
   vkf8       =vk_f8;
   vkf9       =vk_f9;
   vkf10      =vk_f10;
   vkf11      =vk_f11;
   vkf12      =vk_f12;
{$endif}

   //-- keyboard action keys -------------------------------------------------
   //Note: Codes are our own values - 31mar2021, 01apr2020
   aknone                 =100000;//no key in use (except for possible a shift/ctrl/alt being down or up)
   akreturn               =100001;//special: fires ONLY when the return key is released -> for dialogs and controls that need a single-fire up-keystroke return code signal - 31mar2021
   aktab                  =100002;
   akdelete               =100003;
   akback                 =100004;
   akescape               =100005;
   akspace                =32;
   akshift                =100006;//shift key downstroke
   akshiftup              =100007;//shift key upstroke
   akreturn_press         =100008;//special: fires as the return key is pressed and automatically repeats while the key is held down -> for text boxes
   //.direction keys
   akleft                 =100020;
   akright                =100021;
   akup                   =100022;
   akdown                 =100023;
   //.extended direction keys
   akhome                 =100030;
   akend                  =100031;
   akprev                 =100032;
   aknext                 =100033;
   //.f keys
   akf1                   =100101;
   akf2                   =100102;
   akf3                   =100103;
   akf4                   =100104;
   akf5                   =100105;
   akf6                   =100106;
   akf7                   =100107;
   akf8                   =100108;
   akf9                   =100109;
   akf10                  =100110;
   akf11                  =100111;
   akf12                  =100112;
   //.akA-Z
   akA                    =65;
   akB                    =66;
   akC                    =67;
   akD                    =68;
   akE                    =69;
   akF                    =70;
   akG                    =71;
   akH                    =72;
   akI                    =73;
   akJ                    =74;
   akK                    =75;
   akL                    =76;
   akM                    =77;
   akN                    =78;
   akO                    =79;
   akP                    =80;
   akQ                    =81;
   akR                    =82;
   akS                    =83;
   akT                    =84;
   akU                    =85;
   akV                    =86;
   akW                    =87;
   akX                    =88;
   akY                    =89;
   akZ                    =90;
   //.akctrlLeft.. - 3mar2021
   akctrlNone            =110000;//base level
   akctrlLast            =119999;
   akctrlLeft            =akctrlnone+(akleft-aknone);
   akctrlRight           =akctrlnone+(akright-aknone);
   akctrlUp              =akctrlnone+(akup-aknone);
   akctrlDown            =akctrlnone+(akdown-aknone);
   //.akctrlLeft.. - 3mar2021
   akaltNone            =120000;//base level
   akaltLast            =129999;
   akaltLeft            =akaltnone+(akleft-aknone);
   akaltRight           =akaltnone+(akright-aknone);
   akaltUp              =akaltnone+(akup-aknone);
   akaltDown            =akaltnone+(akdown-aknone);
   //.akctrlA-Z -> Important Note: Delphi complains of "line too long" if only a "#10" is used to stamp out below block of constant values, MUST use a "#13#10" return code - 01apr2020
   akctrlA               =100565;
   akctrlB               =100566;
   akctrlC               =100567;
   akctrlD               =100568;
   akctrlE               =100569;
   akctrlF               =100570;
   akctrlG               =100571;
   akctrlH               =100572;
   akctrlI               =100573;
   akctrlJ               =100574;
   akctrlK               =100575;
   akctrlL               =100576;
   akctrlM               =100577;
   akctrlN               =100578;
   akctrlO               =100579;
   akctrlP               =100580;
   akctrlQ               =100581;
   akctrlR               =100582;
   akctrlS               =100583;
   akctrlT               =100584;
   akctrlU               =100585;
   akctrlV               =100586;
   akctrlW               =100587;
   akctrlX               =100588;
   akctrlY               =100589;
   akctrlZ               =100590;
   //.akaltA-Z
   akaltA                =100865;
   akaltB                =100866;
   akaltC                =100867;
   akaltD                =100868;
   akaltE                =100869;
   akaltF                =100870;
   akaltG                =100871;
   akaltH                =100872;
   akaltI                =100873;
   akaltJ                =100874;
   akaltK                =100875;
   akaltL                =100876;
   akaltM                =100877;
   akaltN                =100878;
   akaltO                =100879;
   akaltP                =100880;
   akaltQ                =100881;
   akaltR                =100882;
   akaltS                =100883;
   akaltT                =100884;
   akaltU                =100885;
   akaltV                =100886;
   akaltW                =100887;
   akaltX                =100888;
   akaltY                =100889;
   akaltZ                =100890;

   //mouse action buttons
   abnone                =0;
   ableft                =1;
   abcenter              =2;
   abright               =3;

   //base64 -> byte array - 30apr2020
   base64v:array[0..64] of byte=(65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,48,49,50,51,52,53,54,55,56,57,43,47,61);
   base64vr:array[0..255] of byte=(113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,110,113,113,113,111,100,101,102,103,104,105,106,107,108,109,113,113,113,112,113,113,113,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,113,113,113,113,113,113,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113);//w

   //memory access and memory mapped file access -------------------------------
   PAGE_NOACCESS    = 1;
   PAGE_READONLY    = 2;
   PAGE_READWRITE   = 4;
   PAGE_WRITECOPY   = 8;

   FILE_MAP_COPY     = 1;
   FILE_MAP_WRITE    = 2;
   FILE_MAP_READ     = 4;
   FILE_MAP_READWRITE=FILE_MAP_COPY or FILE_MAP_WRITE or FILE_MAP_READ;

   //multimedia supports -------------------------------------------------------
{$ifdef mm}
   MHDR_DONE           = $00000001;       { done bit }
   MHDR_PREPARED       = $00000002;       { set if header prepared }
   MHDR_INQUEUE        = $00000004;       { reserved for driver }
   MHDR_ISSTRM         = $00000008;       { Buffer is stream buffer }
   MM_MOM_OPEN         = $3C7;//actual buffer
   MM_MOM_CLOSE        = $3C8;//actual buffer
   MM_MOM_DONE         = $3C9;//actual buffer
   CALLBACK_FUNCTION   = $00030000;    { dwCallback is a FARPROC }
   CALLBACK_WINDOW     = $00010000;    { dwCallback is a HWND }
   WAVERR_BASE         = 32;
   MIDIERR_BASE        = 64;
   MIDI_MAPPER         = UINT(-1);//20JAN2011
   WAVE_MAPPER         = UINT(-1);
   CALLBACK_NULL       = $00000000;//no callback
   MAXPNAMELEN         = 32;    { max product name length (including nil) }
   MMSYSERR_NOERROR    = 0;                  { no error }
   WAVECAPS_VOLUME     = $0004;   { supports volume control }
   WAVECAPS_LRVOLUME   = $0008;   { separate left-right volume control }
   MIDICAPS_VOLUME     = $0001;  { supports volume control }
   MIDICAPS_LRVOLUME   = $0002;  { separate left-right volume control }

{ flags for dwFlags field of WAVEHDR }
   //.wave
   WHDR_DONE       = $00000001;  { done bit }
   WHDR_PREPARED   = $00000002;  { set if this header has been prepared }
   WHDR_BEGINLOOP  = $00000004;  { loop start block }
   WHDR_ENDLOOP    = $00000008;  { loop end block }
   WHDR_INQUEUE    = $00000010;  { reserved for driver }
   MM_WOM_OPEN         = $3BB;
   MM_WOM_CLOSE        = $3BC;
   MM_WOM_DONE         = $3BD;
   MM_WIM_OPEN         = $3BE;
   MM_WIM_CLOSE        = $3BF;
   MM_WIM_DATA         = $3C0;
   WAVE_FORMAT_QUERY   = $0001;
   WAVE_ALLOWSYNC      = $0002;
   WAVE_MAPPED         = $0004;

   //.midi
   MIDIERR_UNPREPARED    = MIDIERR_BASE + 0;   { header not prepared }
   MIDIERR_STILLPLAYING  = MIDIERR_BASE + 1;   { still something playing }
   MIDIERR_NOMAP         = MIDIERR_BASE + 2;   { no current map }
   MIDIERR_NOTREADY      = MIDIERR_BASE + 3;   { hardware is still busy }
   MIDIERR_NODEVICE      = MIDIERR_BASE + 4;   { port no longer connected }
   MIDIERR_INVALIDSETUP  = MIDIERR_BASE + 5;   { invalid setup }
   MIDIERR_BADOPENMODE   = MIDIERR_BASE + 6;   { operation unsupported w/ open mode }
   MIDIERR_DONT_CONTINUE = MIDIERR_BASE + 7;   { thru device 'eating' a message }
   MIDIERR_LASTERROR     = MIDIERR_BASE + 5;   { last error in range }

  //  GM_Reset: array[1..6] of byte = ($F0, $7E, $7F, $09, $01, $F7); // = GM_On
//  GS_Reset: array[1..11] of byte = ($F0, $41, $10, $42, $12, $40, $00, $7F, $00, $41, $F7);
//  XG_Reset: array[1..9] of byte = ($F0, $43, $10, $4C, $00, $00, $7E, $00, $F7);
//  GM2_On: array[1..6] of byte = ($F0, $7E, $7F, $09, $03, $F7);  // = GM2_Reset
//  GM2_Off: array[1..6] of byte = ($F0, $7E, $7F, $09, $02, $F7); // switch to GS
//  GS_Off: array[1..11] of byte = ($F0, $41, $10, $42, $12, $40, $00, $7F, $7F, $42, $F7); // = Exit GS Mode
//  SysExMasterVolume: array[1..8] of byte = ($F0, $7F, $7F, $04, $01, $0, $0, $F7);

{multi-media}
  //general
  MM_MCINOTIFY        = $3B9;
  //flags for wParam of MM_MCINOTIFY message
  MCI_NOTIFY_SUCCESSFUL           =$0001;
  MCI_NOTIFY_SUPERSEDED           =$0002;
  MCI_NOTIFY_ABORTED              =$0004;
  MCI_NOTIFY_FAILURE              =$0008;
  //common flags for dwFlags parameter of MCI command messages
  MCI_NOTIFY                      =$00000001;
  MCI_WAIT                        =$00000002;
  MCI_FROM                        =$00000004;
  MCI_TO                          =$00000008;
  MCI_TRACK                       =$00000010;
  //flags for dwFlags parameter of MCI_OPEN command message
  MCI_OPEN_SHAREABLE              =$00000100;
  MCI_OPEN_ELEMENT                =$00000200;
  MCI_OPEN_ALIAS                  =$00000400;
  MCI_OPEN_ELEMENT_ID             =$00000800;
  MCI_OPEN_TYPE_ID                =$00001000;
  MCI_OPEN_TYPE                   =$00002000;
  //other
  MCI_SET_DOOR_OPEN               = $00000100;
  MCI_SET_DOOR_CLOSED             = $00000200;
  MCI_SET_TIME_FORMAT             = $00000400;
  MCI_SET_AUDIO                   = $00000800;
  MCI_SET_VIDEO                   = $00001000;
  MCI_SET_ON                      = $00002000;
  MCI_SET_OFF                     = $00004000;
  //MCI command message identifiers
  MCI_OPEN                        =$0803;
  MCI_CLOSE                       =$0804;
  MCI_ESCAPE                      =$0805;
  MCI_PLAY                        =$0806;
  MCI_SEEK                        =$0807;
  MCI_STOP                        =$0808;
  MCI_PAUSE                       =$0809;
  MCI_INFO                        =$080A;
  MCI_GETDEVCAPs                  =$080B;
  MCI_SPIN                        =$080C;
  MCI_SET                         =$080D;
  MCI_STEP                        =$080E;
  MCI_RECORD                      =$080F;
  MCI_SYSINFO                     =$0810;
  MCI_BREAK                       =$0811;
  MCI_SOUND                       =$0812;
  MCI_SAVE                        =$0813;
  MCI_STATUS                      =$0814;
  MCI_CUE                         =$0830;
  MCI_REALIZE                     =$0840;
  MCI_WINDOW                      =$0841;
  MCI_PUT                         =$0842;
  MCI_WHERE                       =$0843;
  MCI_FREEZE                      =$0844;
  MCI_UNFREEZE                    =$0845;
  MCI_LOAD                        =$0850;
  MCI_CUT                         =$0851;
  MCI_COPY                        =$0852;
  MCI_PASTE                       =$0853;
  MCI_UPDATE                      =$0854;
  MCI_RESUME                      =$0855;
  MCI_DELETE                      =$0856;
  //flags for dwFlags parameter of MCI_STATUS command message
  MCI_STATUS_ITEM                 =$00000100;
  MCI_STATUS_START                =$00000200;
  //flags for dwItem field of the MCI_STATUS_PARMS parameter block
  MCI_STATUS_LENGTH               =$00000001;
  MCI_STATUS_POSITION             =$00000002;
  MCI_STATUS_NUMBER_OF_TRACKS     =$00000003;
  MCI_STATUS_MODE                 =$00000004;
  MCI_STATUS_MEDIA_PRESENT        =$00000005;
  MCI_STATUS_TIME_FORMAT          =$00000006;
  MCI_STATUS_READY                =$00000007;
  MCI_STATUS_CURRENT_TRACK        =$00000008;
{$endif}

//managed states
   msFree      =0;
   msHold      =1;
   msQueued    =2;
   msWorking   =3;
   msFinished  =4;
//playback modes
   mmOnce              =0;
   mmRepeatOne         =1;
   mmRepeatAll         =2;
   mmAllOnce           =3;
   mmRandom            =4;
   mmMax               =4;


   //system cursors - 29aug2021 ------------------------------------------------
cur_orange:array[0..765] of byte=(
0,0,2,0,1,0,32,32,16,0,0,0,1,0,232,2,0,0,22,0,0,0,40,0,0,0,32,0,0,0,64,0,0,0,1,0,4,0,0,0,0,0,192,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25,114,178,0,36,164,255,0,54,182,255,0,73,200,255,0,91,218,255,0,109,237,255,0,128,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22,81,0,0,0,0,0,0,0,0,0,0,0,17,0,0,22,81,0,0,0,0,0,0,0,0,0,0,0,18,16,1,118,16,0,0,0,0,0,0,0,0,0,0,0,18,49,1,118,16,0,0,0,0,0,0,0,0,0,0,0,18,52,22,113,0,0,0,0,0,0,0,0,0,0,0,0,18,52,86,113,17,17,0,0,0,0,0,0,0,0,0,0,18,52,86,118,84,49,0,0,0,0,0,0,0,0,0,0,18,52,86,118,84,16,0,0,0,0,0,0,0,0,0,0,18,
52,86,118,81,0,0,0,0,0,0,0,0,0,0,0,18,52,86,118,16,0,0,0,0,0,0,0,0,0,0,0,18,52,86,113,0,0,0,0,0,0,0,0,0,0,0,0,18,52,86,16,0,0,0,0,0,0,0,0,0,0,0,0,18,52,81,0,0,0,0,0,0,0,0,0,0,0,0,0,18,52,16,0,0,0,0,0,0,0,0,0,0,0,0,0,18,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,127,255,255,252,63,255,255,60,63,255,255,24,127,255,255,8,127,255,255,0,255,255,255,0,15,255,255,0,15,255,255,0,31,255,255,0,63,255,255,0,127,255,255,0,255,255,255,1,255,255,255,3,255,255,255,7,255,255,255,15,255,255,255,31,255,255,255,63,255,255,255,127,255,255,255,255,255,255,255);

cur_navy:array[0..765] of byte=(
0,0,2,0,1,0,32,32,16,0,0,0,1,0,232,2,0,0,22,0,0,0,40,0,0,0,32,0,0,0,64,0,0,0,1,0,4,0,0,0,0,0,192,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,97,39,39,0,187,75,75,0,197,100,100,0,206,125,125,0,215,151,151,0,225,176,176,0,178,50,50,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,49,0,0,0,0,0,0,0,0,0,0,0,17,0,0,20,49,0,0,0,0,0,0,0,0,0,0,0,18,16,1,84,16,0,0,0,0,0,0,0,0,0,0,0,18,49,1,84,16,0,0,0,0,0,0,0,0,0,0,0,18,52,22,81,0,0,0,0,0,0,0,0,0,0,0,0,18,52,86,81,17,17,0,0,0,0,0,0,0,0,0,0,18,52,86,84,50,113,0,0,0,0,0,0,0,0,0,0,18,52,86,84,50,16,0,0,0,0,0,0,0,0,0,0,18,52,86,
84,49,0,0,0,0,0,0,0,0,0,0,0,18,52,86,84,16,0,0,0,0,0,0,0,0,0,0,0,18,52,86,81,0,0,0,0,0,0,0,0,0,0,0,0,18,52,86,16,0,0,0,0,0,0,0,0,0,0,0,0,18,52,81,0,0,0,0,0,0,0,0,0,0,0,0,0,18,52,16,0,0,0,0,0,0,0,0,0,0,0,0,0,18,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,127,255,255,252,63,255,255,60,63,255,255,24,127,255,255,8,127,255,255,0,255,255,255,0,15,255,255,0,15,255,255,0,31,255,255,0,63,255,255,0,127,255,255,0,255,255,255,1,255,255,255,3,255,255,255,7,255,255,255,15,255,255,255,31,255,255,255,63,255,255,255,127,255,255,255,255,255,255,255);

cur_green:array[0..765] of byte=(
0,0,2,0,1,0,32,32,16,0,0,0,1,0,232,2,0,0,22,0,0,0,40,0,0,0,32,0,0,0,64,0,0,0,1,0,4,0,0,0,0,0,192,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,48,96,48,0,103,208,103,0,110,219,110,0,115,231,115,0,122,243,122,0,128,255,128,0,98,196,98,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,49,0,0,0,0,0,0,0,0,0,0,0,17,0,0,20,49,0,0,0,0,0,0,0,0,0,0,0,18,16,1,84,16,0,0,0,0,0,0,0,0,0,0,0,18,49,1,84,16,0,0,0,0,0,0,0,0,0,0,0,18,52,22,81,0,0,0,0,0,0,0,0,0,0,0,0,18,52,86,81,17,17,0,0,0,0,0,0,0,0,0,0,18,52,86,84,50,113,0,0,0,0,0,0,0,0,0,0,18,52,86,84,50,16,0,0,0,0,0,0,0,0,0,0,18,52,
86,84,49,0,0,0,0,0,0,0,0,0,0,0,18,52,86,84,16,0,0,0,0,0,0,0,0,0,0,0,18,52,86,81,0,0,0,0,0,0,0,0,0,0,0,0,18,52,86,16,0,0,0,0,0,0,0,0,0,0,0,0,18,52,81,0,0,0,0,0,0,0,0,0,0,0,0,0,18,52,16,0,0,0,0,0,0,0,0,0,0,0,0,0,18,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,127,255,255,252,63,255,255,60,63,255,255,24,127,255,255,8,127,255,255,0,255,255,255,0,15,255,255,0,15,255,255,0,31,255,255,0,63,255,255,0,127,255,255,0,255,255,255,1,255,255,255,3,255,255,255,7,255,255,255,15,255,255,255,31,255,255,255,63,255,255,255,127,255,255,255,255,255,255,255);

cur_grey:array[0..765] of byte=(
0,0,2,0,1,0,32,32,16,0,0,0,1,0,232,2,0,0,22,0,0,0,40,0,0,0,32,0,0,0,64,0,0,0,1,0,4,0,0,0,0,0,192,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,103,103,103,0,201,201,201,0,204,204,204,0,207,207,207,0,210,210,210,0,213,213,213,0,216,216,216,0,219,219,219,0,222,222,222,0,225,225,225,0,228,228,228,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,145,0,0,0,0,0,0,0,0,0,0,0,17,0,0,24,145,0,0,0,0,0,0,0,0,0,0,0,18,16,1,120,16,0,0,0,0,0,0,0,0,0,0,0,18,49,1,120,16,0,0,0,0,0,0,0,0,0,0,0,18,52,22,113,0,0,0,0,0,0,0,0,0,0,0,0,18,52,86,113,17,17,0,0,0,0,0,0,0,0,0,0,18,52,86,120,154,177,0,0,0,0,0,0,0,0,0,0,18,52,86,
120,154,16,0,0,0,0,0,0,0,0,0,0,18,52,86,120,145,0,0,0,0,0,0,0,0,0,0,0,18,52,86,120,16,0,0,0,0,0,0,0,0,0,0,0,18,52,86,113,0,0,0,0,0,0,0,0,0,0,0,0,18,52,86,16,0,0,0,0,0,0,0,0,0,0,0,0,18,52,81,0,0,0,0,0,0,0,0,0,0,0,0,0,18,52,16,0,0,0,0,0,0,0,0,0,0,0,0,0,18,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,127,255,255,252,63,255,255,60,63,255,255,24,127,255,255,8,127,255,255,0,255,255,255,0,15,255,255,0,15,255,255,0,31,255,255,0,63,255,255,0,127,255,255,0,255,255,255,1,255,255,255,3,255,255,255,7,255,255,255,15,255,255,255,31,255,255,255,63,255,255,255,127,255,255,255,255,255,255,255);

cur_pink:array[0..765] of byte=(
0,0,2,0,1,0,32,32,16,0,0,0,1,0,232,2,0,0,22,0,0,0,40,0,0,0,32,0,0,0,64,0,0,0,1,0,4,0,0,0,0,0,192,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,99,46,153,0,166,77,255,0,179,103,255,0,192,129,255,0,205,155,255,0,218,181,255,0,153,51,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,49,0,0,0,0,0,0,0,0,0,0,0,17,0,0,20,49,0,0,0,0,0,0,0,0,0,0,0,18,16,1,84,16,0,0,0,0,0,0,0,0,0,0,0,18,49,1,84,16,0,0,0,0,0,0,0,0,0,0,0,18,52,22,81,0,0,0,0,0,0,0,0,0,0,0,0,18,52,86,81,17,17,0,0,0,0,0,0,0,0,0,0,18,52,86,84,50,113,0,0,0,0,0,0,0,0,0,0,18,52,86,84,50,16,0,0,0,0,0,0,0,0,0,0,18,52,
86,84,49,0,0,0,0,0,0,0,0,0,0,0,18,52,86,84,16,0,0,0,0,0,0,0,0,0,0,0,18,52,86,81,0,0,0,0,0,0,0,0,0,0,0,0,18,52,86,16,0,0,0,0,0,0,0,0,0,0,0,0,18,52,81,0,0,0,0,0,0,0,0,0,0,0,0,0,18,52,16,0,0,0,0,0,0,0,0,0,0,0,0,0,18,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,127,255,255,252,63,255,255,60,63,255,255,24,127,255,255,8,127,255,255,0,255,255,255,0,15,255,255,0,15,255,255,0,31,255,255,0,63,255,255,0,127,255,255,0,255,255,255,1,255,255,255,3,255,255,255,7,255,255,255,15,255,255,255,31,255,255,255,63,255,255,255,127,255,255,255,255,255,255,255);

cur_purple:array[0..765] of byte=(
0,0,2,0,1,0,32,32,16,0,0,0,1,0,232,2,0,0,22,0,0,0,40,0,0,0,32,0,0,0,64,0,0,0,1,0,4,0,0,0,0,0,192,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,80,19,49,0,182,44,113,0,200,60,130,0,218,74,146,0,237,90,163,0,255,105,180,0,164,30,97,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,49,0,0,0,0,0,0,0,0,0,0,0,17,0,0,20,49,0,0,0,0,0,0,0,0,0,0,0,18,16,1,84,16,0,0,0,0,0,0,0,0,0,0,0,18,49,1,84,16,0,0,0,0,0,0,0,0,0,0,0,18,52,22,81,0,0,0,0,0,0,0,0,0,0,0,0,18,52,86,81,17,17,0,0,0,0,0,0,0,0,0,0,18,52,86,84,50,113,0,0,0,0,0,0,0,0,0,0,18,52,86,84,50,16,0,0,0,0,0,0,0,0,0,0,18,52,86,84,
49,0,0,0,0,0,0,0,0,0,0,0,18,52,86,84,16,0,0,0,0,0,0,0,0,0,0,0,18,52,86,81,0,0,0,0,0,0,0,0,0,0,0,0,18,52,86,16,0,0,0,0,0,0,0,0,0,0,0,0,18,52,81,0,0,0,0,0,0,0,0,0,0,0,0,0,18,52,16,0,0,0,0,0,0,0,0,0,0,0,0,0,18,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,127,255,255,252,63,255,255,60,63,255,255,24,127,255,255,8,127,255,255,0,255,255,255,0,15,255,255,0,15,255,255,0,31,255,255,0,63,255,255,0,127,255,255,0,255,255,255,1,255,255,255,3,255,255,255,7,255,255,255,15,255,255,255,31,255,255,255,63,255,255,255,127,255,255,255,255,255,255,255);

cur_yellow:array[0..765] of byte=(
0,0,2,0,1,0,32,32,16,0,0,0,1,0,232,2,0,0,22,0,0,0,40,0,0,0,32,0,0,0,64,0,0,0,1,0,4,0,0,0,0,0,192,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,65,130,130,0,139,255,255,0,144,255,255,0,150,255,255,0,156,255,255,0,161,255,255,0,167,255,255,0,173,255,255,0,178,255,255,0,184,255,255,0,189,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,145,0,0,0,0,0,0,0,0,0,0,0,17,0,0,24,145,0,0,0,0,0,0,0,0,0,0,0,18,16,1,120,16,0,0,0,0,0,0,0,0,0,0,0,18,49,1,120,16,0,0,0,0,0,0,0,0,0,0,0,18,52,22,113,0,0,0,0,0,0,0,0,0,0,0,0,18,52,86,113,17,17,0,0,0,0,0,0,0,0,0,0,18,52,86,120,154,177,0,0,0,0,0,0,0,0,0,0,18,52,86,
120,154,16,0,0,0,0,0,0,0,0,0,0,18,52,86,120,145,0,0,0,0,0,0,0,0,0,0,0,18,52,86,120,16,0,0,0,0,0,0,0,0,0,0,0,18,52,86,113,0,0,0,0,0,0,0,0,0,0,0,0,18,52,86,16,0,0,0,0,0,0,0,0,0,0,0,0,18,52,81,0,0,0,0,0,0,0,0,0,0,0,0,0,18,52,16,0,0,0,0,0,0,0,0,0,0,0,0,0,18,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,127,255,255,252,63,255,255,60,63,255,255,24,127,255,255,8,127,255,255,0,255,255,255,0,15,255,255,0,15,255,255,0,31,255,255,0,63,255,255,0,127,255,255,0,255,255,255,1,255,255,255,3,255,255,255,7,255,255,255,15,255,255,255,31,255,255,255,63,255,255,255,127,255,255,255,255,255,255,255);

cur_black:array[0..765] of byte=(
0,0,2,0,1,0,32,32,16,0,0,0,1,0,232,2,0,0,22,0,0,0,40,0,0,0,32,0,0,0,64,0,0,0,1,0,4,0,0,0,0,0,192,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,226,226,226,0,13,13,13,0,19,19,19,0,26,26,26,0,32,32,32,0,39,39,39,0,46,46,46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22,81,0,0,0,0,0,0,0,0,0,0,0,17,0,0,22,81,0,0,0,0,0,0,0,0,0,0,0,18,16,1,118,16,0,0,0,0,0,0,0,0,0,0,0,18,49,1,118,16,0,0,0,0,0,0,0,0,0,0,0,18,52,22,113,0,0,0,0,0,0,0,0,0,0,0,0,18,52,86,113,17,17,0,0,0,0,0,0,0,0,0,0,18,52,86,118,84,49,0,0,0,0,0,0,0,0,0,0,18,52,86,118,84,16,0,0,0,0,0,0,0,0,0,0,18,52,86,118,81,
0,0,0,0,0,0,0,0,0,0,0,18,52,86,118,16,0,0,0,0,0,0,0,0,0,0,0,18,52,86,113,0,0,0,0,0,0,0,0,0,0,0,0,18,52,86,16,0,0,0,0,0,0,0,0,0,0,0,0,18,52,81,0,0,0,0,0,0,0,0,0,0,0,0,0,18,52,16,0,0,0,0,0,0,0,0,0,0,0,0,0,18,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,127,255,255,252,63,255,255,60,63,255,255,24,127,255,255,8,127,255,255,0,255,255,255,0,15,255,255,0,15,255,255,0,31,255,255,0,63,255,255,0,127,255,255,0,255,255,255,1,255,255,255,3,255,255,255,7,255,255,255,15,255,255,255,31,255,255,255,63,255,255,255,127,255,255,255,255,255,255,255);

cur_white:array[0..765] of byte=(
0,0,2,0,1,0,32,32,16,0,0,0,1,0,232,2,0,0,22,0,0,0,40,0,0,0,32,0,0,0,64,0,0,0,1,0,4,0,0,0,0,0,192,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,255,255,254,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,33,0,0,0,0,0,0,0,0,0,0,0,17,0,0,18,33,0,0,0,0,0,0,0,0,0,0,0,18,16,1,34,16,0,0,0,0,0,0,0,0,0,0,0,18,33,1,34,16,0,0,0,0,0,0,0,0,0,0,0,18,34,18,33,0,0,0,0,0,0,0,0,0,0,0,0,18,34,34,33,17,17,0,0,0,0,0,0,0,0,0,0,18,34,34,34,34,33,0,0,0,0,0,0,0,0,0,0,18,34,34,34,34,16,0,0,0,0,0,0,0,0,0,0,18,34,34,34,33,0,0,0,0,0,0,0,0,0,0,0,18,
34,34,34,16,0,0,0,0,0,0,0,0,0,0,0,18,34,34,33,0,0,0,0,0,0,0,0,0,0,0,0,18,34,34,16,0,0,0,0,0,0,0,0,0,0,0,0,18,34,33,0,0,0,0,0,0,0,0,0,0,0,0,0,18,34,16,0,0,0,0,0,0,0,0,0,0,0,0,0,18,33,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,127,255,255,252,63,255,255,60,63,255,255,24,127,255,255,8,127,255,255,0,255,255,255,0,15,255,255,0,15,255,255,0,31,255,255,0,63,255,255,0,127,255,255,0,255,255,255,1,255,255,255,3,255,255,255,7,255,255,255,15,255,255,255,31,255,255,255,63,255,255,255,127,255,255,255,255,255,255,255);


//GIF - thashtable
{$ifdef gif}
  HashKeyBits		= 13;			//Max number of bits per Hash Key
  HashSize		= 8009;			//Size of hash table, must be prime, must be > than HashMaxCode, must be < than HashMaxKey
  HashKeyMax		= (1 SHL HashKeyBits)-1;//Max hash key value, 13 bits = 8191
  HashKeyMask		= HashKeyMax;		//$1FFF
  GIFCodeBits		= 12;			//Max number of bits per GIF token code
  GIFCodeMax		= (1 SHL GIFCodeBits)-1;//Max GIF token code
  GIFCodeMask		= GIFCodeMax;		//$0FFF
  HashEmpty		= $000FFFFF;		//20 bits
  GIFTableMaxMaxCode	= (1 SHL GIFCodeBits);
  GIFTableMaxFill	= GIFTableMaxMaxCode-1;	//Clear table when it fills to
{$endif}

   //zip
   zlib_version='1.0.4';//??uni?? -> will this work as unicode???

type
   //.system support
   tcommonform     =tform;
   pobject         =^tobject;
   tpointer        =^pointer;
   tstr8           =class;
   tmask8          =class;
   tbasicimage     =class;
   tdynamiclist    =class;
   tdynamicbyte    =class;
   tdynamicinteger =class;
   tdynamicstring  =class;
   tbasicbwp       =class;
   //.GUI support
   tbasicsystem    =class;
   tbasiccontrol   =class;
   tbasicscroll    =class;
   tbasiccols      =class;
   tbasicsplash    =class;
   tbasichead      =class;
   tbasichelp      =class;
   tbasiccolor     =class;
   tbasictick      =class;
   tbasictitle     =class;
   tbasicbreak     =class;
   tbasicedit      =class;
   tbasictoolbar   =class;
   tbasicinfo      =class;
   tbasicstatus    =class;
   tbasicmenu      =class;
   tbasicscrollbar =class;
   tbasicint       =class;
   tbasicset       =class;
   tbasicsel       =class;
   tbasiccolors    =class;
   tbasicnav       =class;
   tdrivelist      =array[0..25] of boolean;//0=A, 1=B, 2=C..25=Z
   tbasiccolormatrix=class;
   tbasicsetcolor  =class;
   tbasicjump      =class;
   tbasictea       =class;
   tmainhelp       =class;
   tpulleventfunc  =function(n:string;var v:string;var int1:longint;var bol1:boolean):boolean;
   TFarProc             =pointer;
   UINT                 =longint;
   DWORD                =longint;
   BOOL                 =longbool;
   HWND                 =longint;
   WPARAM               =longint;
   LPARAM               =longint;
   LRESULT              =longint;
   THandle              =longint;
   tsysthread_buffer    =array[0..9999] of byte;
   TFNThreadStartRoutine=TFarProc;
   TFNTimeCallBack      =procedure(uTimerID,uMessage:UINT;dwUser,dw1,dw2:dword) stdcall;// <<-- special note: NO semicolon between "dword)" and "stdcall"!!!!
   MMRESULT = UINT;              { error return code, 0 means no error }
//tpoint
   ppoint=^tpoint;
   tpoint=record
    x:longint;
    y:longint;
    end;
//tmsg
   pmsg=^tmsg;
   tmsg= packed record
    hwnd:HWND;
    message:UINT;
    wParam:WPARAM;
    lParam:LPARAM;
    time:DWORD;
    pt:tpoint;
    end;


   //.events
   tsystemnotify                 =function(sender:tobject):boolean of object;
   tlongintevent                 =procedure(sender:tobject;xval:longint) of object;
   tlongintgetevent              =procedure(sender:tobject;var xval:longint) of object;
   tsimplestringevent            =procedure(sender:tobject;var xval:string) of object;//28feb2022
   tsimplestringeventb           =procedure(sender:tobject;xval:string) of object;//19jun2022
   tbasicmenu_getitem            =function(sender:tobject;xindex:longint;var xtab,xtep,xtepcolor:longint;var xcaption,xcaplabel,xhelp,xcode2:string;var xcode,xshortcut,xindent:longint;var xflash,xenabled,xtitle,xsep:boolean):boolean of object;//24feb2021
   tbasicint_onreadwriteval      =procedure(sender:tobject;var xval:longint;xwrite:boolean) of object;
   ttoolbarevent2                =function(sender:tbasiccontrol;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean of object;//15mar2021
   tstr8event                    =procedure(sender:tobject;xval:tstr8) of object;
   tmenufillevent                =procedure(sender:tobject;xstyle:string;xmenudata:tstr8;var ximagealign:longint;var xmenuname:string) of object;//19mar2021, 15mar2021
   tonacceptfilesevent           =procedure(sender:tobject;var msg:tmessage) of object;
   tonacceptevent                =function(sender:tobject;xfolder,xfilename:string;xindex,xcount:longint):boolean of object;
   tonfindheight                 =function(sender:tobject;xclientwidth:longint):longint of object;
   tfindlistimage                =procedure(sender:tobject;xformat:string;xindex:longint;var xcount,xtranscol:longint;var ximage:tobject) of object;

   //.color
   pcolor8       =^tcolor8;      tcolor8 =byte;
   pcolor16      =^tcolor16;     tcolor16=word;
{$ifdef D3}
   pcolor24      =^tcolor24;     tcolor24=packed record b:byte;g:byte;r:byte;end;//shoulde be packed for safety - 27SEP2011
   pcolor32      =^tcolor32;     tcolor32=packed record b:byte;g:byte;r:byte;a:byte;end;
{$endif}
{$ifdef D10}
   pcolor24      =^tcolor24;     tcolor24=packed record r:byte;g:byte;b:byte;end;//shoulde be packed for safety - 27SEP2011
   pcolor32      =^tcolor32;     tcolor32=packed record r:byte;g:byte;b:byte;a:byte;end;
{$endif}
   pcolor96      =^tcolor96;     tcolor96=packed record v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11:byte;end;
   //.row
   pcolorrow8    =^tcolorrow8;   tcolorrow8 =array[0..maxpixel] of tcolor8;
   pcolorrow16   =^tcolorrow16;  tcolorrow16=array[0..maxpixel] of tcolor16;
   pcolorrow24   =^tcolorrow24;  tcolorrow24=array[0..maxpixel] of tcolor24;
   pcolorrow32   =^tcolorrow32;  tcolorrow32=array[0..maxpixel] of tcolor32;
   pcolorrow96   =^tcolorrow96;  tcolorrow96=array[0..maxpixel] of tcolor96;
   //.rows
   pcolorrows8   =^tcolorrows8 ; tcolorrows8 =array[0..maxrow] of pcolorrow8;
   pcolorrows16  =^tcolorrows16; tcolorrows16=array[0..maxrow] of pcolorrow16;
   pcolorrows24  =^tcolorrows24; tcolorrows24=array[0..maxrow] of pcolorrow24;
   pcolorrows32  =^tcolorrows32; tcolorrows32=array[0..maxrow] of pcolorrow32;
   pcolorrows96  =^tcolorrows96; tcolorrows96=array[0..maxrow] of pcolorrow96;
   //.reference arrays
   pbitboolean   =^tbitboolean;  tbitboolean=set of 0..7;
   pdlbitboolean =^tdlbitboolean;tdlbitboolean=array[0..((maxint div sizeof(tbitboolean))-1)] of tbitboolean;
   pdlbyte       =^tdlbyte;      tdlbyte=array[0..((maxint div sizeof(byte))-1)] of byte;
   pdlchar       =^tdlchar;      tdlchar=array[0..((maxint div sizeof(char))-1)] of char;
   pdlsmallint   =^tdlsmallint;  tdlsmallint=array[0..((maxint div sizeof(smallint))-1)] of smallint;
   pdlword       =^tdlword;      tdlword=array[0..((maxint div sizeof(word))-1)] of word;
   pbilongint    =^tbilongint;   tbilongint=array[0..1] of longint;
   pdlbilongint  =^tdlbilongint; tdlbilongint=array[0..((maxint div sizeof(tbilongint))-1)] of tbilongint;
   pdllongint    =^tdllongint;   tdllongint=array[0..((maxint div sizeof(longint))-1)] of longint;
   pdlpoint      =^tdlpoint;     tdlpoint=array[0..((maxint div sizeof(tpoint))-1)] of tpoint;
   pdlcurrency   =^tdlcurrency;  tdlcurrency=array[0..((maxint div sizeof(currency))-1)] of currency;
   pdlcomp       =^tdlcomp;      tdlcomp=array[0..((maxint div sizeof(comp))-1)] of comp;
   pdldouble     =^tdldouble;    tdldouble=array[0..((maxint div sizeof(double))-1)] of double;
   pdldatetime   =^tdldatetime;  tdldatetime=array[0..((maxint div sizeof(tdatetime))-1)] of tdatetime;
   pdlrect       =^tdlrect;      tdlrect=array[0..((maxint div sizeof(trect))-1)] of trect;
   pdlstring     =^tdlstring;    tdlstring=array[0..((maxint div 32)-1)] of pstring;
   pdlpointer    =^tdlpointer;   tdlpointer=array[0..((maxint div sizeof(pointer))-1)] of pointer;
   pdlobject     =^tdlobject;    tdlobject=array[0..((maxint div sizeof(pobject))-1)] of tobject;

   //.conversion records
   pbit8=^tbit8;
   tbit8=record//01may2020 - char discontinued due to Unicode in D10
    case longint of
    0:(bits:tbitboolean);
    1:(val:byte);
    2:(s:shortint);
    end;

   pbyt1=^tbyt1;
   tbyt1=record
    case longint of
    0:(val:byte);
    1:(b:byte);
    2:(s:shortint);
    3:(bits:set of 0..7);
    4:(bol:boolean);
    end;

   pwrd2=^twrd2;
   twrd2=record
    case longint of
    0:(val:word);
    1:(si:smallint);
    3:(bytes:array [0..1] of byte);
    4:(bits:set of 0..15);
    end;

   pint4=^tint4;
   tint4=record
    case longint of
    0:(r,g,b,a:byte);
    1:(val:longint);
    2:(bytes:array [0..3] of byte);
    3:(wrds:array [0..1] of word);
    4:(bols:array [0..3] of bytebool);
    5:(sint:array[0..1] of smallint);
    6:(short:array[0..3] of shortint);
    7:(bits:set of 0..31);
    end;

   pcmp8=^tcmp8;
   tcmp8=record
    case longint of
    0:(val:comp);
    1:(cur:currency);
    2:(dbl:double);
    3:(bytes:array[0..7] of byte);
    4:(wrds:array[0..3] of word);
    5:(ints:array[0..1] of longint);
    6:(bits:set of 0..63);
    7:(datetime:tdatetime);
    end;

   pcur8=^tcur8;
   tcur8=record
    case longint of
    0:(val:currency);
    1:(cmp:comp);
    2:(dbl:double);
    3:(bytes:array[0..7] of byte);
    4:(wrds:array[0..3] of word);
    5:(ints:array[0..1] of longint);
    6:(bits:set of 0..63);
    7:(datetime:tdatetime);
    end;

   pext10=^text10;
   text10=record
    case longint of
    0:(val:extended);
    1:(bytes:array[0..9] of byte);
    2:(wrds:array[0..4] of word);
    3:(bits:set of 0..79);
    end;

   plistptr=^tlistptr;
   tlistptr=record
     count:longint;
     bytes:pdlbyte;
     end;

   //.system coloring record
   pvirtualinfo=^tvirtualinfo;
   tvirtualinfo=record
    frame         :longint;//main form border - 18apr2020
    frame2        :longint;
    framefindcol  :longint;//works with winLdr - 23feb202
    framefindcol2 :longint;//works with winLdr - 23feb202
    border        :longint;
    background    :longint;
    highlight     :longint;
    hover         :longint;
    disable       :longint;//used for background
    disableborder :longint;//used for border
    disablefont   :longint;
    font          :longint;
    fonthighlight :longint;
    fontname      :string;//unicode in Delph 10
    fontsize      :longint;
    fn            :longint;//system font index
    fb            :longint;
    fnH           :longint;//font height
    fbH           :longint;
    end;
   pvirtualmorecolors=^tvirtualmorecolors;
   tvirtualmorecolors=record
    frame         :longint;
    title         :longint;
    standard      :longint;
    allinone      :longint;
    dark_light    :longint;
    light_dark    :longint;
    end;

   //.bitmap animation helper record
   panimationinformation=^tanimationinformation;
   tanimationinformation=record
    format:string;//uppercase EXT (e.g. JPG, BMP, SAN etc)
    subformat:string;//same style as format, used for dual format streams "ATEP: 1)animation header + 2)image"
    info:string;//UNICODE WARNING --- optional custom information data block packed at end of image data - 22APR2012
    filename:string;
    map16:string;//UNICODE WARNING --- 26MAY2009 - used in "CAN or Compact Animation" to map all original cells to compacted imagestrip
    transparent:boolean;
    syscolors:boolean;//13apr2021
    flip:boolean;
    mirror:boolean;
    delay:longint;
    itemindex:longint;
    count:longint;//0..X (0=1cell, 1=2cells, etc)
    bpp:byte;
    binary:boolean;
    //cursor - 20JAN2012
    hotspotX:longint;//-1=not set=default
    hotspotY:longint;//-1=not set=default
    hotspotMANUAL:boolean;//use this hotspot instead of automatic hotspot - 03jan2019
    //32bit capable formats
    owrite32bpp:boolean;//default=false, for write modes within "ccs.todata()" where 32bit is used as the default save BPP - 22JAN2012
    //final
    readB64:boolean;//true=image was b64 encoded
    readB128:boolean;//true=image was b128 encoded
    writeB64:boolean;//true=encode image using b64
    writeB128:boolean;//true=encode image using b128 - 09feb2015
    //internal
    iosplit:longint;//position in IO stream that animation sep. (#0 or "#" occurs)
    cellwidth:longint;
    cellheight:longint;
    use32:boolean;
    end;

{twordcore}
   twordcharinfo=record
     c       :byte;
     cs      :byte;
     wid     :word;//primary array index (txtname/imgdata etc)
     txtid   :word;//secondary array index (lgfdata/lgfnref)
     width   :longint;
     height  :longint;
     height1 :longint;
     end;
   pwordcore=^twordcore;
   twordcore=record
     //init
     initstate     :string;//is set to "done" once this structure has be setup for the first time - 21aug2019
     dataonly      :boolean;//defaults=false=fonts load for GUI, true=font don't load and thus no GUI support (but faster for pure data conversion)
     hostsizing    :boolean;//default=false=host is NOT resizing so it's ok to perform WRAP request, true=host IS resizing so hold off performing WRAP calculations - 22apr2022
     //.onefontname/size - 05feb2022
     onefontname   :string;//default="<nil>", if set to a font name then ALL font names are overridden inclduing any pasted, io'ed, current etc even in dataonly mode -> now supports multiple dynamic fontnames of "$fontname=viFontname/$fontname2=viFontname2/default/default 2/<any valid fontname>" - 05feb2022
     onefontsize   :longint;//default=-1=off, 0=viFontsize, 1=viFontsize2 OR 2..N=set ALL font sizes to this value
     onefontREF    :string;//internal use only
     lastvisyncid  :longint;//13feb2022
     maxformatlevel:longint;//0=plaintext, 1=enhanced text, 2=advanced text (default) - 12jun2022
     //font list -> linear graphic font
     lgfdata       :array[0..999] of tstr8;//rapid access linear graphic font - 21aug2019
     lgfnref       :array[0..999] of string;//simple lookup name for style|size|fontname -> used to autocreate lgfDATA when required - 25sep2019
     //text list
     txtname       :array[0..999] of string;//font name
     txtsize       :array[0..999] of longint;//font size
     txtbold       :array[0..999] of boolean;//font style
     txtitalic     :array[0..999] of boolean;
     txtunderline  :array[0..999] of boolean;
     txtstrikeout  :array[0..999] of boolean;
     txtcolor      :array[0..999] of longint;
     txtbk         :array[0..999] of longint;
     txtborder     :array[0..999] of longint;
     txtalign      :array[0..999] of byte;//0=left, 1=centre, 2=right
     txtid         :array[0..999] of word;//pointer to "lgfdata"
     txtzoom       :array[0..999] of byte;//1..4 -> not stored in datastream -> internal reference only - 14mar2021
     //image list
     imgdata       :array[0..999] of tstr8;//original image data stream (JPG, TEH, TEM, BMP etc)
     img24         :array[0..999] of tbasicimage;//raw 24bit image data (no header, in-order, continous stream of BGR pixels)
     imgtrans      :array[0..999] of boolean;//transparent (top-left) - 27aug2021
     imgw          :array[0..999] of longint;
     imgh          :array[0..999] of longint;
     //data streams
     data          :tstr8;//single byte text stream
     data2         :tstr8;//as above, forms a 16bit (word) list id in range 0..999 for above
     data3         :tstr8;//2nd part of list1's 16bit list id
     //alt datastreams - these are assumed to be POINTERS and thus are not destroyed - 26jun2022
     alt1          :tstr8;//pointer only
     alt2          :tstr8;//pointer only
     alt3          :tstr8;//pointer only
     //multi undo handler - 25jun2022
     menabled      :boolean;//default=false;
     mn            :array[-1..199] of string;
     mlimit        :longint;//2..200
     //.support
     mlist         :tstr8;
     md1           :tstr8;
     md2           :tstr8;
     md3           :tstr8;
     mstyle        :longint;
     mfrom1        :longint;//required
     mact          :longint;//vital - 03jul2022
     mlen          :longint;//required
     //support streams -> list every item's x,y,w,h information (in 32bit blocks) and line information - 21aug2019
     linex         :pdlLONGINT;
     liney         :pdlLONGINT;
     lineh         :pdlLONGINT;
     lineh1        :pdlLONGINT;
     linep         :pdlLONGINT;//item pos at start of this line
     //.hard and fast limit of each core, exceeding these limits will cause memory corruption/system failure - 22aug2019
     linesize      :longint;
     listsize      :longint;
     //.stream cores
     corelinex     :tstr8;
     coreliney     :tstr8;
     corelineh     :tstr8;
     corelineh1    :tstr8;
     corelinep     :tstr8;
     //current support
     cfontname     :string;
     cfontsize     :longint;
     cbold         :boolean;
     citalic       :boolean;
     cunderline    :boolean;
     cstrikeout    :boolean;
     ccolor        :longint;
     cbk           :longint;
     cborder       :longint;
     calign        :byte;//0=left, 1=centre, 2=right
     //paint + management
     cursorpos     :longint;
     cursorpos2    :longint;
     papersize     :longint;//0=psA4, 1=psA3 etc -> used when wrapstyle=wwsPage
     paperwidth    :longint;//read only - width of paper for screen purposes
     paperheight   :longint;//read only - height of paper for screen purposes
     dpi           :longint;//default=95, widescreen=120
     widestline    :longint;//retains the wides line in pixels even when said lines have been removed -> inline with Notepad - 12mar2021
     usezoom       :boolean;//default=true=zoom fontsize and images to system zoom level (vizoom), false=do not apply zoom - 14mar2021
     lastzoom      :longint;//internal use only -> tracks change in zoom level - 14mar2021
     zoomnow       :longint;//internal use only -> current zoom level -> used for all zooming of text and images - 14mar2021
     pagewidth     :longint;//0=wrap to area
     pageheight    :longint;//maxint=continuous
     pagecolor     :longint;//color of page background -> default=clnone=>white=rgb(255,255,255)
     pagecolor2    :longint;//override pagecolor
     pagefontcolor2:longint;//override text color (all fonts)
     pagecolorise2 :boolean;//default=false, true=draw colored images as shades of system colors (page override2)
     pageoverride2 :boolean;//default=false=don't use "pagecolor2" or "pagefontcolor2"
     pageselcolor  :longint;//selection color -> uses built-in light blue by default
     pagefontselcolor:longint;
     viewwidth     :longint;//control view width
     viewheight    :longint;//control view height
     viewcolor     :longint;//color of unused area -> default=rgb(152,152,152)
     vpos          :longint;//control vertical scrollbar position
     vposPART      :longint;//fine adjustment of vpos -> part line in pixels - 21jun2022
     vhostsync     :boolean;//true=host must read "vpos/vmax" and sync with host scrollbar
     vcheck        :longint;//internal use only
     hpos          :longint;//control horizontal scrollbar position
     hhostsync     :boolean;//true=host must read "hpos/hmax" and sync with host scrollbar
     pagecount     :longint;//number of pages (always 1 or more) -> works when "wrapstyle=wwsPage"
     totalheight   :longint;//height of all items within the confines of pagewidth & pageheight
     linecount     :longint;
     line          :longint;
     col           :longint;
     wrapcount     :longint;//indicates HOW FAR the wrap system has progressed (complete when wrapcount>=length(x.data))
     dataid        :longint;//reset between documents and calls to "clear"
     dataid2       :longint;//this dataid is NEVER reset and is persistent between documents, calls to "clear" etc, but is RESET only on call to "init" - 14jun2022
     mustpaint     :boolean;
     paintlock     :boolean;
     modified      :boolean;
     timer100      :currency;//used to internally throttle the "timer" event to a steady 100ms internval cycle MAX
     timerslow     :currency;
     timerfont500  :currency;//02feb2022
     idleref       :currency;
     k_idleref     :currency;//keyboard idle - 26sep2022
     timerbusy     :boolean;
     wrapstack     :tstr8;//stack of wordwrap ranges to process (from(4b)+to(4b)=64bit)
     kstack        :tstr8;//stack of keyboard inputs
     mstack        :tstr8;//stack of mouse inputs
     briefstatus   :string;
     shortcuts     :boolean;
     styleshortcuts:boolean;
     flashcursor   :boolean;//internally managed
     drawcursor    :boolean;//internally managed
     cursoronscrn  :boolean;//*
     linecursorx   :longint;//internal use only -> used to remember cursor's original X coordinate when scrolling up/down using keyboard keys - 31aug2019
     havefocus     :boolean;//set by host
     showcursor    :boolean;//set by host
     readonly      :boolean;//set by host
     shift         :boolean;//set internally -> true=shift key is down
     wasdown       :boolean;//mouse support - internal
     wasright      :boolean;//mouse support - internal
     feather       :longint;//0=sharp edges to text, 1=light feather, 2=heavy feather
     sysfeather    :boolean;//default=true=uses system feather (fills ".feather" with "vifeather" value) - 26aug2020
     activecursor  :tcursor;
     //.buffer support -> used for screen painting
     buffer24      :tbasicimage;//we could use 24bits here since it's our image handler - 21aug2020
     bufferref     :string;
     syncref       :string;
     //consts
     c_smallwrap   :longint;//set once by "init"
     c_bigwrap     :longint;//set once by "init"
     c_pagewrap    :longint;//use to wrap an entire screen of characters -> best guess -> not actual requirement, but a large number to cover even 8k displays
     c_idlepause   :longint;//time to take before cursor can flash again, default=500ms
     //special - delayed events/vars
     cursorstyle             :char;//"t" = text cursor, "l" = link cursor
     cursor_keyboard_moveto  :longint;
     timer_chklinecursorx    :boolean;
     sysfontDefault          :string;
     sysfontDefault2         :string;
//xxxxxxxxxxxxxxxx     wine                    :boolean;//default=false, true=then all fonts thare are listed as "Default" are remade and the control updated - 02feb2022
     //other
     landscape     :boolean;//default=false
     wrapstyle     :longint;//0=wwsNone=no wrap, 1=wwsWindow=to window(viewwidth/height), 2=wwsPage=to page (pagewidth/pageheight)
     wrapreadonly  :boolean;//default=false=wrapstyle adjust with "ioset()", true=wrap ONLY changes when specifically called via "low__wordcore(x,'wrap','<new wrapstyle value>') - 12mar2021
     lastfindalignpos:longint;//default=-1=not set
     //reference
     bwd_color     :longint;
     bwd_color2    :longint;
     bwd_bk        :longint;
     //claude support - optional color overrides for Claude - 14jul2020
     useclaudecolors  :boolean;//default=false=off
     claude_text1     :longint;
     claude_text2     :longint;
     claude_text3     :longint;
     claude_text4     :longint;
     claude_text5     :longint;
     claude_header1   :longint;
     claude_header2   :longint;
     claude_header3   :longint;
     claude_header4   :longint;
     claude_header5   :longint;
     //special options
     defCopyformat    :string;//'txt';
     defFontname      :string;//"arial" - 05sep2020
     defFontsize      :longint;//"12"
     defFontcolor     :longint;//"0" = black
     //special actions - 19apr2021
     oviewurl         :boolean;//default=true=click on a url "http://" or "https://" or "ftp://" or "ftps://" or "mailto:" with not active selection and the link is executed via the default system handler - 19apr2021
     end;

//zip support ------------------------------------------------------------------
   TAlloc = function (AppData: Pointer; Items, Size: longint): Pointer;
   TFree = procedure (AppData, Block: Pointer);

  // Internal structure.  Ignore. - updated for "pointer instead of pchar" 26jan2021
  TZStreamRec = packed record
    next_in: pointer;//was: PChar;       // next input byte
    avail_in: longint;    // number of bytes available at next_in
    total_in: longint;    // total nb of input bytes read so far

    next_out: pointer;//was: PChar;      // next output byte should be put here
    avail_out: longint;   // remaining free space at next_out
    total_out: longint;   // total nb of bytes output so far

    msg: PChar;           // last error message, NULL if no error
    internal: Pointer;    // not visible by applications

    zalloc: TAlloc;       // used to allocate the internal state
    zfree: TFree;         // used to free the internal state
    AppData: Pointer;     // private data object passed to zalloc and zfree

    data_type: longint;   //  best guess about the data type: ascii or binary
    adler: longint;       // adler32 value of the uncompressed data
    reserved: longint;    // reserved for future use
  end;

//system objects ---------------------------------------------------------------

//tbasicprg1
   tbasicprg1=class(tobject)
   public
    //create
    constructor create; virtual;
    procedure createfinish; virtual;//30jul2021
    destructor destroy; override;
    function getsystem:tbasicsystem; virtual;
    //information
    property sys:tbasicsystem read getsystem;//short version
    property gui:tbasicsystem read getsystem;
    //workers
    procedure xloadsettings; virtual;
    procedure xsavesettings; virtual;
   end;

//tbasicprg2
   tbasicprg2=class(tbasicprg1)
   private
    isystem:tbasicsystem;
    irootwin:tbasicscroll;
   public
    //create
    constructor create(xminsysver:longint;xhost:tobject;dwidth,dheight:longint); virtual;
    procedure createfinish; override;//30jul2021
    destructor destroy; override;
    function getsystem:tbasicsystem; override;
    procedure xstarttimer; virtual;
    //values
    property sys;
    property gui;
    property rwin:tbasicscroll read irootwin;//short version
    property rootwin:tbasicscroll read irootwin;
    //events
    procedure __ontimer(sender:tobject); virtual;
   end;

//tobjectex
   tobjectex=class(tobject)
   public
    constructor create; virtual;
    destructor destroy; override;
   end;

{ttbt}
{$ifdef tbt}
    ttbt=class(tobjectex)
    private
     ipassword,ikeyrandom,ikey:string;//fixed length string of 1000 chars
     ikeymodified:boolean;
     ipower:integer;
     function keyinit:boolean;
     function keyid(x:tstr8;var id:integer):boolean;
     procedure setpassword(x:string);
     procedure setpower(x:integer);
    public
     //options
     obreath:boolean;//default=true=application.processmessage, false=do not use "application.processmessages" - 02mar2015
     //create
     constructor create;
     destructor destroy; override;
     //workers
     property power:integer read ipower write setpower;
     property password:string read ipassword write setpassword;
     function encode(s,d:tstr8;var e:string):boolean;
     function encode4(s,d:tstr8;var e:string):boolean;
     function encodeLITE4(s:tstr8;e:string):boolean;
     function decode(s,d:tstr8;var e:string):boolean;
     function decodeLITE(s:tstr8;var e:string):boolean;//uses minimal RAM - 02JAN2012
     //internal
     function frs(s,d:tstr8;m:byte):boolean;//feedback randomisation of string - 16sep2017, 16nov2016
    end;
{$endif}

//GIF - thashtable
{$ifdef gif}
    tgifscreen=packed record//7
     w:word;
     h:word;
     pf:byte;//packed flags
     bgi:byte;//background color index that points to a color in "global color palette"
     ar:byte;//aspectratio => actual ratio = (AspectRatio + 15) / 64
     end;
    tgifimgdes=packed record
     sep:byte;
     dx:word;
     dy:word;
     w:word;
     h:word;
     pf:byte;//bit fields
     end;
   // A Hash Key is 20 bits wide.
    // - The lower 8 bits are the postfix character (the new pixel).
    // - The upper 12 bits are the prefix code (the GIF token).
    // A KeyInt must be able to represent the integer values -1..(2^20)-1
    //KeyInt = longInt;	// 32 bits
    //CodeInt = SmallInt;	// 16 bits
    thasharray=array[0..hashsize-1] of longint;
    phasharray=^thasharray;
    thashtable=class(tobjectex)//hash table for GIF compressor
    private
     hashtable:phasharray;
    public
     constructor create; override;
     destructor destroy; override;
     procedure clear;
     procedure insert(key:longint;code:smallint);
     function lookup(key:longint):smallint;
    end;
{$endif}

{tbasicthreadstop}
//xxxxxxxxxxxxxxxxxxxxxxxxxxnew -> need to copy over to gosscore !!!!!!!!!!
{//was:
   tbasicthreadstop=class(tthread)
   private
    //64bit system timer support - Delphi 3
    ims64init:boolean;
    ims64LAST:comp;
    ims64OFFSET:comp;
    //vars
    imustfree,ivcl_waiting,idestroying,istopped,istopping:boolean;
   public
    //create
    constructor create;
    destructor destroy; override;
    procedure xcreate; virtual;
    procedure xdestroy; virtual;
    procedure xdestroy2; virtual;
    //.stop support -> internal use only
    procedure mustfree;
    procedure muststop;
    property mustfreeok:boolean read imustfree;
    property stopping:boolean read istopping write istopping;
    property stopped:boolean read istopped write istopped;
    property vcl_waiting:boolean read ivcl_waiting write ivcl_waiting;
    //workers
    function m64:comp;//64bit millisecond system timer, 01-SEP-2006
   end;
{}//yyyyyyyyyyyyyyyy

//xxxxxxxxxxxxxxxxxxxxxxxxxxxxx//ggggggggggggggggggggggggggggg
{tbasicimage}
   tbasicimage=class(tobject)
   private
    idata,irows:tstr8;
    ibits,iwidth,iheight:longint;
    iprows8 :pcolorrows8;
    iprows16:pcolorrows16;
    iprows24:pcolorrows24;
    iprows32:pcolorrows32;
    istable:boolean;
   public
    //animation support
    ai:tanimationinformation;
    dtransparent:boolean;
    omovie:boolean;//default=false, true=fromdata will create the "movie" if not already created
    oaddress:string;//used for "AAS" to load from a specific folder - 30NOV2010
    ocleanmask32bpp:boolean;//default=false, true=reads only the upper levels of the 8bit mask of a 32bit icon/cursor to eliminate poor mask quality - ccs.fromicon32() etc - 26JAN2012
    rhavemovie:boolean;//default=false, true=object has a movie as it's animation
    //create
    constructor create; virtual;
    destructor destroy; override;
    function copyfrom(s:tbasicimage):boolean;//09may2022, 09feb2022
    //information
    property stable:boolean read istable;
    property bits:longint read ibits;
    property width:longint read iwidth;
    property height:longint read iheight;
    property prows8 :pcolorrows8  read iprows8;
    property prows16:pcolorrows16 read iprows16;
    property prows24:pcolorrows24 read iprows24;
    property prows32:pcolorrows32 read iprows32;
    property rows:tstr8 read irows;
    //workers
    function sizeto(dw,dh:longint):boolean;
    function setparams(dbits,dw,dh:longint):boolean;
    function findscanline(slayer,sy:longint):pointer;
    //io
    function todata:tstr8;//19feb2022
    function fromdata(s:tstr8):boolean;//19feb2022

    //core
    property data:tstr8 read idata;
    function setraw(dbits,dw,dh:longint;ddata:tstr8):boolean;
   end;

{tbmp}
   tbmp=class(tobject)
   private
    icore:tbitmap;
    irows:tstr8;
    isharp,ilockcount,ibits,iwidth,iheight:longint;
    iunlocking:boolean;
    irows8 :pcolorrows8;
    irows15:pcolorrows16;
    irows16:pcolorrows16;
    irows24:pcolorrows24;
    irows32:pcolorrows32;
    ilockptr:pointer;
    {$ifdef D3}
    isharphfont:hfont;//Win32 only
    {$endif}
    procedure setbits(x:longint);
    procedure setwidth(x:longint);
    procedure setheight(x:longint);
    procedure setsharp(x:longint);
    function getcanvas:tcanvas;
    procedure xinfo;
   public
    //animation support
    ai:tanimationinformation;
    dtransparent:boolean;
    omovie:boolean;//default=false, true=fromdata will create the "movie" if not already created
    oaddress:string;//used for "AAS" to load from a specific folder - 30NOV2010
    ocleanmask32bpp:boolean;//default=false, true=reads only the upper levels of the 8bit mask of a 32bit icon/cursor to eliminate poor mask quality - ccs.fromicon32() etc - 26JAN2012
    rhavemovie:boolean;//default=false, true=object has a movie as it's animation
    //create
    constructor create; virtual;
    destructor destroy; override;
    //information
    property core:tbitmap read icore;
    function cansetparams:boolean;
    function setparams(dbits,dw,dh:longint):boolean;
    property width:longint read iwidth write setwidth;
    property height:longint read iheight write setheight;
    property bits:longint read ibits write setbits;
    //rows -> can only use rows when locked, e.g. "canrows=true" - 21may2020
    function canrows:boolean;
    property rows:tstr8 read irows;//read-only
    property prows8 :pcolorrows8  read irows8;
    property prows15:pcolorrows16 read irows15;
    property prows16:pcolorrows16 read irows16;
    property prows24:pcolorrows24 read irows24;
    property prows32:pcolorrows32 read irows32;
    //lock -> required to map rows under Android via FireMonkey
    function locked:boolean;
    function lock:boolean;
    function unlock:boolean;
    //sharp -> can't do this once we're locked
    function cansharp:boolean;
    property sharp:longint read isharp write setsharp;//0=off, 1=sharp, 2=greyscale
    //canvas
    function cancanvas:boolean;
    property canvas:tcanvas read getcanvas;
    //assign
    function canassign:boolean;
    function assign(x:tobject):boolean;
   end;

{tbitmapenhanced}
   tbitmapenhanced=class(tbitmap)
   public
    ai:tanimationinformation;
    dtransparent:boolean;
    //options
    omovie:boolean;//default=false, true=fromdata will create the "movie" if not already created
    oaddress:string;//used for "AAS" to load from a specific folder - 30NOV2010
    ocleanmask32bpp:boolean;//default=false, true=reads only the upper levels of the 8bit mask of a 32bit icon/cursor to eliminate poor mask quality - ccs.fromicon32() etc - 26JAN2012
    //optional advancement - pointer to a control - 28NOV2010
    //**not supported:     movie:tvirtualmoviebasic;
    //special result vars
    rhavemovie:boolean;//default=false, true=object has a movie as it's animation
    //create
    constructor create; override;//01NOV2011
    destructor destroy; override;//28NOV2010
   end;

//tstr8 - 8bit binary string -> replacement for Delphi 10's lack of 8bit native string - 29apr2020
//xxxxxxxxxxxxxxxxxxxxxxx//88888888888888888888888
   tstr8=class(tobject)
   private
    idata:pointer;
    ilockcount,idatalen,icount:longint;//datalen=size of allocated memory | count=size of memory in use by user
    ichars :pdlchar;
    ibytes :pdlbyte;
    iints4 :pdllongint;
    irows8 :pcolorrows8;
    irows15:pcolorrows16;
    irows16:pcolorrows16;
    irows24:pcolorrows24;
    irows32:pcolorrows32;
    function getbytes(x:longint):byte;
    procedure setbytes(x:longint;xval:byte);
    function getbytes1(x:longint):byte;//1-based
    procedure setbytes1(x:longint;xval:byte);
    function getchars(x:longint):char;
    procedure setchars(x:longint;xval:char);
    //get + set support --------------------------------------------------------
    function getcmp8(xpos:longint):comp;
    function getcur8(xpos:longint):currency;
    function getint4(xpos:longint):longint;
    function getint4i(xindex:longint):longint;
    function getint4R(xpos:longint):longint;
    function getint3(xpos:longint):longint;
    function getsml2(xpos:longint):smallint;//28jul2021
    function getwrd2(xpos:longint):word;
    function getwrd2R(xpos:longint):word;
    function getbyt1(xpos:longint):byte;
    function getbol1(xpos:longint):boolean;
    function getchr1(xpos:longint):char;
    function getstr(xpos,xlen:longint):string;//0-based - fixed - 16aug2020
    function getstr1(xpos,xlen:longint):string;//1-based
    function getnullstr(xpos,xlen:longint):string;//20mar2022
    function getnullstr1(xpos,xlen:longint):string;//20mar2022
    function gettext:string;
    procedure settext(x:string);
    function gettextarray:string;
    procedure setcmp8(xpos:longint;xval:comp);
    procedure setcur8(xpos:longint;xval:currency);
    procedure setint4(xpos:longint;xval:longint);
    procedure setint4i(xindex:longint;xval:longint);
    procedure setint4R(xpos:longint;xval:longint);
    procedure setint3(xpos:longint;xval:longint);
    procedure setsml2(xpos:longint;xval:smallint);
    procedure setwrd2(xpos:longint;xval:word);
    procedure setwrd2R(xpos:longint;xval:word);
    procedure setbyt1(xpos:longint;xval:byte);
    procedure setbol1(xpos:longint;xval:boolean);
    procedure setchr1(xpos:longint;xval:char);
    procedure setstr(xpos:longint;xlen:longint;xval:string);//0-based
    procedure setstr1(xpos:longint;xlen:longint;xval:string);//1-based
    //replace support ----------------------------------------------------------
    procedure setreplace(x:tstr8);
    procedure setreplacecmp8(x:comp);
    procedure setreplacecur8(x:currency);
    procedure setreplaceint4(x:longint);
    procedure setreplacewrd2(x:word);
    procedure setreplacebyt1(x:byte);
    procedure setreplacebol1(x:boolean);
    procedure setreplacechr1(x:char);
    procedure setreplacestr(x:string);
    //.ease of use support
    procedure setbdata(x:tstr8);
    function getbdata:tstr8;
    procedure setbappend(x:tstr8);
   public
    //ease of use support options
    oautofree:boolean;//default=false
    otestlock1:boolean;//debug only - 09may2021
    //create
    constructor create(xlen:longint); virtual;
    destructor destroy; override;
    function xresize(x:longint;xsetcount:boolean):boolean;
    function copyfrom(s:tstr8):boolean;//09feb2022
    //lock - disables "oautofree" whilst many layers are working on same object - 19aug2020
    procedure lock;
    procedure unlock;
    property lockcount:longint read ilockcount;
    //information
    property core:pointer read idata;//read-only
    property datalen:longint read idatalen;//actual internal size of data buffer - 25sep2020
    property len:longint read icount;
    property count:longint read icount;
    property chars[x:longint]:char read getchars write setchars;
    property bytes[x:longint]:byte read getbytes write setbytes;//0-based
    property bytes1[x:longint]:byte read getbytes1 write setbytes1;//1-based
    function scanline(xfrom:longint):pointer;
    //.rapid access -> no range checking
    property pbytes:pdlbyte       read ibytes;
    property pints4 :pdllongint   read iints4;
    property prows8 :pcolorrows8  read irows8;
    property prows16:pcolorrows16 read irows16;
    property prows24:pcolorrows24 read irows24;
    property prows32:pcolorrows32 read irows32;
    function maplist:tlistptr;//26apr2021, 07apr2021
    //workers
    function clear:boolean;
    function setlen(x:longint):boolean;
    function minlen(x:longint):boolean;
    function fill(xfrom,xto:longint;xval:byte):boolean;
    function del(xfrom,xto:longint):boolean;
    function del3(xfrom,xlen:longint):boolean;//27jan2021
    //.object support
    function add(var x:tstr8):boolean;
    function addb(x:tstr8):boolean;
    function add2(var x:tstr8;xfrom,xto:longint):boolean;
    function add3(var x:tstr8;xfrom,xlen:longint):boolean;
    function add31(var x:tstr8;xfrom1,xlen:longint):boolean;//28jul2021
    function ins(var x:tstr8;xpos:longint):boolean;
    function ins2(var x:tstr8;xpos,xfrom,xto:longint):boolean;//26apr2021
    function owr(var x:tstr8;xpos:longint):boolean;//overwrite -> enlarge if required - 01oct2020
    function owr2(var x:tstr8;xpos,xfrom,xto:longint):boolean;
    //.swappers
    function swap(s:tstr8):boolean;//27dec2021
    //.array support
    function aadd(x:array of byte):boolean;
    function aadd1(x:array of byte;xpos1,xlen:longint):boolean;//1based - 19aug2020
    function aadd2(x:array of byte;xfrom,xto:longint):boolean;
    function ains(x:array of byte;xpos:longint):boolean;
    function ains2(x:array of byte;xpos,xfrom,xto:longint):boolean;
    function pins2(x:pdlbyte;xcount,xpos,xfrom,xto:longint):boolean;//07feb2022
    //.add number support -> always append to end of data
    function addcmp8(xval:comp):boolean;
    function addcur8(xval:currency):boolean;
    function addRGBA4(r,g,b,a:byte):boolean;
    function addRGB3(r,g,b:byte):boolean;
    function addint4(xval:longint):boolean;
    function addint4R(xval:longint):boolean;
    function addint3(xval:longint):boolean;
    function addwrd2(xval:word):boolean;
    function addwrd2R(xval:word):boolean;
    function addsmi2(xval:smallint):boolean;//01aug2021
    function addbyt1(xval:byte):boolean;
    function addbol1(xval:boolean):boolean;
    function addchr1(xval:char):boolean;
    function addstr(xval:string):boolean;
    function addrec(a:pointer;asize:longint):boolean;//07feb2022
    //.insert number support -> insert at specified position (0-based)
    function insbyt1(xval:byte;xpos:longint):boolean;
    function insbol1(xval:boolean;xpos:longint):boolean;
    function insint4(xval,xpos:longint):boolean;
    //.string support
    function sadd(x:string):boolean;
    function sadd2(x:string;xfrom,xto:longint):boolean;
    function sadd3(x:string;xfrom,xlen:longint):boolean;
    function sins(x:string;xpos:longint):boolean;
    function sins2(x:string;xpos,xfrom,xto:longint):boolean;
    //.push support -> insert data at position "pos" and inc pos to new position
    function pushcmp8(var xpos:longint;xval:comp):boolean;
    function pushcur8(var xpos:longint;xval:currency):boolean;
    function pushint4(var xpos:longint;xval:longint):boolean;
    function pushint4R(var xpos:longint;xval:longint):boolean;
    function pushint3(var xpos:longint;xval:longint):boolean;//range: 0..16777215
    function pushwrd2(var xpos:longint;xval:word):boolean;
    function pushwrd2R(var xpos:longint;xval:word):boolean;
    function pushbyt1(var xpos:longint;xval:byte):boolean;
    function pushbol1(var xpos:longint;xval:boolean):boolean;
    function pushchr1(var xpos:longint;xval:char):boolean;//WARNING: Unicode conversion possible -> use only 0-127 chars????
    function pushstr(var xpos:longint;xval:string):boolean;
    //.get/set support
    property cmp8[xpos:longint]:comp read getcmp8 write setcmp8;
    property cur8[xpos:longint]:currency read getcur8 write setcur8;
    property int4[xpos:longint]:longint read getint4 write setint4;
    property int4i[xindex:longint]:longint read getint4i write setint4i;
    property int4R[xpos:longint]:longint read getint4R write setint4R;
    property int3[xpos:longint]:longint read getint3 write setint3;//range: 0..16777215
    property sml2[xpos:longint]:smallint read getsml2 write setsml2;//28jul2021
    property wrd2[xpos:longint]:word read getwrd2 write setwrd2;
    property wrd2R[xpos:longint]:word read getwrd2R write setwrd2R;
    property byt1[xpos:longint]:byte read getbyt1 write setbyt1;
    property bol1[xpos:longint]:boolean read getbol1 write setbol1;
    property chr1[xpos:longint]:char read getchr1 write setchr1;
    property str[xpos:longint;xlen:longint]:string read getstr write setstr;//0-based
    property str1[xpos:longint;xlen:longint]:string read getstr1 write setstr1;//1-based
    property nullstr[xpos:longint;xlen:longint]:string read getnullstr;//0-based
    property nullstr1[xpos:longint;xlen:longint]:string read getnullstr1;//1-based
    function setarray(xpos:longint;xval:array of byte):boolean;
    property text:string read gettext write settext;//use carefully -> D10 uses unicode
    property textarray:string read gettextarray;
    //.replace support
    property replace:tstr8 write setreplace;
    property replacecmp8:comp write setreplacecmp8;
    property replacecur8:currency write setreplacecur8;
    property replaceint4:longint write setreplaceint4;
    property replacewrd2:word write setreplacewrd2;
    property replacebyt1:byte write setreplacebyt1;
    property replacebol1:boolean write setreplacebol1;
    property replacechr1:char write setreplacechr1;
    property replacestr:string write setreplacestr;
    //.writeto structures - 28jul2021
    function writeto1(a:pointer;asize,xfrom1,xlen:longint):boolean;
    function writeto1b(a:pointer;asize:longint;var xfrom1:longint;xlen:longint):boolean;
    function writeto(a:pointer;asize,xfrom0,xlen:longint):boolean;//28jul2021
    //.logic support
    function empty:boolean;
    function notempty:boolean;
    function same(var x:tstr8):boolean;
    function same2(xfrom:longint;var x:tstr8):boolean;
    function asame(x:array of byte):boolean;
    function asame2(xfrom:longint;x:array of byte):boolean;
    function asame3(xfrom:longint;x:array of byte;xcasesensitive:boolean):boolean;
    function asame4(xfrom,xmin,xmax:longint;var x:array of byte;xcasesensitive:boolean):boolean;
    //.converters
    function uppercase:boolean;
    function uppercase1(xpos1,xlen:longint):boolean;
    function lowercase:boolean;
    function lowercase1(xpos1,xlen:longint):boolean;
    //.data block support
    function datpush(n:longint;x:tstr8):boolean;//27jun2022
    function datpull(var xpos,n:longint;x:tstr8):boolean;//27jun2022
    //.ease of use point of access
    property bdata:tstr8 read getbdata write setbdata;
    property bappend:tstr8 write setbappend;
   end;

{tmemstr8}
   tmemstr8=class(tstream)//tstringstream replacement
   private
    iposition:longint;
    idata:tstr8;//pointer only
   protected
    procedure setsize(newsize:longint); override;
   public
    //create
    constructor create(_ptr:tstr8); virtual;
    destructor destroy; override;
    //workers
    function read(var x;xlen:longint):longint; override;
    function write(const x;xlen:longint):longint; override;
    function seek(offset:longint;origin:word):longint; override;
    function readstring(count:longint):string;
    procedure writestring(const x:string);
   end;

{tvars8}
   tvars8=class(tobject)
   private
    icore:tstr8;
    function getb(xname:string):boolean;
    procedure setb(xname:string;xval:boolean);
    function geti(xname:string):longint;
    procedure seti(xname:string;xval:longint);
    function geti64(xname:string):comp;
    procedure seti64(xname:string;xval:comp);
    function getdt64(xname:string):tdatetime;
    procedure setdt64(xname:string;xval:tdatetime);//31jan2022
    function getc(xname:string):currency;
    procedure setc(xname:string;xval:currency);
    function gets(xname:string):string;
    procedure sets(xname,xvalue:string);
    function getd(xname:string):tstr8;
    procedure setd(xname:string;xvalue:tstr8);
    function xfind(xname:string;var xpos,nlen,dlen,blen:longint):boolean;
    function xnext(var xfrom,xpos,nlen,dlen,blen:longint):boolean;
    procedure xsets(xname,xvalue:string);
    procedure xsetd(xname:string;xvalue:tstr8);
    function gettext:string;
    procedure settext(x:string);
    function getdata:tstr8;
    procedure setdata(xdata:tstr8);
    function getbinary(hdr:string):tstr8;
    procedure setbinary(hdr:string;xval:tstr8);
   public
    //create
    constructor create; virtual;
    destructor destroy; override;
    property core:tstr8 read icore;//use carefully - 09oct2020
    //workers
    procedure clear;
    //information
    function len:longint;
    function found(xname:string):boolean;
    property b[xname:string]:boolean read getb write setb;
    property i[xname:string]:longint read geti write seti;
    property i64[xname:string]:comp read geti64 write seti64;
    property dt64[xname:string]:tdatetime read getdt64 write setdt64;//31jan2022
    property c[xname:string]:currency read getc write setc;
    property value[xname:string]:string read gets write sets;//support text only
    property s[xname:string]:string read gets write sets;//support text only
    property d[xname:string]:tstr8 read getd write setd;//supports binary data
    //.fast "d" access - 28dec2021
    function dget(xname:string;xdata:tstr8):boolean;
    //default value handlers
    function bdef(xname:string;xdefval:boolean):boolean;
    function idef(xname:string;xdefval:longint):longint;
    function idef2(xname:string;xdefval,xmin,xmax:longint):longint;
    function idef64(xname:string;xdefval:comp):comp;
    function idef642(xname:string;xdefval,xmin,xmax:comp):comp;
    function sdef(xname,xdefval:string):string;
    //special setters -> return TRUE if new value set else FALSE - 25mar2021
    function bok(xname:string;xval:boolean):boolean;
    function iok(xname:string;xval:longint):boolean;
    function i64ok(xname:string;xval:comp):boolean;
    function cok(xname:string;xval:currency):boolean;
    function sok(xname,xval:string):boolean;
    //workers
    property text:string read gettext write settext;
    property data:tstr8 read getdata write setdata;
    property binary[hdr:string]:tstr8 read getbinary write setbinary;
    function xnextname(var xpos:longint;var xname:string):boolean;
    function xdel(xname:string):boolean;//02jan2022
   end;

//tmask8 - rapid 8bit graphic mask for tracking onscreen window areas (square and rounded) - 05may2020
   tmaskrgb96 =packed array[0..11] of byte;
   pmaskrow96 =^tmaskrow96;tmaskrow96=packed array[0..((maxint div sizeof(tmaskrgb96))-1)] of tmaskrgb96;
   pmaskrows96=^tmaskrows96;tmaskrows96=array[0..maxrow] of pmaskrow96;
   tmask8=class(tobject)
   private
    icore:tstr8;
    irows:tstr8;
    ilastdy,icount,iblocksize,irowsize,iwidth,iheight:longint;
    irows96:pmaskrows96;
    irows8:pcolorrows8;
    ibytes:pdlbyte;
   public
    //create
    constructor create(w,h:longint); virtual;
    destructor destroy; override;
    //information
    property width:longint read iwidth;
    property height:longint read iheight;
    property rowsize:longint read irowsize;
    property bytes:pdlbyte read ibytes;
    property rows:pmaskrows96 read irows96;
    property prows8:pcolorrows8 read irows8;
    property core:tstr8 read icore;//read-only
    //workers
    function resize(w,h:longint):boolean;
    //mask writers -> boundary is checked
    function cls(xval:byte):boolean;
    function fill(xarea:trect;xval:byte;xround:boolean):boolean;
    function fill2(xarea:trect;xval:byte;xround:boolean):boolean;//29apr2020
    //mask readers -> boundary is NOT checked -> out of range values will cause memory errors - 29apr2020
    procedure mrow(dy:longint);
    function mval(dx:longint):byte;
    function mval2(dx,dy:longint):byte;
   end;

{tany}
   tany=class(tobject)//management orientated object -> primarily designed to hold a single object or multiple object and copy/paste/move around a managed "man__*" array of object "pdlobject" using the "man__" class of procs - designed to work easily with "tlistedit", requires "man" to be specified in the compiler tags - 09feb2022
   private

   public
    //options
    omustfree:boolean;//default=true
    ocopyvals:boolean;//default=true=copyfrom will take a COPY of the source tany and all it's objects so they are unique to each tany - 09feb2022
    //vars
    cap:string;
    name:string;
    filename:string;
    refstr:string;//14feb2022
    ref32:longint;
    ref64:comp;
    obj:tobject;
    obj2:tobject;
    img:tbasicimage;
    img2:tbasicimage;
    str:tstr8;
    str2:tstr8;
    tag:longint;
    tag2:longint;
    sysid32:longint;//random number not copied during a "copyfrom()" call - 09feb2022
    //create
    constructor create; virtual;
    destructor destroy; override;
    function copyfrom(s:tany):boolean;//09feb2022
    //workers -> note: all procs return a reference to self so multi-procs can be easily written e.g. "myany.setcap('Hello').setname('name33').setref32(12345).setimg(misimg24(32,32));"
    function setcap(x:string):tany;
    function setname(x:string):tany;
    function setfilename(x:string):tany;
    function setrefstr(x:string):tany;//14feb2022
    function setref32(x:longint):tany;
    function setref64(x:comp):tany;
    function setobj(x:tobject):tany;
    function setobj2(x:tobject):tany;
    function setimg(x:tbasicimage):tany;
    function setimg2(x:tbasicimage):tany;
    function setstr(x:tstr8):tany;
    function setstr2(x:tstr8):tany;
    function settag(x:longint):tany;
    function settag2(x:longint):tany;
    //data
    function todata:tstr8;
    function fromdata(s:tstr8):boolean;
    //makers
    function makeCopyvals:boolean;
    function makeHoldvals:boolean;
   end;

//tdynamiclist
   tdynamiclistevent=procedure(sender:tobject;index:longint) of object;
   tdynamiclistswapevent=procedure(sender:tobject;x,y:longint) of object;
   tdynamiclist=class(tobjectex)
   private
    itextsupported:boolean;
    icore:pointer;
    iincsize,ilimit,ibpi,isize:longint;
    procedure setcount(x:longint);
    procedure setsize(x:longint);
    procedure setbpi(x:longint);//bytes per item
    procedure setincsize(x:longint);
    function notify(s,f:longint;_event:tdynamiclistevent):boolean;
    procedure sdm_track(xby:comp);
   protected
    icount:longint;
    ilockedBPI:boolean;
    freesorted:boolean;//destroys "sorted" object if TRUE
    //critical info handlers
    procedure _oncreateitem(sender:tobject;index:longint); virtual;
    procedure _onfreeitem(sender:tobject;index:longint); virtual;
    function _setparams(_count,_size,_bpi:longint;_notify:boolean):boolean; virtual;
    procedure shift(s,by:longint); virtual;
    procedure _init; virtual;
    procedure _corehandle; virtual;
    procedure _sort(_asc:boolean); virtual;
   public
    //vars
    sorted:tdynamicinteger;
    //user vars
    utag:longint;
    //events
    oncreateitem:tdynamiclistevent;
    onfreeitem:tdynamiclistevent;
    onswapitems:tdynamiclistswapevent;
    //internal - 07feb2021
    property _textsupported:boolean read itextsupported write itextsupported;
    property _size:longint read isize write isize;
    //create
    constructor create; virtual;
    destructor destroy; override;
    procedure _createsupport; virtual;
    procedure _destroysupport; virtual;
    //workers
    procedure clear; virtual;
    //.add
    function add:boolean;
    function addrange(_count:longint):boolean;
    //.delete
    function _del(x:longint):boolean;//2nd copy - 20oct2018
    function del(x:longint):boolean;
    function delrange(s,_count:longint):boolean;
    //.insert
    function ins(x:longint):boolean;
    function insrange(s,_count:longint):boolean;
    function swap(x,y:longint):boolean;
    function setparams(_count,_size,_bpi:longint):boolean;
    //limits
    property count:longint read icount write setcount;
    property size:longint read isize write setsize;
    function atleast(_size:longint):boolean; virtual;
    property bpi:longint read ibpi write setbpi;//bytes per item
    property limit:longint read ilimit;
    property incsize:longint read iincsize write setincsize;
    function findvalue(_start:longint;_value:pointer):longint;
    function sindex(x:longint):longint;
    //sort
    procedure sort(_asc:boolean);
    procedure nosort;
    procedure nullsort;
    //core
    property core:pointer read icore;
   end;

//tdynamicbyte
   tdynamicbyte=class(tdynamiclist)
   private
    iitems:pdlbyte;
    ibits:pdlbitboolean;
    function getvalue(_index:longint):byte;
    procedure setvalue(_index:longint;_value:byte);
    function getsvalue(_index:longint):byte;
    procedure setsvalue(_index:longint;_value:byte);
    procedure _init; override;
    procedure _corehandle; override;
   protected
    procedure _sort(_asc:boolean); override;
    procedure __sort(a:pdlBYTE;b:pdllongint;l,r:longint;_asc:boolean);
   public
    constructor create; override;//01may2019
    destructor destroy; override;//01may2019
    property value[x:longint]:byte read getvalue write setvalue;
    property svalue[x:longint]:byte read getsvalue write setsvalue;
    property items:pdlBYTE read iitems;
    property bits:pdlBITBOOLEAN read ibits;
    function find(_start:longint;_value:byte):longint;
   end;

//tdynamicinteger
   tdynamicinteger=class(tdynamiclist)//09feb2022
   private
    iitems:pdllongint;
    function getvalue(_index:longint):longint;
    procedure setvalue(_index:longint;_value:longint);
    function getsvalue(_index:longint):longint;
    procedure setsvalue(_index:longint;_value:longint);
    procedure _init; override;
    procedure _corehandle; override;
   protected
    procedure _sort(_asc:boolean); override;
    procedure __sort(a:pdllongint;b:pdllongint;l,r:longint;_asc:boolean);
   public
    constructor create; override;//01may2019
    destructor destroy; override;//01may2019
    function copyfrom(s:tdynamicinteger):boolean;//09feb2022
    property value[x:longint]:longint read getvalue write setvalue;
    property svalue[x:longint]:longint read getsvalue write setsvalue;
    property items:pdllongint read iitems;
    function find(_start:longint;_value:longint):longint;
   end;

{tdynamiccurrency}
    tdynamiccurrency=class(tdynamiclist)
    private
     iitems:pdlCURRENCY;
     function getvalue(_index:longint):currency;
     procedure setvalue(_index:longint;_value:currency);
     function getsvalue(_index:longint):currency;
     procedure setsvalue(_index:longint;_value:currency);
     procedure _init; override;
     procedure _corehandle; override;
    protected
     procedure _sort(_asc:boolean); override;
     procedure __sort(a:pdlCURRENCY;b:pdllongint;l,r:longint;_asc:boolean);
    public
     constructor create; override;//01may2019
     destructor destroy; override;//01may2019
     property value[x:longint]:currency read getvalue write setvalue;
     property svalue[x:longint]:currency read getsvalue write setsvalue;
     property items:pdlCURRENCY read iitems;
     function find(_start:longint;_value:currency):longint;
    end;

{tdynamicstring}
    tdynamicstring=class(tdynamiclist)//09feb2022
    private
     iitems:pdlstring;
     function getvalue(_index:longint):string;
     procedure setvalue(_index:longint;_value:string); virtual;
     function getsvalue(_index:longint):string;
     procedure setsvalue(_index:longint;_value:string);
     procedure _oncreateitem(sender:tobject;index:longint); override;
     procedure _onfreeitem(sender:tobject;index:longint); override;
     procedure _init; override;
     procedure _corehandle; override;
     function gettext:string;
     procedure settext(x:string);
     function getstext:string;
    protected
     procedure _sort(_asc:boolean); override;
     procedure __sort(a:pdlstring;b:pdllongint;l,r:longint;_asc:boolean);
    public
     constructor create; override;//01may2019
     destructor destroy; override;//01may2019
     function copyfrom(s:tdynamicstring):boolean;//09feb2022
     property text:string read gettext write settext;
     property stext:string read getstext;
     property value[x:longint]:string read getvalue write setvalue;
     property svalue[x:longint]:string read getsvalue write setsvalue;
     property items:pdlstring read iitems;
     function find(_start:longint;_value:string;_casesensitive:boolean):longint;
    end;

//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//tframe
   tframe=class(tobject)
   private
    //frame
    iopacity       :longint;
    ishadeangle    :longint;
    ishadepower    :longint;
    isoftjoins     :boolean;
    //framesets
    ifmax          :longint;//host applied limit = default = 29 (30x framesets) inline with Framer Plus
    ifs            :array[0..99] of longint;//source color
    ifd            :array[0..99] of longint;//destination color
    ift            :array[0..99] of longint;//texture (richness)
    ifo            :array[0..99] of longint;//opacity (0=off, 1..255=on)
    ifw            :array[0..99] of longint;//size of frameset
    //logo
    ilo            :longint;//logo opacity (0=off, 1..255=on)
    ilusecolors    :boolean;//use "ls" and "ld" instead of logo pixel colors
    ils            :longint;//logo source color - optional
    ild            :longint;//logo destination color - optional
    ilt            :longint;//logo richness
    ilx            :longint;//logo relative X position
    ily            :longint;//logo relative Y position
    ilm            :longint;//logo relative mode => 0=top-left, 1=bottom-left
    ildata         :tstr8;//keep copy of i32 original datastream
    il32           :tbasicimage;
    //special
    isInstagram    :longint;
    isResample     :longint;
    //information
    isize,idataid,ilastdataid:longint;
    procedure setfmax(x:longint);
   public
    //create
    constructor create; virtual;
    destructor destroy; override;
    //information
    property  size:longint read isize;
    property  dataid:longint read idataid write idataid;
    function  changed(xreset:boolean):boolean;
    //framesets
    property  fmax:longint read ifmax write setfmax;//sets the allowed upper limit for framesets in a frame, default=29 (30x framesets)
    function  fok(xindex:longint):boolean;
    procedure fclear;
    procedure fdel(xindex:longint);
    function  fadd(scol,dcol,xrich,xopacity,xsize:longint):boolean;
    function  fset(xindex,scol,dcol,xrich,xopacity,xsize:longint):boolean;
    function  fget(xindex:longint;var scol,dcol,xrich,xopacity,xsize:longint):boolean;
    //options
    procedure oset(xopacity,xshadepower,xshadeangle:longint;xsoftjoins:boolean);
    procedure oget(var xopacity,xshadepower,xshadeangle:longint;var xsoftjoins:boolean);
    //logo
    procedure lset(xusecolors:boolean;xscol,xdcol,xopacity,xrich,xrelx,xrely,xrelm:longint);
    procedure lget(var xusecolors:boolean;var xscol,xdcol,xopacity,xrich,xrelx,xrely,xrelm:longint);
    function  lsetdata(xlogodata:tstr8;var e:string):boolean;
    function  lgetdata(xlogodata:tstr8):boolean;
    //special
    procedure sset(xinstagram,xresample:longint);
    procedure sget(var xinstagram,xresample:longint);
    //io
    function ioget(xdata:tstr8;xformat:string;var e:string):boolean;
    function ioset(xdata:tstr8;var e:string):boolean;
    //workers
    procedure clear;//reset entire frame to default (nil) - 31jan2021
    procedure xmakesimple(scol,dcol,xsize:longint);
    procedure xmakesimple2(scol,dcol,xsize,scol2,dcol2,xsize2:longint);
    function draw82432(da_cliparea:trect;senlarge,sfullsoften:boolean;s,b:tobject;var e:string):boolean;
    //support
    procedure xsyncinfo;
    procedure xincid;
   end;

//GUI Support ------------------------------------------------------------------
{tbasicsystem}
   townlist=record
      list:array[0..maxcore] of word;
      count:longint;
      end;
   twinlist=record
      list:array[0..254] of word;
      count:longint;
      end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxx//ssssssssssssssssssssssssssssss
   tbasicsystem=class(tobject)
   private
    //general
    imousedownref,ihidecursorref,ipumptimer2,ibufferresize64,ibufferresize642,ilastsystem_slowref64,iecomode64,itimer1000,itimer250,ishowonceref:comp;
    isizing,ilastmousemovecheckx,ilastmousemovechecky,icursorloadid,ishowaitcount,icloselocked,imustgstate,ilastdataid,iwinmax,iwinlimit,ilastsystem_mustidSLOW,ilastsystem_mustid,igstate:longint;
    ishowoptions_crosssync,iwinemaximised,imustcloseprompt,iwasdrop_showing,itimer_busy,idragging_fullwin,iclosed,iontimerbusy,iinternalpaint,ilastshowing,itiming,icreating,idestroying,imustclose,ialigning:boolean;
    inormalarea:trect;//nor only
    ikeyboardlaststate:byte;
    ihost:tcommonform;
    fontimer,fontimer2:tnotifyevent;
    //wound support
    iwounddirx,iwounddiry,iwoundlastx,iwoundlasty,iwoundratex,iwoundratey,iwoundratelimit:longint;
    iwoundref:comp;
    //showoptions support
    ishowoptions_inuse:boolean;
    ishowoptions_window:tbasicscroll;//08mar2021
    ishowoptions_list,ishowoptions_frames:tbasicmenu;
    ishowoptions_options:tbasicset;//26feb2022
    ishowoptions_cols:tbasiccols;
    ishowoptions_colors:tbasiccolors;
    ishowoptions_framesize1,ishowoptions_framesize2,ishowoptions_sparkle1,ishowoptions_sparkle2:tbasicint;
    ishowoptions_toolbar_colors:tbasictoolbar;
    ishowoptions_timer100,ishowoptions_timer500:comp;
    //core support
    icore:array[0..maxcore] of tbasiccontrol;
    icorecount:longint;
    //action support
    ias:array[0..maxcore] of char;
    iam:array[0..maxcore] of byte;
    iax:array[0..maxcore] of longint;
    iay:array[0..maxcore] of longint;
    iacount:longint;
    iabusy :boolean;
    //pop support
    ipophost:tbasiccontrol;
    ipopshortcut:longint;//aknone=nothing
    //window support
    iwinhover,iwinhoverlayer:longint;
    iwinfocus,iwinfocuslayer:longint;
    idragindex,idragstart:longint;
    idragrect:trect;//note: used internally within "__onpaint()" only - 18may2020
    isizeindex,isizestart:longint;//25feb2021
    //keyboard + mouse support
    idownrect,ihostdownrect:trect;
    imousebuttonlock,iwheel,ikey,imousebutton:longint;
    ihoverindex,ifocusindex,ifocussizemodex,ifocussizemodey:longint;//minint=none, -1=resize, 0..N=coreindex
    ishiftok,ictrlok,ialtok,iscreendraggingout,iscreenmovingfine,iscreendragging,iscreendraggingv,iscreendraggingh,iscreendraggingfine,iscreendraggingfinev,iscreendraggingfineh,imousemoved,imousedown,imousewasdown,imousedbclick:boolean;
    iscreenmovingfinexy,imousedownxy,imousemovexy:tpoint;
    iscreendownxy,iscreenmovexy:tpoint;
    iscreenmovingfine64,imousedbclicktime:comp;
    //paint support
    ipartpaintarea:trect;
    ipartpaintareaok,ipaintingpart,imasking,ipaintbusy:boolean;
    imaskval,ipainting,imustpaint,imustalign,ialignid,ipaintid,ibits,iwidth,iheight:longint;
    //buffers
    ibuffer,ibuffer2:tbmp;
    idragbuffer:tbasicimage;//used to cache image of screen during important operations such as "dragging a window" - 16may2020
    imask:tmask8;
    //splash
    isplash:tbasicsplash;
    //status support
    istatuswin:tbasicscroll;
    istatustime:comp;
    istatuspert:double;
    istatustab,istatusrowcount:longint;
    istatustext:array[0..9] of string;
    istatustep:array[0..9] of longint;
    istatustitle:string;
    istatusshow:boolean;
    istatusstopped:boolean;
    function xcommonevent(a:tbasiccontrol;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean;
    function xcommongetitem(sender:tobject;xindex:longint;var xtab,xtep,xtepcolor:longint;var xcaption,xcaplabel,xhelp,xcode2:string;var xcode,xshortcut,xindent:longint;var xflash,xenabled,xtitle,xsep:boolean):boolean;
    procedure setfocusindex(x:longint);
    procedure sethoverindex(x:longint);
    function getfocuscontrol:tbasiccontrol;
    procedure setfocuscontrol(x:tbasiccontrol);
    function getcore(x:longint):tbasiccontrol;
    procedure xtimer;
    procedure setwinfocus(x:longint);
    function getmaskval:longint;
    //host form support
    procedure __onmousedown(sender:tobject;button:tmousebutton;shift:tshiftstate;x,y:longint);
    procedure __onmouseup(sender:tobject;button:tmousebutton;shift:tshiftstate;x,y:longint);
    procedure __onmousemove(sender:tobject;shift:tshiftstate;x,y:longint);
    procedure __onkeydown(sender:tobject;var key:word;shift:tshiftstate);
    procedure __onkeyup(sender:tobject;var key:word;shift:tshiftstate);
    procedure __onkeypress(sender:tobject;var key:char);
    procedure __onshow(sender:tobject);
    procedure __onresize(sender:tobject);
    procedure __onpaint(sender:tobject);//28jul2020
    procedure __ontimer(sender:tobject);
    procedure __ontimer2(sender:tobject);
    procedure setfullscreen(x:boolean);
    function getfullscreen:boolean;
    function xmaximised:boolean;//supports both Windows and Wine modes - 05feb2022
    function xnormal:boolean;
    procedure xsetNM(xmax:boolean);//set normal/maximised
    //other
    procedure xshowoptions_crosssync;
    property xshowoptions_list:tbasicmenu read ishowoptions_list;//Warning: can be nil - 24jul2021
    procedure xshowoptions_reload;
    procedure xshowoptions_timer(sender:tobject);
    procedure xshowoptions_showmenu(sender:tobject);
    procedure xshowoptions_click(sender:tobject);
    procedure xshowoptions_sync(sender:tobject);
    procedure xshowoptions_sync2(sender:tobject;xname:string;xclicked:boolean);
    procedure xsafearea;
    function getgstate:longint;
    procedure setgstate(x:longint);
    procedure __onaccept(sender:tobject;var msg:tmessage);//drag&drop files - 24APR2011, 07DEC2009
    //.status support
    procedure __xstatus(xpert:double;xtitle:string;xshow,xupdatenow:boolean);
    function getstatustext(xindex:longint):string;
    procedure setstatustext(xindex:longint;x:string);
    function getstatustep(xindex:longint):longint;
    procedure setstatustep(xindex:longint;x:longint);
    procedure setstatuspert(xpert:double);
    function getstatusstopped:boolean;//catches "escape" key hiding status window - 02aug2021
    //.wound support
    procedure xwoundcalc(x,y:longint);
   public
    //show modes
    smnone:byte;
    smmodal:byte;
    smwait:byte;
    //index styles
    xsnone:byte;
    xsoutside:byte;
    xscontrol:byte;
    xsunknown:byte;
    //paint support
    recs:array[0..19] of trect;
    //own support
    ownlist:townlist;
    ownid:longint;//for entire GUI -> increments each time *any* ownlist changes - 19mar2020
    //window support
    winlist:twinlist;
    //mask support -> detects when the system Window mask needs to be updated
    winmask_cnt:longint;
    winmask_id :array[0..254] of longint;
    winmask_aid:array[0..254] of longint;//Note: must be same size and range as "twinlist.list[0..254]" - 19may2020
    winmask_vis:array[0..254] of boolean;
    winmask_rnd:array[0..254] of boolean;
    //options
    omax_entirescreen:boolean;//default=false=maximised is workwarea, true=maximised area is entire visible screen area - 28jul2020
    //create
    constructor create(xminver:longint;xhost:tobject;dwidth,dheight:longint); virtual;
    destructor destroy; override;
    property creating:boolean read icreating;
    property destroying:boolean read idestroying;
    function clienttoscreen(x:tpoint):tpoint;
    function clientareatoscreen(x:trect):trect;//25feb2021
    procedure setbounds(x,y,w,h:longint);
    function showing:boolean;//works under Win7 - 01FEB2011
    property showaitcount:longint read ishowaitcount;
    procedure pumptimer2;//forceably drive the timer - 15jul2021
    function xmainwin(var xwin:tbasicscroll):boolean;
    function xpopnav(var xvalue:string;xcommonfolder,xstyle:string):boolean;
    function xpopnav2(var xvalue:string;var xfilterindex:longint;xfilterlist,xcommonfolder,xstyle,xhisname,xtitle:string):boolean;
    function xpopnav3(var xvalue:string;var xfilterindex:longint;xfilterlist,xcommonfolder,xstyle,xhisname,xtitle:string;xcanpreview:boolean):boolean;
    property winemaximised:boolean read iwinemaximised;
    //closelock
    property mustcloseprompt:boolean read imustcloseprompt write imustcloseprompt;//allow host program to set TRUE or FALSE to PROMPT before closing the program - 26aug2021
    property closelocked:longint read icloselocked;
    procedure closelock;
    procedure closeunlock;
    procedure xfireevent(sender:tobject;xevent:tnotifyevent);//lock close -> fireevent -> unlock close - 03apr2021
    //information
    property showingoptions:boolean read ishowoptions_inuse;//07mar2022
    function stable:boolean;
    property host:tcommonform read ihost;
    function hostshowing:boolean;
    property gstate:longint read getgstate write setgstate;//gui state: gsNormal, gsMin, gsMax
    function mainappwindow:boolean;
    property bits:longint read ibits;
    function left:longint;
    function top:longint;
    property width:longint read iwidth;
    property height:longint read iheight;
    property alignid:longint read ialignid;
    property paintid:longint read ipaintid;
    property painting:boolean read ipaintbusy;
    property paintingpart:boolean read ipaintingpart;
    property partpaintareaok:boolean read ipartpaintareaok;
    //.window mask support
    property masking:boolean read imasking;//paint via mask8 layer support -> for fast, multiple overlapping window support - 17may2020
    function mustmask:boolean;
    property mask:tmask8 read imask;
    property maskval:longint read getmaskval;
    //.fullscreen
    property fullscreen:boolean read getfullscreen write setfullscreen;
    procedure xsyncfullscreen;//internal use only
    //new handlers
    function nfullwin:tbasicscroll;
    function nwindow(da:trect):tbasicscroll;
    function nontop(da:trect):tbasicscroll;
    function ndlg(da:trect;xshowhead:boolean):tbasicscroll;
    function ndlg2(da:trect;xshowhead,xstatic:boolean):tbasicscroll;
    function ndlg3(da:trect;xtep:longint;xtitle:string;xshowhead,xstatic:boolean):tbasicscroll;
    function nstatus(xtitle:string):tbasicscroll;
    function nscroll(da:trect):tbasicscroll;
    function nsetcolor(da:trect;xshowhead:boolean):tbasicsetcolor;//27feb2021
    //position support (left/right/top/bottom) - 27feb2022
    function canposition:boolean;
    procedure position(xstyle:string);
    //pop handlers
    //.special
    function popint(var xval:longint;xmin,xmax,xdef:longint;xtep32:longint;xtitle,xcap,xhelp,xcancelcap,xokcap:string;xsize:longint):boolean;
    //.edit
    function popedit(var x:string;xcap,xhelp:string):boolean;
    function popedit2(var x:string;xtep32:longint;xtitle,xcap,xhelp,xcancelcap,xokcap:string;xsize:longint):boolean;
    function popmanyedit2(xcount:longint;var x:array of string;xtep32:longint;xtitle:string;xcap:array of string;xhelp:array of string;xcancelcap,xokcap:string;xsize:longint):boolean;
    //.txt - poptext()
    function poptxt(var x:string;xwrap:longint;xcap,xhelp:string):boolean;
    function poptxt2(var x:string;xwrap:longint;xreadonly:boolean;xcap,xhelp:string):boolean;
    function poptxt3(var x:string;xwrap:longint;xrows,xreadonly:boolean;xcap,xhelp,xcancelcap,xokcap:string):boolean;
    function poptxt8(xtext:tstr8;xwrap:longint;xrows,xreadonly:boolean;xcap,xhelp,xcancelcap,xokcap:string):boolean;
    function poptxt__event2(a:tbasiccontrol;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean;
    //.query
    function popquery(x:string):boolean;
    function popquery2(x,xcancelcap,xokcap:string;xlarge:boolean):boolean;
    function popqueryex(x,xcancelcap,xokcap:string;dw,dh,ccancel,cok:longint):boolean;
    //.error
    function poperror(x:string):boolean;
    function poperror2(x,xclosecap:string;xlarge:boolean):boolean;
    function poperrorex(x,xclosecap:string;dw,dh,cclose:longint):boolean;
    //.info
    function popinfo(xtitle,x:string):boolean;
    function popinfo2(xtitle,x,xclosecap:string;xlarge:boolean):boolean;
    function popinfoex(xtitle,x,xclosecap:string;dw,dh,cclose:longint):boolean;
    function poperrorORinfo(xtitle,x,xclosecap:string;dw,dh,cclose:longint;xinfo:boolean):boolean;//03jun2021
    //.menu
    function popmenu(xpopstyle,ximagealign:longint;xmenudata:tstr8;var xcode:longint;var xcode2:string;var xtepcolor:longint):boolean;
    function popmenu2(xpopstyle,ximagealign:longint;xmenudata:tstr8;xmenuname:string;xstyle:longint;var xcode:longint;var xcode2:string;var xtepcolor:longint):boolean;
    function popmenu2b(xpopstyle,ximagealign:longint;xmenudata:tstr8;xcontrol:tbasiccontrol;xmenuname:string;xstyle:longint;var xcode:longint;var xcode2:string;var xtepcolor:longint):boolean;
    function popmenu3(xpopstyle,ximagealign:longint;xmenudata:tstr8;xcontrol:tbasiccontrol;xstyle,xpos,xhover,xselstart,xselcount:longint;var xoutpos,xouthover,xoutselstart,xoutselcount,xcode:longint;var xcode2:string;var xtepcolor:longint):boolean;
    function popmenu4(xpopstyle,ximagealign:longint;xmenudata:tstr8;xcontrol:tbasiccontrol;xshowhelp:boolean;xstyle,xdropcount,xpos,xhover,xselstart,xselcount:longint;var xoutpos,xouthover,xoutselstart,xoutselcount,xcode:longint;var xcode2:string;var xtepcolor:longint):boolean;
    function popmenu5(xpopstyle,ximagealign:longint;xmenudata:tstr8;xcontrol:tbasiccontrol;xshowhelp:boolean;xstyle,xdropcount,xpos,xhover,xselstart,xselcount:longint;var xoutpos,xouthover,xoutselstart,xoutselcount,xcode:longint;var xcode2:string;var xtepcolor:longint;xfindbycode2:string):boolean;//07jul2021
    //.droplist -> simulates a dropdown list -> must specify a control via "xcontrol" - 04oct2020
    function popdroplist(xmenudata:tstr8;xcontrol:tbasiccontrol;var xpos,xcode:longint;var xcode2:string;xfindbycode2:string):boolean;
    function popdroplist2(xmenudata:tstr8;xcontrol:tbasiccontrol;xdropcount:longint;var xpos,xcode:longint;var xcode2:string;xfindbycode2:string):boolean;
    //.io
    function popopenimg(var xfilename:string;var xfilterindex:longint;xcommonfolder:string):boolean;//12apr2021
    function popsaveimg(var xfilename:string;xcommonfolder:string):boolean;//12apr2021
    function popsaveimg2(var xfilename:string;xcommonfolder,xtitle2:string):boolean;//18jun2021, 12apr2021
    function popopencur(var xfilename:string;var xfilterindex:longint;xcommonfolder:string;xmore:boolean):boolean;//29aug2021
    function popopen(var xfilename:string;var xfilterindex:longint;xfilterlist,xcommonfolder:string):boolean;
    function popopen2(var xfilename:string;var xfilterindex:longint;xfilterlist,xcommonfolder,xtitle2:string):boolean;
    function popsave(var xfilename:string;xfilterlist,xcommonfolder:string):boolean;
    function popsave2(var xfilename:string;xfilterlist,xcommonfolder,xtitle2:string):boolean;
    function popfolder(var xfilename:string;xcommonfolder:string):boolean;
    function popnewfolder(xfolder:string;var xoutfolder:string):boolean;//14apr2021
    function popfolderimg(xfolder:string):boolean;
    function popfav(var xfilename:string):boolean;
    function popnav(var xfilename:string;xcommonfolder:string):boolean;
    //.color
    function popcolorstatic(var xvalue:longint):boolean;
    function popcolorhistory(var xvalue:longint):boolean;
    function popcolorhistory__add(xvalue:longint):boolean;
    function popcolorhistory__edit:boolean;
    function popcolor(var xvalue:longint):boolean;
    //..color support
    function xcolorhistory(var xvalue:longint;xaddonly,xeditonly:boolean):boolean;//19mar2021
    //.font - 26mar2022
    function popfont(var xfontname:string):boolean;//26mar2022

    //.pop dialogs
    procedure xsafepopXYWHex(var dx,dy,dw,dh:longint;dy2:longint);//15NOV2010
    function xshowwait(a:tbasicscroll;xpreviousfocus:longint):boolean;
    function xshowwait2(a:tbasicscroll;xpreviousfocus,xtimeout:longint):boolean;
    function xshowwait3(a:tbasicscroll;xpreviousfocus,xtimeout:longint;xlimitsize:boolean):boolean;
    function xpopwait(a:tbasicscroll;xpreviousfocus,dw,dh:longint;xcenter:boolean):boolean;//21may2020
    function xpopwait2(a:tbasicscroll;xcontrol:tbasiccontrol;xpreviousfocus,dw,dh:longint;xcenter:boolean):boolean;//21may2020
    procedure xclose(a:tbasiccontrol);
    procedure xcloseok(a:tbasiccontrol);
    //.wait support - 03apr2021
    function xhavewaitfocusLOOSE:boolean;//06apr2021
    procedure xwaitfocus;
    //window handlers
    property winhover:longint        read iwinhover;
    property winhoverlayer:longint   read iwinhoverlayer;
    property winfocus:longint        read iwinfocus write setwinfocus;
    property winfocuslayer:longint   read iwinfocuslayer;
    function xwinfindlayer(xcoreindex:longint;var xlayer:longint):boolean;
    function xwinfindbyxy(sx,sy:longint;var xcoreindex,xwinlayer:longint):boolean;
    procedure xwintop(x:tbasiccontrol);
    procedure xwinbot(x:tbasiccontrol);
    procedure xwinnil(x:tbasiccontrol);
    procedure xwinadd(x:tbasiccontrol;xstyle:char);
    function xdlg(var x:tbasiccontrol):boolean;//get active dialog window
    function xfindwinname(xwinname:string;var x:tbasicscroll):boolean;
    function wtop(var x:tbasiccontrol;var xindex:longint):boolean;//xxxxxxxxxxxxx//dodgy, needs upgrading........
    function xacceptfindbyxy(sx,sy:longint;var xout:tbasiccontrol):boolean;//updated - 20mar2022
    //.drag support
    procedure dragstart(xcoreindex:longint);
    procedure dragstart_fullwin;//this relates to external OS only and NOT to our internal system - 15apr2021
    procedure dragstop;
    //..drag support
    property dragging_fullwin:boolean read idragging_fullwin;
    //.size support
    procedure sizestart(xcoreindex:longint);
    procedure sizestop;
    function resizing:boolean;
    property sizing:longint read isizing;//0=off, 1=resizing MAIN window (wm_fullwin), 2=resizing OTHER window types - 22apr2022
    //.status support
    procedure xstatuspaintnow;
    procedure xstatusstart(xrowcount:longint);
    procedure xstatusstart2(xrowcount,xtab:longint);//15may2022
    procedure xstatusstart3(xrowcount,xtab:longint;xresetcancel:boolean);//20may2022
    procedure xstatusstop;
    property xstatustopped:boolean read getstatusstopped;
    procedure xstatus(xpert:double;xtitle:string);//15may2022
    property xstatustext[xindex:longint]:string read getstatustext write setstatustext;
    property xstatustep[xindex:longint]:longint read getstatustep write setstatustep;
    procedure xstatustab(xtab:longint);//15may2022
    procedure xstatus_sysstatus_alloff;
    property xstatustitle:string read istatustitle;
    property xstatuspert:double read istatuspert write setstatuspert;
    //system handlers
    procedure xcenter(x:tbasiccontrol);
    procedure xshowsplash;
    procedure xshowabout;
    procedure xshowoptions;
    procedure xshowhelp;
    procedure xdefaults;
    procedure xdefaultzoom;
    //core handlers
    property core[x:longint]:tbasiccontrol read getcore;
    property corecount:longint read icorecount;
    function xrootok(x:tbasiccontrol):boolean;
    function xinuse(xcoreindex:longint):boolean;
    function xvisible(xcoreindex:longint):boolean;
    procedure mustclose;
    function xsafeown(var xownlist:townlist):boolean;
    function xownhave(var xownlist:townlist;x:tbasiccontrol):boolean;
    function xownfind(var xownlist:townlist;x:tbasiccontrol;var xownslot:longint):boolean;
    function xownfindcount(var xownlist:townlist):longint;
    function xownadd(var xownlist:townlist;x:tbasiccontrol):boolean;
    procedure xowndel(var xownlist:townlist;x:tbasiccontrol);
    function xownget(var xownlist:townlist;xownslot:longint;var x:tbasiccontrol):boolean;
    function xowndel__fast(var xownlist:townlist;xownslot:longint):boolean;//04may2021
    procedure ownadd(xhost,xcontrol:tobject);
    procedure owndel(xhost,xcontrol:tobject);
    function xareaok(var x:trect):boolean;
    function xareaokb(x:trect):boolean;
    function xareaongui(x:trect):boolean;
    function xareaseen(sa:trect;xbeneathwindowlayer:longint):boolean;//can a square (non-rounded) area be seen in anyway beneath the window stack from window "xbeneathwindowlayer" and up -> if so, then return TRUE else return FALSE - 22may2020
    function xadd(x:tbasiccontrol;var xcoreindex:longint):boolean;
    function xdel(xcoreindex:longint;xfree:boolean):boolean;
    //pop support
    property pophost:tbasiccontrol read ipophost;//pointer only, may be nil at anytime - 01apr2020
    property popshortcut:longint read ipopshortcut write ipopshortcut;//this is the shortcut the user executed whilst the menu was up and active, default=aknone -> no shortcut was triggered - 02apr2020
    //mouse system
    procedure xfindany(sx,sy:longint;var xfocusindex,xhoverindex,xsizemode,ysizemode:longint);
    property hoverindex:longint read ihoverindex write sethoverindex;
    property focusindex:longint read ifocusindex write setfocusindex;
    property focuscontrol:tbasiccontrol read getfocuscontrol write setfocuscontrol;
    property focussizemodex:longint read ifocussizemodex;//resize by x-coor
    property focussizemodey:longint read ifocussizemodey;//resize by y-coor
    property downrect:trect read idownrect;//area of control that has focus when mouse is clicked down
    property hostdownrect:trect read ihostdownrect;//area of host form when mouse is clicked down
    function indexstyle(xindex:longint):longint;
    function styleindex(xstyle:longint):longint;
    //.local cursor support -> cursor position within system area
    function curpos:tpoint;//our internal cursor position (within the system area only) - 21may2020
    function downcurpos:tpoint;//our internal cursor position (within the system area only) - 21may2020
    procedure showcursor;//28feb2022
    procedure hidecursor;//28feb2022
    //.localised coordinates
    property mousedbclick:boolean read imousedbclick;//double click
    property mousedown:boolean read imousedown;
    function mousedowntime:comp;//09mar2022
    property mousewasdown:boolean read imousewasdown;
    property mousedownxy:tpoint read imousedownxy;
    property mousemovexy:tpoint read imousemovexy;
    //.takes ~20px(xfine=false) or 1px(xfine=true) to start and MUST be outside to START of specified controls' area - 09mar2021, 25feb2021
    function mousedraggingout(x:tbasiccontrol;xkeepchecking,xfine:boolean):boolean;
    function mousedraggingout2(x:trect;xkeepchecking,xfine:boolean):boolean;
    function mousedraggingout3(xoffx,xoffy:longint;x:trect;xkeepchecking,xfine:boolean):boolean;
    property mousewasdraggingout:boolean read iscreendraggingout;
    //.takes ~20px to start
    property mousedragging:boolean read iscreendragging;
    property mousedraggingv:boolean read iscreendraggingv;
    property mousedraggingh:boolean read iscreendraggingh;
    //.takes ~1px to start
    property mousedraggingfine:boolean read iscreendraggingfine;
    property mousedraggingfinev:boolean read iscreendraggingfinev;
    property mousedraggingfineh:boolean read iscreendraggingfineh;
    //.other
    property mousemoved:boolean read imousemoved;//mouse moved
    property mousemovingfine:boolean read iscreenmovingfine;//takes ~2px - 27feb2022
    function mousedownstroke:boolean;//mouse has been clicked down
    function mouseupstroke:boolean;//mouse has released the click
    //.button modes
    property mousebutton:longint read imousebutton;//abnone, ableft, abcenter, abright
    function mousenone:boolean;
    function mouseleft:boolean;
    function mousecenter:boolean;
    function mouseright:boolean;
    //.special key
    property shiftok:boolean read ishiftok;
    property altok:boolean read ialtok;
    property ctrlok:boolean read ictrlok;
    property key:longint read ikey write ikey;//aknone=off
    property wheel:longint read iwheel;//0=off - wheel movement
    //.wound rates & direction - 30sep2022
    function woundratexpert1:extended;//0.0..1.0
    function woundrateypert1:extended;//0.0..1.0
    function woundratexpert100:longint;//0..100
    function woundrateypert100:longint;//0..100
    function woundratextime(xmaxtime:longint;xincludedir:boolean):longint;
    function woundrateytime(xmaxtime:longint;xincludedir:boolean):longint;
    property woundratex:longint read iwoundratex;//0..woundratelimit
    property woundratey:longint read iwoundratey;//0..woundratelimit
    property woundratelimit:longint read iwoundratelimit;
    property wounddirx:longint read iwounddirx;//-1=left, 1=right OR stopped
    property wounddiry:longint read iwounddiry;//-1=up,   1=down  OR stopped
    //.screen coordinates
    property screendragging:boolean read iscreendragging;
    property screendraggingfine:boolean read iscreendraggingfine;
    property screendraggingout:boolean read iscreendraggingout;//25feb2021
    property screendownxy:tpoint read iscreendownxy;
    property screenmovexy:tpoint read iscreenmovexy;
    //action support
    function aadd(xs:char;xm:byte;xx,xy:longint):boolean;
    function apull(var xs:char;var xm:byte;var xx,xy:longint):boolean;
    procedure anext;//next action
    procedure amouseupfinalise;//14may2020
    //timer + paint support
    function  xtimerinterval:longint;
    property  xmustpaint:longint read imustpaint;
    //.paint support
    property buffer:tbmp read ibuffer;
    function rows:tstr8;
    procedure ppincludearea(xpaintarea:trect);//part-paint include area
    //events
    procedure _onnotify(sender:tobject;xstyle:char);
    procedure _onnotifylast(sender:tobject;xhandled:boolean);
    function  _onshortcut(sender:tobject):boolean;
    //additional support
    procedure paintallnow;
    procedure paintnow;
    procedure alignallnow;
    procedure alignnow;
    procedure sizenow;
    procedure fullalignpaint;
    //special events
    property ontimer:tnotifyevent read fontimer write fontimer;//main timer -> itimer
   end;

{tbasiccontrol}
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//bbbbbbbbbbbbbbbbbbbbbbbbb
   tbasiccontrol=class(tobject)
   private
    igui:tbasicsystem;//pointer only -> never nil
    iparent:tbasiccontrol;
    ioffloading,imustalign,imustpaint,icreating,idestroying,ialigned,ipainted,ipainting,ialigning,itimer,itiming,ienabled,ivisible,inormal:boolean;
    iclientarea:trect;//area of control (visible bits or not)
    ipaintarea:trect;//area of control that is visible (invalid rect if nothing is visible at all)
    icaption,ihelp,ihelp2,isubhelp,isubhelp2:string;
    iwoundtime,imakemode,iid,iaid,iwinstyle,iparentcoreindex,icoreindex,iheightref,ibordersize:longint;
    iidleREF64,iwoundtimer:comp;
    fontimer2,fonvalue,fonalign,fonpaint:tnotifyevent;
    fonnotify:tsystemnotify;
    fonaccept:tonacceptevent;//18jun2021
    fonfindheight:tonfindheight;//06jul2021
    fonwinLdrcolor:tlongintgetevent;
    //.show menu support
    ishowmenu:tstr8;//default=nil
    fshowmenuFill1,fshowmenuFillINT,fshowmenuFill2:tmenufillevent;
    fshowmenuClick1,fshowmenuClickINT,fshowmenuClick2:ttoolbarevent2;
    fonshowmenu:tnotifyevent;//optional override
    //.makeImageViewer support - 22may2022
    iimagebuffer:tbasicimage;//dedicated image buffer -> DOES own the image
    iimagebufferi:tbasicimage;//pointer only -> does NOT own the image
    iimagebufferinfo,iimagebuffermustfile,iimagebufferlastfile:string;
    iimagebuffertimer:comp;
    procedure settimer(x:boolean);
    procedure setbordersize(x:longint);
    function gethelpline:string; virtual;
    procedure setparent(x:tbasiccontrol);
    procedure setvisible(x:boolean);
    procedure setenabled(x:boolean);
    procedure setclientarea(a:trect);
    function getleft:longint;
    function gettop:longint;
    function getclientwidth:longint;
    function getclientheight:longint;
    procedure setclientwidth(x:longint);
    procedure setclientheight(x:longint);
    procedure setwinstyle(x:longint);
    procedure setcaption(x:string);
    procedure __onimageviewertimer(sender:tobject);//22may2022
   public
    //options
    omade:longint;//default==0=made_none -> helps the control know what to do when it "makes" itself into special handler - 23mar2022
    ominimal:boolean;//default=false
    ocanshowmenu:boolean;//default=false
    obold:boolean;//default=false, true=use bold font for text if supported - 03mar2021
    oparentcorners:boolean;//default=true=draws control's corners with parent's background color when the control is ROUNDED - 07oct2020
    osafearea:boolean;//default=true=only for window controls
    oroundstyle:longint;//default=1=corRound
    oautotop:boolean;//default=true=when a window it is automatically brought to top of it's stack, false=retain stack order
    ominheight:longint;//default=0=off, use to specify another height other than "getalignheight"
    ominwidth:longint;//default=0=off, use to specify another width other than "getalignwidth"
    oautoheight:boolean;//default=false=no auto fit, true=fit to remaining vertical screen space - 01mar2021
    oautowidth:boolean;//default=false
    oautofocus:boolean;//default=false, true=set this control to be focused when form shows - 31mar2020
    osoftclose:boolean;//default=false=use system default, true=always softclose such as a popup menu - 03apr2021
    owinname:string;//default=<nil>, optional - set a window name -> e.g. "sys:options" or "sys:help" or "user1" etc - 14aug2020
    opagename:string;//default=<nil>, set to a name e.g. "user" to show/hide using the "form.page:=<page name here>" option - 04apr2020
    oseph:longint;//optional horizontal separation spacing, default=0 -> for use with tbasicscroll class of controls etc
    osepv:longint;//optional vertical separation spacing, default=0   -> for use with tbasicscroll class of controls etc
    oalignvert:boolean;//default=true=align control full width and vertically, else align by ominwidth/getalignwidth and horizontally - 22apr2020
    oframebrightness:longint;//default=100, 0..100
    oframebrightnessDARK:longint;//default=0=black -> color used to fade downto when brightness drops below 100%
    //.special colors
    ospbackcolor:longint;//default=clnone, override background color - 17aug2020
    ospbackname:string;//default=<nil>, override background color with a color name via "low__color()" - 19aug2020
    //.override colors
    obackcolor:longint;//default=clnone, override back color - 22mar2021
    otextcolor:longint;//default=clnone, override text color - 22mar2021
    owinLdrCOLOR:longint;//default=clnone, override system CORNER patch color - 07mar2022
    oframecolor:longint;//default=clnone, override system frame color - 17mar2021
    oframecolor2:longint;
    oframesparkle:longint;//default=-1, override system sparkle (0..20 range) - 27mar2021
    oborderstyle:longint;//default=0=internal, 1=system "vibordersize", 2=50% of system "vibordersize" - 17aug2020
    owinresizeable:boolean;//default=false
    oimagealign:longint;//default=iaNormal
    otab:longint;//default=tbNone - 23feb2021
    //.tag support
    tag:longint;
    tagstr:string;//05aug2020
    tagobj:tobject;//14aug2020
    //.optional  pointers - 15mar2021
    bc1:tbasiccontrol;
    bc2:tbasiccontrol;
    bc3:tbasiccontrol;
    bc4:tbasiccontrol;
    //own support
    ownlist:townlist;
    ownid:longint;//04apr2020
    //window support/menu/feedback support -> return codes for "clicked" menu item - 29aug2020
    ocode:longint;
    ocode2:string;
    otepcolor:longint;//02mar2021
    mkescape:boolean;
    mkreturn:boolean;
    //system info
    paintid:longint;//used internally to trigger a paint reguest
    //create
    constructor create(xparent:tobject); virtual;
    constructor create2(xparent:tobject;xstart:boolean); virtual;
    destructor destroy; override;
    procedure destroychildren; virtual;//1st
    procedure destroyothers; virtual;//2nd
    procedure start;//04jul2021
    function stable:boolean;
    function xsetclientarea(a:trect):boolean; virtual;
    function xlimitsize:boolean; virtual;
    function xfindheight(xclientwidth:longint;var xheight:longint):boolean;
    function getalignheight(xclientwidth:longint):longint; virtual;
    function getalignwidth(xclientheight:longint):longint; virtual;
    function client:tbasiccontrol; virtual;
    procedure xparentcorners;
    procedure xresizer; virtual;//25feb2021
    function canautoheight:boolean; virtual;//26feb2021
    function setbc14(v1,v2,v3,v4:tbasiccontrol):boolean;//15mar2021
    procedure xfaster;//boost system performance for upto 5sec - 25jul2021
    //system handlers
    //.timer
    property timer:boolean read itimer write itimer;//start or stop calling of "_ontimer()"
    procedure xtimer; virtual;//do not call - used by "tbasicform"
    //.align
    procedure alignpaintnow__heightcheck(xalign,xpaint:boolean;xclientwidth:longint);
    procedure alignallnow;
    procedure alignnow;
    procedure parentalignnow;
    procedure xalign;//do not call - used by "tbasicform"
    property xmustalign:boolean read imustalign write imustalign;
    //.onvalue
    procedure xonvalue; virtual;
    //.winstyle
    property winstyle:longint read iwinstyle write setwinstyle;
    function xwinfocused:boolean;
    function xwindow(var x:tbasiccontrol):boolean;//return our containing window
    function xwindowindex:longint;
    function winmaxed:boolean;//14mar2021
    //.paint
    procedure paintallnow;
    procedure paintnow;
    procedure parentpaintnow;
    procedure paintimmediate;//use sparingly - 09sep2021
    function xcanpaint:boolean;
    function xcanpaint_fast:boolean;//checks only the current layer -> assumes all previous layers have already been checked -> done for maximum speed - 05apr2020
    function xpaint:boolean;//do not call - used by "tbasicform"
    property xmustpaint:boolean read imustpaint write imustpaint;
    function xmustpaintcount:longint;
    property painted:boolean read ipainted;
    property aligned:boolean read ialigned;
    function parentpainted:boolean;
    function parentaligned:boolean;
    function minimal:boolean; virtual;
    //.align+paint
    procedure alignpaintnow;//05oct2020
    procedure alignpaintallnow;//05oct2020
    //.focus
    function focused:boolean;
    procedure setfocus;
    //showmenu
    function canshowmenu:boolean; virtual;
    procedure showmenu; virtual;
    procedure showmenu2(xstyle:string); virtual;
    procedure autoshowmenu;//detects when menu should be displayed and displays it - 15mar2021
    procedure autoshowmenu2(xstyle:string);
    function mustshowmenu:boolean;//detects when menu should be displayed
    //.fill
    procedure showmenuFill(xstyle:string;xmenudata:tstr8;var ximagealign:longint;var xmenuname:string); virtual;
    property showmenuFill1:tmenufillevent read fshowmenuFill1 write fshowmenuFill1;
    property showmenuFillINT:tmenufillevent read fshowmenuFillINT write fshowmenuFillINT;
    property showmenuFill2:tmenufillevent read fshowmenuFill2 write fshowmenuFill2;
    //.click
    function showmenuClick(sender:tobject;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean; virtual;
    property showmenuClick1:ttoolbarevent2 read fshowmenuClick1 write fshowmenuClick1;
    property showmenuClickINT:ttoolbarevent2 read fshowmenuClickINT write fshowmenuClickINT;
    property showmenuClick2:ttoolbarevent2 read fshowmenuClick2 write fshowmenuClick2;
    //.onshowmenu -> optional external event handler
    property onshowmenu:tnotifyevent read fonshowmenu write fonshowmenu;
    //sync control values from/to system handlers
    function xfromsys(xname:string):boolean;
    function xfromprg(xname:string):boolean;
    function xfromprg2(xname:string;dvars:tvars8):boolean;//prgsettings -> control -> dvars (allows for filtering of value) - 25mar2021
    function xtosys(xname:string):boolean;
    function xtoprg(xname:string):boolean;
    function xfrom(sender:tbasiccontrol;xvars:tvars8;xname:string):boolean; virtual;
    function xto(sender:tbasiccontrol;xvars:tvars8;xname:string):boolean; virtual;
    //core
    property gui:tbasicsystem read igui;//never nil
    property coreindex:longint read icoreindex;//0..N only -> position within "gui.core[n]"
    property parent:tbasiccontrol read iparent write setparent;
    property parentcoreindex:longint read iparentcoreindex;//0..N and "-1" if a root control - 19mar2020
    property xvisible:boolean read ivisible write ivisible;
    property visible:boolean read ivisible write setvisible;
    property enabled:boolean read ienabled write setenabled;
    function visibletohost:boolean;//true=control is visible and all controls directly beneath to "host form" (control.parent=nil) are visible too
    function enabledtohost:boolean;//true=control is visible and all controls directly beneath to "host form" (control.parent=nil) are enabled too
    function rootparent:tbasiccontrol;//01aug2021
    function areatohost(da:trect):trect;
    function setbounds(x,y,w,h:longint):boolean;
    property clientarea:trect read iclientarea write setclientarea;
    property left:longint read getleft;
    property top:longint read gettop;
    function headheight:longint; virtual;//25jan2021
    function clientspace:trect;//rect(0,0,clientwidth-1,clientheight-1) - 11apr2020
    function clientinner:trect;
    function clientinner2(x:tbasiccontrol):trect; virtual;
    property clientwidth:longint read getclientwidth write setclientwidth;
    property clientheight:longint read getclientheight write setclientheight;
    property paintarea:trect read ipaintarea;//visible area of control to paint
    function yshift:longint;
    function xshift:longint;
    procedure ownidInc;
    //.area handlers
    function xinside(x:tpoint):boolean;//local coordinates
    function xinside2(sx,sy:longint):boolean;//local coordinates
    function xinsideclientarea(x:tpoint):boolean;
    function xinsideclientarea2(sx,sy:longint):boolean;
    //.local mouse support
    function mousedownxy:tpoint;
    function mousemovexy:tpoint;
    function mouseinside:boolean;
    function mouseinsideclientarea:boolean;
    //.local draw support -> special draw procs for non-ms and non-delphi graphic drawing - 09apr2020
    procedure ldv(dx,dy,dy2,dcol:longint;xround:boolean);
    procedure ldv2(dx,dy,dy2,dcol:longint;xdot,xround:boolean);
    procedure ldh(dx,dx2,dy,dcol:longint;xround:boolean);
    procedure ldh2(dx,dx2,dy,dcol:longint;xdot,xround:boolean);
    procedure ldsOUTSIDE(dx,dy,dw,dh,dcol:longint);//02jun2021
    procedure lds(darea:trect;dcol:longint;xround:boolean);//draw solid area
    procedure lds2(darea:trect;dcol,dcol2,dcol3,drich:longint;xoptions:string;xround:boolean);
    procedure lds3(xdyanmicCorners:boolean;darea:trect;dcol,dcol2,dcol3,drich:longint;xoptions:string;xround,xdarktolight:boolean);
    procedure ldo(darea:trect;dcol:longint;xround:boolean);//draw hollow area
    procedure ldo2(darea:trect;dcol,dcol2,dcol3,drich:longint;xoptions:string;xround:boolean);
    procedure ldo3(xdyanmicCorners:boolean;darea:trect;dcol,dcol2,dcol3,drich:longint;xoptions:string;xround,xdarktolight:boolean);
    procedure ldso(darea:trect;dborder,dback:longint;xround:boolean);
    procedure ldso2(darea:trect;dborder,dborder2,dback,dback2,dback3,drich:longint;xoptions:string;xround:boolean);
    procedure ldso3(xdyanmicCorners:boolean;darea:trect;dborder,dborder2,dback,dback2,dback3,drich:longint;xoptions:string;xround,xdarktolight:boolean);
    procedure ldr(darea:trect;dcol:longint;xround:boolean);
    procedure ldr2(darea:trect;dcolTL,dcolTR,dcolBL,dcolBR,drich:longint;xoptions:string;xround:boolean);
    procedure ldr3(xdynamicCorners:boolean;darea:trect;dcolTL,dcolTR,dcolBL,dcolBR,drich:longint;xoptions:string;xround:boolean);
    property onwinLdrcolor:tlongintgetevent read fonwinLdrcolor write fonwinLdrcolor;
    function winLdrCOLOR:longint; virtual;//24feb2022
    procedure winLdr;
    procedure ldf(darea:trect;dcol,dcol2,dsize:longint;xframecode:tstr8;xround:boolean);//draw frame
    procedure ldf2(darea:trect;dcol,dcol2,dcol3,dsize,drich:longint;xoptions:string;xframecode:tstr8;xround:boolean);
    procedure ldf3(darea:trect;dcol,dcol2,dcol3,dsize,drich:longint;xoptions:string;xframecode:tstr8;xround:boolean);
    procedure ldf4(darea:trect;dcol,dcol2,dcol3,dsize,dbrightness,dbrightnessDARK,drich:longint;xoptions:string;xframecode:tstr8;xround:boolean);
    procedure ldm(darea:trect;xround:boolean);//draw color matrix
    procedure ldm2(darea:trect;dcol3:longint;xround:boolean);//draw color matrix
    procedure ldi(darea:trect;dx,dy,dcol,dtep:longint;xfocus,xgrey,xround:boolean);
    procedure ldi2(darea:trect;dx,dy,dcol,dcol2,dtep:longint;xfocus,xgrey,xround:boolean);
    procedure ldis(darea:trect;dx,dy,dcol,dtep:longint;xfocus,xgrey,xround:boolean);//system version
    procedure ldis2(darea:trect;dx,dy,dcol,dcol2,dtep:longint;xfocus,xgrey,xround:boolean);//system version
    procedure ltea(xdynamicCorners,xcolorise,xsyszoom:boolean;darea:trect;dx,dy,dcol:longint;xteadata:tstr8;xfocus,xgrey,xround:boolean);//07apr2021
    procedure lteas(darea:trect;dx,dy,dcol,dcol2:longint;xteadata:tstr8;xfocus,xgrey,xround:boolean);//07apr2021
    procedure ldc(darea:trect;ddx,ddy,ddw,ddh:currency;sa:trect;s:tobject;xpower255,xtrans,xtc:longint;xoptions:currency);
    procedure ldc2(darea:trect;ddx,ddy,ddw,ddh:currency;sa:trect;s:tobject;xpower255,xtrans,xtc,xwriteShadesofcolor:longint;xoptions:currency;xusealpha:boolean);
    procedure ldcs(xcolorise1,xcolorise2:longint;darea:trect;ddx,ddy,ddw,ddh:currency;sa:trect;s:tobject;xpower255,xtrans,xtc:longint;xoptions:currency);//system version
    procedure ldcs2(xcolorise1,xcolorise2:longint;darea:trect;ddx,ddy,ddw,ddh:currency;sa:trect;s:tobject;xpower255,xtrans,xtc:longint;xoptions:currency;xusealpha:boolean);//system version
    procedure ldt(darea:trect;dx,dy,dcol:longint;xline:string;xfontindex,xfeather:longint;xround:boolean);
    procedure ldt2(darea:trect;dx,dy,dcol:longint;xline:string;xfontindex,xfeather:longint;xbold,xitalic,xunderline,xstrikeout,xround:boolean);
    procedure ldt3(darea:trect;dx,dy,dcol:longint;xline:tstr8;xfontindex,xfeather:longint;xround:boolean);
    procedure ldt4(darea:trect;dx,dy,dcol:longint;xline:tstr8;xfontindex,xfeather:longint;xbold,xitalic,xunderline,xstrikeout,xround:boolean);
    procedure ldtTAB(xtab:longint;darea:trect;dx,dy,dcol:longint;xline:string;xfontindex,xfeather:longint;xround:boolean);
    procedure ldtTAB2(xtab:longint;darea:trect;dx,dy,dcol:longint;xline:string;xfontindex,xfeather:longint;xbold,xitalic,xunderline,xstrikeout,xround:boolean);
    procedure ldtTAB3(xtab:longint;darea:trect;dx,dy,dcol:longint;xline:tstr8;xfontindex,xfeather:longint;xround:boolean);
    procedure ldtTAB4(xtab:longint;darea:trect;dx,dy,dcol:longint;xline:tstr8;xfontindex,xfeather:longint;xbold,xitalic,xunderline,xstrikeout,xround:boolean);
    //system id
    property id:longint read iid;//unique for each and every control system wide
    //area id
    property aid:longint read iaid;//area id -> changed each time control changes position or size or both
    procedure ainc;
    //information
    property caption:string read icaption write setcaption;
    function info:pvirtualinfo;
    function info_round:boolean;
    function info_cs:trect;
    function info_bs:longint;
    function info_ci:trect;
    function findback:longint;//find background color - 25feb2021
    procedure findbackRound(var xback:longint;var xround:boolean);
    function findtext:longint;//find text color - 22mar2021
    function findframe:longint;//find frame color - 17mar2021
    function findframe2:longint;//find frame2 color - 17mar2021
    procedure infovars(var xinfo:pvirtualinfo;var xclientspace,xclientinner:trect;var fn,fb,fnH,fbH,fnbH,xclientwidth,xclientheight,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize:longint;var xenabled,xround,xnormal:boolean);
    procedure infovars2(var xinfo:pvirtualinfo;var xclientspace,xclientinner:trect;var fn,fb,fnH,fbH,fnbH,xclientwidth,xclientheight,xfont,xfontdisable,xfont2,xback,xback2,xborder,xhover,xfontheight,xfeather,xbordersize:longint;var xenabled,xround,xnormal:boolean);
    procedure xresetcanvas(x:tcanvas;xenabled:boolean);
    property normal:boolean read inormal write inormal;
    function mousex:longint;
    function mousey:longint;
    function mousexy:tpoint;
    property bordersize:longint read ibordersize write setbordersize;
    function findbordersize:longint; virtual;
    function rounded:boolean;
    //.help support
    property help:string read ihelp write ihelp;
    property help2:string read ihelp2 write ihelp2;//optional - replaces "help"
    property subhelp:string read isubhelp write isubhelp;
    property subhelp2:string read isubhelp2 write isubhelp2;//optional - replaces "subhelp"
    property helpline:string read gethelpline;
    //new control makers
    function ntea(xmaxW,xmaxH:longint;xcap,xhelp:string):tbasictea;
    function nimageviewer(xdata:tstr8;xhelp:string):tbasiccontrol;//12jan2022
    function nimageviewer2(xfilename:string;xuseai:boolean;xhelp:string):tbasiccontrol;//22may2022
    function ntitle(xlarge:boolean;xcap,xhelp:string):tbasictitle;
    function ntitlebar(xlarge:boolean;xcap,xhelp:string):tbasictoolbar;
    function ntitlebar2(xlarge,xright:boolean;xcap,xhelp:string):tbasictoolbar;
    function ninfo(xtitle,xhead,xtext,xhelp:string):tbasicinfo;
    function ncontrol:tbasiccontrol;
    function nlabel(xcap,xhelp:string):tbasiccontrol;
    function njump(xcap,xhelp:string;xpos,xlen:longint):tbasicjump;
    function nint(xcap,xhelp:string;xmin,xmax,xdef,xval:longint):tbasicint;
    function nint2(xcap,xhelp:string;xmin,xmax,xdef,xval:longint;xbackname:string):tbasicint;//26feb2021
    function nset(xcap,xhelp:string;xdef,xval:longint):tbasicset;
    function nsel(xcap,xhelp:string;xdef:longint):tbasicsel;
    function nint3(xcap,xhelp:string;xmin,xmax,xdef,xval:longint;xbackname,xloadfromname:string):tbasicint;
    function nmidivol(xcap,xhelp:string):tbasicint;//23mar2022, 29mar2021
    function nwavevol(xcap,xhelp:string):tbasicint;//23mar2022, 29mar2021
    function nmidi(xcap,xhelp:string):tbasicsel;//05mar2022
    function nwave(xcap,xhelp:string):tbasicsel;//05mar2022
    function nsel3(xcap,xhelp:string;xdef:longint;xloadfromname:string):tbasicsel;
    function ntick(xcap,xhelp:string):tbasictick;
    function ntick2(xcap,xhelp:string;xvert:boolean):tbasictick;
    function nedit(xcap,xhelp:string):tbasicedit;
    function nedit2(xcap,xhelp:string;xvert:boolean):tbasicedit;
    function ndropstatic(xhelp:string;xtep:longint):tbasicedit;
    function npass(xcap,xhelp:string):tbasicedit;
    function ncolor(xcap,xhelp:string):tbasiccolor;
    function ncolor2(xcap,xhelp:string;xvert:boolean;hsp:longint):tbasiccolor;
    function nscrollbar(xhelp:string;xvert:boolean):tbasicscrollbar;
    function nscroll(xhelp:string):tbasicscroll;//06oct2020
    function ntoolbar(xhelp:string):tbasictoolbar;//29may2021
    function ntoolbar_buttons(xhelp:string):tbasictoolbar;//29may2021
    function ncols:tbasiccols;//columns - 06oct2020
    function ncolors:tbasiccolors;
    function nbwp(xhelp:string;xdata:tstr8):tbasicbwp;
    function nbwp2(xhelp:string;xdata:tstr8;xwrap:longint;xrows,xautoheight:boolean):tbasicbwp;//17mar2021
    function nbwp3(xhelp:string;xdata:tstr8;xwrap:longint;xrows,xautoheight,xretaindata:boolean):tbasicbwp;//17mar2021
    function nbwp4(xhelp:string;xdata:tstr8;xwrap:longint;xrows,xautoheight,xretaindata,xtransform,xwebimages:boolean):tbasicbwp;//15may2021
    function nmenu(xcap,xhelp:string):tbasicmenu;
    function npoplist(xcap,xhelp:string;xlistdata:tstr8):tbasicmenu;
    function nlist(xcap,xhelp:string;xlistdata:tstr8;xrowcount:longint):tbasicmenu;
    function nlist3(xcap,xhelp:string;xlistdata:tstr8;xrowcount:longint;xloadfromname:string):tbasicmenu;
    function nlistx(xcap,xhelp:string;xcount,xrowcount:longint;xongetitem:tbasicmenu_getitem):tbasicmenu;
    function nlistx3(xcap,xhelp:string;xcount,xrowcount:longint;xongetitem:tbasicmenu_getitem;xloadfromname:string):tbasicmenu;
    function nnav:tbasicnav;//22sep2020
    function ncolormatrix:tbasiccolormatrix;//26feb2021
    function nsetcolor:tbasicsetcolor;//27feb2021
    function nbreak(xheight:longint):tbasicbreak;
    //events
    procedure _ontimer(sender:tobject); virtual;
    procedure _onpaint(sender:tobject); virtual;
    procedure _onalign(sender:tobject); virtual;
    function  _onshortcut(sender:tobject):boolean; virtual;
    function  _onnotify(sender:tobject):boolean; virtual;
    procedure _onfocus(sender:tobject); virtual;
    //special events
    property onalign:tnotifyevent read fonalign write fonalign;
    property onvalue:tnotifyevent read fonvalue write fonvalue;
    property onpaint:tnotifyevent read fonpaint write fonpaint;
    property onnotify:tsystemnotify read fonnotify write fonnotify;
    property ontimer2:tnotifyevent read fontimer2 write fontimer2;
    property onfindheight:tonfindheight read fonfindheight write fonfindheight;
    //offloader support - 07mar2021
    property xoffloading:boolean read ioffloading write ioffloading;//used to turn off some internal procs/functions that are not required during offloading -> purely optional - 07mar2021
    //.triggers
    function xoff_toolbaradd(x:tbasictoolbar):boolean;
    function xoff_toolbarsync(x:tbasictoolbar):boolean;
    function xoff_toolbarevent(x:tbasictoolbar):boolean;
    //.code handlers
    function _xoff_toolbaradd(x:tbasictoolbar):boolean; virtual;
    function _xoff_toolbarsync(x:tbasictoolbar):boolean; virtual;
    function _xoff_toolbarevent(x:tbasictoolbar):boolean; virtual;
    //.accept support -> drag and drop - 18jun2021
    property onaccept:tonacceptevent read fonaccept write fonaccept;
    function canaccept:boolean;
    function accept_passthru(sender:tobject;xfolder,xfilename:string;xindex,xcount:longint):boolean;
    //.makers
    property imageviewerinfo:string read iimagebufferinfo;
    procedure makeimageviewerfromfile(x:string;xuseai:boolean);//best to use this version, it's multi-task OK - 22may2022
    procedure makeimageviewer(x:tstr8);//not multi-task safe
    procedure makeimageviewer2(x:tstr8;xuseai:boolean);//not multi-task safe
    procedure makeimagevieweri(x:tbasicimage);//uses the image -> must set to nil to stop using it - 07feb2022
    property ximageviewerbuffer:tbasicimage read iimagebuffer;
    property ximageviewerbufferi:tbasicimage read iimagebufferi write iimagebufferi;
    procedure xmakeimageviewer(x:tstr8;xstyle:longint;xreset,xpaintnow:boolean);
    //idle tracking support - 21feb2022
    procedure notidle;
    function idletime:comp; virtual;
    //automation support
    procedure xwound_mousevert(xmaxtime:longint;xforce:boolean);
    procedure xwound_mousevert2(xmaxtime:longint;xforce,xinvert:boolean);
    procedure xwound_mousevert3(xmaxtime:longint;xforce,xinvert,xvertical:boolean);
    function xwound_mustpaint(spos,xrowsperpaint:longint;var dpos,ddir:longint):boolean;
    function xwound_mustpaint2(spos,xrowsperpaint:longint):longint;
    function xwound_off:boolean;
    procedure xwound_autooff(spos,xdir,xmin,xmax:longint);
    function xwound_finddir(xtime:longint):longint;
    function xwound_dirmatch(xtime1,xtime2:longint):boolean;
    procedure xwound_wheel(xtimems:longint);
   end;

{tbasichead}
   tbasichead=class(tbasiccontrol)
   private
    idragref64,idragref64check,itimer250:currency;
    iimg:tbasicimage;
    itranscol,istyle,itep,ilongperiod,ishortperiod,vinf,vmin,vmax,vclo,idownindex,ihoverindex:longint;
    icaption2,iinfostate,iinforef:string;
    iformrect:trect;
    //.note: control supports both system buttons (vmin,vmax,vclo) and user buttons with a total of 9 buttons supported (3 for system) and (6 for user - optional) - 14mar2020
    ibuttep:array[0..8] of longint;
    ibutcmd:array[0..8] of string;
    ibuthlp:array[0..8] of string;
    ibutenb:array[0..8] of boolean;
    ibutvis:array[0..8] of boolean;
    ibutw  :array[0..8] of longint;
    ibuth  :array[0..8] of longint;
    ibutare:array[0..8] of trect;
    //.animation support
    ianitep:array[0..9] of longint;
    ianims :array[0..9] of longint;
    ianipos,ianicount:longint;
    ianiplay64,ianinext64:comp;
    function xok(xindex:longint):boolean;
    procedure setbuttep(xindex:longint;xtep:longint);
    function getbuttep(xindex:longint):longint;
    function getbuthlp(xindex:longint):string;
    procedure settep(x:longint);
    procedure setstyle(x:longint);
    procedure setcaption2(x:string);
   public
    //options
    oiconpad:longint;//default=1
    osafepos:boolean;//default=true=always on screen checking with smart next screen autooff, false=no checking and form can be dragged off screen without chance of recovery
    osmall:boolean;//default=false;
    //create
    constructor create2(xparent:tobject;xstart:boolean); override;
    destructor destroy; override;
    procedure _ontimer(sender:tobject); override;
    procedure _onpaint(sender:tobject); override;//28may2021, 26apr2021
    function  _onnotify(sender:tobject):boolean; override;
    function _onnotify2(sender:tobject;xdragonly:boolean):boolean;
    function xfind(sx,sy:longint):longint;
    function xfindcmd(xcmd:string;var xindex:longint):boolean;
    procedure xcmd(x:string);
    procedure xdragthewindow;//force head to act as a window dragger - assuming mouse input matches up - 07mar2022
    function getalignheight(xclientwidth:longint):longint; override;
    //showmenu
    procedure showmenuFill(xstyle:string;xmenudata:tstr8;var ximagealign:longint;var xmenuname:string); override;
    function showmenuClick(sender:tobject;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean; override;
    //information
    function displaysize:longint;
    property caption;
    property caption2:string read icaption2 write setcaption2;//18jun2021
    property buttep[xindex:longint]:longint read getbuttep write setbuttep;
    property buthlp[xindex:longint]:string read getbuthlp;
    property style:longint read istyle write setstyle;//buttons -> wuNone, wuClose, wuAll
    //.style support
    function canmin:boolean;
    function cannor:boolean;
    function canmax:boolean;
    function canclo:boolean;
    function canmen:boolean;
    //.image
    property tep:longint read itep write settep;//main icon/image - 13may2020
    property transcol:longint read itranscol;
    //.animation support
    procedure aniClear;
    function aniAdd(xtep,xms:longint):boolean;//16sep2022
    procedure aniPlay;//plays for 2 seconds before stopping - 30apr2022
    //makers
    function make_bare:tbasichead;
   end;

{tbasichelp}
   tbasichelp=class(tbasiccontrol)
   private
    ipostime,itimer250:currency;
    ishowhelp,ipause:boolean;
    ideftext,itext,iinforef:string;
    iimg,iimgw,iimgh,ipos,itextid:longint;
    procedure settext(x:string);
    function paintscroll:boolean;
    procedure setshowhelp(x:boolean);
    procedure xsync;
   public
    //create
    constructor create2(xparent:tobject;xstart:boolean); override;
    destructor destroy; override;
    procedure _ontimer(sender:tobject); override;
    procedure _onpaint(sender:tobject); override;
    function getalignheight(xclientwidth:longint):longint; override;
    //information
    property showhelp:boolean read ishowhelp write setshowhelp;
    property text:string read itext write settext;
    property deftext:string read ideftext write ideftext;
   end;

//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//nnnnnnnnnnnnnnnnnnn
{tbasicnav}
   tbasicnav=class(tbasiccontrol)
   private
    ifolderid,ifavlimit,iownerid,iownerid2,isortstyle,istyle,inavcount,ifoldercount,ifilecount,itotalcount:longint;
    itimer100,itimer250:currency;
    ifav,ilist:tbasicmenu;//in dynamic list mode - 28sep2020
    iname,ifilter:tbasicedit;
    ipreviewbox:tbasiccontrol;
    ipreviewlabel:tbasictitle;
    ifavlabel,ilistlabel,inamelabel,ifilterlabel:tbasiccontrol;
    ibar,ibut:tbasictoolbar;
    ilastpreviewfile,iprevnextcode,ifavfolder,ireloadref,ilastmask,ilastemask,ilastemask_minmax,ifolderidREF,ilistfolder,imustfolder,imustname:string;
    ihisname:string;
    isyspreview,ipreview,icanpreview,ilastpreview,imustreload:boolean;
    ilistcore:tstr8;
    ifavcore:tdynamicstring;//10mar2021
    ifavteps:tdynamicinteger;//14apr2021
    fonclick:tnotifyevent;
    //.filter support
    findex,fcount:longint;
    fcap:array[0..99] of string;//label e.g. "Bitmap (bmp)|Jpeg Image (jpg/jpeg)"
    fext:array[0..99] of string;//extension e.g. "BMP" or "JPG;JPEG"
    fmsk:array[0..99] of string;//mask e.g. "*.bmp;*.jpg;*.jpeg"
    ftep:array[0..99] of longint;//store tep for each ext or group of exts (e.g. support for teps for "bcs", pebcs and feAllDocs(a group of document types)) - 10mar2021
    procedure setstyle(x:longint);
    function __ongetitem(sender:tobject;xindex:longint;var xtab,xtep,xtepcolor:longint;var xcaption,xcaplabel,xhelp,xcode2:string;var xcode,xshortcut,xindent:longint;var xflash,xenabled,xtitle,xsep:boolean):boolean;
    function __ongetitem2(sender:tobject;xdisplayonly:boolean;xindex:longint;var xtab,xtep,xtepcolor:longint;var xcaption,xcaplabel,xhelp,xcode2:string;var xcode,xshortcut,xindent:longint;var xflash,xenabled,xtitle,xsep:boolean):boolean;
    procedure __onclick(sender:tobject);
    procedure filter__onclick(sender:tobject);
    procedure setfilterlist(x:string);
    function getfilterlist:string;
    function getfilter:string;
    procedure setfilter(x:string);
    procedure setfilterfromfilename(x:string);
    function getfilterindex:longint;
    procedure setfilterindex(x:longint);
    procedure setvalue(x:string);
    function getvaluelist(xindex:longint):string;//28sep2022
    function getvalue:string;//06apr2021
    function getvaluestyle:longint;
    function getvalueEXT:string;//12jan2022
    function getfolder:string;
    procedure setfolder(x:string);
    procedure setsortstyle(x:longint);
    function getdownindex:longint;
    procedure setdownindex(x:longint);
    function getfiledownindex:longint;
    function getfolderdownindex:longint;
    function getnavdownindex:longint;
    function xfiltername(xnewname:string;xaddfilterext:boolean):string;
    procedure findex_tep;
    function xenhancednames(x:string):string;
    function getitemindex:longint;
    procedure setitemindex(x:longint);
    //fav support
    procedure loadfav;
    function savefav(xdata:tstr8):boolean;
    procedure addfav(xfolder:string);
    function xfavfolder:string;
    //his support
    procedure sethisname(x:string);
    procedure xhisadd(xval:string;xpos,xitemindex:longint;xstorev12:boolean);//22mar2021
    //showmenu support
    procedure xshowmenuFill1(sender:tobject;xstyle:string;xmenudata:tstr8;var ximagealign:longint;var xmenuname:string);
    procedure xshowmenuFill2(sender:tobject;xstyle:string;xmenudata:tstr8;var ximagealign:longint;var xmenuname:string);
    procedure xshowmenuFill(sender:tobject;xstyle:string;xmenudata:tstr8;var ximagealign:longint;var xmenuname:string);
    function xshowmenuClick1(sender:tbasiccontrol;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean;
    function xshowmenuClick2(sender:tbasiccontrol;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean;
    function xshowmenuClick(sender:tbasiccontrol;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean;
   public
    //options
    ocommonfolder:string;//default=<nil>
    omasklist:string;
    oemasklist:string;
    oretainpos:boolean;//default=true=keeps vertical position during reloads
    ofindname:boolean;//default=false, true=selects name from list when value is a full filename - 19dec2021
    ocansort:boolean;//default=true=allow user to change sort style - 12jan2022
    onumber:boolean;//default=false, true=number only the files list section - 20mar2022
    //.minmax range enforcer - 27sep2022
    ominsize:comp;
    omaxsize:comp;
    ominmax_emasklist:string;//files to be excludes from the "ominsize..omaxsize" range check - 27sep2022
    //create
    constructor create2(xparent:tobject;xstart:boolean); override;
    destructor destroy; override;
    procedure _ontimer(sender:tobject); override;
    procedure _onpaint(sender:tobject); override;
    procedure _onalign(sender:tobject); override;
    function xfrom(sender:tbasiccontrol;xvars:tvars8;xname:string):boolean; override;
    function xto(sender:tbasiccontrol;xvars:tvars8;xname:string):boolean; override;
    function xcmd(xcode:longint;xcode2:string;xtepcolor:longint):boolean;
    //change ids - 27sep2022
    property folderID:longint read ifolderid;//increments each time a new folder is loaded - 27sep2022

    //information
    property sortstyle:longint read isortstyle write setsortstyle;
    property style:longint read istyle write setstyle;//bnNil .. bnMax
    property filterlist:string read getfilterlist write setfilterlist;
    property filter:string read getfilter write setfilter;
    property filterfromfilename:string read getfilter write setfilterfromfilename;//18jun2021
    property filterindex:longint read getfilterindex write setfilterindex;
    property folder:string read getfolder write setfolder;
    property valuelist[xindex:longint]:string read getvaluelist;//28sep2022
    property value:string read getvalue write setvalue;
    property valuestyle:longint read getvaluestyle;//e.g. nltFile, nltFolder, nltNav, nltTitle etc - 22mar2021
    property valueEXT:string read getvalueext;//works for "nltFile" only and returns the file extension in LOWERCASE - 12jan2022
    function selectedfolder:string;//current item's folder "filepath" - 07apr2021
    property navcount:longint read inavcount;
    property foldercount:longint read ifoldercount;
    property filecount:longint read ifilecount;
    property totalcount:longint read itotalcount;
    property downindex:longint read getdownindex write setdownindex;
    function findinfo(var xselstart,xselcount,xdownindex,xnavindex,xfolderindex,xfileindex,xnavcount,xfoldercount,xfilecount:longint;var xisnav,xisfolder,xisfile:boolean):boolean;
    function findinfo2(xindex:longint;var xselstart,xselcount,xdownindex,xnavindex,xfolderindex,xfileindex,xnavcount,xfoldercount,xfilecount:longint;var xisnav,xisfolder,xisfile:boolean;var xsize:comp;var xvalue:string;xfindvalue:boolean):boolean;
    procedure findinfoBrief(var xisnav,xisfolder,xisfile:boolean);
    property favfolder:string read ifavfolder write ifavfolder;//optional folder to allow user to add to fav upon clicking the link "Add" - 10mar2021
    property itemindex:longint read getitemindex write setitemindex;//23mar2022
    //showmenu
    function canshowmenu:boolean; override;
    procedure showmenu; override;//20mar2022
    //history support
    property hisname:string read ihisname write sethisname;//used to store folder history via system history support - default=<nil>=off
    //.prev
    function canprev:boolean;
    function prev:boolean;
    //.next
    function cannext:boolean;
    function next:boolean;
    //.fav - show fav window
    function popfav:string;
    //.preview
    property preview:boolean read ipreview write ipreview;
    property canpreview:boolean read icanpreview write icanpreview;//default=true, controls whether preview link on toolbar and preview can in fact be shown even if set to preview this overrides - 22may2022
    property syspreview:boolean read isyspreview write isyspreview;//default=false, true=read/write "preview" state from internal system vars - 22may2022
    //workers
    procedure reload;
    //makers
    function makenil:tbasicnav;
    function makefav:tbasicnav;
    function makenav:tbasicnav;
    function makefolder:tbasicnav;
    function makeopen:tbasicnav;
    function makesave:tbasicnav;
    function makefavlist:tbasicnav;
    function makenavlist:tbasicnav;//use this for a standard filebox list - 27sep2022
    function makenavlist2:tbasicnav;
    function makenamelist:tbasicnav;
    function xautoclose(x:boolean):tbasicnav;
    //.support
    function xbar:tbasictoolbar;
    function xbut:tbasictoolbar;
    function xfav:tbasicmenu;
    function xfavlabel:tbasiccontrol;
    function xpreviewbox:tbasiccontrol;//22may2022
    function xpreviewlabel:tbasiccontrol;//22may2022
    function xlist:tbasicmenu;
    function xlistlabel:tbasiccontrol;
    function xname:tbasicedit;
    function xnamelabel:tbasiccontrol;
    function xfilter:tbasicedit;
    function xfilterlabel:tbasiccontrol;
    //.special value handlers
    function xvaluefile(xdef:string):string;
    //home
    function canhome:boolean;
    procedure home;
    //offloaders
    function _xoff_toolbaradd(x:tbasictoolbar):boolean; override;
    function _xoff_toolbarsync(x:tbasictoolbar):boolean; override;
    function _xoff_toolbarevent(x:tbasictoolbar):boolean; override;
    //idletime - custom
    function idletime:comp; override;//21feb2022
    //events
    property onclick:tnotifyevent read fonclick write fonclick;
   end;

{tbasicbwp}
//xxxxxxxxxxxxxxxxxxxxxxxxxxx//wwwwwwwwwwwwwwwwwwwwwwwwwwww
   tbasicbwp=class(tbasiccontrol)
   private
    icore:twordcore;
    iv,ih:tbasicscrollbar;
    islowdownref,itimersync:comp;
    imustpos,imustpos2,imustscrollv,imustscrollh,itimersync_fastcount,imleft,imright,imtop,imbottom:longint;
    iusepagecolor,ibuildingcontrol:boolean;
    iref:string;
    irevertdata:tstr8;
    fonact:tsimplestringeventb;
    procedure setpos(x:longint);
    function getpos:longint;
    procedure setposh(x:longint);
    function getposh:longint;
    function getposc:longint;
    procedure setposc(x:longint);
    function getposc2:longint;
    procedure setposc2(x:longint);
    procedure _onpos(sender:tobject);
    procedure setreadonly(x:boolean);
    function getreadonly:boolean;
    procedure setshowcursor(x:boolean);
    function getshowcursor:boolean;
    function getcore:pwordcore;
    procedure setusepagecolor(x:boolean);
    function getroundstyle:longint;
    procedure setroundstyle(x:longint);
    procedure setwrap(x:longint);//0=no wrap, 1=to window, 2=to page (default)
    function getwrap:longint;
    procedure setwrapreadonly(x:boolean);//true=prevents wrapstyle from changing during "ioset()" operations - 12mar2021
    function getwrapreadonly:boolean;
    procedure xsync;
    procedure setsyscols(x:boolean);
    function getsyscols:boolean;
    function getundoenabled:boolean;
    procedure setundoenabled(x:boolean);
    procedure _onarrow(sender:tobject;var xmoveval:longint);
   public
    //options
    orows:boolean;//default=false, true=draw text with alternating row color - 12mar2021
    omenustyles:boolean;//default=false, true=show style options in menu - 19dec2021
    ocopystyles:boolean;//default=true=show copy enhanced etc, else hide them - 18jun2022
    ousecolorise:boolean;//default=true=works with "syscols" etc, false=instructs box NOT to colorise it's images - 21jun2022
    vsmooth:boolean;//default=true=smooth scroll by pixels, false=older style, scroll by lines - 21jun2022
    //create
    constructor create(xparent:tobject); override;
    constructor create2(xparent:tobject;xstart:boolean); override;
    destructor destroy; override;
    function _onnotify(sender:tobject):boolean; override;
    procedure _ontimer(sender:tobject); override;
    procedure _onpaint(sender:tobject); override;
    procedure _onalign(sender:tobject); override;
    function _onshortcut(sender:tobject):boolean; override;
    property core:pwordcore read getcore;
    procedure syncdef;//06oct2020
    procedure showmenuFill(xstyle:string;xmenudata:tstr8;var ximagealign:longint;var xmenuname:string); override;
    function showmenuClick(sender:tobject;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean; override;
    procedure xwordcoretimer(xsyncnow:boolean);
    //information
    property roundstyle:longint read getroundstyle write setroundstyle;
    property oreadonly:boolean read getreadonly write setreadonly;
    property oshowcursor:boolean read getshowcursor write setshowcursor;
    property ousepagecolor:boolean read iusepagecolor write setusepagecolor;
    property vpos:longint read getpos write setpos;
    property hpos:longint read getposh write setposh;
    property cpos:longint read getposc write setposc;
    property cpos2:longint read getposc2 write setposc2;
    property wrap:longint read getwrap write setwrap;
    property wrapreadonly:boolean read getwrapreadonly write setwrapreadonly;
    property syscols:boolean read getsyscols write setsyscols;
    //scrollto
    procedure vscrolltopos(xpos:longint);
    procedure scrollto(_vpos,_hpos,_pos,_pos2:longint;xforcewrapall:boolean);
    //margin
    procedure margin(xl,xt,xr,xb:longint);
    property mleft:longint read imleft;
    property mtop:longint read imtop;
    property mright:longint read imright;
    property mbottom:longint read imbottom;
    //revert support
    procedure revertinit(xdata:tstr8;xenable:boolean);
    //io
    function ioget(xdata:tstr8;xformat:string):boolean;
    function ioset(xdata:tstr8):boolean;
    function ioset2(xdata:tstr8;xvpos:longint):boolean;
    function ioset3(xdata:tstr8;xvpos,xhpos,xpos,xpos2:longint;xtransform,xwebimages:boolean):boolean;
    //.txt
    function iogettxt(xdata:tstr8):boolean;
    function iosettxt(xdata:tstr8):boolean;
    //.bwd
    function iogetbwd(xdata:tstr8):boolean;
    function iosetbwd(xdata:tstr8):boolean;
    //.bwp
    function iogetbwp(xdata:tstr8):boolean;
    function iosetbwp(xdata:tstr8):boolean;
    //.rtf - 22jun2022
    function iogetrtf(xdata:tstr8):boolean;
    function iosetrtf(xdata:tstr8):boolean;
    //edit support
    //.can
    function xcan(x:string):boolean;
    function canundo:boolean;
    function canredo:boolean;
    function cancut:boolean;
    function cancopy:boolean;
    function cancopyall:boolean;
    function canpaste:boolean;
    function canpastereplace:boolean;
    function candeleteall:boolean;//has undo
    function canclearall:boolean;//no undo
    property undoenabled:boolean read getundoenabled write setundoenabled;
    //.act
    function xact(x:string;var e:string):boolean;
    //.other
    procedure undoon;
    procedure undooff;
    procedure undoclear;
    //transformers
    function makeviewonly:tbasicbwp;
    function claudesupport:tbasicbwp;
    //makers - 12jun2022
    //.vifontsize + onefontname="$fontname" - 21jun2022
    procedure makeplaintext1;
    procedure maketxt1;
    procedure makebwd1;
    procedure makebwp1;
    //.vifontsize2 + onefontname="$fontname2" - 21jun2022
    procedure makeplaintext2;
    procedure maketxt2;
    procedure makebwd2;
    procedure makebwp2;
    //.full version (all fonts, styles, images etc) -21jun2022
    procedure makebwpFull;
    procedure makexxx(xformatlevel:longint;xuseonefont:longint;xviewurl:boolean);//12jun2022
    //events
    property onact:tsimplestringeventb read fonact write fonact;//19jun2022
   end;

{tbasiccolor}
   tbasiccolor=class(tbasiccontrol)
   private
    icolor,ishadecolor:longint;
    foncolor:tlongintevent;
    ishadearea:trect;
    ishadeused:boolean;
    procedure setcolor(x:longint);
    procedure _setcolor(x:longint);
    procedure xdomenu(xcode2:string);
   public
    //options
    opopcolor:boolean;//default=true=click to show colordlg
    oshaderange:boolean;
    //create
    constructor create(xparent:tobject;xcaption:string);
    constructor create2(xparent:tobject;xstart:boolean;xcaption:string); virtual;
    destructor destroy; override;
    function getalignheight(xclientwidth:longint):longint; override;
    function getalignwidth(xclientheight:longint):longint; override;
    //information
    property color:longint read icolor write setcolor;
    //workers
    procedure showmenu;
    //events
    procedure _onpaint(sender:tobject); override;
    function  _onnotify(sender:tobject):boolean; override;
    function  _onshortcut(sender:tobject):boolean; override;
    property oncolor:tlongintevent read foncolor write foncolor;//26feb2021
   end;

{tbasiccolormatrix}
//xxxxxxxxxxxxxxxxxxxxxxxxxxx//zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
   tbasiccolormatrix=class(tbasiccontrol)
   private
    icolor:longint;
    foncolor:tlongintevent;
    procedure setcolor(x:longint);
   public
//xxxxxxxxxxxxxxxxxx need to have an event that sends out current color by cursor position!!!!!!!!
    //override
    constructor create2(xparent:tobject;xstart:boolean); override;
    destructor destroy; override;
    //events
    procedure _onpaint(sender:tobject); override;
    function _onnotify(sender:tobject):boolean; override;
    property oncolor:tlongintevent read foncolor write foncolor;
    //information
    property color:longint read icolor write setcolor;
   end;

{tbasicinfo}
   tbasicinfo=class(tbasiccontrol)
   private
    itimer250:currency;
    ititle,ihead,itext,iinforef:string;
    irowpad,idataid:longint;
    procedure settitle(x:string);
    procedure sethead(x:string);
    procedure settext(x:string);
   public
    //options
    ocolwidth:longint;//first column
    orowlimit:longint;//default=5 rows -> 0=manual height, 1..N=restrict autoheight to specified number of rows - 13apr2020
    //create
    constructor create2(xparent:tobject;xstart:boolean); override;
    destructor destroy; override;
    property dataid:longint read idataid;
    function getalignheight(xclientwidth:longint):longint; override;
    //information
    property title:string read ititle write settitle;//1 line
    property head:string read ihead write sethead;//1 line
    property text:string read itext write settext;//multiple lines
    procedure setdata(xtitle,xhead,xtext:string);
    //events
    procedure _ontimer(sender:tobject); override;
    procedure _onpaint(sender:tobject); override;
   end;

{tbasicstatus}
   tbasicstatus=class(tbasiccontrol)
   private
    //Note: Now supports auto-width if no cellwidths are set BUT "celltext[0]" has text - 05oct2020
    itimer250:currency;
    ilastflash,ipause:boolean;
    iflashcount:longint;
    iinforef:string;
    icellflash:array[0..9] of boolean;
    icellwidth:array[0..9] of longint;
    icellpert:array[0..9] of double;
    icelltext:array[0..9] of string;
    icellref:array[0..9] of string;
    function xcellok(x:longint):boolean;
    procedure setcelltext(x:longint;y:string);
    function getcelltext(x:longint):string;
    procedure setcellwidth(x,y:longint);
    function getcellwidth(x:longint):longint;
    procedure setcellpert(x:longint;y:double);
    function getcellpert(x:longint):double;
    procedure setcellflash(x:longint;y:boolean);
    function getcellflash(x:longint):boolean;
   public
    //create
    constructor create2(xparent:tobject;xstart:boolean); override;
    destructor destroy; override;
    procedure _ontimer(sender:tobject); override;
    procedure _onpaint(sender:tobject); override;
    function getalignheight(xclientwidth:longint):longint; override;
    //information
    property pause:boolean read ipause write ipause;
    property celltext[x:longint]:string read getcelltext write setcelltext;
    property cellwidth[x:longint]:longint read getcellwidth write setcellwidth;
    property cellpert[x:longint]:double read getcellpert write setcellpert;//07jul2021
    property cellflash[x:longint]:boolean read getcellflash write setcellflash;//29dec2021
   end;

{tbasictitle}
   tbasictitle=class(tbasiccontrol)
   private
    itimer250:currency;
    iinforef,itext:string;
    ilabel:boolean;
    procedure settext(x:string);
    function xtitleheight:longint;//text height
   public
    //options
    olarge:boolean;//default=false=small
    //create
    constructor create(xparent:tobject;xlarge,xlabel:boolean;xcaption:string);
    constructor create2(xparent:tobject;xstart,xlarge,xlabel:boolean;xcaption:string); virtual;
    destructor destroy; override;
    procedure _ontimer(sender:tobject); override;
    procedure _onpaint(sender:tobject); override;
    function getalignheight(xclientwidth:longint):longint; override;//07sep2020
    //information
    property text:string read itext write settext;
   end;

{tbasicbreak}
   tbasicbreak=class(tbasiccontrol)
   private
    iheight:longint;
   public
    //create
    constructor create(xparent:tobject;xheight:longint); virtual;
    constructor create2(xparent:tobject;xstart:boolean;xheight:longint); virtual;
    destructor destroy; override;
    function getalignheight(xclientwidth:longint):longint; override;
    //events
    procedure _onpaint(sender:tobject); override;
   end;

{tbasicint}
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//iiiiiiiiiiiiiiiiiiiii
   tbasicint=class(tbasiccontrol)
   private
    itimer500,itimer250:comp;
    ilastval,ireloadid,idownval,ipaintid,ivalid,ilastpaintid,ilastvalid,imin,imax,idef,ival:longint;
    ilastvalunit,idownstyle:string;
    fonreadwriteval:tbasicint_onreadwriteval;
    fonvalue2:tlongintevent;
    fonvalcap:tsimplestringevent;
    iamore,ialess,iamore2,ialess2,iadef,iabar:trect;
    procedure setval(xval:longint);
    procedure writeval(xval:longint);
    function readval:longint;
    procedure xnorects;
    procedure __onvol(sender:tobject;var xval:longint;xwrite:boolean);
    procedure setdef(xdef:longint);
   public
    //options
    omore:longint;
    oless:longint;
    omore2:longint;
    oless2:longint;
    //.label overrides - 07jul2021
    omorecap:string;
    olesscap:string;
    omorecap2:string;
    olesscap2:string;
    odefcap:string;
    oshow2:boolean;//default=true - 07feb2022
    //.showval
    oshowdef:boolean;//03mar2022
    ovalshow:boolean;
    ovalmultiplier:extended;//default=1
    ovalunit:string;//default=<nil>, can use to show a unit of measure AND/OR include helpful hints etc
    ovalstyle:string;//default=<nil>, msfps=ms -> frames per second
    oloadfromname:string;//get value from a system value using a name
    oautoreload:boolean;
    //create
    constructor create(xparent:tobject); virtual;
    constructor create2(xparent:tobject;xstart:boolean); virtual;
    destructor destroy; override;
    procedure _ontimer(sender:tobject); override;
    function _onnotify(sender:tobject):boolean; override;
    function getalignheight(xclientwidth:longint):longint; override;
    function zname(n:string):string;
    //workers
    procedure setparams(xmin,xmax,xdef,xval:longint);
    procedure setparams3(xmin,xmax,xdef,xval:longint;xloadfromname:string);
    property min:longint read imin;
    property max:longint read imax;
    property def:longint read idef write setdef;
    property val:longint read readval write setval;
    procedure reload;//uses "oloadfromname" to gain value - 07sep2020
    //makers
    procedure makeZoom10k;
    procedure makeFps10;
    procedure makemidivol;//23mar2022
    procedure makewavevol;
    procedure makevol(xmade:longint);//12nov2022
    //events
    procedure _onpaint(sender:tobject); override;
    property onvalue2:tlongintevent read fonvalue2 write fonvalue2;//26feb2021
    property onreadwriteval:tbasicint_onreadwriteval read fonreadwriteval write fonreadwriteval;
    property onvalcap:tsimplestringevent read fonvalcap write fonvalcap;
   end;

{tbasicset}
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//oooooooooooooooooooooooooo
   tbasicset_valarray=array[0..31] of boolean;
   tbasicset_onreadwriteval=procedure(sender:tobject;var xval:tbasicset_valarray;xwrite:boolean) of object;
   tbasicset=class(tbasiccontrol)
   private
    itimer250:comp;
    icaps:array[0..31] of string;
    inams:array[0..31] of string;
    ihlps:array[0..31] of string;
    ivisb:array[0..31] of boolean;
    iloadfromnames:array[0..31] of string;
    irecs:array[0..31] of trect;
    ilastval,ireloadid,icount,ilastitemsperline,ilastcount,iitemsperline,idownindex,ipaintid,ivalid,ilastpaintid,ilastvalid,idef,ival:longint;
    fonreadwriteval:tbasicset_onreadwriteval;
    procedure setval(xval:longint);
    procedure xnorects;
    function getcaps(xindex:longint):string;
    procedure setcaps(xindex:longint;xval:string);
    function getnams(xindex:longint):string;
    procedure setnams(xindex:longint;xval:string);
    function getvisb(xindex:longint):boolean;
    procedure setvisb(xindex:longint;xval:boolean);
    function getvals(xindex:longint):boolean;
    procedure setvals(xindex:longint;xval:boolean);
    procedure setitemsperline(x:longint);
    procedure xsynccount;
    procedure ysetval(xval:longint);
    function ygetval:longint;
    property yval:longint read ygetval write ysetval;
    function getvals2(xname:string):boolean;
    procedure setvals2(xname:string;xval:boolean);
   public
    //options
    oautoreload:boolean;
    ovpad:longint;//default=0, set to Nxbordersize to pad vertical height to match other stacked controls - 21may2022
    //create
    constructor create(xparent:tobject); virtual;
    constructor create2(xparent:tobject;xstart:boolean); virtual;
    destructor destroy; override;
    procedure _ontimer(sender:tobject); override;
    function _onnotify(sender:tobject):boolean; override;
    function getalignheight(xclientwidth:longint):longint; override;
    //workers
    function linecount:longint;
    property count:longint read icount;
    function viscount:longint;//visible count
    property itemsperline:longint read iitemsperline write setitemsperline;
    procedure xset(xindex:longint;xcap,xnam,xhlp:string;xval:boolean);
    procedure xset3(xindex:longint;xcap,xnam,xhlp:string;xval:boolean;xloadfromname:string);
    property caps[xindex:longint]:string read getcaps write setcaps;
    property nams[xindex:longint]:string read getnams write setnams;
    property visb[xindex:longint]:boolean read getvisb write setvisb;
    procedure setparams(xdef,xval:longint);
    procedure setparams2(xdef,xval,xitemsperline:longint);
    property def:longint read idef;
    property val:longint read ygetval write setval;
    property vals[xindex:longint]:boolean read getvals write setvals;
    property vals2[xname:string]:boolean read getvals2 write setvals2;//28feb2022
    function findname(xname:string;var xindex:longint):boolean;
    procedure reload;//uses "oloadfromname" to gain value - 07sep2020
    //events
    procedure _onpaint(sender:tobject); override;
    property onreadwriteval:tbasicset_onreadwriteval read fonreadwriteval write fonreadwriteval;
   end;

{tbasicsel}
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//lllllllllllllllllllllll
   tbasicsel_onreadwriteval=procedure(sender:tobject;var xval:longint;xwrite:boolean) of object;
   tbasicsel=class(tbasiccontrol)
   private
    icaps:array[0..31] of string;
    inams:array[0..31] of string;
    ihlps:array[0..31] of string;
    istrs:array[0..31] of string;//host support only
    irecs:array[0..31] of trect;
    itep,ireloadid,icount,ilastitemsperline,ilastcount,iitemsperline,idownindex,ipaintid,ivalid,ilastpaintid,ilastvalid,idef,ival,imax:longint;
    iwasselected:boolean;
    fonreadwriteval:tbasicsel_onreadwriteval;
    fonclick:tnotifyevent;
    itimer500:comp;
    procedure setval(xval:longint);
    procedure writeval(xval:longint);
    function readval:longint;
    procedure xnorects;
    function getcaps(xindex:longint):string;
    procedure setcaps(xindex:longint;xval:string);
    function getnams(xindex:longint):string;
    procedure setnams(xindex:longint;xval:string);
    function gethlps(xindex:longint):string;//13mar2022
    procedure sethlps(xindex:longint;xval:string);
    function getstrs(xindex:longint):string;
    procedure setstrs(xindex:longint;xval:string);
    procedure xsynccount;
    procedure setitemsperline(x:longint);
    procedure settep(x:longint);
   public
    //options
    oloadfromname:string;//get value from a system value using a name
    oautoreload:boolean;
    ovalueclick:boolean;//default=false, true=onvalue is fired EACH TIME an item is selected EVEN if it is already selected - 29aug2021
    omididevice:boolean;//running as a Midi Device selector - 05mar2022
    owavedevice:boolean;//running as a Wave Device selector - 05mar2022
    oboldhead:boolean;//default=false - 12mar2022
    //create
    constructor create(xparent:tobject); virtual;
    constructor create2(xparent:tobject;xstart:boolean); virtual;
    destructor destroy; override;
    procedure _ontimer(sender:tobject); override;
    function _onnotify(sender:tobject):boolean; override;
    function getalignheight(xclientwidth:longint):longint; override;
    procedure xsyncmididevice(xforce:boolean); virtual;
    procedure xsyncwavedevice(xforce:boolean); virtual;
    //workers
    property tep:longint read itep write settep;
    function linecount:longint;
    property itemsperline:longint read iitemsperline write setitemsperline;
    procedure xclear;
    procedure xadd(xcap,xnam,xhlp:string);
    procedure xadd2(xcap,xnam,xhlp,xstr:string);
    property caps[xindex:longint]:string read getcaps write setcaps;
    property nams[xindex:longint]:string read getnams write setnams;
    property hlps[xindex:longint]:string read gethlps write sethlps;
    property strs[xindex:longint]:string read getstrs write setstrs;
    procedure setparams(xdef,xval:longint);
    procedure setparams2(xdef,xval,xitemsperline:longint);
    procedure setparams3(xdef,xval,xitemsperline:longint;xloadfromname:string);
    property def:longint read idef;
    property val:longint read ival write setval;
    property max:longint read imax;
    procedure reload;//uses "oloadfromname" to gain value - 07sep2020
    property wasselected:boolean read iwasselected;
    //find
    function findname(xnam:string;var xindex:longint):boolean;
    //makers
    function makemididevice:tbasicsel;
    function makewavedevice:tbasicsel;
    //events
    procedure _onpaint(sender:tobject); override;
    property onreadwriteval:tbasicsel_onreadwriteval read fonreadwriteval write fonreadwriteval;
    property onclick:tnotifyevent read fonclick write fonclick;//07mar2022
   end;

{tbasictea}
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//aaaaaaaaaaaaaaaaaaaaaaaa
   tbasictea=class(tbasiccontrol)
   private
    itimer500:comp;
    iversion,iwidth,iheight,ibytes,ipadv0,ipadv1,ipadh1,iminw,iminh,imaxw,imaxh:longint;
    itransparent,isyscolors,imustpaint:boolean;
    idata:tstr8;
    imanage_toolbar1,imanage_toolbar2:tbasictoolbar;//optional integrated toolbar handlers
    function gettext:string;
    procedure settext(x:string);
    function xtitleborder:longint;
    function xtitleheight:longint;
    function xtitleheight2:longint;
    procedure xsync;
   public
    //options
    odefaultmsg:string;//default=nil="( Not in use )" -> set to override the default message - 12apr2021
    odefault:boolean;//default=true
    osyscolors:boolean;//default=false=converts "(0,0,0)" and "(1,0,0)" to "(1,1,1)" to avoid system black color handling - 13apr2021
    //create
    constructor create(xparent:tobject); virtual;
    constructor create2(xparent:tobject;xstart:boolean); virtual;
    destructor destroy; override;
    procedure _ontimer(sender:tobject); override;
    function _onnotify(sender:tobject):boolean; override;
    function getalignheight(xclientwidth:longint):longint; override;
    procedure xshowmenuFill(sender:tobject;xstyle:string;xmenudata:tstr8;var ximagealign:longint;var xmenuname:string);
    function xshowmenuClick(sender:tbasiccontrol;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean;
    function xcmd(sender:tbasiccontrol;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean;
    //information
    property width:longint read iwidth;
    property height:longint read iheight;
    property bytes:longint read ibytes;
    property version:longint read iversion;
    property transparent:boolean read itransparent;
    property syscolors:boolean read isyscolors;
    //workers
    procedure setparams(xmaxW,xmaxH:longint);
    property maxW:longint read imaxw;
    property maxH:longint read imaxH;
    property text:string read gettext write settext;
    function setdata(xdata:tstr8):boolean;//13apr2021
    function getdata(xdata:tstr8):boolean;
    function settep(xindex:longint):boolean;
    function setimg(ximg:tobject;xtransparent,xsyscolors:boolean):boolean;
    function getimg(ximg:tobject):boolean;
    //manage
    procedure manage(xtoolbar1,xtoolbar2:tbasictoolbar);
    procedure unmanage;
    //events
    procedure _onpaint(sender:tobject); override;
   end;

{tbasiccolors}
   tbasiccolors=class(tbasiccontrol)
   private
    itime200:currency;
    istys   :array[0..299] of longint;
    icaps   :array[0..299] of string;
    inams   :array[0..299] of string;
    iidxs   :array[0..299] of longint;//for system colors
    ihlps   :array[0..299] of string;
    icols   :array[0..299] of longint;
    idefcols:array[0..299] of longint;
    irecs   :array[0..299] of trect;
    icount,imax,idownindex,iitemsperline,ilastalignid,ialignid,ilastpaintid,ipaintid:longint;
    ilastsysname:string;
    imustwrite:boolean;
    foncolor:tlongintevent;
    foncolorchanged:tnotifyevent;
    procedure xnewid(xalign,xpaint:boolean);
    procedure setitemsperline(x:longint);
    function getcap(x:longint):string;
    procedure setcap(x:longint;xval:string);
    function getnam(x:longint):string;
    procedure setnam(x:longint;xval:string);
    function getcol(x:longint):longint;
    procedure setcol(x:longint;xval:longint);
    procedure setcol3(x:longint;xval:longint);
    function getidx(x:longint):longint;
    procedure xsynccount;
    function getcol1(xidx:longint):longint;
    procedure setcol1(xidx:longint;xval:longint);
    procedure xsetcol(x:longint;xval:longint;xspecialoverride:boolean);
    function getcol2(xname:string):longint;
    procedure setcol2(xname:string;xval:longint);
    function xpaintcalc(xmustpaint:boolean):longint;
    function getdata:string;
    procedure setdata(x:string);
    //special color handlers - 25may2021
    procedure xset(xindex,xval:longint);
    procedure xspecial(xname,xstyle:string;xval:longint);
   public
    //options
    osyscolor:boolean;//default=false, true=directly edits "custom" colors in "syssettings"
    oshowcaps:boolean;//default=true
    opopcolor:boolean;//default=true=click/drag to adjust color, false=color is locked (static)
    otightblocks:boolean;//default=false
    oclicktouse:boolean;//default=false
    //create
    constructor create(xparent:tobject); virtual;
    constructor create2(xparent:tobject;xstart:boolean); override;
    destructor destroy; override;
    procedure _ontimer(sender:tobject); override;
    procedure _onpaint(sender:tobject); override;
    function _onnotify(sender:tobject):boolean; override;
    function getalignheight(xclientwidth:longint):longint; override;
    //information
    property count:longint read icount;
    property itemsperline:longint read iitemsperline write setitemsperline;
    property nam[x:longint]:string read getnam;
    property idx[x:longint]:longint read getidx;
    property cap[x:longint]:string read getcap;
    property col[x:longint]:longint read getcol write setcol;
    property col1[xidx:longint]:longint read getcol1 write setcol1;//updates when color changes
    property col2[xname:string]:longint read getcol2 write setcol2;
    property col3[xidx:longint]:longint read getcol1 write setcol3;//updates when color changes AND always updates if it's a special color being set - 25may2021
    function linecount:longint;
    function lineheight:longint;
    function lineheight2:longint;//title
    property data:string read getdata write setdata;
    //workers
    procedure clear;
    procedure addcol(xcap,xnam,xhlp:string);
    procedure addcol1(xcap:string;xidx:longint;xhlp:string);
    procedure addcol2(xcap,xnam,xhlp:string;xidx,xcol,xdefcol:longint);
    procedure addtitle(xcap,xhlp:string);
    procedure xadd(xstyle:longint;xcap,xnam,xhlp:string;xidx,xcol,xdefcol:longint);
    function findname(xname:string;var xindex:longint):boolean;
    function findidx(xidx:longint;var xindex:longint):boolean;
    //system color workers
    procedure xreadfrom(xnormal,xtitle:pvirtualinfo;xmorecolors:pvirtualmorecolors);
    procedure xwriteto(xnormal,xtitle:pvirtualinfo;xmorecolors:pvirtualmorecolors);
    procedure fromsys(xname:string);
    procedure tosys(xname:string;xautosync:boolean);
    //makers
    procedure makesystem;
    procedure makestatic;
    procedure makeadjustable;
    procedure makeadjustable2(xitemsperline:longint);
    //events
    property oncolor:tlongintevent read foncolor write foncolor;//tiggered when using "oclicktouse=true"
    property oncolorchanged:tnotifyevent read foncolorchanged write foncolorchanged;
   end;

{tbasictoolbar}
   tbasictoolbar=class(tbasiccontrol)
   private
    fonclick:tnotifyevent;
    fonclick2:ttoolbarevent2;
    iinforef:string;
    ilastfindbycode2,irowcount,istyle,idownindex,ifocusindex,ihoverindex,iaddcount,itepheight,irowpad,ibuttonpad,ibuttonvpad:longint;
    icountdown1000,itimer500,itimer250,itimer100:currency;
    imustlink,iflash,ilastflash,ipause:boolean;
    iarea     :array[0..79] of trect;
    icanarea  :array[0..79] of boolean;
    iusex     :array[0..79] of longint;
    ialign    :array[0..79] of longint;//0=left, 1=center, 2=right
    iw        :array[0..79] of longint;
    ih        :array[0..79] of longint;
    icap      :array[0..79] of string;
    isize     :array[0..79] of longint;//0=automatic (default), 1..N=static pixels, -1..-N=percentage
    ipert     :array[0..79] of double;//0..100 -> optional progress bar support - 07jul2021
    itep      :array[0..79] of longint;
    icode     :array[0..79] of longint;
    icode2    :array[0..79] of string;//inline with "tbasicmenu"
    ibuthelp  :array[0..79] of string;
    iref      :array[0..79] of string;
    ienableds :array[0..79] of boolean;
    ivisibles :array[0..79] of boolean;
    imarked   :array[0..79] of boolean;
    ihighlight:array[0..79] of boolean;//30may2021
    ican      :array[0..79] of boolean;//30may2021
    iflasher  :array[0..79] of boolean;//24feb2021
    iimgright :array[0..79] of boolean;//align image on right of caption
    ibutpad   :array[0..79] of boolean;//use with "bhighlight" for a button like highlight -> similar to "oasbuttons=true" but link by link instead of all - 05jun2021
    icountdown:array[0..79] of longint;//in seconds -> "minint..0" = off, 1..maxint = seconds remaining - 05sep2020
    procedure setstyle(x:longint);
    function xok(x:longint):boolean;
    procedure xsetcap(x:longint;y:string);
    function xgetcap(x:longint):string;
    procedure xsettep(x:longint;y:longint);
    function xgettep(x:longint):longint;
    procedure xsetsize(x:longint;y:longint);
    function xgetsize(x:longint):longint;
    procedure setpert(x:longint;y:double);
    function getpert(x:longint):double;
    procedure xsetalign(x:longint;y:longint);
    function xgetalign(x:longint):longint;
    procedure xsetcountdown(x,y:longint);//05sep2020
    function xgetcountdown(x:longint):longint;
    procedure xsetcode(x,y:longint);
    function xgetcode(x:longint):longint;
    procedure xsetcode2(x:longint;y:string);
    function xgetcode2(x:longint):string;
    procedure xsethelp(x:longint;y:string);
    function xgethelp(x:longint):string;
    procedure xsetvisibles(x:longint;y:boolean);
    function xgetvisibles(x:longint):boolean;
    procedure xsetenableds(x:longint;y:boolean);
    function xgetenableds(x:longint):boolean;
    procedure xsetmarked(x:longint;y:boolean);
    function xgetmarked(x:longint):boolean;
    procedure xsethighlight2(x:string;y:boolean);
    function xgethighlight2(x:string):boolean;
    procedure xsetcan2(x:string;y:boolean);
    function xgetcan2(x:string):boolean;
    procedure xsetcap2(x:string;y:string);
    function xgetcap2(x:string):string;
    procedure xsettep2(x:string;y:longint);
    function xgettep2(x:string):longint;
    procedure xsetflash(x:longint;y:boolean);
    function xgetflash(x:longint):boolean;
    procedure xsethighlight(x:longint;y:boolean);//15mar2022
    function xgethighlight(x:longint):boolean;
    procedure xsetimgright(x:longint;y:boolean);
    function xgetimgright(x:longint):boolean;
    procedure xsetbutpad(x:longint;y:boolean);
    function xgetbutpad(x:longint):boolean;
    procedure xsetbutpad2(x:string;y:boolean);
    function xgetbutpad2(x:string):boolean;
    procedure xsetvisible2(x:string;y:boolean);
    function xgetvisible2(x:string):boolean;
    procedure xsetflash2(x:string;y:boolean);
    function xgetflash2(x:string):boolean;
    procedure xsetmarked2(x:string;y:boolean);
    function xgetmarked2(x:string):boolean;
    procedure xsetenabled2(x:string;y:boolean);
    function xgetenabled2(x:string):boolean;
    procedure xsetsize2(x:string;y:longint);
    function xgetsize2(x:string):longint;
    procedure xsetpert2(x:string;y:double);
    function xgetpert2(x:string):double;
    procedure xsetalign2(x:string;y:longint);
    function xgetalign2(x:string):longint;
    procedure xsetimgright2(x:string;y:boolean);
    function xgetimgright2(x:string):boolean;
    function xcapok(xindex:longint):boolean;
    function xtepok(xindex:longint):boolean;
    function xcapok2(xindex:longint):boolean;//supports visible=false
    function xtepok2(xindex:longint):boolean;//supports visible=false
    function xrowheight:longint;
    function xrowcount:longint;
    procedure xpaintcalc(sender:tobject;xclientwidth:longint;xmustpaint:boolean);//08mar2021, 21feb2021, 23apr2020
    function getparentpage:string;
    procedure setparentpage(x:string);
    procedure xclickbutton(xindex:longint);
    function xtitleheight:longint;
    function xflashcount:longint;
   public
    //options
    oclickthru:boolean;//default=false, true=transmit internally handled clicks to external host for analysis - 19jun2022
    owrap:boolean;//default=true
    oasbuttons:boolean;//default=false, true=draw as buttons
    orighttoleft:boolean;//default=false
    ocountdown:boolean;//default=true=allow countdowns
    ocountdown_dlgcheck:boolean;//default=true=countdown only if top dlg - 05sep2020
    omarkcleanly:boolean;//default=true=do not fill with background color and instead underline, false=fill link/button with background color when down - 24feb2021
    ovpad:longint;//default=2, set in range 0..N
    //.oequalwidths support
    oequalwidths:boolean;//default=false=each button assumes it's own width, true=each button has the same width as the longest/widest button - 02jun2021
    //.title support
    otitle:boolean;//default=false, true=toolbar with caption
    olarge:boolean;//default=false=small title caption, true=large title caption
    //.return values
    oindex:longint;
    ominrows:longint;//default=0
    //create
    constructor create2(xparent:tobject;xstart:boolean); override;
    destructor destroy; override;
    procedure _ontimer(sender:tobject); override;
    procedure _onpaint(sender:tobject); override;
    function  _onnotify(sender:tobject):boolean; override;
    function getalignheight(xclientwidth:longint):longint; override;
    //information
    property style:longint read istyle write setstyle;//0=tep+cap, 1=tep, 2=cap
    property pause:boolean read ipause write ipause;
    property bcap[xindex:longint]        :string    read xgetcap       write xsetcap;//Note: '-' = vertical sep (visible line), '+' = new line (invisible)
    property balign[xindex:longint]      :longint   read xgetalign     write xsetalign;
    property bsize[xindex:longint]       :longint   read xgetsize      write xsetsize;
    property btep[xindex:longint]        :longint   read xgettep       write xsettep;
    property bcode[xindex:longint]       :longint   read xgetcode      write xsetcode;
    property bcode2[xindex:longint]      :string    read xgetcode2     write xsetcode2;
    property bcountdown[xindex:longint]  :longint   read xgetcountdown write xsetcountdown;
    property bhelp[xindex:longint]       :string    read xgethelp      write xsethelp;
    property benabled[xindex:longint]    :boolean   read xgetenableds  write xsetenableds;
    property bvisible[xindex:longint]    :boolean   read xgetvisibles  write xsetvisibles;
    property bmarked[xindex:longint]     :boolean   read xgetmarked    write xsetmarked;
    property bhighlight[xindex:longint]  :boolean   read xgethighlight write xsethighlight;//15mar2022
    property bflash[xindex:longint]      :boolean   read xgetflash     write xsetflash;
    property bimgright[xindex:longint]   :boolean   read xgetimgright  write xsetimgright;
    property bbutpad[xindex:longint]     :boolean   read xgetbutpad    write xsetbutpad;
    property balign2[xcode2:string]      :longint   read xgetalign2    write xsetalign2;
    property bsize2[xcode2:string]       :longint   read xgetsize2     write xsetsize2;
    property bpert2[xcode2:string]       :double    read xgetpert2     write xsetpert2;
    property benabled2[xcode2:string]    :boolean   read xgetenabled2  write xsetenabled2;
    property bbutpad2[xcode2:string]     :boolean   read xgetbutpad2   write xsetbutpad2;
    property bvisible2[xcode2:string]    :boolean   read xgetvisible2  write xsetvisible2;
    property bmarked2[xcode2:string]     :boolean   read xgetmarked2   write xsetmarked2;
    property bhighlight2[xcode2:string]  :boolean   read xgethighlight2 write xsethighlight2;
    property bcan2[xcode2:string]        :boolean   read xgetcan2      write xsetcan2;
    property bflash2[xcode2:string]      :boolean   read xgetflash2    write xsetflash2;
    property bcap2[xindex:string]        :string    read xgetcap2      write xsetcap2;
    property btep2[xindex:string]        :longint   read xgettep2      write xsettep2;//19dec2021
    property bimgright2[xindex:string]   :boolean   read xgetimgright2 write xsetimgright2;//29jun2022
    property parentpage:string read getparentpage write setparentpage;
    //makers
    function maketitle(xcap:string):tbasictoolbar;
    function maketitle2(xcap:string;xlarge:boolean):tbasictoolbar;
    function maketitle3(xcap:string;xlarge,xright:boolean):tbasictoolbar;
    //add
    procedure clear;//22sep2020
    function add(xcap:string;xtep,xcode:longint;xcode2,xhelp:string):longint;
    function add2(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;ximgright:boolean):longint;
    function add3(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;xenabled,xvisible,ximgright:boolean):longint;
    function sadd(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;xsize,xalign:longint):longint;
    function hcsadd(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;xsize:longint):longint;//highlighter with button padding - 05jun2021
    function csadd(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;xsize:longint):longint;
    function rsadd(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;xsize:longint):longint;
    function lsadd(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;xsize:longint):longint;
    function cadd(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;xcountdown:longint):longint;
    function cadd2(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;ximgright:boolean;xcountdown:longint):longint;
    function cadd3(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;xenabled,xvisible,ximgright:boolean;xcountdown:longint):longint;
    function cadd4(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;xenabled,xvisible,ximgright,xbutpad:boolean;xcountdown,xsize,xalign:longint):longint;
    function addsep:longint;
    function addsep2(xcode2:string):longint;
    function addhline:longint;//draw horizontal line under current line - 26sep2022
    function newline:longint;//05jun2021
    //.optional system links - 14aug2020
    procedure xaddoptions;
    procedure xaddoptions2(xcmd:string);//07mar2022
    procedure xaddhelp;
    procedure xaddabout;
    procedure xaddsplash;
    procedure xaddmixer;//07mar2022
    procedure xaddmax;//15mar2022
    procedure xaddonTop;//15mar2022
    //find
    function xfind(sx,sy:longint):longint;
    function xfindbycode(xcode:longint):longint;
    function xfindbycodeb(xcode:longint;var xindex:longint):boolean;
    function xfindbycode2(xcode2:string):longint;
    function xfindbycode2b(xcode2:string;var xindex:longint):boolean;
    function xfindbycodes(xcode:longint;xcode2:string):longint;
    //special
    procedure marktab(xname:string;xmark:boolean);//11sep2021
    //reference
    function visref:string;//05jun2021
    //events
    property onclick:tnotifyevent read fonclick write fonclick;
    property onclick2:ttoolbarevent2 read fonclick2 write fonclick2;
   end;

{tbasicmenu}
//xxxxxxxxxxxxxxxxxxxxxxxxx//mmmmmmmmmmmmmmmmmmmmmmmmmmm
   tbasicmenu=class(tbasiccontrol)
   private
    iinforef:string;
    imanysel1,imanysel2:longint;//28sep2022
    icountx,ireloadid,itep,iselstart,iselcount,idownpos,ilastitemindex,idownindex,ipos,ipad,imaxindentwidth,imaxttitepwidth,imaxtepwidth,imaxtepheight,imaxcapwidth,imaxtitcapwidth,imaxcutwidth,irowpad,irowheight,icount,ihoverindex:longint;
    ilastflash,iwasflashing,iflashing,icandrag:boolean;
    idata:tstr8;//menu items as a realtime readable data block
    iv:tbasicscrollbar;
    fonclick,fondbclick:tnotifyevent;
    fongetitem:tbasicmenu_getitem;
    //.list of items painted on screen with their itemindex+vertical areas -> format: [itemindex/4]+[y.start/4]+[y.finish/4] => list of items and their click areas -> a mouse click in one of these areas equates to a menu item being actioned - 28mar2020
    ilist:tstr8;//Note: list never shrinks for maximum stability
    ilistcount:longint;//number of active items
    procedure setdata(x:tstr8);//08jun2021
    procedure setpos(x:longint);
    procedure sethoverindex(x:longint);
    function xrowheight:longint;
    function xrowcount:longint;
    procedure _onpos(sender:tobject);
    procedure setselstart(x:longint);
    procedure setselcount(x:longint);
    procedure setcountx(x:longint);
    procedure setdownindex(x:longint);
    function getitemindex:longint;
    procedure setitemindex(x:longint);
   public
    //options
    ofast:boolean;//default=false=maxwidths are calculated, true=maxwidths are omitted and "_onpaint()" proc must work on the fly for maximum speed - use for large lists etc - 29mar2020
    orows:boolean;//default=false, true=alternate the coloring of continous items, restarts after each title item - 07apr2020
    ostyle:byte;//0(lsmenu)=menu, l(lslist)=single item highlight list, 2(lsmany)=multi-select list
    okeepopen:boolean;//default=false, true=menu stays open after a mouse click - 07apr2020
    orowcount:longint;//default=0=off, 1..N=make # rows in height - 14aug2020
    oautoclose:boolean;//default=true
    olisthover:boolean;//default=false (normal list mode), true=highlight hover row of list with select color - 06oct2020
    ohoverunderline:boolean;//default=true=underline hover item, false=do not underline a hover item
    onumberfrom:longint;//default=-1=off - 20mar2022
    onumberfrom2:longint;//default=-1=off - 20mar2022
    onumberfrom3:longint;//default=-1=off - 20mar2022
    //.list based options - 07sep2020
    oloadfromname:string;
    oautoreload:boolean;
    oretainpos:boolean;//default=false, true=retain vertical position during "setdata()" - 04oct2020
    //create
    constructor create2(xparent:tobject;xstart:boolean); override;
    destructor destroy; override;
    function getalignheight(xclientwidth:longint):longint; override;
    function getalignwidth(xclientheight:longint):longint; override;
    function xsetclientarea(a:trect):boolean; override;
    function xgetitem(xindex:longint;var xtab,xtep,xtepcolor:longint;var xcaption,xcaplabel,xhelp,xcode2:string;var xcode,xshortcut,xindent:longint;var xflash,xenabled,xtitle,xsep:boolean):boolean;//20mar2022
    function xgetval(xindex:longint;var xvalue:string):boolean;
    function xgetval2(xindex:longint):string;//03mar2022
    //information
    property pos:longint read ipos write setpos;//scroll position
    property hoverindex:longint read ihoverindex write sethoverindex;
    property downindex:longint read idownindex write setdownindex;//22mar2021, 24feb2021
    property countx:longint read icountx write setcountx;//-1=off (init only), 0..N=realtime dynamic list mode -> values sourced externally - 28spe2020
    property count:longint read icount;//number of menu items
    function vpos1:longint;//first visible item
    function vpos2:longint;//last visible item
    function vcount:longint;//visible count
    function scount:longint;//scroll count
    property data:tstr8 read idata write setdata;
    property tep:longint read itep write itep;//fallback tep used when no tep specified
    //.special list support
    property selstart:longint read iselstart write setselstart;
    property selcount:longint read iselcount write setselcount;
    function setsel(xselstart,xselcount:longint):boolean;
    function xsetsel(xselstart,xselcount:longint):boolean;
    property itemindex:longint read getitemindex write setitemindex;
    property rowheight:longint read xrowheight;//11oct2022
    //selectrange
    function canselectrange:boolean;//28sep2022
    procedure selectrange;
    procedure selectoff;
    //.support
    procedure xselectrange(x1,x2:longint);
    //find
    function xfindb(sx,sy:longint):longint;
    function xfind(sx,sy:longint;var xindex:longint):boolean;//07apr2020
    function xfindbycode2(xfindval:string;var xindex:longint):boolean;
    function xfindbycaption(xfindval:string;var xindex:longint):boolean;//28sep2020
    function xfindbycaption2(xfindval:string):longint;
    function xfindnext(xfindpart:string;var xindex:longint):boolean;//06oct2020
    function xok(x:longint):boolean;
    //makers
    procedure makemenu;
    procedure makelist;
    procedure makelistx(xcount:longint);//22sep2020
    procedure makemany;
    procedure makepoplist;
    procedure makepopmany;
    //reload
    procedure reload;
    //events
    property onclick:tnotifyevent read fonclick write fonclick;
    property ondbclick:tnotifyevent read fondbclick write fondbclick;
    property ongetitem:tbasicmenu_getitem read fongetitem write fongetitem;
    procedure _ontimer(sender:tobject); override;
    procedure _onpaint(sender:tobject); override;
    procedure _onalign(sender:tobject); override;
    function  _onnotify(sender:tobject):boolean; override;
    function  _onshortcut(sender:tobject):boolean; override;
   end;

{tbasicscrollbar}
   tbasicscrollbar=class(tbasiccontrol)
   private
    iposref64,idowntime64,itimer100,itimerscroll:currency;
    iinforef:string;
    idownbutindex,idownpos,ipos,imin,imax:longint;
    iscrollscope:extended;
    ilessbut,imorebut,idragzone,idragbut:trect;
    idragbutdown:boolean;
    fonpos:tnotifyevent;
    fonarrow:tlongintgetevent;//21jun2022
    procedure setpos(x:longint);
    function xmoveval(x:longint):longint;
   public
    //options
    overtical:boolean;//default=true=vertical, false=horizontal
    owheelchange:longint;//default=1
    osmallchange:longint;//default=1
    olargechange:longint;//default=10
    oassistedscroll:longint;//default=10 - 04oct2022
    ofullhandling:boolean;//default=true=all functions handled internally, false=some keyboard and wheel functions are passed down to parent control - 04apr2020
    //create
    constructor create2(xparent:tobject;xstart:boolean); override;
    destructor destroy; override;
    function getalignheight(xclientwidth:longint):longint; override;
    function getalignwidth(xclientheight:longint):longint; override;
    function minimal:boolean; override;
    //pos
    property pos:longint read ipos write setpos;
    property min:longint read imin;
    property max:longint read imax;
    procedure setparams(xpos,xmin,xmax:longint);
    procedure setparams2(xpos,xmin,xmax:longint;xevent:boolean);
    //events
    property onpos:tnotifyevent read fonpos write fonpos;
    procedure _ontimer(sender:tobject); override;
    procedure _onpaint(sender:tobject); override;
    function  _onnotify(sender:tobject):boolean; override;
    property onarrow:tlongintgetevent read fonarrow write fonarrow;
    //makers
    procedure makeMinimal;
   end;

{tbasicscroll}
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxx//rrrrrrrrrrrrrrrrrrrrrr
   tbasicscroll=class(tbasiccontrol)
   private
    itimer100,itimer250:currency;
    irightgap,irightminwidth,irightmaxwidth,idownpos:longint;
    ipage,iposref,iinforef:string;
    iv:tbasicscrollbar;
    irightmax,istatic,iscroll:boolean;
    //.built-in root controlls
    ihead:tbasichead;
    imainhelp:tmainhelp;//24jul2021
    itoolbar,itoolbar2:tbasictoolbar;
    ihigh,ihigh2:tbasicscroll;//automatic-height panels - 21feb2021
    istatus,istatus2:tbasicstatus;
    icols:tbasiccols;
    ihelp:tbasichelp;
    imenu:tbasicmenu;
    iright:tbasicscroll;//optional - 24jul2021
    function getpos:longint;
    procedure setpos(x:longint);
    procedure setscroll(x:boolean);
    procedure setstatic(x:boolean);
    procedure setpage(x:string);
    procedure xcalcalign(xalignok:boolean;xclientwidth:longint;var xoutclientheight,xoutheight:longint);
    procedure setrightmax(x:boolean);
    procedure setrightgap(x:longint);
    procedure setrightminwidth(x:longint);
    procedure setrightmaxwidth(x:longint);
    function getrightvisible:boolean;
    procedure setrightvisible(x:boolean);
   public
    //options
    osmallchange:longint;//default=10%
    olargechange:longint;//default=50%
    ofirstpos:longint;//default=minint=off
    otopspace:longint;//default=0px
    //create
    constructor create(xparent:tobject); override;
    constructor create2(xparent:tobject;xscroll,xstart:boolean); virtual;
    destructor destroy; override;
    procedure destroychildren; override;
    function headheight:longint; override;//25jan2021
    function clientinner2(x:tbasiccontrol):trect; override;
    function getalignheight(xclientwidth:longint):longint; override;
    function findbordersize:longint; override;
    //information
    property pos:longint read getpos write setpos;
    property scroll:boolean read iscroll write setscroll;
    property static:boolean read istatic write setstatic;
    property page:string read ipage write setpage;
    function xbuiltinOK(x:tobject):boolean;
    //auto-create controls
    function xright:tbasicscroll;//right side - 24jul2021
    function xmainhelp:tmainhelp;//24jul2021
    function xhead:tbasichead;//top
    function xhelp:tbasichelp;//top
    function xtoolbar:tbasictoolbar;//top
    function xstatus:tbasicstatus;//top
    function xhigh:tbasicscroll;//top - 21feb2021
    function xtoolbar2:tbasictoolbar;//bottom
    function xhigh2:tbasicscroll;//bottom - 21feb2021
    function xstatus2:tbasicstatus;//bottom
    function xcols:tbasiccols;//standard -> base takes up entire remaining clientarea
    function xcolsh:tbasiccols;//autoheight -> base takes up enough clientheight to display static children, scroll children adapt to height - 26feb2021
    function xpage(xpagename:string;xstatic:boolean):tbasicscroll;
    function xpage2(xpagename,xtoplink,xbotlink,xhelp:string;xtep:longint;xstatic:boolean):tbasicscroll;
    function xpage3(xpagename,xtoplink,xbotlink,xhelp:string;xtep,xtopspace:longint;xstatic:boolean):tbasicscroll;
    function xmenu:tbasicmenu;//bottom
    //detect controls
    function xhaveright:boolean;
    function xhavemainhelp:boolean;
    function xhavehead:boolean;
    function xhavehelp:boolean;
    function xhavemenu:boolean;
    function xhavetoolbar:boolean;
    function xhavehigh:boolean;
    function xhavehigh2:boolean;
    function xhavecols:boolean;
    function xhavestatus2:boolean;
    function xhavetoolbar2:boolean;
    function xhavestatus:boolean;
    //.right support
    property rightvisible:boolean read getrightvisible write setrightvisible;
    property rightmax:boolean read irightmax write setrightmax;
    property rightgap:longint read irightgap write setrightgap;
    property rightminwidth:longint read irightminwidth write setrightminwidth;
    property rightmaxwidth:longint read irightmaxwidth write setrightmaxwidth;
    procedure setrightparams(xminwidth,xmaxwidth,xgap:longint;xrightmax,xvisible:boolean);
    //makers
    function makedlg(da:trect;xshowhead:boolean):tbasicscroll;//27feb2021
    function makedlg2(da:trect;xshowhead,xstatic,xcancel,xok:boolean):tbasicscroll;
    function makedlg3(da:trect;xtep:longint;xtitle:string;xshowhead,xstatic:boolean;xcanceltime,xoktime:longint):tbasicscroll;
    function makeautohigh:boolean;
    //events
    procedure _ontimer(sender:tobject); override;
    procedure _onalign(sender:tobject); override;
    function  _onnotify(sender:tobject):boolean; override;
    //support
    function xsmall:longint;
    function xlarge:longint;
   end;

{tbasicsetcolor}
   tbasicsetcolor=class(tbasicscroll)
   private
    ir,ig,ib:tbasicint;
    im:tbasiccolormatrix;
    ic:tbasiccolor;
    icolor,iundocolor,irevertcolor:longint;
    icanfillundo,ilocksync:boolean;
    foncolor:tlongintevent;
    procedure setcolor(x:longint);
    procedure __onclick(sender:tobject);
    procedure __oncolor(sender:tobject;xval:longint);
    function ext__onnotify(sender:tobject):boolean;
   public
    //create
    constructor create2(xparent:tobject;xscroll,xstart:boolean); override;
    destructor destroy; override;
    //information
    property color:longint read icolor write setcolor;
    property revertcolor:longint read irevertcolor write irevertcolor;
    //workers
    procedure setparams(xcolor,xrevertcolor:longint;xpage:string);
    procedure getparams(var xcolor,xrevertcolor:longint;var xpage:string);
    //events
    property oncolor:tlongintevent read foncolor write foncolor;
   end;

{tbasiccols}
   tbasiccols=class(tbasiccontrol)
   private
    icols:array[0..9] of tbasicscroll;
    isize:array[0..9] of longint;
    iwratio:array[0..9] of boolean;//default=true=adapts "fixed" sizes using vifontwidthratio
    ihsp,ivsp,istyle:longint;
    iinforef:string;
    itimer250:comp;
    function getcols(x:longint):tbasicscroll;
    function getcols2(x,xsize:longint;xscroll:boolean):tbasicscroll;
    procedure setstyle(x:longint);
    procedure setsize(x,xval:longint);
    function getsize(x:longint):longint;
    procedure setwratio(x:longint;xval:boolean);
    function getwratio(x:longint):boolean;
    procedure sethsp(x:longint);
    procedure setvsp(x:longint);
    function xfindsize(x,cw:longint):longint;
    procedure setvis(x:longint;xval:boolean);
    function getvis(x:longint):boolean;
   public
    //options
    ofullarea:boolean;//default=true=last column uses entire remaining space regardless of it's specified size - 07oct2020
    omakeautoheight:boolean;//default=false, true=make self and all "static" children "autoheight" where posssible - 26feb2021
    ofillheight:boolean;//default=false, true=force columns to use remaining vertical height - 07mar2022 -> option was introduced because it was FAR TO DIFFICULT to work out which options were required in what order to get the same affect
    //create
    constructor create(xparent:tobject); override;
    constructor create2(xparent:tobject;xstart:boolean); virtual;
    destructor destroy; override;
    function getalignheight(xclientwidth:longint):longint; override;
    function canautoheight:boolean; override;
    //information
    property style:longint                read istyle write setstyle;
    property cols[x:longint]:tbasicscroll read getcols;//auto-creates "static" columns as required -> range 0..9
    property cols2[x,xsize:longint;xscroll:boolean]:tbasicscroll read getcols2;//auto-creates as required -> range 0..9
    property vis[x:longint]:boolean       read getvis write setvis;
    property size[x:longint]:longint      read getsize write setsize;
    property wratio[x:longint]:boolean    read getwratio write setwratio;
    property vsp:longint read ivsp write setvsp;
    property hsp:longint read ihsp write sethsp;
    //makers
    procedure makeautoheight;//sets self and all STATIC children to oautoheight=true - 26feb2021
    //events
    procedure _ontimer(sender:tobject); override;
    procedure _onalign(sender:tobject); override;
   end;

{tbasiccells}
   tbasiccellsimageevent=function(sender:tobject;xindex,xfocus,xcount:longint;var ximage:tbasicimage;var xtranscol:longint;var xcaption:string):boolean of object;
   tbasiccellsmoveevent=function(sender:tobject;sindex,dindex,xfocus,xcount:longint):boolean of object;
   tbasiccells=class(tbasiccontrol)
   private
    fonimage:tbasiccellsimageevent;
    fonmove:tbasiccellsmoveevent;
    ilastscrollpos,ilastfocus,iprevscrollpos,iprevfocus:longint;
    idropindex,istarty,istartx,istopx,ilastzoom,iseppad,itoppad,ibotpad,ithumbw,ithumbh,ifocus,icount,ipaintid,ilastpaintid:longint;
    idragarea:trect;
    idownxy:tpoint;
    iscroll:tbasicscrollbar;
    idragref,iref,iref2:string;
    itimer100:currency;
    procedure xincpaint;
    procedure _onalign(sender:tobject); override;
    procedure _onpos(sender:tobject);
    function getscrollpos:longint;
    procedure setscrollpos(x:longint);
    procedure xsetfocus(x:longint);
    procedure setcount(x:longint);
   public
    //create
    constructor create(xparent:tobject); virtual;
    constructor create2(xparent:tobject;xstart:boolean); virtual;
    destructor destroy; override;
    procedure _ontimer(sender:tobject); override;
    function getalignheight(xclientwidth:longint):longint; override;
    procedure _onpaint(sender:tobject); override;
    function _onnotify(sender:tobject):boolean; override;
    //information
    property focus:longint read ifocus write xsetfocus;
    property count:longint read icount write setcount;
    property scrollpos:longint read getscrollpos write setscrollpos;
    function scrollmax:longint;
    property thumbw:longint read ithumbw;
    property thumbh:longint read ithumbh;
    procedure setthumbsize(w,h:longint);
    //keyboard support
    procedure xprev;
    procedure xnext;
    function xcanmove:boolean;
    function xmove(s,d:longint):boolean;
    //finders
    function findcell(mx:longint;var xindex:longint;xpastend:boolean):boolean;
    function findcell2(mx:longint;var xindex:longint;var xarea,xinnerarea:trect;xpastend:boolean):boolean;//09feb2022
    //workers
    function setparams(xscroll,xfocus,xcount:longint):boolean;
    function setparams2(xscroll,xfocus,xcount,xthumbW,xthumbH:longint):boolean;
    procedure xprevlocation;
    //external
    property onimage:tbasiccellsimageevent read fonimage write fonimage;
    property onmove:tbasiccellsmoveevent   read fonmove  write fonmove;
    //support

   end;

{tbasicsplash}
   tbasicsplash=class(tbasicscroll)
   private
    ilastframecol2,ilastframeid,ishowstyle,iscrollpos:longint;
    iimage:tbasicimage;
    iscreen:tbasiccontrol;
    ipreviousfocus:longint;
    idelaytimer,itimeout:comp;
    ilink:trect;
    iiconartref,iscrolltext:string;
    function onnotify__screen(sender:tobject):boolean;
    procedure onpaint__screen(sender:tobject);
    function iconart_width:longint;
    function iconart_height:longint;
   public
    //options
    ostyle:longint;//0=static, 1=scrolling, 2=icon art - 27apr2022
    constructor create(xparent:tobject); override;
    constructor create2(xparent:tobject;xstart:boolean); virtual;
    destructor destroy; override;
    procedure _ontimer(sender:tobject); override;
    function winLdrCOLOR:longint; override;
    //workers
    procedure xsplash;
    procedure xabout;
    function xmustclose:boolean;
   end;

{tbasictick}
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//kkkkkkkkkkkkkkkkkk
   tbasictick=class(tbasiccontrol)
   private
    itimer250:currency;
    iref,icaption:string;
    ivalue:boolean;
    procedure setvalue(x:boolean);
    procedure xcheckref;
   public
    //create
    constructor create(xparent:tobject;xcaption:string); virtual;
    constructor create2(xparent:tobject;xstart:boolean;xcaption:string); virtual;
    destructor destroy; override;
    function getalignwidth(xclientheight:longint):longint; override;
    function getalignheight(xclientwidth:longint):longint; override;
    function xpaintcalc(xmustpaint:boolean):longint;
    //information
    property caption;
    property value:boolean read ivalue write setvalue;
    //events
    procedure _ontimer(sender:tobject); override;
    procedure _onpaint(sender:tobject); override;
    function  _onnotify(sender:tobject):boolean; override;
   end;

{tbasicedit}
   tbasicedit=class(tbasiccontrol)
   private
    iidleref,itimerslow,itimer250:currency;
    iundodata,ibuthelp,ibuthelp2,ivalue,iref,icaption,ititle:string;
    iundoref,itep,itep2,itep2b,iimgw,iimgh,iimgw2,iimgh2:longint;
    ibutarea1,ibutarea2:trect;
    iprogress:single;
    iundodataOK,idropstatic,ireveal,iflash:boolean;
    fonshowpass,fonchange,fonclick2,fonclick1:tnotifyevent;
    procedure settep(x:longint);
    procedure settep2(x:longint);
    procedure settep2b(x:longint);
    procedure setvalue(x:string);
    procedure setprogress(x:single);
    procedure xcheckref;
    function xshowcursor:boolean;
    procedure xnotidle;
    procedure settitle(x:string);
    function xundoautofill(xref:longint):boolean;//pass-thru proc
    procedure xundofill;
   public
    //options
    olimit:longint;//0=no limit, 1..maxint=limit content to this length
    oreadonly:boolean;
    opassword:boolean;//default=false, true=PASSWORD mode and thus option to hide chars and display a mask char "#"
    oborder2:boolean;//default=false, true=draw border around tep2
    omoreoptions:boolean;//default=true=full right click menu of options, false=brief right click menu - 31mar2021
    //create
    constructor create(xparent:tobject;xcaption:string); virtual;
    constructor create2(xparent:tobject;xstart:boolean;xcaption:string); virtual;
    destructor destroy; override;
    function getalignheight(xclientwidth:longint):longint; override;
    procedure showmenuFill(xstyle:string;xmenudata:tstr8;var ximagealign:longint;var xmenuname:string); override;
    function showmenuClick(sender:tobject;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean; override;
    function xtitleheight:longint;
    //information
    property caption;
    property title:string read ititle write settitle;
    property value:string read ivalue write setvalue;
    property progress:single read iprogress write setprogress;
    property tep:longint read itep write settep;//left
    property tep2:longint read itep2 write settep2;//right
    property tep2b:longint read itep2b write settep2b;//right
    property buthelp:string read ibuthelp write ibuthelp;
    property buthelp2:string read ibuthelp2 write ibuthelp2;
    property reveal:boolean read ireveal write ireveal;//for password mode only - 13apr2020
    property showpass:boolean read ireveal write ireveal;//18jun2022
    //.undo - 19jun2022
    function canundo:boolean;
    function undo:boolean;
    function undoclear:boolean;
    //.password support
    function canclearpassword:boolean;
    function clearpassword:boolean;
    function canpastepassword:boolean;
    function pastepassword:boolean;
    //makers
    procedure makeedit;
    procedure makepass;
    procedure makedrop;
    procedure makedropstatic;
    procedure makeprogress;
    //events
    procedure _ontimer(sender:tobject); override;
    procedure _onpaint(sender:tobject); override;
    function  _onshortcut(sender:tobject):boolean; override;//01mar2022
    function  _onnotify(sender:tobject):boolean; override;
    property  onclick2:tnotifyevent read fonclick2 write fonclick2;//tep #2 - right
    property  onclick1:tnotifyevent read fonclick1 write fonclick1;//tep #1 - left
    property onchange:tnotifyevent read fonchange write fonchange;
    property onshowpass:tnotifyevent read fonshowpass write fonshowpass;
    //support
    procedure xchanged;
    procedure xshowpass;
   end;

//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//jjjjjjjjjjjjjjjjjjjjjjjjjj
{tbasicjump}
   tbasicjump=class(tbasiccontrol)
   private
    inewref,itimer250,ihoveref:comp;
    ilastmousex,ilasthoverpos,ihoverpos,ipos,ilen:longint;
    ihoverpert,ipert:double;//06mar2022
    ipaintref:string;
    fonclick:tnotifyevent;
    procedure xsyncpos;//20feb2022
   public
    //create
    constructor create(xparent:tobject;xcaption:string); virtual;
    constructor create2(xparent:tobject;xstart:boolean;xcaption:string); virtual;
    destructor destroy; override;
    function getalignheight(xclientwidth:longint):longint; override;
    //information
    procedure setparams(xpos,xlen:longint);//in milliseconds
    property hoverpos:longint read ihoverpos;
    property hoverpert:double read ihoverpert;//0..100
    property pert:double read ipert;//0..100
    property pos:longint read ipos;
    property len:longint read ilen;
    //events
    procedure _ontimer(sender:tobject); override;
    procedure _onpaint(sender:tobject); override;
    function  _onnotify(sender:tobject):boolean; override;
    property  onclick:tnotifyevent read fonclick write fonclick;
   end;

{tmainhelp}
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//hhhhhhhhhhhhhhhhhhhhhhhhhh
   tmainhelp=class(tbasicscroll)
   private
    ifasttimer:comp;
    ibwp:tbasicbwp;
    itopics:tdynamicstring;//list of help topics
    ibuildingcontrol:boolean;
    procedure __onclick(sender:tobject);
    procedure xhelptopics;
    procedure _ontimer(sender:tobject); override;
    procedure showmenuFill(xstyle:string;xmenudata:tstr8;var ximagealign:longint;var xmenuname:string); override;
    function showmenuClick(sender:tobject;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean; override;
   public
    //create
    constructor create2(xparent:tobject;xscroll,xstart:boolean); override;
    destructor destroy; override;
    //info
    procedure xsetroundstyle(x:longint);
   end;

//multimedia support -----------------------------------------------------------
    tmmodes=(mmNotReady,mmStopped,mmPlaying,mmRecording,mmSeeking,mmPaused,mmOpen);
{$ifdef mm}
{taudiobasic}
   //.midi system support
   MMVERSION = UINT;             { major (high byte), minor (low byte) }
   PHMIDI = ^HMIDI;
   HMIDI = longint;
   PHMIDIIN = ^HMIDIIN;
   HMIDIIN = longint;
   PHMIDIOUT = ^HMIDIOUT;
   HMIDIOUT = longint;
   PHMIDISTRM = ^HMIDISTRM;
   HMIDISTRM = longint;
   PHWAVE = ^HWAVE;
   HWAVE = longint;
   PHWAVEIN = ^HWAVEIN;
   HWAVEIN = longint;
   PHWAVEOUT = ^HWAVEOUT;
   HWAVEOUT = longint;

   PWaveOutCaps=^PWaveOutCaps;
   TWaveOutCaps = record
    wMid: Word;                 { manufacturer ID }
    wPid: Word;                 { product ID }
    vDriverVersion: MMVERSION;       { version of the driver }
    szPname: array[0..MAXPNAMELEN-1] of AnsiChar;  { product name (NULL terminated string) }
    dwFormats: DWORD;          { formats supported }
    wChannels: Word;            { number of sources supported }
    dwSupport: DWORD;          { functionality supported by driver }
    end;

   PMidiOutCaps=^TMidiOutCaps;
   TMidiOutCaps = record
    wMid: Word;                  { manufacturer ID }
    wPid: Word;                  { product ID }
    vDriverVersion: MMVERSION;        { version of the driver }
    szPname: array[0..MAXPNAMELEN-1] of AnsiChar;  { product name (NULL terminated string) }
    wTechnology: Word;           { type of device }
    wVoices: Word;               { # of voices (internal synth only) }
    wNotes: Word;                { max # of notes (internal synth only) }
    wChannelMask: Word;          { channels used (internal synth only) }
    dwSupport: DWORD;            { functionality supported by driver }
    end;

   PMidiHdr = ^TMidiHdr;
   TMidiHdr = record
    lpData: PChar;               { pointer to locked data block }
    dwBufferLength: DWORD;       { length of data in data block }
    dwBytesRecorded: DWORD;      { used for input only }
    dwUser: DWORD;               { for client's use }
    dwFlags: DWORD;              { assorted flags (see defines) }
    lpNext: PMidiHdr;            { reserved for driver }
    reserved: DWORD;             { reserved for driver }
    dwOffset: DWORD;             { Callback offset into buffer }
    dwReserved: array[0..7] of DWORD; { Reserved for MMSYSTEM }
   end;

    MCIERROR = DWORD;     { error return code, 0 means no error }
    MCIDEVICEID = UINT;   { MCI device ID type }
    PMCI_Generic_Parms=^TMCI_Generic_Parms;
    TMCI_Generic_Parms=record
      dwCallback:DWORD;
      end;
    PMCI_Open_ParmsA=^TMCI_Open_ParmsA;
    PMCI_Open_Parms=PMCI_Open_ParmsA;
    TMCI_Open_ParmsA=record
      dwCallback:DWORD;
      wDeviceID:MCIDEVICEID;
      lpstrDeviceType:PAnsiChar;
      lpstrElementName:PAnsiChar;
      lpstrAlias:PAnsiChar;
      end;
    TMCI_Open_Parms=TMCI_Open_ParmsA;
    PMCI_Play_Parms=^TMCI_Play_Parms;
    TMCI_Play_Parms=record
      dwCallback:DWORD;
      dwFrom:DWORD;
      dwTo:DWORD;
      end;
    PMCI_Set_Parms=^TMCI_Set_Parms;
    TMCI_Set_Parms=record
      dwCallback:DWORD;
      dwTimeFormat:DWORD;
      dwAudio:DWORD;
      end;
    PMCI_Status_Parms=^TMCI_Status_Parms;
    TMCI_Status_Parms=record
      dwCallback:DWORD;
      dwReturn:DWORD;
      dwItem:DWORD;
      dwTrack:DWORD;
      end;
    PMCI_Seek_Parms=^TMCI_Seek_Parms;
    TMCI_Seek_Parms=record
      dwCallback:DWORD;
      dwTo:DWORD;
      end;

{tbasicmidi}
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//mmmmmmmmmmmmmmmmmmmmmmmmmmmm
   tbasicmidi=class(tobjectex)
   private
    itimer100,itimer500,iopenref:comp;
    ithreadignore,ithreadtimerbusy,itimereventbusy,ipdobusy,imustplaydata,imustplayfile,ikeepopen,iloop,imuststop,imustplay,iplaying:boolean;
    imustopen:longint;//0=ready, 1=busy, 2=timer must load
    inewvol,inewvol2,iresetvol,isysthreadSLOT,ivol,ivol2,ichangedidB,iphandle,ilastid,iid,ibytes,imidbytes,ilastspeed2,ilastspeed,ispeed,ispeed2,imidformat,imidtracks,imidmsgs:longint;
    //lag support
    ilag,ilastlag,ilagref,iref1000:comp;
    //midi track data handlers -> these point a track(0..255) to a list of "time.4 + dpos.4" items within "imidref" where "dpos.4" points to the actual midi msg to be processed and "time.4" refers to the TOTAL TIME in MS to have transpired until THIS midi msg IS to be processed (not time is a 32bit time, limit of 21 days) - 15feb2021
    ilistdata    :array[0..255] of tstr8;
    ilistpos     :array[0..255] of longint;//current item (midi msg) we are up to in track (0..midcount-1)
    ilistcount   :array[0..255] of longint;//total number of items (midi msgs) in track
    ilistlimit   :longint;//number of lists in use
    ilyrics      :tstr8;//one long stream of text - 24feb2022
    ilyricsref   :tstr8;//list of <ms4><pos4> pairs for finding and displaying then current lyrics position
    //actual midi values (pos=current playback position in ms, len=total ms of song)
    inewdeviceindex,ideviceindex,inewstyle,istyle,inewpos,inewspeed,inewspeed2,ipos,ilen:longint;
    inewpertpos:double;//06mar2022
    ipos64:comp;//used to increment internal "pos" without required a synced timer var
    idisablenotes,ilocked:boolean;//true=shutdown critical functions for a safe destruction of control
    //external support
    ifilename:string;
    idata,idata2:tstr8;
    procedure flush;
    procedure closehandle;//24may2021
    procedure openhandle;
    procedure xplaydata;
    procedure __ontimer(sender:tobject);
    procedure __ontimerevent(sender:tobject;xfast:boolean);//._ontimer
    procedure setspeed(x:longint);
    procedure setspeed2(x:longint);
    procedure setstyle(x:longint);
    procedure setdeviceindex(x:longint);
    procedure setvol(x:longint);
    procedure setvol2(x:longint);
    procedure resetlag;
    procedure synclag;
    procedure setnewpos(x:longint);
    procedure setnewpertpos(x:double);
    function getpos:longint;
    function getpertpos:double;
   public
    //options
    oautostop:boolean;//default=false=remains playing
    //create
    constructor create; override;
    destructor destroy; override;//02mar2022
    //information
    function usingtimer:boolean;
    function seeking:boolean;//true=midi is in process of updating "pos" to new value, false=read to set new pos - 30mar2021
    procedure moretime;
    function get(xindex,xmsgindex:longint;var xtimems:longint;var xmsg,xval1,xval2,xval3:byte):boolean;
    procedure pdo;
    procedure resetvols;
    property loop:boolean read iloop write iloop;
    property keepopen:boolean read ikeepopen write ikeepopen;
    function canplaymidi:boolean;
    function canopen:boolean;
    function canclose:boolean;
    procedure open;
    procedure close;
    procedure autoopen;
    procedure setpos(x:longint);
    procedure syncpos;
    procedure restart;
    function canstop:boolean;
    procedure stop;
    function canplay:boolean;
    procedure play;
    property playing:boolean read iplaying;
    property bytes:longint read ibytes;
    property midbytes:longint read imidbytes;
    property msgs:longint read imidmsgs;
    function msgssent:longint;
    property handle:longint read iphandle;
    property format:longint read imidformat;
    property tracks:longint read imidtracks;
    property pos:longint read getpos write setnewpos;//26sep2021
    property pertpos:double read getpertpos write setnewpertpos;//06mar2022
    property len:longint read ilen;
    property speed:longint read ispeed write inewspeed;
    property speed2:longint read ispeed2 write inewspeed2;//02mar2022
    property style:longint read istyle write setstyle;
    property deviceindex:longint read ideviceindex write setdeviceindex;
    function playdata(x:tstr8):boolean;
    function playfile(x:string):boolean;
    property vol:longint read ivol write setvol;
    property vol2:longint read ivol2 write setvol2;
    property lag:comp read ilag;
    procedure threadtimer(sender:tobject);//16oct2021
    //lyrics support
    function lcount:longint;
    function lfind(xpos:longint;xshowsep:boolean):string;//find lyrics - 24feb2022
   end;

//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//ccccccccccccccccccc
{tbasicchimes}
   tbasicchimes=class(tobjectex)//15nov2022, 02mar2022
   private
    ipausenote64,itimer100,itimer500:comp;
    iworklist:string;
    ivol,ibuzzer2,ibuzzer,imustplay,iworkindex,iworkmins,iworkpos,iworkcount:longint;
    iwork0,iwork15,iwork30,iwork45,iworktest,ibuzzerpaused,imuststop,iplaying:boolean;
    //.chime + buzzer support - 01mar2022
    iname  :array[0..199] of string;
    istyle :array[0..199] of longint;//0=title, 1=standard, 2=ships bells, 3=grande sonnerie
    itep   :array[0..199] of longint;
    iintro :array[0..199] of tstr8;//intro melody - optional
    idong  :array[0..199] of tstr8;//standard SINGLE DONG - required
    idong2 :array[0..199] of tstr8;//ships bell DOUBLE DONG - optional
    itemp  :array[0..199] of tstr8;//used to store and entire chiming sequence such as for Sonnerie - 16mar2022
    igap   :array[0..199] of longint;//gap in ms between dong and dong2 - optional
    iintroX:array[0..199] of string;//intro melody - optional
    idongX :array[0..199] of string;//standard SINGLE DONG - required
    idong2X:array[0..199] of string;//ships bell DOUBLE DONG - optional
    icount :longint;
    inumberfrom1,inumberfrom2,inumberfrom3:longint;//09nov2022
    ibuzzers      :array[1..99] of tstr8;//14nov2022
    ibuzzerlabels :array[1..99] of string;//14nov2022
    ibuzzercount:longint;
    procedure _ontimer(sender:tobject);
    function getchiming:boolean;
    procedure setbuzzer(x:longint);
    procedure setvol(x:longint);
   public
    //create
    constructor create; override;
    destructor destroy; override;//02mar2022
    procedure xinitChimes;
    procedure xgrabfiles;//grabs mid/txt files from old chimerdata2015 folder and converts into Delphi code ready for inclusion in the "gossdat" unit - 02mar202
    procedure xaddTitle(xname:string);
    procedure xaddStandard(xname:string;xintro,xdong:array of byte);
    procedure xaddStandard2(xname,xintro,xdong:string);//14nov2022
    procedure xaddStandard3(xname,xintro,xdong:string;aintro,adong:array of byte);//15nov2022
    procedure xaddBells(xname:string;xdong,xdong2:array of byte);
    procedure xaddBells2(xgap:longint;xname,xdong,xdong2:string);
    procedure xaddSonnerie(xgap:longint;xname:string;xdong,xdong2:array of byte);
    procedure xaddSonnerie2(xgap:longint;xname,xdong,xdong2:string);
    procedure xadd(xgap:longint;xname:string;xintro,xdong,xdong2:array of byte;xstyle,xtep:longint);
    procedure xadd2(xgap:longint;xname:string;xintro,xdong,xdong2:array of byte;sintro,sdong,sdong2:string;xstyle,xtep:longint);
    //information
    property count:longint read icount;
    property numberfrom1:longint read inumberfrom1;//standard - 09nov2022
    property numberfrom2:longint read inumberfrom2;//ships bells
    property numberfrom3:longint read inumberfrom3;//grande sonnerie
    property chiming:boolean read getchiming;
    function chimingpert:double;//actual chime progress 0-100%
    property vol:longint read ivol write setvol;//used for chiming, buzzer remains at 100%
    //workers
    function info(xindex:longint;var xname:string;var xstyle,xtep:longint;var xintro,xdong,xdong2:tstr8):boolean;
    //.find
    function findname(xname:string;var xindex:longint):boolean;
    function findworklist(xindex,xmins:longint;x0,x15,x30,x45,xtest:boolean;var xworklist:string):boolean;
    //.stop
    function canstop:boolean;
    procedure stop;
    //.play
    function mustplayname(xname:string;xmins:longint):boolean;
    function mustplayindex(xindex,xmins:longint):boolean;
    function canplay:boolean;
    procedure playname(xname:string;xmins:longint;x0,x15,x30,x45,xtest:boolean);
    procedure playname2(xname:string);
    procedure playname3(xname:string;xmins:longint;n0,n15,n30,n45,b0,s0,s15,s30,s45,xtest:boolean);
    procedure playindex(xindex,xmins:longint;x0,x15,x30,x45,xtest:boolean);
    procedure playindex2(xindex:longint);
    property testing:boolean read iworktest;//sounding a test chime
    //.buzzer
    property buzzer:longint read ibuzzer write setbuzzer;
    property buzzercount:longint read ibuzzercount;
    function findbuzzerlabel(x:longint):string;
    function addbuzzer(xlabel,xdata:string;xmiddata:array of byte):boolean;
    procedure setbuzzerdata(x:longint;xlabel,xdata:string;xmiddata:array of byte);
   end;

//tsnd32 - 32bit binary list for storage and manipulation of audio samples -> each sample is stored in a single 32bit slot - 14jul2021
//xxxxxxxxxxxxxxxxxxxxxxxxxxxx//333333333333333333333333
   tsnd32=class(tobjectex)
   private
    icore,ivmax:tstr8;
    ilastvmaxid,iid,ibits,ihz,ikhz,iincby,ilen:longint;
    procedure setkhz(x:longint);
    procedure sethz(x:longint);
    procedure setincby(x:longint);
    function getbytes:longint;
    procedure setlen(x:longint);
    function getv(xpos:longint):longint;
    procedure setv(xpos,xval:longint);
    function getpv(xpos:longint):longint;
    procedure setpv(xpos,xval:longint);
    function getnv(xpos:longint):longint;
    procedure setnv(xpos,xval:longint);
    function getms:longint;
    procedure setms(x:longint);
    function xadd(x:tstr8;dhz,xfrom,xlen,xpower255:longint;xasms:boolean;var e:string):boolean;
    function xpull(x:tstr8;dhz,xfrom,xlen:longint;xasms:boolean;var e:string):boolean;
    procedure setbits(x:longint);
    function getlen100:longint;
    procedure setlen100(x:longint);
    function getvmax(x:longint):longint;
   public
    //create
    constructor create; override;
    destructor destroy; override;
    procedure xincid;

    //core support
    property id:longint read iid;
    property incby:longint read iincby write setincby;
    property hz:longint read ihz write ihz;
    property khz:longint read ikhz write setkhz;
    property bits:longint read ibits;
    procedure setparams(xkhz,xbits,xlen:longint);
    function minlen(x:longint):boolean;
    property len:longint read ilen write setlen;//number of slots used by audio stream
    property len100:longint read getlen100 write setlen100;//based on VideoMagic's 100fps (so hz=44100 => 1 second = 100 slots => 100 = 44100 and 1 slot = 44.1 samples)
    property bytes:longint read getbytes;//memory used by slots of audio stream

    //slot access -> one slot per audio sample (16bit audio uses one slot) - 14jul2021
    property val[xpos:longint]:longint read getv write setv;
    property v[xpos:longint]:longint read getv write setv;
    property pv[xpos:longint]:longint read getpv write setpv;//values as positive numbers
    property nv[xpos:longint]:longint read getnv write setnv;//values as negative numbers
    property vmax[xpos:longint]:longint read getvmax;//used for graphing purposes only - 21jul2021

    //add -> add an audio stream from one format to the core's format specified by "hz" or "khz" and "bits"(bits not supported as yet, defaults to 16bit)
    function add(x:tsnd32;xfrom,xlen,xpower255:longint;xasms:boolean;var e:string):boolean;
    function add22(x:tstr8;xfrom,xlen,xpower255:longint;xasms:boolean;var e:string):boolean;
    function add44(x:tstr8;xfrom,xlen,xpower255:longint;xasms:boolean;var e:string):boolean;
    function add48(x:tstr8;xfrom,xlen,xpower255:longint;xasms:boolean;var e:string):boolean;
    function add96(x:tstr8;xfrom,xlen,xpower255:longint;xasms:boolean;var e:string):boolean;

    //pull -> pull core audio stream to external stream in output format
    function pull96(x:tstr8;xfrom,xlen:longint;xasms:boolean;var e:string):boolean;
    function pull48(x:tstr8;xfrom,xlen:longint;xasms:boolean;var e:string):boolean;
    function pull44(x:tstr8;xfrom,xlen:longint;xasms:boolean;var e:string):boolean;
    function pull22(x:tstr8;xfrom,xlen:longint;xasms:boolean;var e:string):boolean;

    //time
    property ms:longint read getms write setms;

    //workers
    procedure clear;
    //.ave volume support -> use to correct volume
    function volave:longint;
    function volave2(xfrom,xlen:longint):longint;
    procedure setvolave(soriginalvolave:longint);
    procedure setvolave2(xfrom,xlen,soriginalvolave:longint);
    //range
    function findrange(var xmin,xmax:longint):boolean;
    function findrange2(var lmin,lmax,hmin,hmax:longint):boolean;
    function findmin:longint;
    function findmax:longint;
    //detect
    function iszero(xfrom,xto:longint):boolean;
    function inrange(xfrom,xto,xmin,xmax:longint):boolean;
    //makers
    procedure make96_16;
    procedure make48_16;
    procedure make44_16;
    procedure make22_16;
   end;

//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
{taudiobasic}
    VERSION = UINT;               { major (high byte), minor (low byte) }
    PWaveFormatEx = ^TWaveFormatEx;
    TWaveFormatEx = packed record
     wFormatTag: Word;         { format type }
     nChannels: Word;          { number of channels (i.e. mono, stereo, etc.) }
     nSamplesPerSec: DWORD;  { sample rate }
     nAvgBytesPerSec: DWORD; { for buffer estimation }
     nBlockAlign: Word;      { block size of data }
     wBitsPerSample: Word;   { number of bits per sample of mono data }
     cbSize: Word;           { the count in bytes of the size of }
     end;
    PWaveHdr = ^TWaveHdr;
    TWaveHdr = record
     lpData: PChar;              { pointer to locked data buffer }
     dwBufferLength: DWORD;      { length of data buffer }
     dwBytesRecorded: DWORD;     { used for input only }
     dwUser: DWORD;              { for client's use }
     dwFlags: DWORD;             { assorted flags (see defines) }
     dwLoops: DWORD;             { loop control counter }
     lpNext: PWaveHdr;           { reserved for driver }
     reserved: DWORD;            { reserved for driver }
     end;

    paudiobasicbuffer=^taudiobasicbuffer;
    taudiobasicbuffer=array[0..47999] of byte;//higher upper limit buffer for 48Khz recording - 03JAN2010
    taudiobasic=class(tobjectex)//Note: Playback and Recording systems now fully operational as at 25JUN2009
    private
     //commmon
     ihandle:hwnd;
     //push - play
     isamplems,isamplesize,isecsize,ipvolume,ipmaxV:integer;
     ipopen,iformatmodified:boolean;
     iformat:twaveformatex;
     iformatstr:string;
     iptime:currency;
     iphandle:HWAVEOUT;
     ipH:array [0..1] of twavehdr;
     ipB:array [0..1] of taudiobasicbuffer;
     ippos:byte;
     ipchcount,ipcount:integer;
     ipdata:tstr8;
     ip16bit,ipplaying:boolean;
     //pull - record
     irsamplems,irsamplesize,irsecsize,irvolume,irmaxV:integer;
     irformatmodified:boolean;
     irformat:twaveformatex;
     irformatstr:string;
     irtime:currency;
     irhandle:HWAVEIN;
     irH:array [0..1] of twavehdr;
     irB:array [0..1] of taudiobasicbuffer;
     irpos:byte;
     irchcount,ircount:integer;
     irdata:tstr8;
     ir16bit,irrecording:boolean;
     //core
     ilocked:boolean;
     itimer:integer;
     procedure _ontimer(sender:tobject);
     procedure pdo;
     procedure paoc;//automatic open/close
     procedure raoc;//automatic open/close
     function handle:hwnd;
     procedure wndproc(var message:tmessage);
     procedure setformat(x:string);
     procedure setrformat(x:string);
     procedure setvolume(x:integer);
     procedure setrvolume(x:integer);
     procedure setsamplems(x:integer);
     procedure setrsamplems(x:integer);
    public
     //options
     oplay_timeout:longint;//milliseconds to wait before timing out play buffer, default=10000 (10sec), use longer such for "tts" of "60000 (1 minute)" - 14apr2017
     orec_timeout:longint;//as above
     //create
     constructor create; override;
     destructor destroy; override;
     function onems(xformat:string):longint;//number of bytes for "1 millsecond" of sound - 21JUL2009
     //workers - common
     function wkMaxV(_16bit:boolean;z:tstr8):integer;
     procedure wkFast(_16bit:boolean;z:tstr8);
     procedure wkAdjustVolume(_16bit:boolean;z:tstr8;_vol:integer);//adjust volume
     //-- PLAY -----------------------------------------------------------------
     //information
     property samplems:integer read isamplems write setsamplems;
     property samplesize:integer read isamplesize;
     property secsize:integer read isecsize;
     property format:string read iformatstr write setformat;
     property playing:boolean read ipplaying;//23JUN2009
     property pmaxV:integer read ipmaxV;
     property volume:integer read ipvolume write setvolume;//adjust playback volume in realtime
     property p16bit:boolean read ip16bit;
     property pchcount:integer read ipchcount;
     property pcount:integer read ipcount;//number of buffers in use (0=none, 1=one, 2=both)
     //push
     function pushonline:boolean;
     function pushlen:integer;//amount of data length in push buffer for playback
     function canpush:boolean;
     function canpushex(seconds:integer):boolean;
     function canpushexMS(ms:integer):boolean;//23JUN2009
     function push(data:tstr8):boolean;//14apr2017
     procedure pflush;
     function pempty:boolean;//assume "ipdata" is never entirely empty as audio rounds to nearest block
     //-- RECORD ---------------------------------------------------------------
     //information
     property rsamplems:integer read irsamplems write setrsamplems;
     property rsamplesize:integer read irsamplesize;
     property rsecsize:integer read irsecsize;
     property rformat:string read irformatstr write setrformat;
     property recording:boolean read irrecording write irrecording;
     property rmaxV:integer read irmaxV write irmaxV;
     property rvolume:integer read irvolume write setrvolume;//adjust playback volume in realtime
     property r16bit:boolean read ir16bit;
     property rchcount:integer read irchcount;
     //pull
     function pullonline:boolean;//hardware is running
     function canpull:boolean;
     function pull(data:tstr8):boolean;
     procedure rflush;
     function rempty:boolean;//assume "irdata" is never entirely empty as audio rounds to nearest block
    end;

{tmm}
    tmm=class(tobjectex)//dual audio system "ms and blaiz" - 19MAY20123
    private
     istate:byte;
     ideviceid:word;
     ihandle:hwnd;
     iformat,ifilename:string;
     iplayBUSY,itrackformat,istoplock,ivalid:boolean;//special note: ibk=true=>using backup audio system (ours) - 19MAY2013
     itracknumber,itrackstart:integer;
     inewposition,ilength:longint;
     inewpertpos:double;//06mar2022
     procedure _ontimer(sender:tobject);
     function getplaying:boolean;
     procedure _stop;
     function _open(var e:string):boolean;
     function _play(var e:string):boolean;
     function gethandle:hwnd;
     procedure wndproc(var message:tmessage);
     function getmode:tmmodes;
     function getposition:longint;
     procedure setposition(x:longint);//Working - 29JUN2010
     function getpertpos:double;
     procedure setnewpertpos(x:double);//06mar2022
    public
     //options
     oAutostop:boolean;//default=false
     oLoop:boolean;//default=false - 01MAY2011
     //events
     onstop:tnotifyevent;
     //create
     constructor create; override;
     destructor destroy; override;
     //workers
     //.play
     property playBUSY:boolean read iplayBUSY;//true=play() is working and is not yet finished, so POS and LEN could be undefined or incorrect - 23MAY2013
     function canplay:boolean;
     function play(x:string;var e:string):boolean;//reinforced, 12AUG2010
     property playing:boolean read getplaying;
     //.stop
     function canstop:boolean;
     procedure stop;
     //.information
     function positionBUSY:boolean;//we are waiting for "inewposition" to be implemented - 23MAY2013
     property position:integer read getposition write setposition;
     property pertpos:double read getpertpos write setnewpertpos;
     property len:longint read ilength;//set by "play" and "stop"
     property mode:tmmodes read getmode;
     property filename:string read ifilename;
     property state:byte read istate;
     //.handle
     property handle:hwnd read gethandle;
    end;

{tplaylist}
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//pppppppppppppppppppppppp
   tplaylist=class(tobjectex)
   private
    ilistcoreUNDO,ilistcoreFULL,ilistcore:tstr8;
    ilistcoreCANUNDO:boolean;
    ifilenameOPEN,ifilenameSAVE,ipartmask,ifullmask:string;
    ilist:tbasicmenu;
    iopenfilter,ilistcoreUNDO_itemindex,ilistcoreid:longint;
    procedure setlist(x:tbasicmenu);
    function xcopy(xall,xcut:boolean;var e:string):boolean;
    function xpaste(xclear:boolean;var e:string):boolean;
    function xundo(var e:string):boolean;
    procedure setpartmask(x:string);
    procedure setfullmask(x:string);
   public
    //create
    constructor create; override;//20mar2022
    destructor destroy; override;//20mar2022
    //internal support
    function xguiOK:boolean;
    function xgui:tbasicsystem;
    function xlistitem(sender:tobject;xindex:longint;var xtab,xtep,xtepcolor:longint;var xcaption,xcaplabel,xhelp,xcode2:string;var xcode,xshortcut,xindent:longint;var xflash,xenabled,xtitle,xsep:boolean):boolean;
    procedure xfillundo;
    procedure xmask(xforce:boolean);
    procedure xlistsync;
    //information
    property id:longint read ilistcoreid;
    function listok:boolean;
    property list:tbasicmenu read ilist write setlist;//pointer only -> use to automaticaly sync with a list control - 20mar2022
    property partmask:string read ipartmask write setpartmask;//used to filter from ilistcoreFULL to ilistcore (e.g. only "*.mid")
    property fullmask:string read ifullmask write setfullmask;//used to filter paste/open to ilistcoreFULL (e.g. *.rmi;*.mid;*.midi)
    //new -> prompt to clear
    function cannew:boolean;
    function new(var e:string):boolean;
    //clear
    function canclear:boolean;
    function clear(var e:string):boolean;
    //cut
    function cancut:boolean;
    function cut(var e:string):boolean;
    //copy
    function cancopy:boolean;
    function copy(var e:string):boolean;
    //copy all
    function cancopyall:boolean;
    function copyall(var e:string):boolean;
    //paste
    function canpaste:boolean;
    function paste(var e:string):boolean;
    //replace - 19apr2022
    function canreplace:boolean;
    function replace(var e:string):boolean;
    //open
    function canopen:boolean;
    function open(var e:string):boolean;
    //save
    function cansave:boolean;
    function save(var e:string):boolean;
    //undo
    function canundo:boolean;
    function undo(var e:string):boolean;

    //command handler
    function xcmd(n:string;var e:string):boolean;
    //open support
    function xopen(var e:string):boolean;
    function xopen2(xfilename:string;xindex:longint;xprompt,afillundo:boolean;var e:string):boolean;
    //save support
    function xsave(var e:string):boolean;
    function xsave2(dfilename:string;xprompt:boolean;var e:string):boolean;
    //add support
    function xadd(xdata:tstr8;xindex:longint;xauthoritativeFilename:string;xclear:boolean):boolean;
    function xaddone(xsec:longint;xtitle,xfilename:string):boolean;
   end;
{$endif}


//system images ----------------------------------------------------------------
const
tep_on          :array[0..288] of byte=(84,69,65,49,35,21,0,0,0,15,0,0,0,255,0,0,13,64,138,213,7,255,0,0,13,64,138,213,9,255,0,0,12,64,138,213,3,255,251,146,3,64,138,213,3,255,0,0,1,64,138,213,13,255,251,146,1,64,138,213,3,255,251,146,1,64,138,213,3,255,251,146,11,64,138,213,2,255,251,146,1,64,138,213,3,255,251,146,1,64,138,213,3,255,251,146,11,64,138,213,2,255,251,146,1,64,138,213,3,255,251,146,1,64,138,213,3,255,251,146,11,64,138,213,3,255,251,146,3,64,138,213,4,255,251,146,11,64,138,213,10,255,251,146,11,64,138,213,2,255,251,146,2,64,138,213,2,255,251,146,1,64,138,213,3,255,251,146,11,64,138,213,2,255,251,146,2,64,138,213,2,255,251,146,1,64,138,213,3,255,251,146,11,64,138,213,2,255,251,146,1,64,138,213,1,255,251,146,1,64,138,213,1,255,251,146,1,64,138,213,2,255,0,0,1,64,138,213,13,255,251,146,1,64,138,213,2,255,251,146,2,64,138,213,2,255,0,0,12,64,138,213,2,255,251,146,1,64,138,213,2,255,251,146,2,64,138,213,2,255,0,0,12,64,138,213,9,255,0,0,13,64,138,213,7,255,0,0,1);
tep_off         :array[0..96] of byte=(84,69,65,49,35,21,0,0,0,15,0,0,0,255,0,0,64,64,138,213,19,255,0,0,1,64,138,213,9,255,251,146,11,64,138,213,10,255,251,146,11,64,138,213,10,255,251,146,11,64,138,213,10,255,251,146,11,64,138,213,10,255,251,146,11,64,138,213,10,255,251,146,11,64,138,213,10,255,251,146,11,64,138,213,1,255,0,0,1,64,138,213,19,255,0,0,64);
tep_up          :array[0..48] of byte=(84,69,65,49,35,10,0,0,0,4,0,0,0,255,255,255,4,0,0,0,2,255,255,255,7,0,0,0,4,255,255,255,5,0,0,0,6,255,255,255,3,0,0,0,8,255,255,255,1);
tep_down        :array[0..48] of byte=(84,69,65,49,35,10,0,0,0,4,0,0,0,255,255,255,1,0,0,0,8,255,255,255,3,0,0,0,6,255,255,255,5,0,0,0,4,255,255,255,7,0,0,0,2,255,255,255,4);
tep_left        :array[0..64] of byte=(84,69,65,49,35,4,0,0,0,10,0,0,0,255,255,255,7,0,0,0,1,255,255,255,2,0,0,0,2,255,255,255,1,0,0,0,11,255,255,255,1,0,0,0,3,255,255,255,2,0,0,0,2,255,255,255,3,0,0,0,1,255,255,255,4);
tep_right       :array[0..64] of byte=(84,69,65,49,35,4,0,0,0,10,0,0,0,255,255,255,4,0,0,0,1,255,255,255,3,0,0,0,2,255,255,255,2,0,0,0,3,255,255,255,1,0,0,0,11,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,1,255,255,255,7);
tep_min         :array[0..32] of byte=(84,69,65,49,35,17,0,0,0,17,0,0,0,255,255,255,207,0,0,0,10,255,255,255,7,0,0,0,10,255,255,255,55);
tep_nor         :array[0..160] of byte=(84,69,65,49,35,17,0,0,0,17,0,0,0,255,255,255,57,0,0,0,7,255,255,255,10,0,0,0,7,255,255,255,16,0,0,0,1,255,255,255,7,0,0,0,7,255,255,255,2,0,0,0,1,255,255,255,7,0,0,0,7,255,255,255,2,0,0,0,1,255,255,255,7,0,0,0,1,255,255,255,5,0,0,0,1,255,255,255,2,0,0,0,1,255,255,255,7,0,0,0,1,255,255,255,5,0,0,0,1,255,255,255,1,0,0,0,2,255,255,255,7,0,0,0,1,255,255,255,5,0,0,0,1,255,255,255,10,0,0,0,1,255,255,255,5,0,0,0,1,255,255,255,10,0,0,0,7,255,255,255,75);
tep_max         :array[0..160] of byte=(84,69,65,49,35,17,0,0,0,17,0,0,0,255,255,255,54,0,0,0,11,255,255,255,6,0,0,0,11,255,255,255,6,0,0,0,11,255,255,255,6,0,0,0,1,255,255,255,9,0,0,0,1,255,255,255,6,0,0,0,1,255,255,255,9,0,0,0,1,255,255,255,6,0,0,0,1,255,255,255,9,0,0,0,1,255,255,255,6,0,0,0,1,255,255,255,9,0,0,0,1,255,255,255,6,0,0,0,1,255,255,255,9,0,0,0,1,255,255,255,6,0,0,0,1,255,255,255,9,0,0,0,1,255,255,255,6,0,0,0,1,255,255,255,9,0,0,0,1,255,255,255,6,0,0,0,11,255,255,255,54);
tep_clo         :array[0..168] of byte=(84,69,65,49,35,17,0,0,0,17,0,0,0,255,255,255,54,0,0,0,2,255,255,255,7,0,0,0,2,255,255,255,6,0,0,0,3,255,255,255,5,0,0,0,3,255,255,255,7,0,0,0,3,255,255,255,3,0,0,0,3,255,255,255,9,0,0,0,3,255,255,255,1,0,0,0,3,255,255,255,11,0,0,0,5,255,255,255,13,0,0,0,3,255,255,255,13,0,0,0,5,255,255,255,11,0,0,0,3,255,255,255,1,0,0,0,3,255,255,255,9,0,0,0,3,255,255,255,3,0,0,0,3,255,255,255,7,0,0,0,3,255,255,255,5,0,0,0,3,255,255,255,6,0,0,0,2,255,255,255,7,0,0,0,2,255,255,255,54);
tep_inf         :array[0..160] of byte=(84,69,65,49,35,13,0,0,0,18,0,0,0,255,255,255,15,0,0,0,9,255,255,255,3,0,0,0,1,255,255,255,9,0,0,0,1,255,255,255,2,0,0,0,1,255,255,255,9,0,0,0,1,255,255,255,3,0,0,0,9,255,255,255,30,0,0,0,9,255,255,255,3,0,0,0,1,255,255,255,9,0,0,0,1,255,255,255,2,0,0,0,1,255,255,255,9,0,0,0,1,255,255,255,3,0,0,0,9,255,255,255,30,0,0,0,9,255,255,255,3,0,0,0,1,255,255,255,9,0,0,0,1,255,255,255,2,0,0,0,1,255,255,255,9,0,0,0,1,255,255,255,3,0,0,0,9,255,255,255,15);
tep_helphint    :array[0..312] of byte=(84,69,65,49,35,18,0,0,0,16,0,0,0,192,192,192,20,132,132,0,10,192,192,192,7,132,132,0,2,255,255,128,8,132,132,0,2,192,192,192,6,132,132,0,1,255,255,128,3,132,132,0,3,255,255,128,4,132,132,0,2,192,192,192,5,132,132,0,1,255,255,128,2,132,132,0,5,255,255,128,3,132,132,0,3,192,192,192,4,132,132,0,1,255,255,128,2,132,132,0,2,255,255,128,2,132,132,0,2,255,255,128,2,132,132,0,4,192,192,192,3,132,132,0,1,255,255,128,2,132,132,0,1,255,255,128,3,132,132,0,2,255,255,128,2,132,132,0,5,192,192,192,2,132,132,0,1,255,255,128,5,132,132,0,3,255,255,128,2,132,132,0,5,192,192,192,2,132,132,0,1,255,255,128,4,132,132,0,3,255,255,128,3,132,132,0,5,192,192,192,2,132,132,0,1,255,255,128,4,132,132,0,2,255,255,128,4,132,132,0,5,192,192,192,2,132,132,0,1,255,255,128,10,132,132,0,4,192,192,192,3,132,132,0,1,255,255,128,4,132,132,0,2,255,255,128,4,132,132,0,3,192,192,192,4,132,132,0,1,255,255,128,4,132,132,0,2,255,255,128,4,132,132,0,
                2,192,192,192,5,132,132,0,2,255,255,128,8,132,132,0,2,192,192,192,7,132,132,0,10,192,192,192,24);
tep_bullet      :array[0..96] of byte=(84,69,65,49,35,8,0,0,0,12,0,0,0,255,255,255,34,128,159,191,4,255,255,255,3,128,159,191,2,255,255,0,2,128,159,191,2,255,255,255,2,128,159,191,1,255,255,0,4,128,159,191,1,255,255,255,2,128,159,191,1,255,255,0,4,128,159,191,1,255,255,255,2,128,159,191,2,255,255,0,2,128,159,191,2,255,255,255,3,128,159,191,4,255,255,255,18);
tep_sep         :array[0..312] of byte=(
                84,69,65,49,35,196,0,0,0,16,0,0,0,255,255,255,96,200,0,200,2,255,255,255,194,200,0,200,2,255,255,255,192,200,0,200,2,255,255,255,2,200,0,200,2,255,255,255,190,200,0,200,2,255,255,255,2,200,0,200,2,255,255,255,96,154,154,220,2,209,209,209,92,255,255,255,2,154,154,220,2,255,255,255,2,209,209,209,94,154,154,220,4,209,209,209,92,255,255,255,2,154,154,220,2,255,255,255,2,209,209,209,94,154,154,220,2,255,255,255,92,209,209,209,2,255,255,255,2,154,154,220,2,255,255,255,2,209,209,209,2,255,255,255,186,209,209,209,2,255,255,255,2,154,154,220,2,255,255,255,2,209,209,209,2,255,255,255,136,154,154,220,2,209,209,209,48,255,255,255,2,200,0,200,2,255,255,255,2,200,0,200,2,255,255,255,2,209,209,209,48,154,154,220,2,255,255,255,86,154,154,220,2,209,209,209,48,255,255,255,2,200,0,200,2,255,255,255,2,200,0,200,2,255,255,255,2,209,209,209,48,154,154,220,2,255,255,255,140,209,209,209,2,255,255,255,194,209,209,209,2,255,255,255,170,154,154,220,2,209,209,209,46,154,154,220,2,255,255,255,146,154,154,220,2,
                209,209,209,46,154,154,220,2,255,255,255,170,209,209,209,2,255,255,255,194,209,209,209,2,255,255,255,98);

//standard images --------------------------------------------------------------
tep_unknown20   :array[0..208] of byte=(84,69,65,49,35,13,0,0,0,15,0,0,0,255,0,0,15,255,251,146,9,255,0,0,3,255,251,146,3,64,138,213,4,255,251,146,4,255,0,0,2,255,251,146,2,64,138,213,6,255,251,146,3,255,0,0,2,255,251,146,1,64,138,213,2,255,251,146,4,64,138,213,2,255,251,146,2,255,0,0,2,255,251,146,7,64,138,213,2,255,251,146,2,255,0,0,2,255,251,146,6,64,138,213,3,255,251,146,2,255,0,0,2,255,251,146,5,64,138,213,3,255,251,146,3,255,0,0,2,255,251,146,4,64,138,213,3,255,251,146,4,255,0,0,2,255,251,146,4,64,138,213,2,255,251,146,5,255,0,0,2,255,251,146,11,255,0,0,2,255,251,146,4,64,138,213,2,255,251,146,5,255,0,0,2,255,251,146,4,64,138,213,2,255,251,146,5,255,0,0,3,255,251,146,9,255,0,0,15);
tep_new20       :array[0..152] of byte=(84,69,65,49,35,11,0,0,0,20,0,0,0,255,0,0,45,64,138,213,7,255,0,0,3,64,138,213,1,217,235,255,6,64,138,213,2,255,0,0,2,64,138,213,1,217,235,255,6,64,138,213,1,217,235,255,1,64,138,213,1,255,0,0,1,64,138,213,1,217,235,255,6,64,138,213,5,217,235,255,9,64,138,213,2,217,235,255,9,64,138,213,2,217,235,255,9,64,138,213,2,217,235,255,9,64,138,213,2,217,235,255,9,64,138,213,2,217,235,255,9,64,138,213,2,217,235,255,9,64,138,213,2,217,235,255,9,64,138,213,1,255,0,0,1,64,138,213,9,255,0,0,34);
tep_fnew20      :array[0..152] of byte=(84,69,65,49,35,11,0,0,0,20,0,0,0,255,0,0,45,0,0,0,7,255,0,0,3,0,0,0,1,255,0,0,6,0,0,0,2,255,0,0,2,0,0,0,1,255,0,0,6,0,0,0,1,255,0,0,1,0,0,0,1,255,0,0,1,0,0,0,1,255,0,0,6,0,0,0,5,255,0,0,9,0,0,0,2,255,0,0,9,0,0,0,2,255,0,0,9,0,0,0,2,255,0,0,9,0,0,0,2,255,0,0,9,0,0,0,2,255,0,0,9,0,0,0,2,255,0,0,9,0,0,0,2,255,0,0,9,0,0,0,1,255,0,0,1,0,0,0,9,255,0,0,34);
tep_home20      :array[0..296] of byte=(84,69,65,49,35,16,0,0,0,20,0,0,0,0,255,0,39,224,112,0,2,0,255,0,2,224,112,0,2,0,255,0,9,224,112,0,1,255,229,204,2,224,112,0,1,0,255,0,1,224,112,0,2,0,255,0,8,224,112,0,1,255,229,204,4,224,112,0,3,0,255,0,7,224,112,0,1,255,229,204,6,224,112,0,2,0,255,0,6,224,112,0,1,255,229,204,8,224,112,0,1,0,255,0,5,224,112,0,1,255,229,204,10,224,112,0,1,0,255,0,3,224,112,0,1,255,229,204,12,224,112,0,1,0,255,0,1,224,112,0,1,255,229,204,14,224,112,0,17,0,255,0,1,224,112,0,1,255,229,204,11,224,112,0,1,0,255,0,3,224,112,0,1,255,229,204,4,224,112,0,3,255,229,204,4,224,112,0,1,0,255,0,3,224,112,0,1,255,229,204,4,224,112,0,3,255,229,204,4,224,112,0,1,0,255,0,3,224,112,0,1,255,229,204,4,224,112,0,3,255,229,204,4,224,112,0,1,0,255,0,3,224,112,0,1,255,229,204,4,224,112,0,3,255,229,204,4,224,112,0,1,0,255,0,3,224,112,0,1,255,229,204,4,224,112,0,3,255,229,204,4,224,112,0,1,0,255,0,3,224,112,0,13,0,255,0,34);
tep_yes20       :array[0..128] of byte=(84,69,65,49,35,13,0,0,0,20,0,0,0,255,0,0,64,0,0,0,1,255,0,0,10,0,0,0,2,255,0,0,10,0,0,0,2,255,0,0,10,0,0,0,2,255,0,0,10,0,0,0,2,255,0,0,10,0,0,0,2,255,0,0,6,0,0,0,2,255,0,0,2,0,0,0,2,255,0,0,6,0,0,0,3,255,0,0,2,0,0,0,2,255,0,0,7,0,0,0,5,255,0,0,9,0,0,0,3,255,0,0,10,0,0,0,3,255,0,0,11,0,0,0,1,255,0,0,61);
tep_yesBLANK20  :array[0..20] of byte=(84,69,65,49,35,13,0,0,0,20,0,0,0,255,0,0,250,255,0,0,10);
tep_open20:array[0..308] of byte=(
84,69,65,49,35,15,0,0,0,20,0,0,0,255,0,0,54,20,157,11,3,255,0,0,11,20,157,11,1,255,0,0,3,20,157,11,1,255,0,0,1,20,157,11,1,255,0,0,13,20,157,11,2,255,0,0,1,160,130,35,3,255,0,0,8,20,157,11,3,160,130,35,1,255,254,149,1,255,255,255,1,255,254,149,1,160,130,35,7,255,0,0,4,160,130,35,1,255,255,255,1,255,254,149,1,255,255,255,1,255,254,149,1,255,255,255,1,255,254,149,1,255,255,255,1,255,254,149,1,255,255,255,1,160,130,35,1,255,0,0,4,160,130,35,1,255,254,149,1,255,255,255,1,255,254,149,1,255,255,255,1,255,254,149,1,255,255,255,1,255,254,149,1,255,255,255,1,255,254,149,1,160,130,35,1,255,0,0,4,160,130,35,1,255,255,255,1,255,254,149,1,255,255,255,1,255,254,149,1,160,130,35,11,255,254,149,1,255,255,255,1,255,254,149,1,160,130,35,1,223,193,104,9,160,130,35,2,255,255,255,1,255,254,149,1,160,130,35,1,223,193,104,9,160,130,35,1,255,0,0,1,160,130,35,1,255,254,149,1,160,130,35,1,223,193,104,9,160,130,35,1,255,0,0,2,160,130,35,2,223,193,104,9,160,130,35,1,255,0,0,4,160,130,35,10,255,0,0,64);
tep_save20:array[0..248] of byte=(
84,69,65,49,35,14,0,0,0,20,0,0,0,255,0,0,43,107,107,207,12,255,0,0,1,107,107,207,1,172,172,255,12,107,107,207,2,172,172,255,2,255,255,255,8,172,172,255,2,107,107,207,2,172,172,255,2,255,255,255,1,172,172,255,6,255,255,255,1,172,172,255,2,107,107,207,2,172,172,255,2,255,255,255,8,172,172,255,2,107,107,207,2,172,172,255,2,255,255,255,1,172,172,255,6,255,255,255,1,172,172,255,2,107,107,207,2,172,172,255,2,255,255,255,8,172,172,255,2,107,107,207,2,172,172,255,12,107,107,207,2,172,172,255,12,107,107,207,2,172,172,255,2,107,107,207,9,172,172,255,1,107,107,207,2,172,172,255,2,107,107,207,6,255,255,255,2,107,107,207,1,172,172,255,1,107,107,207,2,172,172,255,2,107,107,207,6,255,255,255,2,107,107,207,1,172,172,255,1,107,107,207,2,172,172,255,2,107,107,207,6,255,255,255,2,107,107,207,1,172,172,255,1,107,107,207,1,255,0,0,1,107,107,207,12,255,0,0,43);
tep_close20:array[0..152] of byte=(
84,69,65,49,35,11,0,0,0,20,0,0,0,0,255,0,55,255,0,0,2,0,255,0,7,255,0,0,5,0,255,0,5,255,0,0,3,0,255,0,1,255,0,0,3,0,255,0,3,255,0,0,3,0,255,0,3,255,0,0,3,0,255,0,1,255,0,0,3,0,255,0,5,255,0,0,5,0,255,0,7,255,0,0,3,0,255,0,7,255,0,0,5,0,255,0,5,255,0,0,3,0,255,0,1,255,0,0,3,0,255,0,3,255,0,0,3,0,255,0,3,255,0,0,3,0,255,0,1,255,0,0,3,0,255,0,5,255,0,0,5,0,255,0,7,255,0,0,2,0,255,0,44);
tep_hide20:array[0..224] of byte=(
84,69,65,49,35,13,0,0,0,20,0,0,0,255,255,255,46,0,128,255,1,255,255,255,11,0,128,255,1,255,255,0,1,0,128,255,1,255,255,255,9,0,128,255,1,255,255,0,2,0,128,255,1,255,255,255,8,0,128,255,1,255,255,0,3,0,128,255,1,255,255,255,7,0,128,255,1,255,255,0,4,0,128,255,4,255,255,255,3,0,128,255,1,255,255,0,8,0,128,255,1,255,255,255,2,0,128,255,1,255,255,0,9,0,128,255,1,255,255,255,2,0,128,255,1,255,255,0,9,0,128,255,1,255,255,255,3,0,128,255,1,255,255,0,8,0,128,255,1,255,255,255,4,0,128,255,1,255,255,0,4,0,128,255,4,255,255,255,5,0,128,255,1,255,255,0,3,0,128,255,1,255,255,255,9,0,128,255,1,255,255,0,2,0,128,255,1,255,255,255,10,0,128,255,1,255,255,0,1,0,128,255,1,255,255,255,11,0,128,255,1,255,255,255,44);
tep_back20:array[0..224] of byte=(
84,69,65,49,35,13,0,0,0,20,0,0,0,255,255,255,46,211,173,9,1,255,255,255,11,211,173,9,1,255,209,11,1,211,173,9,1,255,255,255,9,211,173,9,1,255,209,11,2,211,173,9,1,255,255,255,8,211,173,9,1,255,209,11,3,211,173,9,1,255,255,255,7,211,173,9,1,255,209,11,4,211,173,9,4,255,255,255,3,211,173,9,1,255,209,11,8,211,173,9,1,255,255,255,2,211,173,9,1,255,209,11,9,211,173,9,1,255,255,255,2,211,173,9,1,255,209,11,9,211,173,9,1,255,255,255,3,211,173,9,1,255,209,11,8,211,173,9,1,255,255,255,4,211,173,9,1,255,209,11,4,211,173,9,4,255,255,255,5,211,173,9,1,255,209,11,3,211,173,9,1,255,255,255,9,211,173,9,1,255,209,11,2,211,173,9,1,255,255,255,10,211,173,9,1,255,209,11,1,211,173,9,1,255,255,255,11,211,173,9,1,255,255,255,44);
tep_forw20:array[0..224] of byte=(
84,69,65,49,35,13,0,0,0,20,0,0,0,255,255,255,44,211,173,9,1,255,255,255,11,211,173,9,1,255,209,11,1,211,173,9,1,255,255,255,10,211,173,9,1,255,209,11,2,211,173,9,1,255,255,255,9,211,173,9,1,255,209,11,3,211,173,9,1,255,255,255,5,211,173,9,4,255,209,11,4,211,173,9,1,255,255,255,4,211,173,9,1,255,209,11,8,211,173,9,1,255,255,255,3,211,173,9,1,255,209,11,9,211,173,9,1,255,255,255,2,211,173,9,1,255,209,11,9,211,173,9,1,255,255,255,2,211,173,9,1,255,209,11,8,211,173,9,1,255,255,255,3,211,173,9,4,255,209,11,4,211,173,9,1,255,255,255,7,211,173,9,1,255,209,11,3,211,173,9,1,255,255,255,8,211,173,9,1,255,209,11,2,211,173,9,1,255,255,255,9,211,173,9,1,255,209,11,1,211,173,9,1,255,255,255,11,211,173,9,1,255,255,255,46);
tep_power20:array[0..224] of byte=(
84,69,65,49,35,17,0,0,0,20,0,0,0,0,255,64,46,255,209,11,5,0,255,64,12,255,209,11,5,0,255,64,12,255,209,11,5,0,255,64,12,255,209,11,5,0,255,64,12,255,209,11,5,0,255,64,12,255,209,11,5,0,255,64,12,255,209,11,5,0,255,64,12,255,209,11,5,0,255,64,6,255,209,11,5,0,255,64,1,255,209,11,5,0,255,64,6,255,209,11,5,0,255,64,1,255,209,11,5,0,255,64,6,255,209,11,5,0,255,64,1,255,209,11,5,0,255,64,6,255,209,11,5,0,255,64,1,255,209,11,5,0,255,64,6,255,209,11,5,0,255,64,1,255,209,11,10,0,255,64,1,255,209,11,5,0,255,64,1,255,209,11,10,0,255,64,1,255,209,11,5,0,255,64,1,255,209,11,10,0,255,64,1,255,209,11,5,0,255,64,1,255,209,11,10,0,255,64,1,255,209,11,5,0,255,64,1,255,209,11,5,0,255,64,17);
tep_refresh20:array[0..256] of byte=(
84,69,65,49,35,13,0,0,0,20,0,0,0,192,192,192,31,163,72,255,3,192,192,192,9,163,72,255,1,192,192,192,3,163,72,255,1,192,192,192,7,163,72,255,1,192,192,192,5,163,72,255,1,192,192,192,6,163,72,255,1,192,192,192,5,163,72,255,1,192,192,192,6,163,72,255,1,192,192,192,5,163,72,255,1,192,192,192,3,255,0,255,7,192,192,192,2,163,72,255,1,192,192,192,4,255,0,255,5,192,192,192,3,163,72,255,1,192,192,192,5,255,0,255,3,192,192,192,4,255,0,255,1,192,192,192,6,255,0,255,1,192,192,192,4,255,0,255,3,192,192,192,5,163,72,255,1,192,192,192,3,255,0,255,5,192,192,192,4,163,72,255,1,192,192,192,2,255,0,255,7,192,192,192,3,163,72,255,1,192,192,192,5,163,72,255,1,192,192,192,6,163,72,255,1,192,192,192,5,163,72,255,1,192,192,192,6,163,72,255,1,192,192,192,5,163,72,255,1,192,192,192,7,163,72,255,1,192,192,192,3,163,72,255,1,192,192,192,9,163,72,255,3,192,192,192,31);
tep_folder20:array[0..264] of byte=(
84,69,65,49,35,15,0,0,0,20,0,0,0,255,0,0,91,160,130,35,3,255,0,0,11,160,130,35,1,255,254,149,1,255,255,255,1,255,254,149,1,160,130,35,7,255,0,0,4,160,130,35,1,255,255,255,1,255,254,149,1,255,255,255,1,255,254,149,1,255,255,255,1,255,254,149,1,255,255,255,1,255,254,149,1,255,255,255,1,160,130,35,1,255,0,0,4,160,130,35,1,255,254,149,1,255,255,255,1,255,254,149,1,255,255,255,1,255,254,149,1,255,255,255,1,255,254,149,1,255,255,255,1,255,254,149,1,160,130,35,1,255,0,0,4,160,130,35,1,255,255,255,1,255,254,149,1,255,255,255,1,255,254,149,1,160,130,35,11,255,254,149,1,255,255,255,1,255,254,149,1,160,130,35,1,223,193,104,9,160,130,35,2,255,255,255,1,255,254,149,1,160,130,35,1,223,193,104,9,160,130,35,1,255,0,0,1,160,130,35,1,255,254,149,1,160,130,35,1,223,193,104,9,160,130,35,1,255,0,0,2,160,130,35,2,223,193,104,9,160,130,35,1,255,0,0,4,160,130,35,10,255,0,0,64);
tep_folderimage20:array[0..212] of byte=(
84,69,65,49,35,15,0,0,0,20,0,0,0,252,252,252,69,160,130,35,4,252,252,252,10,160,130,35,1,255,0,255,4,160,130,35,1,252,252,252,2,160,130,35,3,252,252,252,3,160,130,35,1,255,0,255,6,160,130,35,2,255,255,128,3,160,130,35,4,255,0,255,5,0,255,255,1,160,130,35,2,255,255,128,6,160,130,35,1,255,0,255,3,0,255,255,3,160,130,35,2,255,255,128,6,160,130,35,1,255,0,255,1,0,255,255,5,160,130,35,2,255,255,128,7,160,130,35,1,0,255,255,4,160,130,35,1,252,252,252,1,160,130,35,1,255,255,128,8,160,130,35,4,252,252,252,2,160,130,35,1,255,255,128,11,160,130,35,1,252,252,252,2,160,130,35,1,255,255,128,11,160,130,35,1,252,252,252,2,160,130,35,2,255,255,128,10,160,130,35,1,252,252,252,3,160,130,35,12,252,252,252,62);
tep_desktop20:array[0..824] of byte=(
84,69,65,49,35,20,0,0,0,20,0,0,0,0,255,0,34,180,220,250,1,65,135,206,2,0,255,0,8,172,192,192,1,65,135,206,4,180,220,250,2,131,197,248,1,68,172,247,1,131,197,248,3,94,99,107,1,0,255,0,3,172,192,192,1,65,135,206,3,131,197,248,2,180,220,250,1,131,197,248,1,68,172,247,2,131,197,248,1,180,220,250,1,232,247,253,1,65,135,206,1,131,197,248,2,94,99,107,1,0,255,0,2,65,135,206,1,180,220,250,1,68,172,247,2,65,135,206,1,255,255,247,10,65,135,206,1,68,172,247,1,94,99,107,1,0,255,0,2,48,98,172,1,131,197,248,1,68,172,247,1,65,135,206,1,255,255,247,3,232,247,253,1,180,220,250,1,68,172,247,2,131,197,248,2,68,172,247,1,255,255,247,2,131,197,248,1,54,68,111,1,0,255,0,2,48,98,172,1,131,197,248,1,68,172,247,2,255,255,247,2,68,172,247,1,131,197,248,2,255,255,247,1,232,247,253,2,180,220,250,1,68,172,247,1,255,255,247,3,54,68,111,1,135,107,109,1,0,255,0,1,48,98,172,1,131,197,248,1,180,220,250,1,255,255,247,3,68,172,247,1,255,255,247,2,232,247,253,3,180,220,250,1,68,172,247,1,251,251,226,1,65,135,206,1,48,98,172,1,49,54,
68,1,135,107,109,2,48,98,172,1,131,197,248,1,251,251,226,4,68,172,247,1,255,255,247,2,232,247,253,3,180,220,250,1,68,172,247,1,65,135,206,1,180,220,250,1,172,192,192,1,135,107,109,1,49,54,68,1,94,99,107,1,48,98,172,1,131,197,248,1,251,251,226,4,68,172,247,1,232,247,253,4,65,135,206,1,180,220,250,2,131,197,248,1,48,98,172,1,131,197,248,1,54,68,111,1,135,107,109,1,0,255,0,1,65,135,206,2,251,251,226,4,68,172,247,1,232,247,253,3,49,54,68,1,135,107,109,1,65,135,206,2,251,251,226,3,3,69,169,1,172,192,192,1,0,255,0,1,65,135,206,2,255,247,206,4,68,172,247,1,232,247,253,3,68,172,247,1,172,192,192,1,131,197,248,1,68,172,247,1,255,247,206,3,3,69,169,1,135,107,109,1,0,255,0,1,172,192,192,1,65,135,206,1,255,247,206,4,68,172,247,1,232,247,253,2,180,220,250,1,131,197,248,1,68,172,247,1,131,197,248,1,68,172,247,1,255,247,206,2,172,192,192,1,3,69,169,1,135,107,109,1,0,255,0,1,172,192,192,1,65,135,206,1,255,247,206,4,68,172,247,1,232,247,253,1,180,220,250,3,131,197,248,2,68,172,247,1,255,247,206,2,48,98,172,1,3,69,
169,1,135,107,109,1,0,255,0,1,172,192,192,1,48,98,172,1,255,247,206,4,68,172,247,1,180,220,250,3,131,197,248,2,172,192,192,2,255,247,206,1,3,69,169,3,135,107,109,1,0,255,0,2,48,98,172,1,65,135,206,1,255,247,206,4,172,192,192,1,255,247,206,5,172,192,192,1,65,135,206,1,3,69,169,2,54,68,111,1,172,192,192,1,0,255,0,2,3,69,169,2,65,135,206,1,255,247,206,6,172,192,192,1,65,135,206,1,3,69,169,3,54,68,111,1,94,99,107,1,135,107,109,1,0,255,0,3,3,69,169,4,65,135,206,2,3,69,169,2,54,68,111,1,94,99,107,2,135,107,109,1,172,192,192,1,0,255,0,7,3,69,169,6,54,68,111,1,94,99,107,1,135,107,109,1,0,255,0,11,172,192,192,1,94,99,107,2,172,192,192,1,0,255,0,15);
tep_startmenu20:array[0..232] of byte=(
84,69,65,49,35,16,0,0,0,20,0,0,0,0,255,0,59,129,129,129,5,0,255,0,5,129,129,129,6,254,255,255,4,129,129,129,1,0,255,0,2,129,129,129,3,254,255,255,2,129,129,129,1,254,255,255,7,129,129,129,3,254,255,255,5,129,129,129,1,254,255,255,7,129,129,129,2,254,255,255,6,129,129,129,1,254,255,255,7,129,129,129,2,254,255,255,6,129,129,129,1,254,255,255,7,129,129,129,2,254,255,255,6,129,129,129,1,254,255,255,7,129,129,129,18,254,255,255,6,129,129,129,1,254,255,255,7,129,129,129,2,254,255,255,6,129,129,129,1,254,255,255,7,129,129,129,2,254,255,255,6,129,129,129,1,254,255,255,7,129,129,129,2,254,255,255,6,129,129,129,1,254,255,255,7,129,129,129,3,254,255,255,5,129,129,129,1,254,255,255,7,129,129,129,1,0,255,0,2,129,129,129,6,254,255,255,7,129,129,129,1,0,255,0,8,129,129,129,8,0,255,0,32);
tep_programs20:array[0..624] of byte=(
84,69,65,49,35,15,0,0,0,20,0,0,0,132,255,255,32,195,142,38,4,132,255,255,10,195,142,38,1,255,255,255,4,195,142,38,1,132,255,255,8,195,142,38,1,255,255,255,1,244,230,168,2,248,222,123,1,244,230,168,1,255,255,255,1,181,127,24,2,160,129,61,1,181,127,24,3,132,255,255,2,195,142,38,1,244,230,168,1,248,222,123,2,244,230,168,1,248,222,123,1,244,230,168,1,255,255,255,5,181,127,24,1,132,255,255,2,195,142,38,1,248,222,123,2,195,142,38,7,181,127,24,4,132,255,255,1,195,142,38,1,248,222,123,1,194,155,102,1,16,107,173,5,0,90,165,1,16,107,173,2,57,115,181,2,96,137,102,1,86,86,74,1,195,142,38,1,248,222,123,1,160,129,61,1,101,167,194,1,107,181,231,1,123,181,222,3,107,181,231,1,123,181,222,2,132,189,222,1,140,189,231,1,181,206,222,1,86,86,74,1,195,142,38,1,248,222,123,1,160,129,61,1,198,206,206,1,107,145,16,1,96,137,102,1,239,239,222,1,248,222,123,1,160,129,61,1,223,225,219,1,239,239,222,1,198,167,172,1,101,167,194,1,239,239,222,1,160,129,61,1,195,142,38,1,248,222,123,1,160,129,61,1,198,206,206,1,107,145,16,1,194,
155,102,1,239,239,222,1,198,167,172,1,194,155,102,1,198,167,172,1,239,239,222,1,194,155,102,1,198,167,172,1,223,225,219,1,160,129,61,1,195,142,38,1,248,222,123,1,160,129,61,1,198,206,206,2,223,225,219,1,239,239,222,1,198,206,206,2,223,225,219,1,239,239,222,1,198,167,172,1,202,214,218,1,239,239,222,1,96,137,102,1,181,127,24,1,248,222,123,1,160,129,61,1,198,167,172,1,248,222,123,1,244,230,168,1,223,225,219,1,239,239,222,1,123,181,222,1,223,225,219,1,239,239,222,1,194,155,102,1,198,167,172,1,239,239,222,1,160,129,61,1,132,255,255,1,181,127,24,1,86,86,74,1,198,206,206,1,96,137,102,1,198,167,172,1,239,239,222,1,198,206,206,1,96,137,102,1,202,214,218,1,239,239,222,1,57,115,181,1,194,155,102,1,239,239,222,1,78,94,119,1,132,255,255,2,86,86,74,1,198,206,206,1,248,222,123,2,239,239,222,1,181,206,222,1,107,181,231,1,223,225,219,1,239,239,222,1,194,155,102,1,198,167,172,1,239,239,222,1,78,94,119,1,132,255,255,3,198,206,206,1,223,225,219,2,239,239,222,3,223,225,219,1,239,239,222,1,244,230,168,1,239,239,222,2,
78,94,119,1,132,255,255,3,78,94,119,1,41,65,94,2,33,57,82,6,33,49,82,2,132,255,255,46);
tep_color20:array[0..188] of byte=(
84,69,65,49,35,16,0,0,0,20,0,0,0,192,192,192,37,125,125,255,3,255,255,0,3,192,192,192,8,125,125,255,5,255,255,0,5,192,192,192,5,125,125,255,6,255,255,0,6,192,192,192,3,125,125,255,7,255,255,0,7,192,192,192,2,125,125,255,7,255,255,0,7,192,192,192,1,125,125,255,8,255,255,0,8,125,125,255,8,255,255,0,8,125,125,255,8,255,255,0,8,0,255,0,8,255,0,255,8,0,255,0,8,255,0,255,8,0,255,0,8,255,0,255,8,192,192,192,1,0,255,0,7,255,0,255,7,192,192,192,2,0,255,0,7,255,0,255,7,192,192,192,3,0,255,0,6,255,0,255,6,192,192,192,5,0,255,0,5,255,0,255,5,192,192,192,8,0,255,0,3,255,0,255,3,192,192,192,37);
tep_colors20:array[0..248] of byte=(
84,69,65,49,35,18,0,0,0,20,0,0,0,255,255,255,56,255,198,255,14,255,255,255,3,255,198,255,1,255,144,199,3,255,198,255,4,255,144,199,4,255,198,255,4,255,255,255,1,255,198,255,1,255,144,199,4,255,198,255,4,255,144,199,4,255,198,255,6,255,144,199,4,255,198,255,4,255,144,199,4,255,198,255,6,255,144,199,4,255,198,255,4,255,144,199,4,255,198,255,10,255,144,199,4,255,198,255,4,255,144,199,4,255,198,255,6,255,144,199,4,255,198,255,4,255,144,199,4,255,198,255,6,255,144,199,4,255,198,255,4,255,144,199,4,255,198,255,6,255,144,199,4,255,198,255,4,255,144,199,4,255,198,255,2,255,144,199,4,255,198,255,4,255,144,199,4,255,198,255,6,255,144,199,4,255,198,255,4,255,144,199,4,255,198,255,6,255,144,199,4,255,198,255,4,255,144,199,4,255,198,255,5,255,255,255,1,255,198,255,1,255,144,199,3,255,198,255,4,255,144,199,4,255,198,255,4,255,255,255,3,255,198,255,14,255,255,255,56);
tep_colormatrix20:array[0..152] of byte=(
84,69,65,49,35,18,0,0,0,20,0,0,0,255,255,255,56,255,144,199,14,255,255,255,3,255,144,199,1,223,148,255,14,255,144,199,1,255,255,255,1,255,144,199,1,217,138,255,16,255,144,199,2,210,128,255,16,255,144,199,2,204,118,255,16,255,144,199,2,197,108,255,16,255,144,199,2,191,98,255,16,255,144,199,2,185,89,255,16,255,144,199,2,178,79,255,16,255,144,199,2,172,69,255,16,255,144,199,2,166,59,255,16,255,144,199,2,159,49,255,16,255,144,199,1,255,255,255,1,255,144,199,1,153,39,255,14,255,144,199,1,255,255,255,3,255,144,199,14,255,255,255,56);
tep_colorpal20:array[0..168] of byte=(
84,69,65,49,35,40,0,0,0,20,0,0,0,255,255,255,82,0,0,1,36,255,255,255,3,0,0,1,1,0,0,0,36,0,0,1,1,255,255,255,1,0,0,1,1,0,0,0,38,0,0,1,2,0,0,0,38,0,0,1,2,0,0,0,38,0,0,1,2,0,0,0,38,0,0,1,2,0,0,0,38,0,0,1,2,0,0,0,38,0,0,1,2,0,0,0,38,0,0,1,2,0,0,0,38,0,0,1,2,0,0,0,38,0,0,1,2,0,0,0,38,0,0,1,2,0,0,0,38,0,0,1,2,0,0,0,38,0,0,1,1,255,255,255,1,0,0,1,1,0,0,0,36,0,0,1,1,255,255,255,3,0,0,1,36,255,255,255,82);
tep_colorhistory20:array[0..440] of byte=(
84,69,65,49,35,18,0,0,0,20,0,0,0,255,255,255,56,255,198,255,14,255,255,255,3,255,198,255,1,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,1,255,255,255,1,255,198,255,1,255,144,199,3,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,3,255,144,199,3,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,3,255,144,199,3,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,3,255,144,199,3,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,3,255,144,199,3,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,3,255,144,199,3,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,3,255,144,199,3,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,
3,255,144,199,3,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,3,255,144,199,3,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,3,255,144,199,3,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,2,255,255,255,1,255,198,255,1,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,1,255,255,255,3,255,198,255,14,255,255,255,56);
tep_schemes20:array[0..412] of byte=(
84,69,65,49,35,16,0,0,0,20,0,0,0,0,255,0,67,74,156,115,2,0,255,0,2,210,45,197,2,0,255,0,2,132,132,8,2,0,255,0,6,74,156,115,2,0,255,0,2,210,45,197,2,0,255,0,2,132,132,8,2,0,255,0,5,74,156,115,3,0,255,0,1,210,45,197,3,0,255,0,1,132,132,8,4,0,255,0,4,74,156,115,1,190,250,234,2,74,156,115,1,210,45,197,1,255,196,196,2,210,45,197,1,132,132,8,1,237,240,32,2,132,132,8,2,0,255,0,2,74,156,115,1,190,250,234,3,210,45,197,1,255,196,196,3,132,132,8,1,237,240,32,4,132,132,8,1,0,255,0,2,74,156,115,1,190,250,234,3,210,45,197,1,255,196,196,3,132,132,8,1,237,240,32,4,132,132,8,1,0,255,0,1,74,156,115,1,190,250,234,3,210,45,197,1,255,196,196,3,132,132,8,1,237,240,32,6,132,132,8,1,74,156,115,1,190,250,234,3,210,45,197,1,255,196,196,3,132,132,8,1,237,240,32,6,132,132,8,1,74,156,115,1,190,250,234,3,210,45,197,1,255,196,196,3,132,132,8,1,237,240,32,6,132,132,8,1,74,156,115,1,190,250,234,3,210,45,197,1,255,196,196,3,132,132,8,1,237,240,32,6,132,132,8,1,74,156,115,1,190,250,234,3,210,45,197,1,255,196,196,3,132,132,8,1,237,
240,32,6,132,132,8,1,74,156,115,1,190,250,234,3,210,45,197,1,255,196,196,3,132,132,8,1,237,240,32,6,132,132,8,1,0,255,0,1,74,156,115,1,190,250,234,3,210,45,197,1,255,196,196,3,132,132,8,1,237,240,32,4,132,132,8,1,0,255,0,3,74,156,115,4,210,45,197,4,132,132,8,4,0,255,0,34);
tep_font20:array[0..328] of byte=(
84,69,65,49,35,22,0,0,0,20,0,0,0,252,252,252,93,255,115,185,3,252,252,252,5,255,115,185,2,252,252,252,12,255,115,185,3,252,252,252,5,255,115,185,2,252,252,252,11,255,115,185,2,252,252,252,1,255,115,185,2,252,252,252,4,255,115,185,2,252,252,252,11,255,115,185,2,252,252,252,1,255,115,185,2,252,252,252,4,255,115,185,2,252,252,252,1,255,115,185,3,252,252,252,7,255,115,185,2,252,252,252,1,255,115,185,2,252,252,252,4,255,115,185,7,252,252,252,5,0,128,255,2,252,252,252,3,0,128,255,2,252,252,252,3,255,115,185,3,252,252,252,2,255,115,185,3,252,252,252,4,0,128,255,2,252,252,252,3,0,128,255,2,252,252,252,3,255,115,185,2,252,252,252,4,255,115,185,2,252,252,252,4,0,128,255,7,252,252,252,3,255,115,185,2,252,252,252,4,0,128,255,2,252,252,252,3,0,128,255,9,252,252,252,2,0,128,255,2,252,252,252,4,0,128,255,2,252,252,252,3,0,128,255,2,252,252,252,5,0,128,255,2,252,252,252,2,0,128,255,3,252,252,252,2,0,128,255,3,252,252,252,3,0,128,255,2,252,252,252,5,0,128,255,2,252,252,252,2,0,128,255,7,252,252,252,3,0,128,255,2,
252,252,252,7,0,128,255,2,252,252,252,1,0,128,255,2,252,252,252,1,0,128,255,3,252,252,252,91);
tep_cut20:array[0..232] of byte=(
84,69,65,49,35,9,0,0,0,20,0,0,0,192,192,192,29,255,128,0,1,192,192,192,3,255,128,0,1,192,192,192,4,255,128,0,1,192,192,192,3,255,128,0,1,192,192,192,4,255,128,0,1,192,192,192,3,255,128,0,1,192,192,192,4,255,128,0,2,192,192,192,1,255,128,0,2,192,192,192,5,255,128,0,1,192,192,192,1,255,128,0,1,192,192,192,6,255,128,0,3,192,192,192,7,255,128,0,1,192,192,192,7,255,128,0,3,192,192,192,6,128,0,255,1,192,192,192,1,128,0,255,3,192,192,192,2,128,0,255,3,192,192,192,1,128,0,255,1,192,192,192,2,128,0,255,2,192,192,192,2,128,0,255,1,192,192,192,1,128,0,255,1,192,192,192,2,128,0,255,2,192,192,192,2,128,0,255,1,192,192,192,1,128,0,255,1,192,192,192,2,128,0,255,2,192,192,192,2,128,0,255,1,192,192,192,2,128,0,255,2,192,192,192,2,128,0,255,2,192,192,192,33);
tep_copy20:array[0..320] of byte=(
84,69,65,49,35,15,0,0,0,20,0,0,0,255,0,0,46,64,138,213,5,255,0,0,9,64,138,213,1,217,235,255,4,64,138,213,2,255,0,0,8,64,138,213,1,217,235,255,4,64,138,213,1,217,235,255,1,64,138,213,1,255,0,0,7,64,138,213,1,217,235,255,1,64,138,213,2,217,235,255,1,64,138,213,7,255,0,0,3,64,138,213,1,217,235,255,5,64,138,213,1,217,235,255,4,64,138,213,2,255,0,0,2,64,138,213,1,217,235,255,1,64,138,213,5,217,235,255,4,64,138,213,1,217,235,255,1,64,138,213,1,255,0,0,1,64,138,213,1,217,235,255,5,64,138,213,1,217,235,255,1,64,138,213,2,217,235,255,1,64,138,213,5,217,235,255,1,64,138,213,5,217,235,255,7,64,138,213,2,217,235,255,5,64,138,213,1,217,235,255,1,64,138,213,5,217,235,255,1,64,138,213,2,217,235,255,1,64,138,213,5,217,235,255,7,64,138,213,2,217,235,255,5,64,138,213,1,217,235,255,1,64,138,213,5,217,235,255,1,64,138,213,1,255,0,0,1,64,138,213,6,217,235,255,7,64,138,213,1,255,0,0,6,64,138,213,1,217,235,255,1,64,138,213,5,217,235,255,1,64,138,213,1,255,0,0,6,64,138,213,1,217,235,
255,7,64,138,213,1,255,0,0,7,64,138,213,7,255,0,0,31);
tep_selectall20:array[0..216] of byte=(
84,69,65,49,35,11,0,0,0,20,0,0,0,192,192,192,34,64,138,213,7,192,192,192,3,64,138,213,1,217,235,255,6,64,138,213,2,192,192,192,2,64,138,213,1,217,235,255,6,64,138,213,1,217,235,255,1,64,138,213,1,192,192,192,1,64,138,213,1,217,235,255,1,64,138,213,4,217,235,255,2,64,138,213,4,217,235,255,1,64,138,213,5,217,235,255,3,64,138,213,2,217,235,255,1,64,138,213,6,217,235,255,2,64,138,213,2,217,235,255,1,64,138,213,7,217,235,255,1,64,138,213,2,217,235,255,1,64,138,213,7,217,235,255,1,64,138,213,2,217,235,255,1,64,138,213,7,217,235,255,1,64,138,213,2,217,235,255,1,64,138,213,7,217,235,255,1,64,138,213,2,217,235,255,1,64,138,213,7,217,235,255,1,64,138,213,2,217,235,255,9,64,138,213,1,192,192,192,1,64,138,213,9,192,192,192,45);
tep_blank20:array[0..20] of byte=(
84,69,65,49,35,20,0,0,0,20,0,0,0,245,150,0,250,245,150,0,150);
tep_clock20:array[0..280] of byte=(
84,69,65,49,35,15,0,0,0,20,0,0,0,0,255,0,50,0,0,255,5,0,255,0,8,0,0,255,2,253,253,253,5,0,0,255,2,0,255,0,5,0,0,255,1,253,253,253,4,0,0,0,1,253,253,253,4,0,0,255,1,0,255,0,3,0,0,255,1,253,253,253,5,0,0,0,1,253,253,253,5,0,0,255,1,0,255,0,2,0,0,255,1,253,253,253,5,0,0,0,1,253,253,253,5,0,0,255,1,0,255,0,1,0,0,255,1,253,253,253,6,0,0,0,1,253,253,253,6,0,0,255,2,253,253,253,6,0,0,0,1,253,253,253,6,0,0,255,3,253,253,253,4,0,0,0,6,253,253,253,1,0,0,255,3,253,253,253,6,0,0,0,1,253,253,253,6,0,0,255,2,253,253,253,6,0,0,0,1,253,253,253,6,0,0,255,1,0,255,0,1,0,0,255,1,253,253,253,11,0,0,255,1,0,255,0,2,0,0,255,1,253,253,253,11,0,0,255,1,0,255,0,3,0,0,255,1,253,253,253,9,0,0,255,1,0,255,0,5,0,0,255,2,253,253,253,2,0,0,255,1,253,253,253,2,0,0,255,2,0,255,0,8,0,0,255,5,0,255,0,35);
tep_alert20:array[0..296] of byte=(
84,69,65,49,35,14,0,0,0,20,0,0,0,0,255,0,34,128,0,255,2,0,255,0,12,128,0,255,2,0,255,0,11,128,0,255,1,255,255,199,2,128,0,255,1,0,255,0,10,128,0,255,1,255,255,199,2,128,0,255,1,0,255,0,9,128,0,255,1,255,255,199,4,128,0,255,1,0,255,0,8,128,0,255,1,255,255,199,1,255,0,128,2,255,255,199,1,128,0,255,1,0,255,0,7,128,0,255,1,255,255,199,2,255,0,128,2,255,255,199,2,128,0,255,1,0,255,0,6,128,0,255,1,255,255,199,2,255,0,128,2,255,255,199,2,128,0,255,1,0,255,0,5,128,0,255,1,255,255,199,3,255,0,128,2,255,255,199,3,128,0,255,1,0,255,0,4,128,0,255,1,255,255,199,3,255,0,128,2,255,255,199,3,128,0,255,1,0,255,0,3,128,0,255,1,255,255,199,4,255,0,128,2,255,255,199,4,128,0,255,1,0,255,0,2,128,0,255,1,255,255,199,10,128,0,255,1,0,255,0,2,128,0,255,1,255,255,199,4,255,0,128,2,255,255,199,4,128,0,255,1,0,255,0,1,128,0,255,1,255,255,199,5,255,0,128,2,255,255,199,5,128,0,255,2,255,255,199,12,128,0,255,15,0,255,0,28);
tep_left20:array[0..288] of byte=(
84,69,65,49,35,20,0,0,0,20,0,0,0,0,255,128,22,85,0,170,7,0,255,128,12,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,12,85,0,170,7,0,255,128,31);
tep_right20:array[0..288] of byte=(
84,69,65,49,35,20,0,0,0,20,0,0,0,0,255,128,31,85,0,170,7,0,255,128,12,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,11,85,0,170,1,128,0,255,7,85,0,170,1,0,255,128,12,85,0,170,7,0,255,128,22);
tep_top20:array[0..144] of byte=(
84,69,65,49,35,20,0,0,0,20,0,0,0,0,255,128,22,85,0,170,16,0,255,128,3,85,0,170,1,128,0,255,16,85,0,170,1,0,255,128,2,85,0,170,1,128,0,255,16,85,0,170,1,0,255,128,2,85,0,170,1,128,0,255,16,85,0,170,1,0,255,128,2,85,0,170,1,128,0,255,16,85,0,170,1,0,255,128,2,85,0,170,1,128,0,255,16,85,0,170,1,0,255,128,2,85,0,170,1,128,0,255,16,85,0,170,1,0,255,128,2,85,0,170,1,128,0,255,16,85,0,170,1,0,255,128,3,85,0,170,16,0,255,128,202);
tep_bottom20:array[0..144] of byte=(
84,69,65,49,35,20,0,0,0,20,0,0,0,0,255,128,202,85,0,170,16,0,255,128,3,85,0,170,1,128,0,255,16,85,0,170,1,0,255,128,2,85,0,170,1,128,0,255,16,85,0,170,1,0,255,128,2,85,0,170,1,128,0,255,16,85,0,170,1,0,255,128,2,85,0,170,1,128,0,255,16,85,0,170,1,0,255,128,2,85,0,170,1,128,0,255,16,85,0,170,1,0,255,128,2,85,0,170,1,128,0,255,16,85,0,170,1,0,255,128,2,85,0,170,1,128,0,255,16,85,0,170,1,0,255,128,3,85,0,170,16,0,255,128,22);
tep_frame20:array[0..248] of byte=(
84,69,65,49,35,18,0,0,0,20,0,0,0,255,255,255,38,128,0,255,15,255,255,255,2,128,0,255,15,255,255,255,3,128,0,255,2,255,0,255,13,255,255,255,3,128,0,255,2,255,0,255,12,255,255,255,4,128,0,255,2,255,0,255,2,219,219,0,9,255,255,255,5,128,0,255,2,255,0,255,2,219,219,0,8,255,255,255,6,128,0,255,2,255,0,255,2,219,219,0,2,255,255,255,12,128,0,255,2,255,0,255,2,219,219,0,2,255,255,255,12,128,0,255,2,255,0,255,2,219,219,0,2,255,255,255,12,128,0,255,2,255,0,255,2,219,219,0,2,255,255,255,12,128,0,255,2,255,0,255,2,219,219,0,2,255,255,255,12,128,0,255,2,255,0,255,2,219,219,0,2,255,255,255,12,128,0,255,2,255,0,255,2,219,219,0,2,255,255,255,12,128,0,255,2,255,0,255,2,219,219,0,1,255,255,255,13,128,0,255,2,255,0,255,2,255,255,255,14,128,0,255,2,255,0,255,1,255,255,255,15,128,0,255,1,255,255,255,34);
tep_wine20:array[0..420] of byte=(
84,69,65,49,35,14,0,0,0,20,0,0,0,0,255,255,17,173,168,166,1,186,182,179,4,145,149,146,1,0,255,255,6,146,149,147,1,186,182,179,1,242,233,232,5,186,182,179,1,0,255,255,6,186,182,179,1,242,233,232,4,230,213,214,1,212,192,191,1,163,148,148,1,0,255,255,6,162,165,162,1,220,216,214,1,242,233,232,2,235,219,219,1,217,186,189,1,151,66,78,1,122,39,52,1,0,255,255,7,196,183,183,1,221,201,202,1,222,200,200,1,214,175,179,1,147,50,63,1,132,20,39,1,116,8,26,1,93,19,29,1,0,255,255,6,138,81,89,1,196,150,156,1,175,109,117,1,152,42,57,1,148,18,37,1,137,3,23,1,129,6,25,1,105,13,28,1,0,255,255,6,106,47,56,1,168,108,119,1,160,55,71,1,159,20,37,1,160,3,20,1,155,3,21,1,142,4,24,1,107,10,25,1,0,255,255,7,130,51,66,1,183,95,108,1,173,26,43,1,171,2,18,2,150,3,22,1,110,9,25,1,0,255,255,7,106,31,45,1,168,86,98,1,181,48,62,1,171,2,18,2,152,3,21,1,110,10,25,1,0,255,255,8,128,40,54,1,179,75,88,1,167,14,31,1,160,4,21,1,145,5,24,1,109,13,28,1,0,255,255,8,137,115,116,1,132,37,53,1,151,29,47,1,143,4,24,1,127,8,25,1,100,21,34,1,0,255,
255,9,113,90,93,1,119,33,48,1,132,36,52,1,123,38,51,1,0,255,255,12,151,132,133,1,143,133,132,1,0,255,255,13,141,148,144,1,0,255,255,13,122,131,127,1,0,255,255,13,141,147,143,1,0,255,255,13,169,174,170,1,168,173,168,1,0,255,255,11,184,182,179,1,194,200,194,6,0,255,255,5,160,149,148,1,194,200,194,6,0,255,255,2);
tep_zoom20:array[0..380] of byte=(
84,69,65,49,35,20,0,0,0,20,0,0,0,192,192,192,6,0,0,255,4,192,192,192,14,0,0,255,2,255,255,170,4,0,0,255,2,192,192,192,11,0,0,255,1,255,255,170,2,255,255,255,4,255,255,170,1,215,215,0,1,0,0,255,1,192,192,192,9,0,0,255,1,255,255,170,1,255,255,255,7,255,255,170,2,0,0,255,1,192,192,192,7,0,0,255,1,215,215,0,1,255,255,170,1,255,255,255,8,255,255,170,2,0,0,255,1,192,192,192,6,0,0,255,1,215,215,0,1,255,255,255,10,255,255,170,1,0,0,255,1,192,192,192,5,0,0,255,1,215,215,0,1,255,255,255,12,255,255,170,1,0,0,255,1,192,192,192,4,0,0,255,1,215,215,0,1,255,255,255,12,255,255,170,1,0,0,255,1,192,192,192,4,0,0,255,1,215,215,0,1,255,255,255,12,255,255,170,1,0,0,255,1,192,192,192,5,0,0,255,1,215,215,0,1,255,255,255,10,215,215,0,1,0,0,255,1,192,192,192,6,0,0,255,1,215,215,0,2,255,255,255,8,215,215,0,2,0,0,255,1,192,192,192,7,0,0,255,1,215,215,0,2,255,255,255,6,215,215,0,2,0,0,255,1,192,192,192,9,0,0,255,1,215,215,0,2,255,255,255,4,215,215,0,2,0,0,255,3,192,192,192,9,0,0,255,2,215,215,0,4,0,0,255,6,192,192,192,10,0,
0,255,4,192,192,192,3,0,0,255,4,192,192,192,17,0,0,255,4,192,192,192,17,0,0,255,4,192,192,192,17,0,0,255,4,192,192,192,17,0,0,255,3,192,192,192,18,0,0,255,2);
tep_sizeto20:array[0..208] of byte=(
84,69,65,49,35,16,0,0,0,20,0,0,0,255,0,0,49,64,138,213,14,255,0,0,1,64,138,213,33,255,255,255,14,64,138,213,2,255,255,255,14,64,138,213,2,255,255,255,3,64,138,213,1,255,255,255,10,64,138,213,2,255,255,255,2,64,138,213,3,255,255,255,9,64,138,213,2,255,255,255,1,64,138,213,5,255,255,255,8,64,138,213,2,255,255,255,3,64,138,213,1,255,255,255,5,64,138,213,1,255,255,255,4,64,138,213,2,255,255,255,3,64,138,213,1,255,255,255,5,64,138,213,2,255,255,255,3,64,138,213,2,255,255,255,3,64,138,213,9,255,255,255,2,64,138,213,2,255,255,255,9,64,138,213,2,255,255,255,3,64,138,213,2,255,255,255,9,64,138,213,1,255,255,255,4,64,138,213,2,255,255,255,14,64,138,213,1,255,0,0,1,64,138,213,14,255,0,0,33);
tep_upper20:array[0..172] of byte=(
84,69,65,49,35,13,0,0,0,20,0,0,0,252,252,252,54,107,30,224,6,252,252,252,7,107,30,224,6,252,252,252,9,107,30,224,2,252,252,252,1,107,30,224,2,252,252,252,8,107,30,224,2,252,252,252,1,107,30,224,2,252,252,252,7,107,30,224,3,252,252,252,1,107,30,224,3,252,252,252,6,107,30,224,2,252,252,252,3,107,30,224,2,252,252,252,6,107,30,224,2,252,252,252,3,107,30,224,2,252,252,252,5,107,30,224,4,255,0,128,5,252,252,252,4,255,0,128,9,252,252,252,3,255,0,128,2,252,252,252,7,255,0,128,2,252,252,252,1,255,0,128,5,252,252,252,3,255,0,128,10,252,252,252,3,255,0,128,5,252,252,252,52);
tep_lower20:array[0..120] of byte=(
84,69,65,49,35,11,0,0,0,20,0,0,0,252,252,252,79,0,128,255,7,252,252,252,3,0,128,255,9,252,252,252,9,0,128,255,2,252,252,252,4,0,128,255,7,252,252,252,2,255,128,0,5,0,128,255,4,252,252,252,1,255,128,0,3,252,252,252,5,255,128,0,1,0,128,255,1,252,252,252,1,255,128,0,2,252,252,252,5,255,128,0,3,252,252,252,1,255,128,0,11,252,252,252,1,255,128,0,6,252,252,252,1,255,128,0,3,252,252,252,44);
tep_name20:array[0..300] of byte=(
84,69,65,49,35,19,0,0,0,20,0,0,0,252,252,252,88,255,0,128,2,252,252,252,9,128,0,255,3,252,252,252,5,255,0,128,2,252,252,252,9,128,0,255,3,252,252,252,5,255,0,128,2,252,252,252,8,128,0,255,2,252,252,252,1,128,0,255,2,252,252,252,4,255,0,128,2,252,252,252,8,128,0,255,2,252,252,252,1,128,0,255,2,252,252,252,4,255,0,128,2,252,252,252,1,255,0,128,3,252,252,252,3,128,0,255,3,252,252,252,1,128,0,255,3,252,252,252,3,255,0,128,7,252,252,252,2,128,0,255,2,252,252,252,3,128,0,255,2,252,252,252,3,255,0,128,2,252,252,252,3,255,0,128,2,252,252,252,2,128,0,255,7,252,252,252,3,255,0,128,2,252,252,252,3,255,0,128,2,252,252,252,1,128,0,255,9,252,252,252,2,255,0,128,2,252,252,252,3,255,0,128,2,252,252,252,1,128,0,255,2,252,252,252,5,128,0,255,2,252,252,252,2,255,0,128,2,252,252,252,3,255,0,128,2,128,0,255,3,252,252,252,5,128,0,255,3,252,252,252,1,255,0,128,6,252,252,252,1,128,0,255,2,252,252,252,7,128,0,255,2,252,252,252,1,255,0,128,2,252,252,252,1,255,0,128,3,252,252,252,77);
tep_eye20:array[0..408] of byte=(
84,69,65,49,35,15,0,0,0,20,0,0,0,0,255,64,49,255,155,205,4,0,255,64,10,255,155,205,1,255,0,128,4,255,155,205,1,0,255,64,8,255,155,205,1,255,0,128,1,255,155,205,4,255,0,128,1,255,155,205,1,0,255,64,6,255,155,205,1,255,0,128,1,255,155,205,1,0,255,64,1,255,155,205,1,0,255,64,2,255,155,205,1,255,0,128,1,255,155,205,1,0,255,64,4,255,155,205,1,255,0,128,1,255,155,205,1,0,255,64,1,255,155,205,1,255,0,128,1,255,155,205,1,0,255,64,2,255,155,205,1,255,0,128,1,255,155,205,1,0,255,64,3,255,155,205,1,255,0,128,1,255,155,205,2,255,0,128,1,255,155,205,1,0,255,64,3,255,155,205,1,255,0,128,1,255,155,205,1,0,255,64,3,255,155,205,1,255,0,128,1,255,155,205,1,0,255,64,1,255,155,205,1,0,255,64,4,255,155,205,1,255,0,128,1,255,155,205,1,0,255,64,3,255,155,205,1,255,0,128,1,255,155,205,1,0,255,64,6,255,155,205,1,255,0,128,1,255,155,205,1,0,255,64,4,255,155,205,1,255,0,128,1,255,155,205,1,0,255,64,4,255,155,205,1,255,0,128,1,255,155,205,1,0,255,64,6,255,155,205,1,255,0,128,1,255,155,205,4,255,0,128,3,255,155,205,1,0,255,
64,6,255,155,205,1,255,0,128,4,255,155,205,1,255,0,128,3,255,155,205,1,0,255,64,6,255,155,205,4,0,255,64,1,255,155,205,1,255,0,128,3,255,155,205,1,0,255,64,11,255,155,205,1,255,0,128,3,255,155,205,1,0,255,64,11,255,155,205,1,255,0,128,2,255,155,205,1,0,255,64,12,255,155,205,2,0,255,64,31);
tep_panel20:array[0..96] of byte=(84,69,65,49,35,14,0,0,0,20,0,0,0,128,255,0,43,0,0,0,12,128,255,0,1,0,0,0,1,128,255,0,12,0,0,0,2,128,255,0,12,0,0,0,2,128,255,0,12,0,0,0,2,128,255,0,12,0,0,0,2,128,255,0,12,0,0,0,2,128,255,0,12,0,0,0,2,128,255,0,12,0,0,0,71,128,255,0,1,0,0,0,12,128,255,0,43);
tep_prev20:array[0..272] of byte=(
84,69,65,49,35,18,0,0,0,20,0,0,0,0,255,0,26,211,173,9,2,0,255,0,15,211,173,9,1,255,209,11,1,211,173,9,1,0,255,0,14,211,173,9,1,255,209,11,2,211,173,9,1,0,255,0,13,211,173,9,1,255,209,11,3,211,173,9,1,0,255,0,12,211,173,9,1,255,209,11,5,211,173,9,7,0,255,0,4,211,173,9,1,255,209,11,12,211,173,9,1,0,255,0,3,211,173,9,1,255,209,11,13,211,173,9,1,0,255,0,2,211,173,9,1,255,209,11,14,211,173,9,1,0,255,0,1,211,173,9,1,255,209,11,15,211,173,9,1,0,255,0,2,211,173,9,1,255,209,11,14,211,173,9,1,0,255,0,3,211,173,9,1,255,209,11,13,211,173,9,1,0,255,0,4,211,173,9,1,255,209,11,12,211,173,9,1,0,255,0,5,211,173,9,1,255,209,11,5,211,173,9,7,0,255,0,6,211,173,9,1,255,209,11,3,211,173,9,1,0,255,0,14,211,173,9,1,255,209,11,2,211,173,9,1,0,255,0,15,211,173,9,1,255,209,11,1,211,173,9,1,0,255,0,16,211,173,9,2,0,255,0,44);
tep_next20:array[0..272] of byte=(
84,69,65,49,35,18,0,0,0,20,0,0,0,0,255,0,26,211,173,9,2,0,255,0,16,211,173,9,1,255,209,11,1,211,173,9,1,0,255,0,15,211,173,9,1,255,209,11,2,211,173,9,1,0,255,0,14,211,173,9,1,255,209,11,3,211,173,9,1,0,255,0,6,211,173,9,7,255,209,11,5,211,173,9,1,0,255,0,5,211,173,9,1,255,209,11,12,211,173,9,1,0,255,0,4,211,173,9,1,255,209,11,13,211,173,9,1,0,255,0,3,211,173,9,1,255,209,11,14,211,173,9,1,0,255,0,2,211,173,9,1,255,209,11,15,211,173,9,1,0,255,0,1,211,173,9,1,255,209,11,14,211,173,9,1,0,255,0,2,211,173,9,1,255,209,11,13,211,173,9,1,0,255,0,3,211,173,9,1,255,209,11,12,211,173,9,1,0,255,0,4,211,173,9,7,255,209,11,5,211,173,9,1,0,255,0,12,211,173,9,1,255,209,11,3,211,173,9,1,0,255,0,13,211,173,9,1,255,209,11,2,211,173,9,1,0,255,0,14,211,173,9,1,255,209,11,1,211,173,9,1,0,255,0,15,211,173,9,2,0,255,0,44);
tep_up20:array[0..144] of byte=(
84,69,65,49,35,17,0,0,0,20,0,0,0,0,255,0,25,255,209,11,1,0,255,0,15,255,209,11,3,0,255,0,13,255,209,11,5,0,255,0,11,255,209,11,7,0,255,0,9,255,209,11,9,0,255,0,7,255,209,11,11,0,255,0,5,255,209,11,13,0,255,0,3,255,209,11,15,0,255,0,1,255,209,11,34,0,255,0,4,255,209,11,9,0,255,0,8,255,209,11,9,0,255,0,8,255,209,11,9,0,255,0,8,255,209,11,9,0,255,0,8,255,209,11,9,0,255,0,8,255,209,11,9,0,255,0,8,255,209,11,9,0,255,0,38);
tep_upone20:array[0..396] of byte=(
84,69,65,49,35,15,0,0,0,20,0,0,0,255,0,0,23,31,125,19,1,255,0,0,13,31,125,19,3,255,0,0,11,31,125,19,1,80,178,50,3,31,125,19,2,255,0,0,8,31,125,19,1,80,178,50,6,31,125,19,1,255,0,0,4,207,163,23,3,31,125,19,3,80,178,50,3,31,125,19,3,255,0,0,2,207,163,23,1,255,255,152,3,207,163,23,3,31,125,19,1,80,178,50,2,31,125,19,1,255,0,0,4,207,163,23,1,255,255,152,6,31,125,19,1,80,178,50,2,31,125,19,1,255,0,0,4,207,163,23,1,255,255,152,5,207,163,23,1,31,125,19,1,80,178,50,3,207,163,23,2,255,0,0,2,207,163,23,1,255,255,152,2,241,218,115,1,239,198,78,2,255,230,144,1,80,178,50,3,203,198,108,1,255,255,152,1,207,163,23,1,255,0,0,2,207,163,23,1,255,255,152,1,239,198,78,1,255,255,152,4,31,125,19,1,80,178,50,1,31,125,19,1,255,255,152,2,207,163,23,1,255,0,0,2,207,163,23,1,255,226,125,1,255,255,152,1,255,255,175,1,255,255,152,2,241,218,115,1,31,125,19,1,80,178,50,2,255,255,152,1,207,163,23,1,255,0,0,3,207,163,23,1,239,198,78,1,255,255,152,4,80,178,50,1,31,125,19,2,241,218,115,1,207,163,23,1,255,0,0,4,207,163,23,1,239,198,
78,1,255,255,152,4,31,125,19,1,80,178,50,1,207,163,23,2,255,0,0,5,207,163,23,1,241,218,115,1,255,255,152,2,239,198,78,2,207,163,23,2,255,0,0,7,207,163,23,1,255,230,144,1,207,163,23,3,255,0,0,10,207,163,23,2,255,0,0,57);
tep_fav20:array[0..368] of byte=(
84,69,65,49,35,20,0,0,0,20,0,0,0,255,0,0,10,222,179,27,1,255,0,0,18,222,179,27,1,255,241,142,1,222,179,27,1,255,0,0,17,222,179,27,1,255,241,142,1,222,179,27,1,255,0,0,17,222,179,27,1,255,241,142,1,222,179,27,1,255,0,0,17,222,179,27,1,255,241,142,1,222,179,27,2,255,0,0,15,222,179,27,1,255,241,142,3,222,179,27,1,255,0,0,15,222,179,27,1,255,241,142,3,222,179,27,1,255,0,0,7,222,179,27,9,255,241,142,3,222,179,27,9,255,241,142,19,255,0,0,1,222,179,27,2,255,241,142,16,222,179,27,1,255,0,0,4,222,179,27,1,255,241,142,10,222,179,27,3,255,0,0,7,222,179,27,2,255,241,142,8,222,179,27,1,255,0,0,9,222,179,27,2,255,241,142,7,222,179,27,1,255,0,0,10,222,179,27,1,255,241,142,9,255,0,0,10,222,179,27,1,255,241,142,9,222,179,27,1,255,0,0,9,222,179,27,1,255,241,142,3,222,179,27,3,255,241,142,3,222,179,27,1,255,0,0,8,222,179,27,2,255,241,142,2,222,179,27,1,255,0,0,3,222,179,27,1,255,241,142,2,222,179,27,2,255,0,0,7,222,179,27,1,255,241,142,2,222,179,27,1,255,0,0,5,222,179,27,1,255,241,142,2,222,179,27,1,255,0,0,7,222,
179,27,1,255,241,142,1,222,179,27,1,255,0,0,7,222,179,27,1,255,241,142,1,222,179,27,1,255,0,0,7,222,179,27,2,255,0,0,9,222,179,27,2,255,0,0,3);
tep_newfolder20:array[0..260] of byte=(
84,69,65,49,35,15,0,0,0,20,0,0,0,252,252,252,55,255,191,191,2,252,252,252,12,255,191,191,1,255,0,0,2,255,191,191,1,252,252,252,9,255,191,191,3,255,0,0,2,255,191,191,3,252,252,252,1,160,130,35,3,252,252,252,2,255,191,191,1,255,0,0,8,160,130,35,1,255,255,128,3,160,130,35,4,255,191,191,1,255,0,0,4,255,191,191,2,160,130,35,1,255,255,128,7,255,191,191,1,255,0,0,4,255,191,191,1,252,252,252,1,160,130,35,1,255,255,128,6,255,191,191,1,255,0,0,2,255,191,191,2,255,0,0,2,255,191,191,1,160,130,35,1,255,255,128,7,255,191,191,1,255,0,0,1,255,191,191,2,255,0,0,1,255,191,191,1,252,252,252,1,160,130,35,1,255,255,128,8,255,191,191,1,255,255,128,2,160,130,35,1,252,252,252,2,160,130,35,1,255,255,128,11,160,130,35,1,252,252,252,2,160,130,35,1,255,255,128,11,160,130,35,1,252,252,252,2,160,130,35,2,255,255,128,10,160,130,35,1,252,252,252,3,160,130,35,12,252,252,252,62);
tep_add20:array[0..184] of byte=(
84,69,65,49,35,12,0,0,0,20,0,0,0,0,255,0,53,255,144,199,2,0,255,0,9,255,144,199,1,255,198,255,2,255,144,199,1,0,255,0,8,255,144,199,1,255,198,255,2,255,144,199,1,0,255,0,8,255,144,199,1,255,198,255,2,255,144,199,1,0,255,0,5,255,144,199,4,255,198,255,2,255,144,199,4,0,255,0,1,255,144,199,1,255,198,255,10,255,144,199,2,255,198,255,10,255,144,199,1,0,255,0,1,255,144,199,4,255,198,255,2,255,144,199,4,0,255,0,5,255,144,199,1,255,198,255,2,255,144,199,1,0,255,0,8,255,144,199,1,255,198,255,2,255,144,199,1,0,255,0,8,255,144,199,1,255,198,255,2,255,144,199,1,0,255,0,9,255,144,199,2,0,255,0,53);
tep_addl20:array[0..120] of byte=(
84,69,65,49,35,17,0,0,0,20,0,0,0,0,255,64,40,255,209,11,5,0,255,64,12,255,209,11,5,0,255,64,12,255,209,11,5,0,255,64,12,255,209,11,5,0,255,64,12,255,209,11,5,0,255,64,12,255,209,11,5,0,255,64,6,255,209,11,85,0,255,64,6,255,209,11,5,0,255,64,12,255,209,11,5,0,255,64,12,255,209,11,5,0,255,64,12,255,209,11,5,0,255,64,12,255,209,11,5,0,255,64,12,255,209,11,5,0,255,64,23);
tep_sub20:array[0..56] of byte=(
84,69,65,49,35,12,0,0,0,20,0,0,0,0,255,0,97,255,144,199,10,0,255,0,1,255,144,199,1,255,198,255,10,255,144,199,2,255,198,255,10,255,144,199,1,0,255,0,1,255,144,199,10,0,255,0,97);
tep_subl20:array[0..24] of byte=(
84,69,65,49,35,17,0,0,0,20,0,0,0,0,255,64,136,255,209,11,85,0,255,64,119);
tep_edit20:array[0..144] of byte=(
84,69,65,49,35,16,0,0,0,20,0,0,0,255,0,0,49,64,138,213,14,255,0,0,1,64,138,213,33,255,255,226,14,64,138,213,2,255,255,222,14,64,138,213,2,255,255,218,14,64,138,213,2,255,255,214,2,64,138,213,10,255,255,214,2,64,138,213,2,255,255,210,14,64,138,213,2,255,255,206,14,64,138,213,2,255,255,202,14,64,138,213,2,255,255,198,2,64,138,213,10,255,255,198,2,64,138,213,2,255,255,194,14,64,138,213,2,255,255,190,14,64,138,213,2,255,255,186,14,64,138,213,1,255,0,0,1,64,138,213,14,255,0,0,33);
tep_favadd20:array[0..184] of byte=(
84,69,65,49,35,12,0,0,0,20,0,0,0,0,255,0,53,255,144,199,2,0,255,0,9,255,144,199,1,255,198,255,2,255,144,199,1,0,255,0,8,255,144,199,1,255,198,255,2,255,144,199,1,0,255,0,8,255,144,199,1,255,198,255,2,255,144,199,1,0,255,0,5,255,144,199,4,255,198,255,2,255,144,199,4,0,255,0,1,255,144,199,1,255,198,255,10,255,144,199,2,255,198,255,10,255,144,199,1,0,255,0,1,255,144,199,4,255,198,255,2,255,144,199,4,0,255,0,5,255,144,199,1,255,198,255,2,255,144,199,1,0,255,0,8,255,144,199,1,255,198,255,2,255,144,199,1,0,255,0,8,255,144,199,1,255,198,255,2,255,144,199,1,0,255,0,9,255,144,199,2,0,255,0,53);
tep_favedit20:array[0..448] of byte=(
84,69,65,49,35,21,0,0,0,20,0,0,0,255,0,0,10,255,144,199,1,255,0,0,19,255,144,199,1,255,198,255,1,255,144,199,1,255,0,0,18,255,144,199,1,255,198,255,1,255,144,199,1,255,0,0,18,255,144,199,1,255,198,255,1,255,144,199,1,255,0,0,18,255,144,199,8,255,0,0,12,255,144,199,2,255,198,255,7,255,144,199,1,255,0,0,11,255,144,199,2,255,198,255,8,255,144,199,1,255,0,0,2,255,144,199,10,255,198,255,9,255,144,199,1,255,0,0,1,255,144,199,1,255,198,255,8,255,144,199,1,255,198,255,10,255,144,199,1,255,0,0,1,255,144,199,2,255,198,255,6,255,144,199,1,255,198,255,10,255,144,199,1,255,0,0,4,255,144,199,1,255,198,255,4,255,144,199,1,255,198,255,2,255,144,199,6,255,198,255,2,255,144,199,1,255,0,0,5,255,144,199,2,255,198,255,2,255,144,199,1,255,198,255,10,255,144,199,1,255,0,0,5,255,144,199,2,255,198,255,2,255,144,199,1,255,198,255,10,255,144,199,1,255,0,0,5,255,144,199,1,255,198,255,3,255,144,199,1,255,198,255,2,255,144,199,6,255,198,255,2,255,144,199,1,255,0,0,5,255,144,199,1,255,198,255,3,255,144,199,1,255,198,255,10,255,
144,199,1,255,0,0,5,255,144,199,1,255,198,255,3,255,144,199,1,255,198,255,10,255,144,199,1,255,0,0,4,255,144,199,2,255,198,255,2,255,144,199,2,255,198,255,2,255,144,199,6,255,198,255,2,255,144,199,1,255,0,0,4,255,144,199,1,255,198,255,2,255,144,199,1,255,0,0,1,255,144,199,1,255,198,255,10,255,144,199,1,255,0,0,4,255,144,199,1,255,198,255,1,255,144,199,1,255,0,0,2,255,144,199,1,255,198,255,10,255,144,199,1,255,0,0,4,255,144,199,2,255,0,0,4,255,144,199,10,255,0,0,1);
tep_undo20:array[0..216] of byte=(
84,69,65,49,35,10,0,0,0,20,0,0,0,255,255,0,25,255,0,255,3,255,255,0,6,255,0,255,1,255,255,0,3,255,0,255,1,255,255,0,4,255,0,255,1,255,255,0,5,255,0,255,1,255,255,0,3,255,0,255,1,255,255,0,5,255,0,255,1,255,255,0,3,255,0,255,1,255,255,0,5,255,0,255,1,255,255,0,3,255,0,255,1,255,255,0,5,255,0,255,1,255,255,0,3,255,0,255,1,255,255,0,5,255,0,255,8,255,255,0,2,255,0,255,1,255,255,0,1,255,0,255,5,255,255,0,3,255,0,255,1,255,255,0,2,255,0,255,3,255,255,0,4,255,0,255,1,255,255,0,3,255,0,255,1,255,255,0,5,255,0,255,1,255,255,0,9,255,0,255,1,255,255,0,9,255,0,255,1,255,255,0,9,255,0,255,1,255,255,0,9,255,0,255,1,255,255,0,9,255,0,255,1,255,255,0,20);
tep_redo20:array[0..216] of byte=(
84,69,65,49,35,10,0,0,0,20,0,0,0,255,255,0,22,255,0,255,3,255,255,0,6,255,0,255,1,255,255,0,3,255,0,255,1,255,255,0,4,255,0,255,1,255,255,0,5,255,0,255,1,255,255,0,3,255,0,255,1,255,255,0,5,255,0,255,1,255,255,0,3,255,0,255,1,255,255,0,5,255,0,255,1,255,255,0,3,255,0,255,1,255,255,0,5,255,0,255,1,255,255,0,3,255,0,255,1,255,255,0,5,255,0,255,1,255,255,0,3,255,0,255,1,255,255,0,2,255,0,255,8,255,255,0,3,255,0,255,5,255,255,0,1,255,0,255,1,255,255,0,4,255,0,255,3,255,255,0,2,255,0,255,1,255,255,0,5,255,0,255,1,255,255,0,3,255,0,255,1,255,255,0,9,255,0,255,1,255,255,0,9,255,0,255,1,255,255,0,9,255,0,255,1,255,255,0,9,255,0,255,1,255,255,0,29);
tep_stop20:array[0..120] of byte=(
84,69,65,49,35,11,0,0,0,20,0,0,0,255,255,255,45,189,0,99,9,255,255,255,1,189,0,99,1,239,102,170,9,189,0,99,2,239,102,170,9,189,0,99,2,239,102,170,9,189,0,99,2,239,102,170,9,189,0,99,2,239,102,170,9,189,0,99,2,239,102,170,9,189,0,99,2,239,102,170,9,189,0,99,2,239,102,170,9,189,0,99,2,239,102,170,9,189,0,99,2,239,102,170,9,189,0,99,1,255,255,255,1,189,0,99,9,255,255,255,45);
tep_play20:array[0..176] of byte=(
84,69,65,49,35,9,0,0,0,20,0,0,0,255,255,255,37,43,189,0,3,255,255,255,5,43,189,0,1,136,238,102,3,43,189,0,1,255,255,255,4,43,189,0,1,136,238,102,4,43,189,0,1,255,255,255,3,43,189,0,1,136,238,102,5,43,189,0,1,255,255,255,2,43,189,0,1,136,238,102,6,43,189,0,1,255,255,255,1,43,189,0,1,136,238,102,7,43,189,0,2,136,238,102,7,43,189,0,2,136,238,102,6,43,189,0,1,255,255,255,1,43,189,0,1,136,238,102,5,43,189,0,1,255,255,255,2,43,189,0,1,136,238,102,4,43,189,0,1,255,255,255,3,43,189,0,1,136,238,102,3,43,189,0,1,255,255,255,5,43,189,0,3,255,255,255,41);
tep_rec20:array[0..160] of byte=(
84,69,65,49,35,10,0,0,0,20,0,0,0,255,255,255,44,121,0,0,2,255,255,255,6,121,0,0,2,255,0,0,2,121,0,0,2,255,255,255,3,121,0,0,1,255,0,0,6,121,0,0,1,255,255,255,2,121,0,0,1,255,0,0,6,121,0,0,1,255,255,255,1,121,0,0,1,255,0,0,8,121,0,0,2,255,0,0,8,121,0,0,2,255,0,0,8,121,0,0,1,255,255,255,1,121,0,0,1,255,0,0,6,121,0,0,1,255,255,255,2,121,0,0,1,255,0,0,6,121,0,0,1,255,255,255,3,121,0,0,2,255,0,0,2,121,0,0,2,255,255,255,6,121,0,0,2,255,255,255,54);
tep_rewind20:array[0..272] of byte=(
84,69,65,49,35,14,0,0,0,20,0,0,0,255,255,255,61,194,194,0,3,255,255,255,2,194,194,0,3,255,255,255,5,194,194,0,1,255,255,128,3,194,194,0,2,255,255,128,3,194,194,0,1,255,255,255,3,194,194,0,1,255,255,128,4,194,194,0,1,255,255,128,4,194,194,0,1,255,255,255,2,194,194,0,1,255,255,128,4,194,194,0,1,255,255,128,5,194,194,0,1,255,255,255,1,194,194,0,1,255,255,128,4,194,194,0,1,255,255,128,6,194,194,0,2,255,255,128,4,194,194,0,1,255,255,128,7,194,194,0,2,255,255,128,4,194,194,0,1,255,255,128,7,194,194,0,1,255,255,255,1,194,194,0,1,255,255,128,4,194,194,0,1,255,255,128,6,194,194,0,1,255,255,255,2,194,194,0,1,255,255,128,4,194,194,0,1,255,255,128,5,194,194,0,1,255,255,255,3,194,194,0,1,255,255,128,4,194,194,0,1,255,255,128,4,194,194,0,1,255,255,255,4,194,194,0,1,255,255,128,3,194,194,0,2,255,255,128,3,194,194,0,1,255,255,255,5,194,194,0,3,255,255,255,2,194,194,0,3,255,255,255,57);
tep_fastforward20:array[0..272] of byte=(
84,69,65,49,35,14,0,0,0,20,0,0,0,255,255,255,57,194,194,0,3,255,255,255,2,194,194,0,3,255,255,255,5,194,194,0,1,255,255,128,3,194,194,0,2,255,255,128,3,194,194,0,1,255,255,255,4,194,194,0,1,255,255,128,4,194,194,0,1,255,255,128,4,194,194,0,1,255,255,255,3,194,194,0,1,255,255,128,5,194,194,0,1,255,255,128,4,194,194,0,1,255,255,255,2,194,194,0,1,255,255,128,6,194,194,0,1,255,255,128,4,194,194,0,1,255,255,255,1,194,194,0,1,255,255,128,7,194,194,0,1,255,255,128,4,194,194,0,2,255,255,128,7,194,194,0,1,255,255,128,4,194,194,0,2,255,255,128,6,194,194,0,1,255,255,128,4,194,194,0,1,255,255,255,1,194,194,0,1,255,255,128,5,194,194,0,1,255,255,128,4,194,194,0,1,255,255,255,2,194,194,0,1,255,255,128,4,194,194,0,1,255,255,128,4,194,194,0,1,255,255,255,3,194,194,0,1,255,255,128,3,194,194,0,2,255,255,128,3,194,194,0,1,255,255,255,5,194,194,0,3,255,255,255,2,194,194,0,3,255,255,255,61);
tep_vol20:array[0..280] of byte=(
84,69,65,49,35,12,0,0,0,20,0,0,0,0,255,0,37,123,123,123,10,0,255,0,1,123,123,123,1,212,212,230,5,123,123,123,1,212,212,230,4,123,123,123,2,212,212,230,5,2,2,2,1,123,123,123,1,212,212,230,3,123,123,123,2,212,212,230,2,123,123,123,7,212,212,230,1,123,123,123,2,212,212,230,4,123,123,123,1,212,212,230,3,123,123,123,1,212,212,230,1,123,123,123,2,212,212,230,2,123,123,123,7,212,212,230,1,123,123,123,2,212,212,230,5,2,2,2,1,123,123,123,1,212,212,230,3,123,123,123,2,212,212,230,2,123,123,123,3,2,2,2,1,123,123,123,2,212,212,230,2,123,123,123,2,212,212,230,5,2,2,2,1,123,123,123,1,212,212,230,3,123,123,123,2,212,212,230,2,123,123,123,3,2,2,2,1,123,123,123,2,212,212,230,2,123,123,123,2,212,212,230,5,2,2,2,1,123,123,123,1,212,212,230,3,123,123,123,2,212,212,230,2,123,123,123,3,2,2,2,1,123,123,123,2,212,212,230,2,123,123,123,2,212,212,230,5,123,123,123,1,212,212,230,4,123,123,123,1,0,255,0,1,123,123,123,10,0,255,0,37);
tep_paste20:array[0..384] of byte=(
84,69,65,49,35,16,0,0,0,20,0,0,0,255,0,0,37,160,130,35,4,255,0,0,8,160,130,35,5,64,138,213,2,160,130,35,5,255,0,0,3,160,130,35,2,255,251,146,2,160,130,35,1,64,138,213,1,160,130,35,2,64,138,213,1,160,130,35,1,255,251,146,2,160,130,35,2,255,0,0,2,160,130,35,1,255,251,146,2,160,130,35,1,255,251,146,6,160,130,35,1,255,251,146,2,160,130,35,1,255,0,0,2,160,130,35,1,255,251,146,2,160,130,35,8,255,251,146,2,160,130,35,1,255,0,0,2,160,130,35,1,255,251,146,12,160,130,35,1,255,0,0,2,160,130,35,1,255,251,146,5,64,138,213,7,160,130,35,1,255,0,0,2,160,130,35,1,255,251,146,5,64,138,213,1,217,235,255,5,64,138,213,2,255,0,0,2,160,130,35,1,255,251,146,5,64,138,213,1,217,235,255,5,64,138,213,1,217,235,255,1,64,138,213,1,255,0,0,1,160,130,35,1,255,251,146,5,64,138,213,1,217,235,255,1,64,138,213,3,217,235,255,1,64,138,213,4,160,130,35,1,255,251,146,5,64,138,213,1,217,235,255,8,64,138,213,1,160,130,35,1,255,251,146,5,64,138,213,1,217,235,255,1,64,138,213,6,217,235,255,1,64,138,213,1,160,130,35,1,255,251,146,5,64,138,
213,1,217,235,255,8,64,138,213,1,160,130,35,2,255,251,146,4,64,138,213,1,217,235,255,1,64,138,213,6,217,235,255,1,64,138,213,1,255,0,0,1,160,130,35,5,64,138,213,1,217,235,255,8,64,138,213,1,255,0,0,7,64,138,213,8,255,0,0,33);
tep_max20:array[0..228] of byte=(84,69,65,49,35,13,0,0,0,20,0,0,0,252,252,252,41,255,144,199,10,252,252,252,2,255,144,199,1,255,198,255,10,255,144,199,1,252,252,252,1,255,144,199,1,255,198,255,10,255,144,199,1,252,252,252,1,255,144,199,1,255,198,255,10,255,144,199,1,252,252,252,1,255,144,199,1,255,198,255,10,255,144,199,1,252,252,252,1,72,138,205,6,255,198,255,5,255,144,199,1,72,138,205,1,170,212,255,6,72,138,205,1,255,198,255,4,255,144,199,1,72,138,205,1,170,212,255,6,72,138,205,1,255,198,255,4,255,144,199,1,72,138,205,1,170,212,255,6,72,138,205,1,255,198,255,4,255,144,199,1,72,138,205,1,170,212,255,6,72,138,205,1,255,198,255,4,255,144,199,1,72,138,205,1,170,212,255,6,72,138,205,1,255,198,255,4,255,144,199,1,72,138,205,1,170,212,255,6,72,138,205,1,255,144,199,4,252,252,252,2,72,138,205,6,252,252,252,58);
tep_ontop20:array[0..240] of byte=(84,69,65,49,35,16,0,0,0,20,0,0,0,255,0,0,67,255,144,199,10,255,0,0,5,255,144,199,1,255,198,255,10,255,144,199,1,255,0,0,4,255,144,199,1,255,198,255,5,72,138,205,6,255,0,0,4,255,144,199,1,255,198,255,4,72,138,205,1,170,212,255,6,72,138,205,1,255,0,0,3,255,144,199,1,255,198,255,4,72,138,205,1,170,212,255,6,72,138,205,1,255,0,0,3,255,144,199,1,255,198,255,4,72,138,205,1,170,212,255,6,72,138,205,1,255,0,0,3,255,144,199,1,255,198,255,4,72,138,205,1,170,212,255,6,72,138,205,1,255,0,0,3,255,144,199,1,255,198,255,4,72,138,205,1,170,212,255,6,72,138,205,1,255,0,0,3,255,144,199,1,255,198,255,4,72,138,205,1,170,212,255,6,72,138,205,1,255,0,0,3,255,144,199,1,255,198,255,5,72,138,205,6,255,0,0,4,255,144,199,1,255,198,255,10,255,144,199,1,255,0,0,5,255,144,199,10,255,0,0,67);
tep_nav20:array[0..224] of byte=(
84,69,65,49,35,16,0,0,0,20,0,0,0,183,255,255,50,255,115,185,12,183,255,255,3,255,115,185,6,255,243,249,7,255,115,185,1,183,255,255,2,255,115,185,6,255,243,249,7,255,115,185,1,183,255,255,2,255,115,185,6,255,243,249,7,255,115,185,1,183,255,255,2,255,115,185,6,255,243,249,7,255,115,185,1,183,255,255,2,255,115,185,6,255,243,249,7,255,115,185,1,183,255,255,2,255,115,185,6,255,243,249,7,255,115,185,1,183,255,255,2,255,115,185,6,255,243,249,7,255,115,185,1,183,255,255,2,255,115,185,6,255,243,249,7,255,115,185,1,183,255,255,2,255,115,185,6,255,243,249,7,255,115,185,1,183,255,255,2,255,115,185,6,255,243,249,7,255,115,185,1,183,255,255,2,255,115,185,6,255,243,249,7,255,115,185,1,183,255,255,2,255,115,185,6,255,243,249,7,255,115,185,1,183,255,255,3,255,115,185,12,183,255,255,50);
tep_less20:array[0..160] of byte=(
84,69,65,49,35,18,0,0,0,20,0,0,0,255,0,0,42,255,255,187,6,255,0,0,10,255,255,187,9,255,0,0,8,255,255,187,12,255,0,0,5,255,255,187,13,255,0,0,5,255,255,187,14,255,0,0,3,255,255,187,16,255,0,0,2,255,255,187,16,255,0,0,2,255,255,187,2,68,136,221,12,255,255,187,2,255,0,0,2,255,255,187,2,68,136,221,12,255,255,187,2,255,0,0,2,255,255,187,16,255,0,0,2,255,255,187,16,255,0,0,3,255,255,187,14,255,0,0,5,255,255,187,12,255,0,0,6,255,255,187,12,255,0,0,8,255,255,187,8,255,0,0,11,255,255,187,6,255,0,0,42);
tep_more20:array[0..224] of byte=(
84,69,65,49,35,18,0,0,0,20,0,0,0,255,0,0,42,255,255,187,6,255,0,0,10,255,255,187,9,255,0,0,8,255,255,187,12,255,0,0,5,255,255,187,6,68,136,221,2,255,255,187,5,255,0,0,5,255,255,187,6,68,136,221,2,255,255,187,6,255,0,0,3,255,255,187,7,68,136,221,2,255,255,187,7,255,0,0,2,255,255,187,7,68,136,221,2,255,255,187,7,255,0,0,2,255,255,187,2,68,136,221,12,255,255,187,2,255,0,0,2,255,255,187,2,68,136,221,12,255,255,187,2,255,0,0,2,255,255,187,7,68,136,221,2,255,255,187,7,255,0,0,2,255,255,187,7,68,136,221,2,255,255,187,7,255,0,0,3,255,255,187,6,68,136,221,2,255,255,187,6,255,0,0,5,255,255,187,5,68,136,221,2,255,255,187,5,255,0,0,6,255,255,187,12,255,0,0,8,255,255,187,8,255,0,0,11,255,255,187,6,255,0,0,42);
tep_bw20:array[0..188] of byte=(
84,69,65,49,35,18,0,0,0,20,0,0,0,255,0,0,42,255,255,255,6,255,0,0,10,255,255,255,9,255,0,0,8,255,255,255,11,4,4,4,1,255,0,0,5,255,255,255,11,4,4,4,2,255,0,0,5,255,255,255,10,4,4,4,4,255,0,0,3,255,255,255,10,4,4,4,6,255,0,0,2,255,255,255,9,4,4,4,7,255,0,0,2,255,255,255,8,4,4,4,8,255,0,0,2,255,255,255,7,4,4,4,9,255,0,0,2,255,255,255,6,4,4,4,10,255,0,0,2,255,255,255,5,4,4,4,11,255,0,0,3,255,255,255,3,4,4,4,11,255,0,0,5,255,255,255,1,4,4,4,11,255,0,0,6,4,4,4,12,255,0,0,8,4,4,4,8,255,0,0,11,4,4,4,6,255,0,0,42);
tep_help20:array[0..696] of byte=(
84,69,65,49,35,16,0,0,0,20,0,0,0,0,255,0,6,192,8,107,5,181,8,99,1,117,104,99,1,0,255,0,7,195,20,113,2,248,124,186,1,243,107,181,1,239,107,169,1,233,88,162,2,241,135,152,1,181,18,123,1,117,104,99,1,0,255,0,4,195,20,113,1,243,135,173,1,245,165,184,1,239,107,169,1,248,124,186,1,239,107,169,1,248,124,186,1,243,135,173,2,245,165,184,1,243,135,173,1,203,45,152,1,181,18,123,1,0,255,0,3,245,165,184,2,241,135,152,1,195,20,113,3,248,124,186,1,243,135,173,1,245,165,184,3,233,88,162,1,191,28,152,1,117,104,99,1,0,255,0,1,195,20,113,1,252,197,185,1,181,18,123,1,117,104,99,1,0,255,0,4,239,107,169,1,243,107,181,1,245,165,184,1,252,197,185,1,243,135,173,1,191,28,152,1,181,8,99,1,195,20,113,1,239,107,169,1,252,241,189,1,191,28,152,1,181,18,123,1,195,20,113,1,123,107,107,1,0,255,0,2,203,45,152,1,239,107,169,1,245,165,184,2,243,135,173,1,203,45,152,1,181,18,123,1,192,8,107,1,239,107,169,1,252,197,185,1,252,241,189,1,245,165,184,1,248,124,186,1,181,18,123,1,123,82,99,1,0,255,0,1,195,20,113,1,239,107,169,1,243,135,173,
2,233,88,162,1,191,28,152,1,181,8,99,1,195,20,113,1,239,107,169,1,252,197,185,1,252,241,189,2,248,124,186,1,191,28,152,2,0,255,0,1,233,88,162,2,243,107,181,1,239,107,169,1,233,88,162,1,191,28,152,1,181,18,123,1,0,255,0,1,195,20,113,1,243,135,173,1,252,197,185,1,245,165,184,1,243,107,181,1,181,18,123,1,123,107,107,1,0,255,0,1,239,107,169,2,233,88,162,1,203,45,152,2,181,18,123,1,0,255,0,3,195,20,113,1,239,107,169,1,241,135,152,1,191,28,152,1,181,18,123,1,123,107,107,1,195,20,113,1,243,107,181,2,233,88,162,1,191,28,152,2,123,107,107,1,0,255,0,9,239,107,169,1,243,135,173,1,241,135,152,1,191,28,152,1,181,18,123,1,123,107,107,1,0,255,0,8,148,148,33,1,241,243,47,2,148,140,16,1,237,200,30,1,140,132,16,1,0,255,0,10,148,148,33,1,252,241,189,1,237,200,30,2,140,132,16,1,123,82,99,1,0,255,0,10,241,243,47,1,237,200,30,2,123,82,99,1,0,255,0,12,148,148,33,1,129,121,35,2,123,82,99,1,0,255,0,12,148,148,33,2,148,140,16,1,123,107,107,1,0,255,0,11,148,148,33,1,252,241,189,1,241,243,47,1,148,140,0,1,140,132,16,2,0,255,
0,10,252,241,189,2,241,243,47,2,148,140,0,1,237,200,30,1,123,82,99,1,0,255,0,9,241,243,47,4,140,132,16,1,165,148,8,1,123,82,99,1,0,255,0,9,148,148,33,1,241,243,47,1,252,241,189,1,148,140,0,2,148,140,16,1,0,255,0,5);
tep_helpbanner:array[0..9964] of byte=(
84,69,65,49,35,46,1,0,0,62,0,0,0,255,0,0,2,255,255,255,250,255,255,255,48,255,0,0,3,255,255,255,1,0,0,0,250,0,0,0,48,255,255,255,1,255,0,0,1,255,255,255,1,0,0,0,250,0,0,0,50,255,255,255,2,0,0,0,3,255,255,255,250,255,255,255,44,0,0,0,3,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,250,255,0,0,44,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,250,255,0,0,44,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,213,255,255,255,3,255,0,0,78,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,212,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,77,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,212,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,77,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,211,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,77,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,211,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,77,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,87,255,
255,255,3,255,0,0,121,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,34,255,255,255,3,255,0,0,40,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,86,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,120,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,33,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,39,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,72,255,255,255,3,255,0,0,10,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,47,255,255,255,3,255,0,0,55,255,255,255,2,255,0,0,13,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,32,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,39,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,27,255,255,255,7,255,0,0,37,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,9,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,46,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,53,255,255,255,1,0,0,0,2,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,32,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,39,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,
255,255,1,255,0,0,22,255,255,255,5,0,0,0,7,255,255,255,3,255,0,0,34,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,14,255,255,255,2,255,0,0,30,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,51,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,33,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,39,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,19,255,255,255,3,0,0,0,15,255,255,255,1,255,0,0,34,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,13,255,255,255,1,0,0,0,2,255,255,255,1,255,0,0,30,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,50,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,33,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,39,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,16,255,255,255,3,0,0,0,10,255,255,255,3,0,0,0,6,255,255,255,1,255,0,0,34,255,255,255,4,255,0,0,8,255,255,255,1,0,0,0,4,255,255,
255,1,255,0,0,12,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,31,255,255,255,4,255,0,0,51,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,33,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,39,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,13,255,255,255,3,0,0,0,7,255,255,255,6,255,0,0,3,255,255,255,2,0,0,0,4,255,255,255,1,255,0,0,46,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,86,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,33,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,39,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,11,255,255,255,2,0,0,0,9,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,46,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,86,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,33,255,255,255,1,0,0,0,3,255,255,255,
1,255,0,0,40,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,9,255,255,255,2,0,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,46,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,86,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,33,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,40,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,6,255,255,255,3,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,46,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,87,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,33,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,40,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,4,255,255,255,2,255,0,0,2,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,
255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,25,255,255,255,2,255,0,0,8,255,255,255,3,255,0,0,9,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,32,255,255,255,3,255,0,0,52,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,18,255,255,255,6,255,0,0,9,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,40,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,9,255,255,255,4,255,0,0,4,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,13,255,255,255,3,255,0,0,8,255,255,255,1,0,0,0,2,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,31,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,8,255,255,255,3,255,0,0,40,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,16,255,255,255,2,0,0,0,6,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,3,255,
255,255,1,255,0,0,5,255,255,255,2,255,0,0,2,255,255,255,3,255,0,0,28,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,17,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,10,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,13,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,8,255,255,255,3,255,0,0,20,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,8,255,255,255,3,255,0,0,28,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,15,255,255,255,1,0,0,0,9,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,3,255,255,255,1,255,0,0,27,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,17,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,9,255,255,255,1,0,0,0,4,255,255,255,1,
255,0,0,13,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,5,255,255,255,2,0,0,0,3,255,255,255,1,255,0,0,19,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,27,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,14,255,255,255,1,0,0,0,4,255,255,255,3,0,0,0,4,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,7,255,255,255,4,255,0,0,24,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,17,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,13,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,
255,1,255,0,0,12,255,255,255,1,0,0,0,4,255,255,255,6,0,0,0,5,255,255,255,1,255,0,0,19,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,5,255,255,255,1,255,0,0,26,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,13,255,255,255,1,0,0,0,3,255,255,255,2,255,0,0,3,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,11,255,255,255,3,255,0,0,21,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,17,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,4,255,255,255,7,255,0,0,8,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,4,255,255,255,1,0,0,0,10,255,255,255,1,255,0,0,19,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,
5,255,255,255,1,0,0,0,6,255,255,255,1,255,0,0,26,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,13,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,5,255,255,255,4,0,0,0,10,255,255,255,3,255,0,0,18,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,17,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,5,255,255,255,2,0,0,0,12,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,5,0,0,0,14,255,255,255,2,255,0,0,21,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,3,255,255,255,1,255,0,0,25,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,3,255,255,255,
1,255,0,0,4,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,3,255,255,255,4,0,0,0,6,255,255,255,2,255,0,0,16,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,17,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,15,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,5,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,3,255,255,255,4,0,0,0,13,255,255,255,6,255,0,0,23,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,3,255,255,255,2,0,0,0,3,255,255,255,1,255,0,0,25,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,3,255,255,255,2,0,0,0,4,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,3,255,
255,255,3,0,0,0,5,255,255,255,1,255,0,0,15,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,17,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,1,255,255,255,3,0,0,0,6,255,255,255,7,0,0,0,3,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,5,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,2,255,255,255,1,0,0,0,14,255,255,255,3,255,0,0,29,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,3,255,255,255,1,0,0,0,2,255,255,255,1,255,0,0,1,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,25,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,1,255,255,255,2,0,0,0,5,255,255,255,1,255,0,0,9,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,2,0,0,0,4,255,255,255,1,255,0,0,14,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,
2,255,255,255,1,255,0,0,17,255,255,255,1,0,0,0,3,255,255,255,2,0,0,0,7,255,255,255,2,255,0,0,6,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,6,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,2,255,255,255,1,0,0,0,6,255,255,255,4,0,0,0,4,255,255,255,1,255,0,0,31,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,2,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,1,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,25,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,4,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,3,0,0,0,5,255,255,255,2,255,0,0,10,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,13,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,17,255,255,255,1,0,0,0,10,255,255,255,2,255,0,0,8,255,255,255,1,
0,0,0,4,255,255,255,1,255,0,0,3,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,6,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,3,255,255,255,6,255,0,0,3,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,22,255,255,255,3,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,2,255,255,255,1,0,0,0,2,255,255,255,1,255,0,0,2,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,25,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,10,255,255,255,2,0,0,0,3,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,9,255,255,255,2,255,0,0,12,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,9,255,255,255,2,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,17,255,255,255,1,0,0,0,7,255,255,255,3,255,0,0,10,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,
255,1,0,0,0,3,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,17,255,255,255,5,0,0,0,3,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,1,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,2,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,25,255,255,255,1,0,0,0,3,255,255,255,11,0,0,0,10,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,7,255,255,255,3,255,0,0,14,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,17,255,255,255,1,0,0,0,4,255,255,255,3,255,0,0,13,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,
255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,12,255,255,255,5,0,0,0,9,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,1,255,255,255,1,0,0,0,2,255,255,255,1,255,0,0,3,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,17,255,255,255,8,0,0,0,4,255,255,255,1,0,0,0,19,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,4,255,255,255,3,255,0,0,10,255,255,255,2,255,0,0,5,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,17,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,14,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,3,255,255,255,2,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,4,255,255,255,1,
255,0,0,11,255,255,255,1,0,0,0,13,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,2,0,0,0,3,255,255,255,1,255,0,0,3,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,16,255,255,255,1,0,0,0,28,255,255,255,4,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,2,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,17,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,14,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,2,255,255,255,1,255,0,0,1,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,6,255,255,255,7,255,0,0,6,255,255,255,1,0,0,0,3,255,
255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,16,255,255,255,1,0,0,0,17,255,255,255,7,0,0,0,4,255,255,255,1,255,0,0,9,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,2,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,18,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,13,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,1,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,12,255,255,255,6,255,0,0,13,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,0,0,0,3,255,255,255,1,255,
0,0,4,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,17,255,255,255,1,0,0,0,6,255,255,255,1,0,0,0,3,255,255,255,6,255,0,0,6,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,9,255,255,255,2,0,0,0,4,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,18,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,3,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,2,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,13,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,31,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,18,255,255,255,
7,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,2,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,2,0,0,0,5,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,18,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,3,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,2,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,13,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,31,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,0,0,0,2,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,24,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,8,255,
255,255,1,0,0,0,4,255,255,255,1,255,0,0,10,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,4,255,255,255,3,0,0,0,6,255,255,255,1,255,0,0,13,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,18,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,10,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,2,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,3,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,13,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,31,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,6,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,24,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,9,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,9,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,
0,3,255,255,255,1,255,0,0,5,255,255,255,4,0,0,0,3,255,255,255,5,0,0,0,7,255,255,255,2,255,0,0,14,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,18,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,9,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,9,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,1,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,13,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,31,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,5,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,24,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,10,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,9,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,16,255,255,255,3,255,0,0,16,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,
1,255,0,0,18,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,2,0,0,0,4,255,255,255,1,255,0,0,10,255,255,255,1,0,0,0,3,255,255,255,2,0,0,0,4,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,13,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,31,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,5,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,24,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,10,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,6,255,255,255,2,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,12,255,255,255,4,255,0,0,19,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,18,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,5,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,6,255,
255,255,1,0,0,0,3,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,13,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,31,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,5,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,24,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,10,255,255,255,1,0,0,0,5,255,255,255,2,255,0,0,2,255,255,255,2,0,0,0,4,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,5,255,255,255,4,0,0,0,3,255,255,255,5,255,0,0,23,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,18,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,4,255,255,255,2,0,0,0,4,255,255,255,2,255,0,0,12,255,255,255,1,0,0,0,7,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,30,255,255,255,1,0,
0,0,4,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,24,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,6,255,255,255,2,0,0,0,5,255,255,255,1,255,0,0,9,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,27,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,17,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,1,255,255,255,3,0,0,0,5,255,255,255,1,255,0,0,14,255,255,255,1,0,0,0,6,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,5,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,6,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,31,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,2,255,255,255,1,255,0,0,8,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,24,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,
255,1,0,0,0,11,255,255,255,1,255,0,0,10,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,27,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,17,255,255,255,1,0,0,0,4,255,255,255,2,0,0,0,7,255,255,255,1,255,0,0,16,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,10,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,4,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,12,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,31,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,8,255,255,255,2,255,0,0,8,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,24,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,10,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,13,255,255,255,1,0,0,0,8,255,255,255,2,255,0,0,12,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,7,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,27,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,17,255,255,255,1,0,0,0,3,255,255,255,1,0,0,0,7,255,255,255,2,255,0,0,18,255,255,255,4,255,
0,0,12,255,255,255,1,0,0,0,2,255,255,255,1,255,0,0,5,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,8,255,255,255,3,255,0,0,14,255,255,255,1,0,0,0,2,255,255,255,1,255,0,0,32,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,18,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,24,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,10,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,14,255,255,255,8,255,0,0,15,255,255,255,3,255,0,0,8,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,27,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,17,255,255,255,1,0,0,0,3,255,255,255,1,0,0,0,5,255,255,255,2,255,0,0,37,255,255,255,2,255,0,0,7,255,255,255,3,255,0,0,27,255,255,255,2,255,0,0,34,255,255,255,3,255,0,0,20,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,23,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,10,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,48,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,27,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,18,255,255,255,3,255,0,0,1,255,255,255,1,0,0,0,2,255,255,255,2,255,
0,0,138,255,255,255,3,255,0,0,24,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,10,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,48,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,27,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,23,255,255,255,2,255,0,0,167,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,11,255,255,255,1,0,0,0,2,255,255,255,1,255,0,0,49,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,27,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,192,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,12,255,255,255,2,255,0,0,50,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,27,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,192,255,255,255,1,0,0,0,4,255,255,255,1,255,0,0,64,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,27,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,193,255,255,255,1,0,0,0,2,255,255,255,1,255,0,0,65,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,27,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,194,255,255,255,2,
255,0,0,66,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,27,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,250,255,0,0,12,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,27,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,250,255,0,0,12,255,255,255,1,0,0,0,3,255,255,255,1,255,0,0,27,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,2,255,255,255,1,255,0,0,250,255,0,0,13,255,255,255,3,255,0,0,28,255,255,255,1,0,0,0,2,255,255,255,2,0,0,0,3,255,255,255,250,255,255,255,44,0,0,0,3,255,255,255,2,0,0,0,250,0,0,0,50,255,255,255,1,255,0,0,1,255,255,255,1,0,0,0,250,0,0,0,48,255,255,255,1,255,0,0,3,255,255,255,250,255,255,255,48,255,0,0,2);
tep_helpdoc20:array[0..216] of byte=(
84,69,65,49,35,14,0,0,0,20,0,0,0,192,192,192,29,132,132,0,12,192,192,192,1,132,132,0,2,255,255,128,10,132,132,0,3,255,255,128,12,132,132,0,2,255,255,128,12,132,132,0,2,255,255,128,6,132,132,0,1,255,255,128,5,132,132,0,2,255,255,128,6,132,132,0,2,255,255,128,4,132,132,0,2,255,255,128,6,132,132,0,3,255,255,128,3,132,132,0,2,255,255,128,2,132,132,0,8,255,255,128,2,132,132,0,2,255,255,128,2,132,132,0,8,255,255,128,2,132,132,0,2,255,255,128,6,132,132,0,3,255,255,128,3,132,132,0,2,255,255,128,6,132,132,0,2,255,255,128,4,132,132,0,2,255,255,128,6,132,132,0,1,255,255,128,5,132,132,0,2,255,255,128,12,132,132,0,2,255,255,128,12,132,132,0,3,255,255,128,10,132,132,0,2,192,192,192,1,132,132,0,12,192,192,192,29);
tep_book20:array[0..632] of byte=(
84,69,65,49,35,19,0,0,0,20,0,0,0,255,0,0,40,132,132,0,3,255,0,0,9,132,132,0,3,255,0,0,2,132,132,0,3,255,255,128,2,132,132,0,2,255,0,0,5,132,132,0,2,255,255,128,2,132,132,0,4,255,255,128,1,132,132,0,1,255,255,128,4,132,132,0,2,255,0,0,1,132,132,0,2,255,255,128,4,132,132,0,1,255,255,128,1,132,132,0,2,255,255,128,1,132,132,0,1,255,255,128,1,132,132,0,2,255,255,128,3,132,132,0,1,255,255,128,3,132,132,0,2,255,255,128,1,132,132,0,1,255,255,128,1,132,132,0,2,255,255,128,1,132,132,0,1,255,255,128,3,132,132,0,2,255,255,128,1,132,132,0,1,255,255,128,1,132,132,0,2,255,255,128,3,132,132,0,1,255,255,128,1,132,132,0,2,255,255,128,1,132,132,0,1,255,255,128,6,132,132,0,1,255,255,128,6,132,132,0,1,255,255,128,1,132,132,0,2,255,255,128,1,132,132,0,1,255,255,128,1,132,132,0,2,255,255,128,3,132,132,0,1,255,255,128,3,132,132,0,2,255,255,128,1,132,132,0,1,255,255,128,1,132,132,0,2,255,255,128,1,132,132,0,1,255,255,128,3,132,132,0,2,255,255,128,1,132,132,0,1,255,255,128,1,132,132,0,2,255,255,128,3,132,132,0,1,255,255,
128,1,132,132,0,2,255,255,128,1,132,132,0,1,255,255,128,1,132,132,0,2,255,255,128,3,132,132,0,1,255,255,128,3,132,132,0,2,255,255,128,1,132,132,0,1,255,255,128,1,132,132,0,2,255,255,128,1,132,132,0,1,255,255,128,3,132,132,0,2,255,255,128,1,132,132,0,1,255,255,128,1,132,132,0,2,255,255,128,3,132,132,0,1,255,255,128,1,132,132,0,2,255,255,128,1,132,132,0,1,255,255,128,6,132,132,0,1,255,255,128,6,132,132,0,1,255,255,128,1,132,132,0,2,255,255,128,1,132,132,0,1,255,255,128,1,132,132,0,2,255,255,128,3,132,132,0,1,255,255,128,3,132,132,0,2,255,255,128,1,132,132,0,1,255,255,128,1,132,132,0,2,255,255,128,1,132,132,0,2,255,255,128,2,132,132,0,2,255,255,128,1,132,132,0,1,255,255,128,1,132,132,0,2,255,255,128,2,132,132,0,2,255,255,128,1,132,132,0,2,255,255,128,1,132,132,0,1,255,255,128,1,132,132,0,2,255,255,128,3,132,132,0,1,255,255,128,3,132,132,0,2,255,255,128,1,132,132,0,1,255,255,128,1,132,132,0,9,255,255,128,1,132,132,0,1,255,255,128,1,132,132,0,8,255,0,0,3,132,132,0,13,255,0,0,11,132,132,0,3,255,0,0,27);
tep_um20:array[0..392] of byte=(
84,69,65,49,35,17,0,0,0,20,0,0,0,255,255,255,42,180,163,0,2,255,255,255,10,180,163,0,2,255,255,255,2,180,163,0,1,255,255,138,2,180,163,0,1,255,255,255,2,180,163,0,2,255,255,255,4,180,163,0,1,255,255,138,2,180,163,0,2,255,255,138,4,180,163,0,2,255,255,138,2,180,163,0,1,255,255,255,3,180,163,0,1,255,255,138,12,180,163,0,1,255,255,255,4,180,163,0,1,255,255,138,10,180,163,0,1,255,255,255,5,180,163,0,1,255,255,138,10,180,163,0,1,255,255,255,3,180,163,0,2,255,255,138,4,180,163,0,3,255,255,138,5,180,163,0,1,255,255,255,1,180,163,0,1,255,255,138,5,180,163,0,1,255,255,255,3,180,163,0,1,255,255,138,5,180,163,0,2,255,255,138,5,180,163,0,1,255,255,255,3,180,163,0,1,255,255,138,5,180,163,0,1,255,255,255,1,180,163,0,2,255,255,138,3,180,163,0,1,255,255,255,3,180,163,0,1,255,255,138,4,180,163,0,1,255,255,255,4,180,163,0,1,255,255,138,3,180,163,0,3,255,255,138,4,180,163,0,1,255,255,255,5,180,163,0,1,255,255,138,10,180,163,0,1,255,255,255,4,180,163,0,1,255,255,138,11,180,163,0,1,255,255,255,4,180,163,0,1,255,255,
138,2,180,163,0,2,255,255,138,4,180,163,0,2,255,255,138,2,180,163,0,1,255,255,255,4,180,163,0,2,255,255,255,2,180,163,0,1,255,255,138,2,180,163,0,1,255,255,255,2,180,163,0,2,255,255,255,9,180,163,0,1,255,255,138,2,180,163,0,1,255,255,255,14,180,163,0,2,255,255,255,24);
tep_about20:array[0..424] of byte=(
84,69,65,49,35,18,0,0,0,20,0,0,0,255,0,0,24,64,138,213,6,255,0,0,10,64,138,213,2,255,255,255,6,64,138,213,2,255,0,0,7,64,138,213,1,255,255,255,2,64,138,213,6,255,255,255,2,64,138,213,1,255,0,0,5,64,138,213,1,255,255,255,1,64,138,213,10,255,255,255,1,64,138,213,1,255,0,0,3,64,138,213,1,255,255,255,1,64,138,213,5,255,255,255,2,64,138,213,5,255,255,255,1,64,138,213,1,255,0,0,2,64,138,213,1,255,255,255,1,64,138,213,5,255,255,255,2,64,138,213,5,255,255,255,1,64,138,213,1,255,0,0,1,64,138,213,1,255,255,255,1,64,138,213,14,255,255,255,1,64,138,213,2,255,255,255,1,64,138,213,14,255,255,255,1,64,138,213,2,255,255,255,1,64,138,213,6,255,255,255,2,64,138,213,6,255,255,255,1,64,138,213,2,255,255,255,1,64,138,213,6,255,255,255,2,64,138,213,6,255,255,255,1,64,138,213,2,255,255,255,1,64,138,213,6,255,255,255,2,64,138,213,6,255,255,255,1,64,138,213,2,255,255,255,1,64,138,213,6,255,255,255,2,64,138,213,6,255,255,255,1,64,138,213,1,255,0,0,1,64,138,213,1,255,255,255,1,64,138,213,5,255,255,255,2,64,138,213,5,255,255,
255,1,64,138,213,1,255,0,0,2,64,138,213,1,255,255,255,1,64,138,213,5,255,255,255,2,64,138,213,5,255,255,255,1,64,138,213,1,255,0,0,3,64,138,213,1,255,255,255,1,64,138,213,10,255,255,255,1,64,138,213,1,255,0,0,5,64,138,213,1,255,255,255,2,64,138,213,6,255,255,255,2,64,138,213,1,255,0,0,7,64,138,213,2,255,255,255,6,64,138,213,2,255,0,0,10,64,138,213,6,255,0,0,24);
tep_settings20:array[0..392] of byte=(
84,69,65,49,35,17,0,0,0,20,0,0,0,255,255,255,42,180,163,0,2,255,255,255,10,180,163,0,2,255,255,255,2,180,163,0,1,255,255,138,2,180,163,0,1,255,255,255,2,180,163,0,2,255,255,255,4,180,163,0,1,255,255,138,2,180,163,0,2,255,255,138,4,180,163,0,2,255,255,138,2,180,163,0,1,255,255,255,3,180,163,0,1,255,255,138,12,180,163,0,1,255,255,255,4,180,163,0,1,255,255,138,10,180,163,0,1,255,255,255,5,180,163,0,1,255,255,138,10,180,163,0,1,255,255,255,3,180,163,0,2,255,255,138,4,180,163,0,3,255,255,138,5,180,163,0,1,255,255,255,1,180,163,0,1,255,255,138,5,180,163,0,1,255,255,255,3,180,163,0,1,255,255,138,5,180,163,0,2,255,255,138,5,180,163,0,1,255,255,255,3,180,163,0,1,255,255,138,5,180,163,0,1,255,255,255,1,180,163,0,2,255,255,138,3,180,163,0,1,255,255,255,3,180,163,0,1,255,255,138,4,180,163,0,1,255,255,255,4,180,163,0,1,255,255,138,3,180,163,0,3,255,255,138,4,180,163,0,1,255,255,255,5,180,163,0,1,255,255,138,10,180,163,0,1,255,255,255,4,180,163,0,1,255,255,138,11,180,163,0,1,255,255,255,4,180,163,0,1,255,255,
138,2,180,163,0,2,255,255,138,4,180,163,0,2,255,255,138,2,180,163,0,1,255,255,255,4,180,163,0,2,255,255,255,2,180,163,0,1,255,255,138,2,180,163,0,1,255,255,255,2,180,163,0,2,255,255,255,9,180,163,0,1,255,255,138,2,180,163,0,1,255,255,255,14,180,163,0,2,255,255,255,24);
tep_options20:array[0..736] of byte=(
84,69,65,49,35,17,0,0,0,20,0,0,0,255,255,255,41,132,132,0,4,255,255,255,9,132,132,0,2,255,255,255,2,132,132,0,1,255,132,198,1,255,214,239,1,132,132,0,1,255,255,255,2,132,132,0,2,255,255,255,4,132,132,0,1,255,214,239,1,206,57,222,1,132,132,0,2,255,214,239,2,255,132,198,1,255,214,239,1,132,132,0,2,255,156,0,1,255,189,82,1,132,132,0,1,255,255,255,3,132,132,0,1,206,57,222,1,255,214,239,1,206,57,222,1,255,214,239,1,255,132,198,1,206,57,222,1,255,214,239,1,206,57,222,1,255,214,239,1,255,132,198,1,255,189,82,1,255,156,0,1,132,132,0,1,255,255,255,4,132,132,0,1,206,57,222,1,255,214,239,1,206,57,222,1,255,214,239,1,255,132,198,1,206,57,222,1,255,214,239,1,255,132,198,1,255,214,239,1,255,189,82,1,132,132,0,1,255,255,255,5,132,132,0,1,255,214,239,1,255,132,198,1,255,214,239,2,255,132,198,1,255,214,239,1,255,132,198,1,255,189,82,1,255,132,198,1,255,214,239,1,132,132,0,1,255,255,255,2,132,132,0,3,132,181,255,1,132,255,255,1,255,214,239,1,132,255,255,1,132,132,0,3,255,156,0,1,255,132,198,1,255,189,82,1,239,247,
33,1,255,156,0,1,132,132,0,3,132,255,255,1,132,181,255,1,132,255,255,1,132,181,255,1,132,255,255,1,132,132,0,1,255,255,255,3,132,132,0,1,255,156,0,1,239,247,33,1,255,189,82,1,239,247,33,1,255,189,82,1,255,156,0,1,132,132,0,1,132,181,255,1,132,255,255,1,132,181,255,1,132,255,255,1,132,181,255,1,132,132,0,1,255,255,255,3,132,132,0,1,255,156,0,1,255,189,82,1,239,247,33,1,255,189,82,1,255,156,0,1,132,132,0,4,132,255,255,1,132,181,255,1,132,255,255,1,132,132,0,1,255,255,255,3,132,132,0,1,255,156,0,1,239,247,33,1,255,189,82,1,255,156,0,1,132,132,0,2,255,255,255,3,132,132,0,1,132,255,255,1,132,181,255,1,132,255,255,1,132,132,0,3,255,156,0,1,239,247,33,1,255,189,82,1,255,156,0,1,132,132,0,1,255,255,255,5,132,132,0,1,132,181,255,1,132,255,255,1,132,181,255,1,132,255,255,1,132,181,255,1,132,255,255,1,239,247,33,3,255,189,82,1,132,132,0,1,255,255,255,4,132,132,0,1,132,181,255,1,132,255,255,1,132,181,255,1,132,255,255,1,132,181,255,1,132,255,255,1,132,181,255,1,239,247,33,1,255,189,82,2,255,156,0,1,132,132,
0,1,255,255,255,4,132,132,0,1,132,255,255,1,132,181,255,1,132,132,0,2,132,255,255,1,132,181,255,1,132,255,255,1,255,156,0,1,132,132,0,2,255,189,82,1,255,156,0,1,255,255,255,4,132,132,0,3,99,90,90,1,255,255,255,1,132,132,0,1,132,255,255,1,255,156,0,1,132,132,0,1,255,255,255,2,132,132,0,2,255,255,255,9,132,132,0,1,239,247,33,1,132,181,255,1,132,132,0,1,255,255,255,13,132,132,0,4,255,255,255,23);
tep_be20:array[0..740] of byte=(//*** Now back to the orginal Aqua icon - 12feb2022 ***
84,69,65,49,35,19,0,0,0,20,0,0,0,255,255,255,22,0,242,253,2,11,231,253,6,55,121,231,1,11,231,253,3,55,121,231,1,255,255,255,5,0,242,253,2,11,231,253,5,22,220,253,3,55,121,231,1,22,220,253,3,255,255,255,4,0,242,253,1,55,121,231,1,255,255,255,4,22,220,253,1,55,121,231,1,33,209,253,2,55,121,231,1,255,255,255,2,22,220,253,2,55,121,231,1,255,255,255,3,55,121,231,1,255,255,255,4,22,220,253,1,55,121,231,1,255,255,255,1,33,209,253,2,55,121,231,1,255,255,255,3,33,209,253,1,22,220,253,1,55,121,231,1,255,255,255,6,33,209,253,2,55,121,231,1,255,255,255,1,44,198,253,2,55,121,231,1,255,255,255,3,44,198,253,2,55,121,231,1,255,255,255,6,33,209,253,1,33,198,253,1,55,121,231,1,255,255,255,1,55,187,253,2,55,121,231,1,255,255,255,2,55,187,253,2,55,121,231,1,255,255,255,5,33,209,253,2,44,198,253,2,55,121,231,1,255,255,255,1,55,187,253,2,55,121,231,1,55,187,253,4,255,255,255,4,33,209,253,2,55,121,231,1,44,198,253,1,44,187,253,1,55,187,253,1,55,121,231,1,255,255,255,1,66,176,253,1,77,165,253,3,55,121,231,1,66,176,253,
3,55,187,253,1,55,121,231,1,255,255,255,1,33,209,253,1,55,121,231,1,255,255,255,2,55,187,253,1,55,176,253,1,55,121,231,1,255,255,255,1,77,165,253,1,77,154,253,3,255,255,255,2,66,165,253,1,66,176,253,2,55,121,231,1,255,255,255,4,55,176,253,1,66,176,253,1,77,165,253,1,55,121,231,1,255,255,255,1,88,154,253,1,88,143,253,1,55,121,231,1,99,143,253,1,255,255,255,2,88,143,253,1,88,154,253,1,77,154,253,1,55,121,231,1,255,255,255,3,55,187,253,1,66,176,253,1,66,165,253,1,77,165,253,1,55,121,231,1,88,143,253,2,55,121,231,1,255,255,255,1,99,132,253,1,99,143,253,3,88,143,253,1,88,154,253,1,55,121,231,1,255,255,255,2,55,187,253,1,66,176,253,1,55,121,231,1,77,165,253,1,88,154,253,1,55,121,231,1,99,143,253,2,55,121,231,1,255,255,255,1,110,132,253,1,55,121,231,2,99,132,253,1,99,143,253,2,55,121,231,1,255,255,255,2,55,121,231,2,255,255,255,1,88,154,253,1,99,143,253,1,99,132,253,1,110,132,253,1,55,121,231,1,255,255,255,2,121,121,253,1,255,255,255,3,110,121,253,1,55,121,231,1,255,255,255,5,88,154,253,1,88,143,253,1,
99,143,253,1,110,132,253,1,110,121,253,2,121,121,253,3,121,110,253,3,121,121,253,1,55,121,231,1,255,255,255,4,77,154,253,1,55,121,231,5,121,121,253,1,121,110,253,1,132,110,253,2,55,121,231,2,255,255,255,6,77,165,253,1,88,154,253,1,255,255,255,5,55,121,231,1,132,110,253,2,55,121,231,1,255,255,255,8,77,154,253,1,88,154,253,1,255,255,255,6,55,121,231,2,255,255,255,9,88,154,253,1,88,143,253,1,255,255,255,17,55,121,231,2,255,255,255,15);
{//old purple BE icon from 2019-2021:
tep_be20:array[0..680] of byte=(
84,69,65,49,35,19,0,0,0,20,0,0,0,255,0,0,2,227,218,245,7,207,192,238,1,227,218,245,1,83,109,207,1,227,218,245,2,207,192,238,1,83,109,207,1,255,0,0,4,227,218,245,6,207,192,238,2,83,109,207,1,207,192,238,6,83,109,207,1,255,0,0,2,227,218,245,1,83,109,207,1,255,0,0,4,207,192,238,1,83,109,207,1,207,192,238,3,83,109,207,1,255,0,0,2,207,192,238,3,255,0,0,2,83,109,207,1,255,0,0,4,207,192,238,2,255,0,0,1,207,192,238,1,197,172,234,1,207,192,238,1,83,109,207,1,255,0,0,3,207,192,238,2,83,109,207,1,255,0,0,6,207,192,238,2,255,0,0,1,197,172,234,3,83,109,207,1,255,0,0,3,197,172,234,2,83,109,207,1,255,0,0,5,197,172,234,3,255,0,0,1,197,172,234,3,83,109,207,1,255,0,0,2,197,172,234,3,255,0,0,4,207,192,238,1,197,172,234,2,207,192,238,1,197,172,234,1,255,0,0,1,197,172,234,1,138,160,246,1,197,172,234,1,83,109,207,1,197,172,234,1,138,160,246,1,197,172,234,1,138,160,246,1,83,109,207,1,255,0,0,2,207,192,238,2,83,109,207,1,207,192,238,1,197,172,234,1,138,160,246,1,197,172,234,1,255,0,0,1,138,160,246,4,83,109,207,2,138,160,
246,2,197,172,234,2,83,109,207,1,207,192,238,1,83,109,207,1,255,0,0,2,197,172,234,1,138,160,246,2,255,0,0,1,138,160,246,4,83,109,207,1,255,0,0,2,138,160,246,3,83,109,207,2,255,0,0,3,138,160,246,3,255,0,0,1,138,160,246,3,83,109,207,1,138,160,246,6,83,109,207,1,255,0,0,3,197,172,234,1,138,160,246,3,255,0,0,1,138,160,246,1,131,129,251,1,138,160,246,1,83,109,207,2,255,0,0,2,131,129,251,1,138,160,246,2,83,109,207,1,255,0,0,2,138,160,246,5,131,129,251,3,83,109,207,1,255,0,0,1,131,129,251,5,138,160,246,1,83,109,207,1,255,0,0,1,138,160,246,1,83,109,207,1,255,0,0,1,138,160,246,2,83,109,207,1,131,129,251,2,83,109,207,1,255,0,0,2,83,109,207,1,255,0,0,3,131,129,251,2,83,109,207,1,255,0,0,1,83,109,207,1,255,0,0,2,138,160,246,1,131,129,251,3,83,109,207,1,255,0,0,3,83,109,207,1,255,0,0,3,131,129,251,1,83,109,207,1,255,0,0,4,138,160,246,1,131,129,251,8,83,109,207,1,131,129,251,4,83,109,207,1,255,0,0,3,138,160,246,1,83,109,207,5,131,129,251,4,83,109,207,3,255,0,0,5,138,160,246,1,83,109,207,1,255,0,0,5,83,109,207,
2,131,129,251,2,255,0,0,8,138,160,246,1,83,109,207,1,255,0,0,17,138,160,246,1,83,109,207,1,255,0,0,17,83,109,207,1,255,0,0,17);
{}//yyy
tep_disk20:array[0..168] of byte=(
84,69,65,49,35,16,0,0,0,20,0,0,0,252,252,252,82,159,159,163,12,252,252,252,3,159,159,163,1,192,192,192,12,159,159,163,1,252,252,252,2,159,159,163,1,192,192,192,12,159,159,163,1,252,252,252,1,159,159,163,1,192,192,192,14,159,159,163,1,252,252,252,1,159,159,163,14,252,252,252,1,159,159,163,1,90,90,90,14,159,159,163,2,90,90,90,2,76,255,145,2,90,90,90,2,255,255,128,6,90,90,90,2,159,159,163,2,90,90,90,2,76,255,145,2,90,90,90,10,159,159,163,2,90,90,90,6,255,255,128,6,90,90,90,2,159,159,163,2,90,90,90,14,159,159,163,1,252,252,252,1,159,159,163,14,252,252,252,65);
tep_cd20:array[0..328] of byte=(
84,69,65,49,35,15,0,0,0,20,0,0,0,0,255,0,50,159,159,163,5,0,255,0,8,159,159,163,2,231,226,248,3,208,208,252,2,159,159,163,2,0,255,0,5,159,159,163,1,249,244,253,1,231,226,248,3,208,208,252,5,159,159,163,1,0,255,0,3,159,159,163,1,249,244,253,4,231,226,248,2,208,208,252,5,159,159,163,1,0,255,0,2,159,159,163,1,249,244,253,5,231,226,248,3,208,208,252,3,159,159,163,1,0,255,0,1,159,159,163,1,231,226,248,1,249,244,253,6,231,226,248,3,208,208,252,3,159,159,163,2,231,226,248,2,249,244,253,4,159,159,163,1,249,244,253,1,231,226,248,5,159,159,163,2,231,226,248,4,249,244,253,1,159,159,163,3,249,244,253,1,231,226,248,4,159,159,163,2,231,226,248,4,249,244,253,2,159,159,163,1,249,244,253,5,231,226,248,1,159,159,163,2,208,208,252,3,231,226,248,2,249,244,253,8,159,159,163,1,0,255,0,1,159,159,163,1,208,208,252,2,231,226,248,4,249,244,253,5,159,159,163,1,0,255,0,2,159,159,163,1,208,208,252,4,231,226,248,4,249,244,253,3,159,159,163,1,0,255,0,3,159,159,163,1,208,208,252,5,231,226,248,4,159,159,163,1,0,255,0,5,159,159,
163,2,208,208,252,3,231,226,248,3,159,159,163,1,0,255,0,8,159,159,163,6,0,255,0,34);
tep_removable20:array[0..208] of byte=(
84,69,65,49,35,16,0,0,0,20,0,0,0,252,252,252,13,159,159,163,1,252,252,252,10,159,159,163,5,252,252,252,10,159,159,163,2,252,252,252,14,159,159,163,1,252,252,252,14,159,159,163,2,252,252,252,10,159,159,163,12,252,252,252,3,159,159,163,1,192,192,192,12,159,159,163,1,252,252,252,2,159,159,163,1,192,192,192,12,159,159,163,1,252,252,252,1,159,159,163,1,192,192,192,14,159,159,163,1,252,252,252,1,159,159,163,14,252,252,252,1,159,159,163,1,90,90,90,14,159,159,163,2,90,90,90,2,76,255,145,2,90,90,90,2,255,255,128,6,90,90,90,2,159,159,163,2,90,90,90,2,76,255,145,2,90,90,90,10,159,159,163,2,90,90,90,6,255,255,128,6,90,90,90,2,159,159,163,2,90,90,90,14,159,159,163,1,252,252,252,1,159,159,163,14,252,252,252,65);
tep_menu20:array[0..160] of byte=(
84,69,65,49,35,16,0,0,0,20,0,0,0,255,255,255,34,0,128,255,12,255,255,255,3,0,128,255,1,128,255,255,12,0,128,255,1,255,255,255,2,0,128,255,1,128,255,255,12,0,128,255,1,255,255,255,3,0,128,255,12,255,255,255,36,0,128,255,12,255,255,255,3,0,128,255,1,255,255,0,12,0,128,255,1,255,255,255,2,0,128,255,1,255,255,0,12,0,128,255,1,255,255,255,3,0,128,255,12,255,255,255,36,0,128,255,12,255,255,255,3,0,128,255,1,128,255,255,12,0,128,255,1,255,255,255,2,0,128,255,1,128,255,255,12,0,128,255,1,255,255,255,3,0,128,255,12,255,255,255,34);
tep_invert20:array[0..256] of byte=(
84,69,65,49,35,15,0,0,0,20,0,0,0,255,0,0,37,64,138,213,6,255,0,0,8,64,138,213,1,255,0,255,6,64,138,213,1,255,0,0,7,64,138,213,1,255,0,255,6,64,138,213,1,255,0,0,7,64,138,213,1,255,0,255,6,64,138,213,1,255,0,0,7,64,138,213,1,255,0,255,6,64,138,213,1,255,0,0,7,64,138,213,1,255,0,255,6,64,138,213,1,255,0,0,7,64,138,213,1,255,0,255,6,64,138,213,1,255,0,0,7,64,138,213,1,255,0,255,2,64,138,213,4,255,0,0,4,64,138,213,4,255,255,0,2,64,138,213,1,255,0,0,7,64,138,213,1,255,255,0,6,64,138,213,1,255,0,0,7,64,138,213,1,255,255,0,6,64,138,213,1,255,0,0,7,64,138,213,1,255,255,0,6,64,138,213,1,255,0,0,7,64,138,213,1,255,255,0,6,64,138,213,1,255,0,0,7,64,138,213,1,255,255,0,6,64,138,213,1,255,0,0,7,64,138,213,1,255,255,0,6,64,138,213,1,255,0,0,8,64,138,213,6,255,0,0,37);
tep_tick20:array[0..368] of byte=(
84,69,65,49,35,16,0,0,0,20,0,0,0,255,0,0,66,124,136,207,2,255,0,0,3,124,136,207,3,255,0,0,7,124,136,207,1,200,245,255,2,124,136,207,1,255,0,0,1,124,136,207,1,200,245,255,3,124,136,207,1,255,0,0,6,124,136,207,1,200,245,255,2,124,136,207,1,255,0,0,1,124,136,207,1,200,245,255,4,124,136,207,1,255,0,0,5,124,136,207,1,200,245,255,2,124,136,207,1,255,0,0,1,124,136,207,1,200,245,255,5,124,136,207,1,255,0,0,4,124,136,207,1,200,245,255,2,124,136,207,1,255,0,0,1,124,136,207,1,200,245,255,6,124,136,207,1,255,0,0,3,124,136,207,1,200,245,255,2,124,136,207,1,255,0,0,1,124,136,207,1,200,245,255,7,124,136,207,1,255,0,0,2,124,136,207,1,200,245,255,2,124,136,207,1,255,0,0,1,124,136,207,1,200,245,255,7,124,136,207,1,255,0,0,2,124,136,207,1,200,245,255,2,124,136,207,1,255,0,0,1,124,136,207,1,200,245,255,6,124,136,207,1,255,0,0,3,124,136,207,1,200,245,255,2,124,136,207,1,255,0,0,1,124,136,207,1,200,245,255,5,124,136,207,1,255,0,0,4,124,136,207,1,200,245,255,2,124,136,207,1,255,0,0,1,124,136,207,1,200,245,255,4,124,136,
207,1,255,0,0,5,124,136,207,1,200,245,255,2,124,136,207,1,255,0,0,1,124,136,207,1,200,245,255,3,124,136,207,1,255,0,0,7,124,136,207,2,255,0,0,3,124,136,207,3,255,0,0,70);
tep_untick20:array[0..192] of byte=(
84,69,65,49,35,16,0,0,0,20,0,0,0,255,0,0,66,124,136,207,2,255,0,0,13,124,136,207,1,200,245,255,2,124,136,207,1,255,0,0,12,124,136,207,1,200,245,255,2,124,136,207,1,255,0,0,12,124,136,207,1,200,245,255,2,124,136,207,1,255,0,0,12,124,136,207,1,200,245,255,2,124,136,207,1,255,0,0,12,124,136,207,1,200,245,255,2,124,136,207,1,255,0,0,12,124,136,207,1,200,245,255,2,124,136,207,1,255,0,0,12,124,136,207,1,200,245,255,2,124,136,207,1,255,0,0,12,124,136,207,1,200,245,255,2,124,136,207,1,255,0,0,12,124,136,207,1,200,245,255,2,124,136,207,1,255,0,0,12,124,136,207,1,200,245,255,2,124,136,207,1,255,0,0,13,124,136,207,2,255,0,0,76);
tep_ticktwo20:array[0..80] of byte=(
84,69,65,49,35,16,0,0,0,20,0,0,0,255,0,0,102,0,0,0,4,255,0,0,11,0,0,0,6,255,0,0,9,0,0,0,8,255,0,0,8,0,0,0,8,255,0,0,8,0,0,0,8,255,0,0,8,0,0,0,8,255,0,0,9,0,0,0,6,255,0,0,11,0,0,0,4,255,0,0,102);
tep_unticktwo20:array[0..128] of byte=(
84,69,65,49,35,16,0,0,0,20,0,0,0,255,0,0,102,0,0,0,4,255,0,0,11,0,0,0,1,255,0,0,4,0,0,0,1,255,0,0,9,0,0,0,1,255,0,0,6,0,0,0,1,255,0,0,8,0,0,0,1,255,0,0,6,0,0,0,1,255,0,0,8,0,0,0,1,255,0,0,6,0,0,0,1,255,0,0,8,0,0,0,1,255,0,0,6,0,0,0,1,255,0,0,9,0,0,0,1,255,0,0,4,0,0,0,1,255,0,0,11,0,0,0,4,255,0,0,102);
tep_tickthree20:array[0..80] of byte=(
84,69,65,49,35,16,0,0,0,20,0,0,0,255,0,0,100,0,0,0,8,255,0,0,8,0,0,0,8,255,0,0,8,0,0,0,8,255,0,0,8,0,0,0,8,255,0,0,8,0,0,0,8,255,0,0,8,0,0,0,8,255,0,0,8,0,0,0,8,255,0,0,8,0,0,0,8,255,0,0,100);
tep_untickthree20:array[0..128] of byte=(
84,69,65,49,35,16,0,0,0,20,0,0,0,255,0,0,100,0,0,0,8,255,0,0,8,0,0,0,1,255,0,0,6,0,0,0,1,255,0,0,8,0,0,0,1,255,0,0,6,0,0,0,1,255,0,0,8,0,0,0,1,255,0,0,6,0,0,0,1,255,0,0,8,0,0,0,1,255,0,0,6,0,0,0,1,255,0,0,8,0,0,0,1,255,0,0,6,0,0,0,1,255,0,0,8,0,0,0,1,255,0,0,6,0,0,0,1,255,0,0,8,0,0,0,8,255,0,0,100);
tep_screen20:array[0..200] of byte=(
84,69,65,49,35,18,0,0,0,20,0,0,0,0,255,0,55,0,0,128,16,0,255,0,1,0,0,128,1,166,166,255,16,0,0,128,2,166,166,255,15,0,0,255,1,0,0,128,2,166,166,255,13,0,0,255,3,0,0,128,2,166,166,255,12,0,0,255,4,0,0,128,2,166,166,255,10,0,0,255,6,0,0,128,2,166,166,255,9,0,0,255,7,0,0,128,2,166,166,255,7,0,0,255,9,0,0,128,2,166,166,255,6,0,0,255,10,0,0,128,2,166,166,255,4,0,0,255,12,0,0,128,2,166,166,255,3,0,0,255,13,0,0,128,2,166,166,255,1,0,0,255,15,0,0,128,1,0,255,0,1,0,0,128,16,0,255,0,8,0,0,128,3,0,255,0,15,0,0,128,3,0,255,0,13,0,0,128,7,0,255,0,11,0,0,128,7,0,255,0,6);
tep_wrap20:array[0..168] of byte=(
84,69,65,49,35,17,0,0,0,20,0,0,0,232,232,232,86,115,115,255,14,232,232,232,3,115,115,255,15,232,232,232,2,255,255,201,13,115,115,255,2,232,232,232,2,255,255,201,13,115,115,255,2,232,232,232,2,255,255,201,13,115,115,255,2,232,232,232,2,255,255,201,3,115,115,255,1,255,255,201,9,115,115,255,2,232,232,232,2,255,255,201,2,115,115,255,2,255,255,201,9,115,115,255,2,232,232,232,2,255,255,201,1,115,115,255,3,255,255,201,9,115,115,255,2,232,232,232,2,115,115,255,15,232,232,232,2,115,115,255,14,232,232,232,4,115,115,255,3,232,232,232,15,115,115,255,2,232,232,232,16,115,115,255,1,232,232,232,46);
//file format teps -------------------------------------------------------------
tep_sfef20:array[0..500] of byte=(
84,69,65,49,35,20,0,0,0,20,0,0,0,255,0,0,9,112,143,116,2,255,0,0,17,106,135,110,1,107,215,0,2,106,135,110,1,255,0,0,15,101,128,104,1,101,204,0,4,101,128,104,1,255,0,0,13,95,120,98,1,96,192,0,6,95,120,98,1,255,0,0,11,89,113,92,1,90,181,0,8,89,113,92,1,255,0,0,9,83,105,86,1,84,170,0,4,119,180,29,1,122,181,31,1,84,170,0,4,83,105,86,1,255,0,0,7,77,98,80,1,78,158,0,4,108,168,23,1,213,213,106,2,108,168,24,1,78,158,0,4,77,98,80,1,255,0,0,5,71,90,73,1,73,146,0,5,119,169,35,1,213,213,106,2,119,169,35,1,73,146,0,5,71,90,73,1,255,0,0,3,65,82,67,1,67,134,0,4,96,152,20,1,120,165,37,1,143,177,54,1,213,213,106,2,138,174,50,1,122,166,39,1,104,156,25,1,67,134,0,4,65,82,67,1,255,0,0,1,59,75,61,1,61,123,0,4,91,142,21,1,213,213,106,8,92,142,21,1,61,123,0,4,59,75,61,1,53,68,55,1,55,112,0,4,86,131,21,1,213,213,106,8,86,131,21,1,55,112,0,4,53,68,55,1,255,0,0,1,47,60,49,1,50,100,0,4,81,119,21,1,101,133,35,1,126,150,50,1,213,213,106,2,121,147,47,1,104,135,36,1,89,125,26,1,50,100,0,4,47,60,49,1,255,0,0,3,41,52,42,1,44,88,
0,5,104,131,39,1,213,213,106,2,104,131,39,1,44,88,0,5,41,52,42,1,255,0,0,5,35,45,37,1,38,77,0,4,83,112,27,1,213,213,106,2,83,112,27,1,38,77,0,4,35,45,37,1,255,0,0,7,29,37,30,1,32,65,0,4,87,110,31,1,92,114,34,1,32,65,0,4,29,37,30,1,255,0,0,9,23,30,24,1,27,54,0,8,23,30,24,1,255,0,0,11,17,22,18,1,21,42,0,6,17,22,18,1,255,0,0,13,11,14,12,1,15,30,0,4,11,14,12,1,255,0,0,15,6,7,6,1,9,19,0,2,6,7,6,1,255,0,0,17,9,19,0,2,255,0,0,9);
tep_bmp20:array[0..576] of byte=(
84,69,65,49,35,16,0,0,0,20,0,0,0,234,0,0,49,130,156,208,11,234,0,0,5,130,156,208,1,255,255,255,7,234,234,234,2,130,156,208,1,104,156,208,1,234,0,0,4,130,156,208,1,255,255,255,4,234,234,234,5,52,156,234,2,52,130,208,1,234,0,0,3,130,156,208,1,234,234,234,1,255,255,255,2,234,234,234,6,182,208,234,2,156,156,234,1,104,130,156,1,234,0,0,2,130,156,208,1,234,234,234,1,234,156,104,1,234,104,52,2,234,130,52,3,234,156,78,1,234,182,78,1,208,234,234,3,182,182,234,1,234,0,0,2,130,156,208,1,234,234,234,1,234,130,78,1,182,78,26,1,234,104,52,1,234,130,52,3,234,156,78,1,234,208,130,1,234,182,104,1,234,156,78,1,130,156,182,1,182,182,234,1,234,0,0,2,130,156,208,1,234,234,234,1,182,52,26,1,104,52,26,1,156,52,0,1,182,52,26,3,208,52,26,1,234,78,26,2,208,52,26,1,130,156,182,1,182,182,234,1,234,0,0,2,130,156,208,1,234,234,234,1,208,130,78,1,130,78,26,1,156,78,26,1,234,130,52,4,234,182,78,1,234,130,52,2,130,156,182,1,182,182,234,1,234,0,0,2,130,156,208,1,208,234,234,1,208,156,104,1,182,104,78,1,78,52,26,1,208,130,78,4,234,
208,104,2,208,130,78,1,130,156,208,1,156,182,234,1,234,0,0,2,104,156,182,1,208,208,234,1,182,156,130,1,182,130,104,1,78,52,52,1,182,130,104,3,208,156,104,1,208,182,130,1,234,182,104,1,182,130,104,1,104,156,208,1,156,182,234,1,234,0,0,2,104,130,182,1,208,208,234,1,156,130,156,1,130,104,156,1,104,104,182,1,156,130,130,3,208,182,130,1,234,208,130,1,234,208,104,1,156,130,130,1,104,156,208,1,156,182,234,1,234,0,0,2,104,130,182,1,208,208,234,1,130,130,182,1,130,104,182,1,130,104,156,1,130,130,156,3,156,130,130,1,208,182,130,1,208,182,104,1,156,130,156,1,104,156,208,1,156,182,234,1,234,0,0,2,104,130,182,1,208,208,208,1,208,208,234,1,156,208,234,2,156,182,234,5,130,182,234,2,156,208,234,1,156,182,234,1,234,0,0,2,104,130,156,1,208,208,208,1,208,208,234,1,182,208,234,7,156,208,234,3,156,182,234,1,234,0,0,2,104,104,156,1,156,156,208,1,130,156,208,3,130,156,182,5,130,130,182,4,234,0,0,33);
tep_wma20:array[0..656] of byte=(
84,69,65,49,35,15,0,0,0,20,0,0,0,132,255,255,32,132,173,222,9,132,255,255,6,132,173,222,1,255,255,255,3,247,255,255,3,219,239,252,1,132,173,222,2,93,109,137,1,132,255,255,4,132,173,222,1,255,255,255,1,247,255,255,2,219,239,252,1,247,255,255,1,219,239,252,2,76,131,225,1,107,165,255,1,76,131,225,1,93,109,137,1,132,255,255,3,132,173,222,1,247,255,255,3,219,239,252,5,181,205,249,1,156,181,239,1,76,131,225,1,132,255,255,3,76,131,225,1,93,109,137,5,90,177,103,1,219,239,252,4,198,206,231,1,93,109,137,1,132,255,255,1,198,206,231,1,57,61,61,1,206,189,107,1,206,123,90,1,198,206,231,1,206,189,107,1,90,177,103,2,93,109,137,1,198,206,231,1,219,239,252,2,181,205,249,1,93,109,137,1,198,206,231,1,57,61,61,1,206,123,90,1,206,189,107,1,247,255,255,2,219,239,252,1,198,206,231,1,90,177,103,2,93,109,137,1,198,206,231,1,219,239,252,1,181,205,249,1,68,79,106,1,93,109,137,1,206,123,90,2,247,255,255,1,198,206,231,1,219,239,252,3,156,181,239,1,90,177,103,2,93,109,137,1,219,239,252,1,181,205,249,1,68,79,106,2,206,123,90,2,
219,239,252,1,76,131,225,2,132,173,222,1,198,206,231,1,156,181,239,1,90,177,103,2,68,79,106,1,181,205,249,2,68,79,106,1,57,61,61,1,206,123,90,1,198,206,231,1,156,181,239,1,93,109,137,1,57,61,61,2,68,79,106,1,156,181,239,1,93,109,137,1,90,177,103,1,57,61,61,1,132,173,222,1,181,205,249,1,93,109,137,1,68,79,106,1,76,131,225,1,156,181,239,1,198,206,231,1,57,61,61,1,68,79,106,2,156,181,239,2,93,109,137,1,90,177,103,1,57,61,61,1,132,173,222,1,198,206,231,1,68,79,106,1,93,109,137,1,76,131,225,1,132,173,222,1,219,239,252,1,156,181,239,2,247,255,255,2,156,181,239,1,206,123,90,2,57,61,61,1,132,173,222,1,181,205,249,1,68,79,106,1,198,206,231,1,68,79,106,1,76,131,225,1,198,206,231,1,247,255,255,3,198,206,231,1,206,189,107,2,68,79,106,2,156,181,239,2,68,79,106,1,132,255,255,1,93,109,137,1,107,165,255,3,132,173,222,1,206,189,107,3,206,123,90,1,57,61,61,1,90,177,103,1,198,206,231,1,156,181,239,1,93,109,137,1,132,255,255,2,57,61,61,1,93,109,137,1,76,131,225,2,206,189,107,1,206,123,90,2,57,61,61,1,93,109,137,1,132,
173,222,1,90,177,103,1,132,173,222,1,93,109,137,1,132,255,255,2,181,205,249,1,68,79,106,1,57,61,61,6,68,79,106,2,93,109,137,1,68,79,106,1,132,255,255,31);
tep_r20:array[0..384] of byte=(
84,69,65,49,35,17,0,0,0,20,0,0,0,255,255,255,36,0,128,255,13,255,255,255,3,0,128,255,1,128,255,255,13,0,128,255,1,255,255,255,2,0,128,255,1,128,255,255,13,0,128,255,1,255,255,255,2,0,128,255,1,128,255,255,3,255,0,128,6,128,255,255,4,0,128,255,1,255,255,255,2,0,128,255,1,128,255,255,3,255,0,128,7,128,255,255,3,0,128,255,1,255,255,255,2,0,128,255,1,128,255,255,3,255,0,128,2,128,255,255,3,255,0,128,2,128,255,255,3,0,128,255,1,255,255,255,2,0,128,255,1,128,255,255,3,255,0,128,2,128,255,255,3,255,0,128,2,128,255,255,3,0,128,255,1,255,255,255,2,0,128,255,1,128,255,255,3,255,0,128,2,128,255,255,3,255,0,128,2,128,255,255,3,0,128,255,1,255,255,255,2,0,128,255,1,128,255,255,3,255,0,128,6,128,255,255,4,0,128,255,1,255,255,255,2,0,128,255,1,128,255,255,3,255,0,128,7,128,255,255,3,0,128,255,1,255,255,255,2,0,128,255,1,128,255,255,3,255,0,128,2,128,255,255,3,255,0,128,2,128,255,255,3,0,128,255,1,255,255,255,2,0,128,255,1,128,255,255,3,255,0,128,2,128,255,255,3,255,0,128,2,128,255,255,3,0,128,255,1,255,255,255,
2,0,128,255,1,128,255,255,3,255,0,128,2,128,255,255,3,255,0,128,2,128,255,255,3,0,128,255,1,255,255,255,2,0,128,255,1,128,255,255,13,0,128,255,1,255,255,255,2,0,128,255,1,128,255,255,13,0,128,255,1,255,255,255,3,0,128,255,13,255,255,255,36);
tep_xml20:array[0..408] of byte=(
84,69,65,49,35,17,0,0,0,20,0,0,0,255,255,255,36,106,0,137,13,255,255,255,3,106,0,137,1,241,255,73,13,106,0,137,1,255,255,255,2,106,0,137,1,241,255,73,13,106,0,137,1,255,255,255,2,106,0,137,1,241,255,73,3,168,40,206,2,241,255,73,3,168,40,206,2,241,255,73,3,106,0,137,1,255,255,255,2,106,0,137,1,241,255,73,3,168,40,206,2,241,255,73,3,168,40,206,2,241,255,73,3,106,0,137,1,255,255,255,2,106,0,137,1,241,255,73,3,168,40,206,2,241,255,73,3,168,40,206,2,241,255,73,3,106,0,137,1,255,255,255,2,106,0,137,1,241,255,73,4,168,40,206,2,241,255,73,1,168,40,206,2,241,255,73,4,106,0,137,1,255,255,255,2,106,0,137,1,241,255,73,4,168,40,206,5,241,255,73,4,106,0,137,1,255,255,255,2,106,0,137,1,241,255,73,5,168,40,206,3,241,255,73,5,106,0,137,1,255,255,255,2,106,0,137,1,241,255,73,4,168,40,206,5,241,255,73,4,106,0,137,1,255,255,255,2,106,0,137,1,241,255,73,4,168,40,206,2,241,255,73,1,168,40,206,2,241,255,73,4,106,0,137,1,255,255,255,2,106,0,137,1,241,255,73,3,168,40,206,2,241,255,73,3,168,40,206,2,241,255,73,3,106,0,137,
1,255,255,255,2,106,0,137,1,241,255,73,3,168,40,206,2,241,255,73,3,168,40,206,2,241,255,73,3,106,0,137,1,255,255,255,2,106,0,137,1,241,255,73,3,168,40,206,2,241,255,73,3,168,40,206,2,241,255,73,3,106,0,137,1,255,255,255,2,106,0,137,1,241,255,73,13,106,0,137,1,255,255,255,3,106,0,137,13,255,255,255,36);
tep_htm20:array[0..400] of byte=(
84,69,65,49,35,17,0,0,0,20,0,0,0,255,255,255,36,0,128,0,13,255,255,255,3,0,128,0,1,0,255,64,13,0,128,0,1,255,255,255,2,0,128,0,1,0,255,64,13,0,128,0,1,255,255,255,2,0,128,0,1,0,255,64,3,255,128,0,2,0,255,64,3,255,128,0,2,0,255,64,3,0,128,0,1,255,255,255,2,0,128,0,1,0,255,64,3,255,128,0,2,0,255,64,3,255,128,0,2,0,255,64,3,0,128,0,1,255,255,255,2,0,128,0,1,0,255,64,3,255,128,0,2,0,255,64,3,255,128,0,2,0,255,64,3,0,128,0,1,255,255,255,2,0,128,0,1,0,255,64,3,255,128,0,2,0,255,64,3,255,128,0,2,0,255,64,3,0,128,0,1,255,255,255,2,0,128,0,1,0,255,64,3,255,128,0,7,0,255,64,3,0,128,0,1,255,255,255,2,0,128,0,1,0,255,64,3,255,128,0,7,0,255,64,3,0,128,0,1,255,255,255,2,0,128,0,1,0,255,64,3,255,128,0,2,0,255,64,3,255,128,0,2,0,255,64,3,0,128,0,1,255,255,255,2,0,128,0,1,0,255,64,3,255,128,0,2,0,255,64,3,255,128,0,2,0,255,64,3,0,128,0,1,255,255,255,2,0,128,0,1,0,255,64,3,255,128,0,2,0,255,64,3,255,128,0,2,0,255,64,3,0,128,0,1,255,255,255,2,0,128,0,1,0,255,64,3,255,128,0,2,0,255,64,3,255,128,0,2,0,255,64,3,0,128,
0,1,255,255,255,2,0,128,0,1,0,255,64,13,0,128,0,1,255,255,255,2,0,128,0,1,0,255,64,13,0,128,0,1,255,255,255,3,0,128,0,13,255,255,255,36);
tep_exe20:array[0..344] of byte=(
84,69,65,49,35,17,0,0,0,20,0,0,0,255,255,255,36,95,22,117,13,255,255,255,3,95,22,117,1,228,10,244,13,95,22,117,1,255,255,255,2,95,22,117,1,228,10,244,13,95,22,117,1,255,255,255,2,95,22,117,1,228,10,244,13,95,22,117,1,255,255,255,2,95,22,117,1,228,10,244,2,241,255,73,6,228,10,244,5,95,22,117,1,255,255,255,2,95,22,117,1,228,10,244,2,241,255,73,5,228,10,244,6,95,22,117,1,255,255,255,2,95,22,117,1,228,10,244,2,241,255,73,4,228,10,244,7,95,22,117,1,255,255,255,2,95,22,117,1,228,10,244,2,241,255,73,5,228,10,244,6,95,22,117,1,255,255,255,2,95,22,117,1,228,10,244,2,241,255,73,2,228,10,244,1,241,255,73,3,228,10,244,5,95,22,117,1,255,255,255,2,95,22,117,1,228,10,244,2,241,255,73,1,228,10,244,3,241,255,73,3,228,10,244,4,95,22,117,1,255,255,255,2,95,22,117,1,228,10,244,7,241,255,73,3,228,10,244,3,95,22,117,1,255,255,255,2,95,22,117,1,228,10,244,8,241,255,73,3,228,10,244,2,95,22,117,1,255,255,255,2,95,22,117,1,228,10,244,9,241,255,73,1,228,10,244,3,95,22,117,1,255,255,255,2,95,22,117,1,228,10,244,13,95,22,117,
1,255,255,255,2,95,22,117,1,228,10,244,13,95,22,117,1,255,255,255,3,95,22,117,13,255,255,255,36);
tep_c2p20:array[0..360] of byte=(
84,69,65,49,35,17,0,0,0,20,0,0,0,255,255,255,36,128,128,0,13,255,255,255,3,128,128,0,1,255,255,128,13,128,128,0,1,255,255,255,2,128,128,0,1,255,255,128,13,128,128,0,1,255,255,255,2,128,128,0,1,255,255,128,2,255,0,128,8,255,255,128,3,128,128,0,1,255,255,255,2,128,128,0,1,255,255,128,2,255,0,128,9,255,255,128,2,128,128,0,1,255,255,255,2,128,128,0,1,255,255,128,2,255,0,128,3,255,255,128,4,255,0,128,2,255,255,128,2,128,128,0,1,255,255,255,2,128,128,0,1,255,255,128,2,255,0,128,3,255,255,128,4,255,0,128,2,255,255,128,2,128,128,0,1,255,255,255,2,128,128,0,1,255,255,128,2,255,0,128,3,255,255,128,4,255,0,128,2,255,255,128,2,128,128,0,1,255,255,255,2,128,128,0,1,255,255,128,2,255,0,128,9,255,255,128,2,128,128,0,1,255,255,255,2,128,128,0,1,255,255,128,2,255,0,128,8,255,255,128,3,128,128,0,1,255,255,255,2,128,128,0,1,255,255,128,2,255,0,128,3,255,255,128,8,128,128,0,1,255,255,255,2,128,128,0,1,255,255,128,2,255,0,128,3,255,255,128,8,128,128,0,1,255,255,255,2,128,128,0,1,255,255,128,2,255,0,128,3,255,255,128,
8,128,128,0,1,255,255,255,2,128,128,0,1,255,255,128,13,128,128,0,1,255,255,255,2,128,128,0,1,255,255,128,13,128,128,0,1,255,255,255,3,128,128,0,13,255,255,255,36);
tep_c2v20:array[0..296] of byte=(
84,69,65,49,35,15,0,0,0,20,0,0,0,255,255,255,31,128,0,255,13,255,255,255,1,128,0,255,1,229,255,255,13,128,0,255,2,229,255,255,13,128,0,255,2,229,255,255,2,128,0,255,2,229,255,255,5,128,0,255,2,229,255,255,2,128,0,255,2,229,255,255,2,128,0,255,2,229,255,255,5,128,0,255,2,229,255,255,2,128,0,255,2,229,255,255,3,128,0,255,2,229,255,255,3,128,0,255,2,229,255,255,3,128,0,255,2,229,255,255,3,128,0,255,2,229,255,255,3,128,0,255,2,229,255,255,3,128,0,255,2,229,255,255,3,128,0,255,2,229,255,255,3,128,0,255,2,229,255,255,3,128,0,255,2,229,255,255,4,128,0,255,2,229,255,255,1,128,0,255,2,229,255,255,4,128,0,255,2,229,255,255,4,128,0,255,2,229,255,255,1,128,0,255,2,229,255,255,4,128,0,255,2,229,255,255,4,128,0,255,2,229,255,255,1,128,0,255,2,229,255,255,4,128,0,255,2,229,255,255,5,128,0,255,3,229,255,255,5,128,0,255,2,229,255,255,5,128,0,255,3,229,255,255,5,128,0,255,2,229,255,255,13,128,0,255,2,229,255,255,13,128,0,255,1,255,255,255,1,128,0,255,13,255,255,255,31);
tep_zip20:array[0..344] of byte=(
84,69,65,49,35,17,0,0,0,20,0,0,0,255,255,255,36,0,0,128,13,255,255,255,3,0,0,128,1,116,116,185,13,0,0,128,1,255,255,255,2,0,0,128,1,116,116,185,13,0,0,128,1,255,255,255,2,0,0,128,1,116,116,185,3,0,255,255,7,116,116,185,3,0,0,128,1,255,255,255,2,0,0,128,1,116,116,185,3,0,255,255,7,116,116,185,3,0,0,128,1,255,255,255,2,0,0,128,1,116,116,185,9,0,255,255,1,116,116,185,3,0,0,128,1,255,255,255,2,0,0,128,1,116,116,185,8,0,255,255,2,116,116,185,3,0,0,128,1,255,255,255,2,0,0,128,1,116,116,185,7,0,255,255,2,116,116,185,4,0,0,128,1,255,255,255,2,0,0,128,1,116,116,185,6,0,255,255,2,116,116,185,5,0,0,128,1,255,255,255,2,0,0,128,1,116,116,185,5,0,255,255,2,116,116,185,6,0,0,128,1,255,255,255,2,0,0,128,1,116,116,185,4,0,255,255,2,116,116,185,7,0,0,128,1,255,255,255,2,0,0,128,1,116,116,185,3,0,255,255,2,116,116,185,8,0,0,128,1,255,255,255,2,0,0,128,1,116,116,185,3,0,255,255,7,116,116,185,3,0,0,128,1,255,255,255,2,0,0,128,1,116,116,185,3,0,255,255,7,116,116,185,3,0,0,128,1,255,255,255,2,0,0,128,1,116,116,185,13,
0,0,128,1,255,255,255,3,0,0,128,13,255,255,255,36);
tep_txt20:array[0..604] of byte=(
84,69,65,49,35,14,0,0,0,20,0,0,0,255,0,0,44,188,154,77,1,212,191,75,1,144,107,49,1,163,132,60,1,212,191,75,1,147,125,98,2,212,191,75,1,132,110,109,1,157,130,93,1,255,0,0,4,120,120,193,2,144,107,49,1,188,170,145,1,141,121,111,1,185,182,211,2,169,144,111,1,190,180,186,1,157,130,93,1,163,163,163,1,255,0,0,2,120,120,192,1,196,198,226,1,134,105,66,1,233,244,242,1,134,105,66,1,236,246,244,1,134,105,66,2,247,251,250,1,134,105,66,1,255,255,255,1,113,113,113,1,255,0,0,2,120,120,192,1,187,205,208,1,233,244,242,3,236,246,244,1,241,248,247,2,247,251,250,1,252,253,253,1,255,255,255,1,113,113,113,1,255,0,0,2,120,120,192,1,193,207,214,1,233,244,242,3,236,246,244,1,241,248,247,2,247,251,250,1,252,253,253,1,255,255,255,1,113,113,113,1,255,0,0,2,120,120,192,1,191,206,213,1,233,244,242,1,126,127,127,3,187,189,189,2,247,251,250,1,252,253,253,1,255,255,255,1,113,113,113,1,255,0,0,2,120,120,192,1,191,205,213,1,233,244,242,3,236,246,244,1,241,248,247,2,247,251,250,1,252,253,253,1,255,255,255,1,113,113,113,1,255,0,0,2,
120,120,192,1,190,208,209,1,233,244,242,1,126,127,127,5,187,189,189,1,255,255,255,2,113,113,113,1,255,0,0,2,120,120,192,1,190,208,209,1,233,244,242,1,255,255,255,8,113,113,113,1,255,0,0,2,120,120,192,1,190,205,212,1,233,244,242,3,236,246,244,1,241,248,247,2,247,251,250,1,252,253,253,1,255,255,255,1,113,113,113,1,255,0,0,2,120,120,192,1,191,202,216,1,233,244,242,1,126,127,127,5,187,189,189,1,255,255,255,2,113,113,113,1,255,0,0,2,120,120,192,1,193,206,217,1,233,244,242,3,236,246,244,1,241,248,247,2,247,251,250,1,252,253,253,1,255,255,255,1,113,113,113,1,255,0,0,2,120,120,192,1,188,204,212,1,233,244,242,1,126,127,127,1,187,189,189,1,236,246,244,1,241,248,247,2,247,251,250,1,252,253,253,1,255,255,255,1,113,113,113,1,255,0,0,2,120,120,192,1,182,202,206,1,233,244,242,2,235,245,243,1,236,245,244,1,195,201,200,2,188,192,192,1,161,164,163,1,143,144,144,1,148,148,148,1,255,0,0,3,188,191,202,1,155,161,161,1,125,129,129,1,106,108,108,1,104,104,104,1,113,113,113,2,128,128,128,1,141,141,141,1,159,159,159,1,255,
0,0,30);
tep_cur20:array[0..328] of byte=(
84,69,65,49,35,12,0,0,0,20,0,0,0,255,0,0,12,0,0,0,1,255,0,0,11,0,0,0,2,255,0,0,10,0,0,0,1,255,255,227,1,0,0,0,1,255,0,0,9,0,0,0,1,255,255,220,2,0,0,0,1,255,0,0,8,0,0,0,1,255,255,213,3,0,0,0,1,255,0,0,7,0,0,0,1,255,255,206,4,0,0,0,1,255,0,0,6,0,0,0,1,255,255,199,5,0,0,0,1,255,0,0,5,0,0,0,1,255,255,192,6,0,0,0,1,255,0,0,4,0,0,0,1,255,255,186,7,0,0,0,1,255,0,0,3,0,0,0,1,255,255,186,8,0,0,0,1,255,0,0,2,0,0,0,1,255,255,192,9,0,0,0,1,255,0,0,1,0,0,0,1,255,255,199,10,0,0,0,2,255,255,206,6,0,0,0,6,255,255,213,3,0,0,0,1,255,255,213,2,0,0,0,1,255,0,0,4,0,0,0,1,255,255,220,2,0,0,0,1,255,0,0,1,0,0,0,1,255,255,220,2,0,0,0,1,255,0,0,3,0,0,0,1,255,255,227,1,0,0,0,1,255,0,0,2,0,0,0,1,255,255,227,2,0,0,0,1,255,0,0,3,0,0,0,2,255,0,0,4,0,0,0,1,255,255,234,2,0,0,0,1,255,0,0,8,0,0,0,1,255,255,241,2,0,0,0,1,255,0,0,9,0,0,0,2,255,0,0,3);
tep_xxx20:array[0..232] of byte=(
84,69,65,49,35,14,0,0,0,20,0,0,0,255,0,0,44,64,138,213,8,255,0,0,5,64,138,213,1,255,255,255,6,64,138,213,3,255,0,0,4,64,138,213,1,255,255,255,6,64,138,213,3,255,0,0,4,64,138,213,1,255,255,255,6,64,138,213,2,255,255,255,1,64,138,213,1,255,0,0,3,64,138,213,1,255,255,255,6,64,138,213,5,255,0,0,2,64,138,213,1,255,255,255,10,64,138,213,1,255,0,0,2,64,138,213,1,255,255,255,10,64,138,213,1,255,0,0,2,64,138,213,1,255,255,255,10,64,138,213,1,255,0,0,2,64,138,213,1,255,255,255,10,64,138,213,1,255,0,0,2,64,138,213,1,255,255,255,10,64,138,213,1,255,0,0,2,64,138,213,1,255,255,255,10,64,138,213,1,255,0,0,2,64,138,213,1,255,255,255,10,64,138,213,1,255,0,0,2,64,138,213,1,255,255,255,10,64,138,213,1,255,0,0,3,64,138,213,10,255,0,0,44);
tep_bwd20:array[0..464] of byte=(
84,69,65,49,35,20,0,0,0,20,0,0,0,241,241,241,80,0,128,255,6,241,241,241,1,0,128,255,6,241,241,241,3,0,128,255,3,241,241,241,2,0,128,255,3,140,197,255,3,241,241,241,1,140,197,255,1,0,128,255,3,140,197,255,2,241,241,241,3,0,128,255,1,140,197,255,2,241,241,241,2,0,128,255,3,241,241,241,4,0,128,255,3,140,197,255,1,241,241,241,4,0,128,255,1,140,197,255,1,241,241,241,3,0,128,255,3,140,197,255,1,241,241,241,4,0,128,255,3,241,241,241,3,0,128,255,1,241,241,241,1,140,197,255,1,241,241,241,4,0,128,255,3,241,241,241,3,0,128,255,4,140,197,255,1,241,241,241,2,0,128,255,1,140,197,255,1,241,241,241,5,0,128,255,3,140,197,255,1,241,241,241,2,0,128,255,4,140,197,255,1,241,241,241,2,0,128,255,1,140,197,255,1,241,241,241,5,0,128,255,3,140,197,255,1,241,241,241,1,0,128,255,1,241,241,241,1,140,197,255,1,0,128,255,3,241,241,241,1,0,128,255,1,241,241,241,1,140,197,255,1,241,241,241,6,0,128,255,3,241,241,241,1,0,128,255,1,140,197,255,1,241,241,241,1,0,128,255,3,140,197,255,1,0,128,255,1,140,197,255,1,241,241,241,7,0,128,
255,3,140,197,255,1,0,128,255,1,140,197,255,1,241,241,241,1,0,128,255,3,140,197,255,1,0,128,255,1,140,197,255,1,241,241,241,8,0,128,255,3,241,241,241,1,140,197,255,1,241,241,241,2,0,128,255,3,241,241,241,1,140,197,255,1,241,241,241,8,0,128,255,3,140,197,255,1,241,241,241,3,0,128,255,3,140,197,255,1,241,241,241,9,0,128,255,3,140,197,255,1,241,241,241,3,0,128,255,3,140,197,255,1,241,241,241,10,0,128,255,1,140,197,255,2,241,241,241,4,0,128,255,1,140,197,255,2,241,241,241,11,140,197,255,1,241,241,241,6,140,197,255,1,241,241,241,45);
tep_bwp20:array[0..464] of byte=(
84,69,65,49,35,20,0,0,0,20,0,0,0,241,241,241,80,255,128,255,6,241,241,241,1,255,128,255,6,241,241,241,3,255,128,255,3,241,241,241,2,255,128,255,3,255,209,255,3,241,241,241,1,255,209,255,1,255,128,255,3,255,209,255,2,241,241,241,3,255,128,255,1,255,209,255,2,241,241,241,2,255,128,255,3,241,241,241,4,255,128,255,3,255,209,255,1,241,241,241,4,255,128,255,1,255,209,255,1,241,241,241,3,255,128,255,3,255,209,255,1,241,241,241,4,255,128,255,3,241,241,241,3,255,128,255,1,241,241,241,1,255,209,255,1,241,241,241,4,255,128,255,3,241,241,241,3,255,128,255,4,255,209,255,1,241,241,241,2,255,128,255,1,255,209,255,1,241,241,241,5,255,128,255,3,255,209,255,1,241,241,241,2,255,128,255,4,255,209,255,1,241,241,241,2,255,128,255,1,255,209,255,1,241,241,241,5,255,128,255,3,255,209,255,1,241,241,241,1,255,128,255,1,241,241,241,1,255,209,255,1,255,128,255,3,241,241,241,1,255,128,255,1,241,241,241,1,255,209,255,1,241,241,241,6,255,128,255,3,241,241,241,1,255,128,255,1,255,209,255,1,241,241,241,1,255,128,255,3,255,209,255,
1,255,128,255,1,255,209,255,1,241,241,241,7,255,128,255,3,255,209,255,1,255,128,255,1,255,209,255,1,241,241,241,1,255,128,255,3,255,209,255,1,255,128,255,1,255,209,255,1,241,241,241,8,255,128,255,3,241,241,241,1,255,209,255,1,241,241,241,2,255,128,255,3,241,241,241,1,255,209,255,1,241,241,241,8,255,128,255,3,255,209,255,1,241,241,241,3,255,128,255,3,255,209,255,1,241,241,241,9,255,128,255,3,255,209,255,1,241,241,241,3,255,128,255,3,255,209,255,1,241,241,241,10,255,128,255,1,255,209,255,2,241,241,241,4,255,128,255,1,255,209,255,2,241,241,241,11,255,209,255,1,241,241,241,6,255,209,255,1,241,241,241,45);
//xxxxxxxxxxxxxxxx RTF requires its OWN image //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//???????????????????????//22jun2022
tep_rtf20:array[0..464] of byte=(
84,69,65,49,35,20,0,0,0,20,0,0,0,241,241,241,80,255,128,255,6,241,241,241,1,255,128,255,6,241,241,241,3,255,128,255,3,241,241,241,2,255,128,255,3,255,209,255,3,241,241,241,1,255,209,255,1,255,128,255,3,255,209,255,2,241,241,241,3,255,128,255,1,255,209,255,2,241,241,241,2,255,128,255,3,241,241,241,4,255,128,255,3,255,209,255,1,241,241,241,4,255,128,255,1,255,209,255,1,241,241,241,3,255,128,255,3,255,209,255,1,241,241,241,4,255,128,255,3,241,241,241,3,255,128,255,1,241,241,241,1,255,209,255,1,241,241,241,4,255,128,255,3,241,241,241,3,255,128,255,4,255,209,255,1,241,241,241,2,255,128,255,1,255,209,255,1,241,241,241,5,255,128,255,3,255,209,255,1,241,241,241,2,255,128,255,4,255,209,255,1,241,241,241,2,255,128,255,1,255,209,255,1,241,241,241,5,255,128,255,3,255,209,255,1,241,241,241,1,255,128,255,1,241,241,241,1,255,209,255,1,255,128,255,3,241,241,241,1,255,128,255,1,241,241,241,1,255,209,255,1,241,241,241,6,255,128,255,3,241,241,241,1,255,128,255,1,255,209,255,1,241,241,241,1,255,128,255,3,255,209,255,
1,255,128,255,1,255,209,255,1,241,241,241,7,255,128,255,3,255,209,255,1,255,128,255,1,255,209,255,1,241,241,241,1,255,128,255,3,255,209,255,1,255,128,255,1,255,209,255,1,241,241,241,8,255,128,255,3,241,241,241,1,255,209,255,1,241,241,241,2,255,128,255,3,241,241,241,1,255,209,255,1,241,241,241,8,255,128,255,3,255,209,255,1,241,241,241,3,255,128,255,3,255,209,255,1,241,241,241,9,255,128,255,3,255,209,255,1,241,241,241,3,255,128,255,3,255,209,255,1,241,241,241,10,255,128,255,1,255,209,255,2,241,241,241,4,255,128,255,1,255,209,255,2,241,241,241,11,255,209,255,1,241,241,241,6,255,209,255,1,241,241,241,45);
tep_mid20:array[0..224] of byte=(
84,69,65,49,35,15,0,0,0,20,0,0,0,0,255,0,69,255,113,184,6,0,255,0,9,255,113,184,6,0,255,0,9,255,113,184,1,0,255,0,4,255,113,184,1,38,105,172,9,255,113,184,1,38,105,172,4,255,113,184,1,0,255,0,4,255,113,184,1,0,255,0,4,255,113,184,1,0,255,0,4,255,113,184,1,38,105,172,4,255,113,184,1,38,105,172,4,255,113,184,1,38,105,172,4,255,113,184,1,0,255,0,4,255,113,184,1,0,255,0,4,255,113,184,1,0,255,0,4,255,113,184,1,38,105,172,4,255,113,184,1,38,105,172,3,255,113,184,2,38,105,172,3,255,113,184,2,0,255,0,4,255,113,184,1,0,255,0,2,255,113,184,3,0,255,0,2,255,113,184,3,38,105,172,4,255,113,184,1,38,105,172,3,255,113,184,2,38,105,172,3,255,113,184,2,0,255,0,2,255,113,184,3,0,255,0,12,255,113,184,2,0,255,0,71);
tep_notes20:array[0..288] of byte=(
84,69,65,49,35,20,0,0,0,20,0,0,0,252,252,252,27,164,93,249,2,252,252,252,18,164,93,249,7,252,252,252,13,164,93,249,10,252,252,252,10,164,93,249,10,252,252,252,10,164,93,249,2,252,252,252,5,164,93,249,3,252,252,252,10,164,93,249,2,252,252,252,6,164,93,249,2,252,252,252,10,164,93,249,2,252,252,252,6,164,93,249,2,252,252,252,10,164,93,249,2,252,252,252,6,164,93,249,2,252,252,252,10,164,93,249,2,252,252,252,6,164,93,249,2,252,252,252,10,164,93,249,2,252,252,252,6,164,93,249,2,252,252,252,6,164,93,249,6,252,252,252,6,164,93,249,2,252,252,252,5,164,93,249,2,255,255,128,1,164,93,249,4,252,252,252,5,164,93,249,3,252,252,252,4,164,93,249,1,255,255,128,1,164,93,249,6,252,252,252,2,164,93,249,6,252,252,252,4,164,93,249,7,252,252,252,1,164,93,249,2,255,255,128,1,164,93,249,5,252,252,252,4,164,93,249,6,252,252,252,2,164,93,249,1,255,255,128,1,164,93,249,6,252,252,252,5,164,93,249,3,252,252,252,4,164,93,249,7,252,252,252,13,164,93,249,6,252,252,252,16,164,93,249,2,252,252,252,27);
tep_bell20:array[0..272] of byte=(
84,69,65,49,35,16,0,0,0,20,0,0,0,0,255,0,38,38,105,172,4,0,255,0,11,38,105,172,2,255,178,216,2,38,105,172,2,0,255,0,10,38,105,172,1,255,178,216,4,38,105,172,1,0,255,0,10,38,105,172,1,255,178,216,4,38,105,172,1,0,255,0,10,38,105,172,1,255,178,216,4,38,105,172,1,0,255,0,9,38,105,172,2,255,178,216,4,38,105,172,2,0,255,0,7,38,105,172,2,255,178,216,6,38,105,172,2,0,255,0,6,38,105,172,1,255,178,216,8,38,105,172,1,0,255,0,6,38,105,172,1,255,178,216,2,38,105,172,4,255,178,216,2,38,105,172,1,0,255,0,5,38,105,172,4,255,178,216,4,38,105,172,4,0,255,0,3,38,105,172,2,255,178,216,4,38,105,172,2,255,178,216,4,38,105,172,2,0,255,0,2,38,105,172,1,255,178,216,4,38,105,172,4,255,178,216,4,38,105,172,1,0,255,0,2,38,105,172,2,255,178,216,4,38,105,172,2,255,178,216,4,38,105,172,2,0,255,0,3,38,105,172,4,255,178,216,4,38,105,172,4,0,255,0,8,38,105,172,4,0,255,0,54);
tep_sonnerie20:array[0..352] of byte=(
84,69,65,49,35,19,0,0,0,20,0,0,0,0,255,0,67,38,105,172,4,0,255,0,14,38,105,172,1,255,178,216,3,38,105,172,2,0,255,0,10,38,105,172,3,255,178,216,5,38,105,172,1,0,255,0,9,38,105,172,1,255,178,216,8,38,105,172,1,0,255,0,5,38,105,172,4,255,178,216,8,38,105,172,1,0,255,0,5,38,105,172,2,255,178,216,2,38,105,172,3,255,178,216,5,38,105,172,1,0,255,0,6,38,105,172,1,255,178,216,6,38,105,172,1,255,178,216,3,38,105,172,1,0,255,0,8,38,105,172,1,255,178,216,2,38,105,172,1,255,178,216,3,38,105,172,1,255,178,216,2,38,105,172,1,0,255,0,3,38,105,172,2,0,255,0,4,38,105,172,1,255,178,216,2,38,105,172,2,255,178,216,1,38,105,172,1,255,178,216,2,38,105,172,1,0,255,0,2,38,105,172,2,0,255,0,5,38,105,172,1,255,178,216,1,38,105,172,3,255,178,216,1,38,105,172,2,255,178,216,1,38,105,172,1,0,255,0,1,38,105,172,3,0,255,0,6,38,105,172,1,255,178,216,1,38,105,172,1,255,178,216,3,38,105,172,2,0,255,0,2,38,105,172,1,0,255,0,2,38,105,172,1,0,255,0,6,38,105,172,1,255,178,216,5,38,105,172,1,0,255,0,6,38,105,172,1,0,255,0,6,38,105,172,
2,255,178,216,3,38,105,172,1,0,255,0,7,38,105,172,1,0,255,0,7,38,105,172,4,0,255,0,65);
//large images -----------------------------------------------------------------
tep_info32:array[0..564] of byte=(
84,69,65,49,35,32,0,0,0,32,0,0,0,0,255,0,15,201,201,150,4,196,196,0,2,0,255,0,24,201,201,150,2,255,255,0,5,196,196,0,2,0,255,0,22,201,201,150,3,244,244,0,2,255,255,0,4,196,196,0,2,0,255,0,20,201,201,150,2,244,244,0,3,255,255,0,6,196,196,0,2,0,255,0,19,201,201,150,2,244,244,0,3,255,255,0,6,196,196,0,2,0,255,0,18,201,201,150,2,244,244,0,4,255,255,0,6,196,196,0,2,0,255,0,18,201,201,150,2,244,244,0,3,255,255,0,7,196,196,0,2,0,255,0,18,201,201,150,2,244,244,0,2,255,255,0,8,196,196,0,2,0,255,0,18,201,201,150,2,244,244,0,1,255,255,0,9,196,196,0,2,0,255,0,18,201,201,150,2,255,255,0,1,244,244,0,1,255,255,0,7,196,196,0,2,0,255,0,19,201,201,150,2,255,255,0,9,196,196,0,2,0,255,0,19,201,201,150,2,255,255,0,9,196,196,0,2,0,255,0,19,201,201,150,2,255,255,0,8,196,196,0,2,0,255,0,20,201,201,150,2,255,255,0,8,196,196,0,2,0,255,0,20,201,201,150,2,255,255,0,8,196,196,0,2,0,255,0,21,201,201,150,1,255,255,0,7,196,196,0,2,0,255,0,22,201,201,150,2,255,255,0,6,196,196,0,2,0,255,0,23,201,201,150,1,255,255,0,5,196,196,0,2,
0,255,0,24,201,201,150,1,255,255,0,5,196,196,0,2,0,255,0,24,201,201,150,2,255,255,0,3,196,196,0,2,0,255,0,26,201,201,150,1,255,255,0,3,196,196,0,2,0,255,0,27,201,201,150,2,196,196,0,2,0,255,0,28,201,201,150,2,196,196,0,1,0,255,0,26,201,201,150,3,255,255,0,3,196,196,0,1,0,255,0,24,201,201,150,2,255,255,0,1,244,244,0,2,255,255,0,2,196,196,0,2,0,255,0,23,201,201,150,1,255,255,0,1,244,244,0,2,255,255,0,4,196,196,0,2,0,255,0,22,201,201,150,1,244,244,0,2,255,255,0,5,196,196,0,2,0,255,0,22,201,201,150,1,255,255,0,7,196,196,0,2,0,255,0,22,201,201,150,1,255,255,0,7,196,196,0,2,0,255,0,22,201,201,150,2,255,255,0,5,196,196,0,2,0,255,0,24,201,201,150,3,196,196,0,4,0,255,0,27,201,201,150,1,196,196,0,3,0,255,0,15);
tep_query32:array[0..616] of byte=(
84,69,65,49,35,32,0,0,0,32,0,0,0,252,252,252,45,0,128,255,8,252,252,252,22,0,128,255,2,0,255,255,8,0,128,255,2,252,252,252,18,0,128,255,2,0,255,255,12,0,128,255,1,252,252,252,16,0,128,255,1,0,255,255,15,0,128,255,1,252,252,252,14,0,128,255,1,0,255,255,5,0,128,255,4,0,255,255,8,0,128,255,1,252,252,252,12,0,128,255,1,0,255,255,5,0,128,255,1,252,252,252,4,0,128,255,1,0,255,255,7,0,128,255,1,252,252,252,12,0,128,255,1,0,255,255,4,0,128,255,1,252,252,252,6,0,128,255,1,0,255,255,7,0,128,255,1,252,252,252,10,0,128,255,1,0,255,255,5,0,128,255,1,252,252,252,7,0,128,255,1,0,255,255,6,0,128,255,1,252,252,252,10,0,128,255,1,0,255,255,6,0,128,255,1,252,252,252,6,0,128,255,1,0,255,255,6,0,128,255,1,252,252,252,10,0,128,255,1,0,255,255,6,0,128,255,1,252,252,252,6,0,128,255,1,0,255,255,6,0,128,255,1,252,252,252,10,0,128,255,1,0,255,255,6,0,128,255,1,252,252,252,5,0,128,255,1,0,255,255,6,0,128,255,1,252,252,252,12,0,128,255,1,0,255,255,4,0,128,255,2,252,252,252,4,0,128,255,1,0,255,255,7,0,128,255,1,252,252,252,12,
0,128,255,2,0,255,255,2,0,128,255,2,252,252,252,4,0,128,255,1,0,255,255,7,0,128,255,1,252,252,252,14,0,128,255,4,252,252,252,4,0,128,255,1,0,255,255,7,0,128,255,1,252,252,252,22,0,128,255,1,0,255,255,6,0,128,255,2,252,252,252,22,0,128,255,1,0,255,255,6,0,128,255,1,252,252,252,23,0,128,255,1,0,255,255,6,0,128,255,1,252,252,252,24,0,128,255,1,0,255,255,5,0,128,255,1,252,252,252,25,0,128,255,1,0,255,255,4,0,128,255,1,252,252,252,27,0,128,255,1,0,255,255,2,0,128,255,1,252,252,252,28,0,128,255,1,0,255,255,1,0,128,255,1,252,252,252,28,0,128,255,3,252,252,252,28,0,128,255,1,0,255,255,2,0,128,255,1,252,252,252,27,0,128,255,1,0,255,255,4,0,128,255,1,252,252,252,25,0,128,255,1,0,255,255,6,0,128,255,1,252,252,252,24,0,128,255,1,0,255,255,6,0,128,255,1,252,252,252,24,0,128,255,1,0,255,255,6,0,128,255,1,252,252,252,25,0,128,255,1,0,255,255,4,0,128,255,1,252,252,252,27,0,128,255,1,0,255,255,2,0,128,255,1,252,252,252,29,0,128,255,2,252,252,252,50);
tep_error32:array[0..328] of byte=(
84,69,65,49,35,32,0,0,0,32,0,0,0,255,255,255,168,255,0,0,4,255,255,255,9,255,0,0,4,255,255,255,15,255,0,0,5,255,255,255,7,255,0,0,5,255,255,255,16,255,0,0,5,255,255,255,5,255,0,0,5,255,255,255,18,255,0,0,4,255,255,255,5,255,0,0,4,255,255,255,19,255,0,0,5,255,255,255,3,255,0,0,5,255,255,255,20,255,0,0,5,255,255,255,1,255,0,0,5,255,255,255,22,255,0,0,4,255,255,255,1,255,0,0,4,255,255,255,23,255,0,0,9,255,255,255,24,255,0,0,7,255,255,255,25,255,0,0,7,255,255,255,26,255,0,0,5,255,255,255,27,255,0,0,5,255,255,255,26,255,0,0,7,255,255,255,24,255,0,0,9,255,255,255,23,255,0,0,4,255,255,255,1,255,0,0,4,255,255,255,22,255,0,0,5,255,255,255,1,255,0,0,5,255,255,255,21,255,0,0,4,255,255,255,3,255,0,0,4,255,255,255,20,255,0,0,5,255,255,255,3,255,0,0,5,255,255,255,18,255,0,0,5,255,255,255,5,255,0,0,5,255,255,255,17,255,0,0,4,255,255,255,7,255,0,0,4,255,255,255,16,255,0,0,5,255,255,255,7,255,0,0,5,255,255,255,14,255,0,0,5,255,255,255,9,255,0,0,5,255,255,255,13,255,0,0,4,255,255,255,11,255,0,0,4,255,255,255,134);
tep_color32:array[0..380] of byte=(
84,69,65,49,35,32,0,0,0,32,0,0,0,255,255,255,14,125,125,255,2,255,255,0,2,255,255,255,24,125,125,255,6,255,255,0,6,255,255,255,18,125,125,255,8,255,255,0,8,255,255,255,15,125,125,255,9,255,255,0,9,255,255,255,12,125,125,255,11,255,255,0,11,255,255,255,9,125,125,255,12,255,255,0,12,255,255,255,8,125,125,255,12,255,255,0,12,255,255,255,7,125,125,255,13,255,255,0,13,255,255,255,5,125,125,255,14,255,255,0,14,255,255,255,4,125,125,255,14,255,255,0,14,255,255,255,3,125,125,255,15,255,255,0,15,255,255,255,2,125,125,255,15,255,255,0,15,255,255,255,2,125,125,255,15,255,255,0,15,255,255,255,1,125,125,255,16,255,255,0,16,125,125,255,16,255,255,0,16,125,125,255,16,255,255,0,16,0,255,0,16,255,0,255,16,0,255,0,16,255,0,255,16,0,255,0,16,255,0,255,16,255,255,255,1,0,255,0,15,255,0,255,15,255,255,255,2,0,255,0,15,255,0,255,15,255,255,255,2,0,255,0,15,255,0,255,15,255,255,255,3,0,255,0,14,255,0,255,14,255,255,255,4,0,255,0,14,255,0,255,14,255,255,255,5,0,255,0,13,255,0,255,13,255,255,255,7,0,255,0,12,255,0,255,12,
255,255,255,8,0,255,0,12,255,0,255,12,255,255,255,9,0,255,0,11,255,0,255,11,255,255,255,12,0,255,0,9,255,0,255,9,255,255,255,15,0,255,0,8,255,0,255,8,255,255,255,18,0,255,0,6,255,0,255,6,255,255,255,24,0,255,0,2,255,0,255,2,255,255,255,14);
tep_folderimage32:array[0..476] of byte=(
84,69,65,49,35,32,0,0,0,32,0,0,0,252,252,252,147,160,130,35,8,252,252,252,23,160,130,35,10,252,252,252,21,160,130,35,2,255,0,255,8,160,130,35,2,252,252,252,19,160,130,35,2,255,0,255,10,160,130,35,2,252,252,252,5,160,130,35,6,252,252,252,6,160,130,35,2,255,0,255,11,0,255,255,1,160,130,35,2,252,252,252,3,160,130,35,8,252,252,252,5,160,130,35,2,255,0,255,9,0,255,255,3,160,130,35,2,252,252,252,2,160,130,35,3,255,255,128,4,160,130,35,9,255,0,255,8,0,255,255,4,160,130,35,2,252,252,252,2,160,130,35,2,255,255,128,6,160,130,35,8,255,0,255,6,0,255,255,6,160,130,35,2,252,252,252,2,160,130,35,2,255,255,128,12,160,130,35,2,255,0,255,4,0,255,255,8,160,130,35,2,252,252,252,2,160,130,35,2,255,255,128,12,160,130,35,2,255,0,255,3,0,255,255,9,160,130,35,2,252,252,252,2,160,130,35,2,255,255,128,12,160,130,35,2,255,0,255,1,0,255,255,11,160,130,35,2,252,252,252,2,160,130,35,2,255,255,128,12,160,130,35,2,0,255,255,12,160,130,35,2,252,252,252,2,160,130,35,2,255,255,128,13,160,130,35,2,0,255,255,10,160,130,35,2,252,252,
252,3,160,130,35,2,255,255,128,14,160,130,35,2,0,255,255,8,160,130,35,2,252,252,252,4,160,130,35,2,255,255,128,15,160,130,35,10,252,252,252,5,160,130,35,2,255,255,128,16,160,130,35,8,252,252,252,6,160,130,35,2,255,255,128,22,160,130,35,2,252,252,252,6,160,130,35,2,255,255,128,22,160,130,35,2,252,252,252,6,160,130,35,2,255,255,128,22,160,130,35,2,252,252,252,6,160,130,35,2,255,255,128,22,160,130,35,2,252,252,252,6,160,130,35,3,255,255,128,21,160,130,35,2,252,252,252,6,160,130,35,4,255,255,128,19,160,130,35,3,252,252,252,7,160,130,35,25,252,252,252,8,160,130,35,23,252,252,252,134);
tep_newfolder32:array[0..536] of byte=(
84,69,65,49,35,32,0,0,0,32,0,0,0,252,252,252,85,255,191,191,4,252,252,252,27,255,191,191,6,252,252,252,25,255,191,191,2,255,0,0,4,255,191,191,2,252,252,252,23,255,191,191,3,255,0,0,4,255,191,191,3,252,252,252,19,255,191,191,6,255,0,0,4,255,191,191,6,252,252,252,15,255,191,191,6,255,0,0,6,255,191,191,5,252,252,252,4,160,130,35,6,252,252,252,4,255,191,191,2,255,0,0,16,255,191,191,1,252,252,252,2,160,130,35,8,252,252,252,3,255,191,191,2,255,0,0,16,255,191,191,1,252,252,252,1,160,130,35,3,255,255,128,4,160,130,35,7,255,191,191,3,255,0,0,10,255,191,191,3,252,252,252,2,160,130,35,2,255,255,128,6,160,130,35,8,255,191,191,2,255,0,0,8,255,191,191,4,252,252,252,2,160,130,35,2,255,255,128,14,255,191,191,2,255,0,0,8,255,191,191,3,252,252,252,3,160,130,35,2,255,255,128,13,255,191,191,3,255,0,0,9,255,191,191,1,252,252,252,4,160,130,35,2,255,255,128,12,255,191,191,2,255,0,0,5,255,191,191,2,255,0,0,5,255,191,191,2,252,252,252,2,160,130,35,2,255,255,128,12,255,191,191,2,255,0,0,4,255,191,191,4,255,0,0,4,255,191,
191,2,252,252,252,2,160,130,35,2,255,255,128,13,255,191,191,2,255,0,0,3,255,191,191,4,255,0,0,3,255,191,191,2,252,252,252,3,160,130,35,2,255,255,128,14,255,191,191,2,255,0,0,2,255,191,191,4,255,0,0,2,255,191,191,2,252,252,252,4,160,130,35,2,255,255,128,15,255,191,191,4,255,255,128,3,255,191,191,2,252,252,252,6,160,130,35,2,255,255,128,16,255,191,191,2,255,255,128,4,160,130,35,2,252,252,252,6,160,130,35,2,255,255,128,22,160,130,35,2,252,252,252,6,160,130,35,2,255,255,128,22,160,130,35,2,252,252,252,6,160,130,35,2,255,255,128,22,160,130,35,2,252,252,252,6,160,130,35,2,255,255,128,22,160,130,35,2,252,252,252,6,160,130,35,3,255,255,128,21,160,130,35,2,252,252,252,6,160,130,35,4,255,255,128,19,160,130,35,3,252,252,252,7,160,130,35,25,252,252,252,8,160,130,35,23,252,252,252,134);
//system color schemes ---------------------------------------------------------
//new built-in colors - 09may2021
cols_BurntYellow:array[0..83] of byte=(99,111,108,50,1,0,0,0,2,35,32,3,50,25,23,2,51,0,0,0,52,176,162,14,53,176,162,14,54,190,175,16,55,25,23,2,56,89,82,8,57,25,23,2,58,0,0,0,100,25,23,2,101,0,0,0,102,176,162,14,103,176,162,14,104,190,175,16,105,210,200,92,106,89,82,8,107,53,49,4,108,0,0,0);
cols_BurntRed:array[0..83] of byte=(99,111,108,50,1,0,0,0,2,35,3,3,50,25,2,2,51,0,0,0,52,163,0,11,53,163,0,11,54,232,0,21,55,219,213,28,56,89,8,8,57,53,4,4,58,0,0,0,100,25,2,2,101,0,0,0,102,163,0,11,103,163,0,11,104,232,0,21,105,219,213,28,106,89,8,8,107,53,4,4,108,0,0,0);
cols_BurntPurple:array[0..83] of byte=(99,111,108,50,1,0,0,0,2,26,0,26,50,18,0,20,51,0,0,0,52,63,0,66,53,63,0,66,54,156,0,163,55,27,154,188,56,99,0,104,57,18,0,20,58,0,0,0,100,18,0,20,101,0,0,0,102,63,0,66,103,63,0,66,104,156,0,163,105,27,154,188,106,99,0,104,107,18,0,20,108,0,0,0);
cols_BurntOrange:array[0..83] of byte=(99,111,108,50,1,0,0,0,2,35,14,3,50,25,13,2,51,0,0,0,52,190,98,16,53,190,98,16,54,190,99,16,55,85,42,87,56,89,36,8,57,25,13,2,58,0,0,0,100,25,13,2,101,0,0,0,102,190,98,16,103,190,98,16,104,190,99,16,105,85,42,87,106,89,36,8,107,25,13,2,108,0,0,0);
cols_Eerie:array[0..83] of byte=(99,111,108,50,1,39,14,0,2,51,40,0,50,39,14,0,51,39,14,0,52,27,37,0,53,27,37,0,54,73,100,0,55,123,123,0,56,54,54,0,57,39,14,0,58,39,14,0,100,51,40,0,101,39,14,0,102,27,37,0,103,27,37,0,104,73,100,0,105,123,123,0,106,54,54,0,107,39,14,0,108,39,14,0);
cols_Army:array[0..83] of byte=(99,111,108,50,1,80,84,73,2,180,184,173,50,234,237,227,51,204,207,197,52,124,127,117,53,124,127,117,54,114,117,107,55,255,255,255,56,154,157,147,57,194,197,187,58,184,187,177,100,205,208,198,101,175,178,168,102,95,98,88,103,95,98,88,104,85,88,78,105,235,238,228,106,125,128,118,107,165,168,158,108,155,158,148);
cols_SoftGreen:array[0..83] of byte=(99,111,108,50,1,120,152,124,2,220,252,224,50,255,255,250,51,224,228,217,52,156,189,159,53,156,189,159,54,126,147,129,55,255,255,255,56,169,173,162,57,213,217,206,58,202,206,195,100,245,255,231,101,215,225,201,102,156,189,159,103,156,189,159,104,136,157,138,105,102,129,105,106,165,175,151,107,205,215,191,108,195,205,181);
cols_Marine:array[0..83] of byte=(99,111,108,50,1,41,70,84,2,140,163,174,50,222,240,249,51,192,210,219,52,112,130,139,53,112,130,139,54,102,120,129,55,192,210,219,56,142,160,169,57,182,200,209,58,172,190,199,100,163,185,196,101,133,155,166,102,53,75,86,103,53,75,86,104,43,65,76,105,193,215,226,106,83,105,116,107,123,145,156,108,113,135,146);
cols_Lilac:array[0..83] of byte=(99,111,108,50,1,122,122,137,2,252,198,255,50,252,209,255,51,222,179,225,52,142,99,145,53,142,99,145,54,132,89,135,55,222,179,225,56,172,129,175,57,212,169,215,58,202,159,205,100,252,198,255,101,222,168,225,102,142,88,145,103,142,88,145,104,132,78,135,105,222,168,225,106,172,118,175,107,212,158,215,108,202,148,205);
cols_Gold:array[0..83] of byte=(99,111,108,50,1,158,149,125,2,241,241,174,50,229,228,165,51,199,198,135,52,119,118,55,53,119,118,55,54,109,108,45,55,255,255,195,56,149,148,85,57,189,188,125,58,179,178,115,100,242,242,175,101,212,212,145,102,132,132,65,103,132,132,65,104,122,122,55,105,212,212,145,106,162,162,95,107,202,202,135,108,192,192,125);
cols_Silver_Gold:array[0..83] of byte=(99,111,108,50,1,145,149,138,2,229,232,222,50,235,238,228,51,205,208,198,52,125,128,118,53,125,128,118,54,115,118,108,55,255,255,255,56,155,158,148,57,195,198,188,58,185,188,178,100,217,220,210,101,187,190,180,102,107,110,100,103,107,110,100,104,97,100,90,105,247,250,240,106,137,140,130,107,177,180,170,108,167,170,160);
cols_Grey:array[0..83] of byte=(99,111,108,50,1,69,79,89,2,169,179,189,50,219,234,249,51,189,204,219,52,109,124,139,53,109,124,139,54,99,114,129,55,189,204,219,56,139,154,169,57,179,194,209,58,169,184,199,100,204,218,233,101,174,188,203,102,94,108,123,103,94,108,123,104,84,98,113,105,234,248,255,106,124,138,153,107,164,178,193,108,154,168,183);
cols_grey2:array[0..83] of byte=(99,111,108,50,1,126,127,124,2,232,232,232,50,232,232,232,51,148,141,137,52,148,141,137,53,148,141,137,54,224,224,224,55,255,255,255,56,158,158,158,57,232,232,232,58,148,141,137,100,214,214,214,101,184,184,184,102,104,104,104,103,104,104,104,104,94,94,94,105,244,244,244,106,134,134,134,107,174,174,174,108,164,164,164);
cols_Soft_Blue:array[0..83] of byte=(99,111,108,50,1,103,139,175,2,255,255,255,50,237,241,244,51,207,211,214,52,127,131,134,53,127,131,134,54,117,121,124,55,207,211,214,56,157,161,164,57,197,201,204,58,187,191,194,100,197,212,227,101,167,182,197,102,87,102,117,103,87,102,117,104,77,92,107,105,227,242,255,106,117,132,147,107,157,172,187,108,147,162,177);
cols_Soft_Blue2:array[0..83] of byte=(99,111,108,50,1,103,139,175,2,255,255,255,50,237,241,244,51,207,211,214,52,217,233,250,53,217,233,250,54,117,121,124,55,79,107,134,56,135,154,172,57,200,211,223,58,184,194,205,100,217,233,250,101,187,203,220,102,107,123,140,103,107,123,140,104,97,113,130,105,255,255,255,106,137,153,170,107,177,193,210,108,167,183,200);//14nov2022
//was:array[0..83] of byte=(99,111,108,50,1,103,139,175,2,255,255,255,50,237,241,244,51,207,211,214,52,217,233,250,53,217,233,250,54,117,121,124,55,79,107,134,56,157,161,164,57,197,201,204,58,187,191,194,100,217,233,250,101,187,203,220,102,107,123,140,103,107,123,140,104,97,113,130,105,255,255,255,106,137,153,170,107,177,193,210,108,167,183,200);//14nov2022
//was blue2:array[0..83] of byte=(99,111,108,50,1,103,139,175,2,255,255,255,50,237,241,244,51,207,211,214,52,127,131,134,53,127,131,134,54,117,121,124,55,207,211,214,56,157,161,164,57,197,201,204,58,187,191,194,100,217,233,250,101,187,203,220,102,107,123,140,103,107,123,140,104,97,113,130,105,187,203,220,106,137,153,170,107,177,193,210,108,167,183,200);//14nov2022
cols_Emerald:array[0..83] of byte=(99,111,108,50,1,126,184,149,2,114,241,241,50,129,216,196,51,99,186,166,52,19,106,86,53,19,106,86,54,9,96,76,55,159,246,226,56,49,136,116,57,89,176,156,58,79,166,146,100,128,205,180,101,98,175,150,102,18,95,70,103,18,95,70,104,8,85,60,105,158,235,210,106,48,125,100,107,88,165,140,108,78,155,130);
cols_Aqua_Marine:array[0..83] of byte=(99,111,108,50,1,0,69,128,2,142,255,255,50,142,255,255,51,112,225,225,52,32,120,160,53,32,120,160,54,22,105,150,55,112,225,225,56,62,175,175,57,102,215,215,58,92,205,205,100,97,204,224,101,67,174,194,102,10,94,114,103,10,94,114,104,0,84,104,105,127,234,254,106,17,124,144,107,57,164,184,108,47,154,174);
cols_Aqua_Marine2:array[0..83] of byte=(99,111,108,50,1,1,84,155,2,172,255,255,50,172,255,255,51,135,255,255,52,38,145,194,53,38,145,194,54,26,128,182,55,135,255,255,56,75,211,211,57,123,255,255,58,111,249,249,100,118,246,255,101,81,210,234,102,12,113,138,103,12,113,138,104,1,101,125,105,154,255,255,106,21,150,174,107,69,198,222,108,57,186,210);
cols_Washed_Crimson:array[0..83] of byte=(99,111,108,50,1,198,71,116,2,254,237,242,50,254,237,242,51,224,207,212,52,144,127,132,53,144,127,132,54,134,117,122,55,224,207,212,56,174,157,162,57,214,197,202,58,204,187,192,100,239,229,239,101,209,199,209,102,129,119,129,103,129,119,129,104,119,109,119,105,255,255,255,106,159,149,159,107,199,189,199,108,189,179,189);
cols_Dusty_Pink:array[0..83] of byte=(99,111,108,50,1,170,154,157,2,247,243,240,50,247,246,246,51,217,216,216,52,137,136,136,53,137,136,136,54,127,126,126,55,217,216,216,56,167,166,166,57,207,206,206,58,197,196,196,100,219,212,213,101,189,182,183,102,109,102,103,103,109,102,103,104,99,92,93,105,249,242,243,106,139,132,133,107,179,172,173,108,169,162,163);
cols_Golden_Sands:array[0..83] of byte=(99,111,108,50,1,157,132,82,2,255,248,228,50,251,235,215,51,221,205,185,52,141,125,105,53,141,125,105,54,131,115,95,55,221,205,185,56,171,155,135,57,211,195,175,58,201,185,165,100,240,221,192,101,210,191,162,102,130,111,82,103,130,111,82,104,120,101,72,105,210,191,162,106,160,141,112,107,200,181,152,108,190,171,142);
cols_Fern:array[0..83] of byte=(99,111,108,50,1,103,72,103,2,226,255,226,50,219,255,219,51,189,225,189,52,109,145,109,53,109,145,109,54,99,135,99,55,189,225,189,56,139,175,139,57,179,215,179,58,169,205,169,100,191,210,191,101,161,180,161,102,81,100,81,103,81,100,81,104,71,90,71,105,221,240,221,106,111,130,111,107,151,170,151,108,141,160,141);
cols_Tangerine:array[0..83] of byte=(99,111,108,50,1,255,128,128,2,255,192,192,50,255,203,203,51,225,173,173,52,145,93,93,53,145,93,93,54,135,83,83,55,225,173,173,56,175,123,123,57,215,163,163,58,205,153,153,100,255,164,164,101,225,134,134,102,145,54,54,103,145,54,54,104,135,44,44,105,225,134,134,106,175,84,84,107,215,124,124,108,205,114,114);
cols_Barely_Beige:array[0..83] of byte=(99,111,108,50,1,174,175,162,2,234,235,222,50,224,225,212,51,194,195,182,52,144,145,132,53,144,145,132,54,134,135,122,55,254,255,242,56,144,145,132,57,184,185,172,58,174,175,162,100,214,215,202,101,184,185,172,102,154,155,142,103,154,155,142,104,134,135,122,105,255,255,252,106,134,135,122,107,174,175,162,108,164,165,152);
cols_Moon_Blue:array[0..83] of byte=(99,111,108,50,1,63,130,175,2,123,190,235,50,113,180,225,51,83,150,195,52,33,100,145,53,33,100,145,54,23,90,135,55,143,210,255,56,33,100,145,57,73,140,185,58,63,130,175,100,103,170,215,101,73,140,185,102,43,110,155,103,43,110,155,104,23,90,135,105,153,220,255,106,23,90,135,107,63,130,175,108,53,120,165);
cols_Howdy_Brown:array[0..83] of byte=(99,111,108,50,1,103,59,30,2,203,159,130,50,213,169,140,51,183,139,110,52,73,29,10,53,73,29,10,54,63,19,0,55,243,199,170,56,133,89,60,57,173,129,100,58,163,119,90,100,143,99,70,101,113,69,40,102,83,39,20,103,83,39,20,104,63,19,0,105,193,149,120,106,63,19,0,107,103,59,30,108,93,49,20);
cols_Chirpy_Charcoal:array[0..83] of byte=(99,111,108,50,1,24,24,24,2,62,62,62,50,32,32,32,51,2,2,2,52,162,162,162,53,162,162,162,54,152,152,152,55,62,62,62,56,112,112,112,57,0,0,0,58,0,0,0,100,32,32,32,101,2,2,2,102,162,162,162,103,162,162,162,104,152,152,152,105,62,62,62,106,112,112,112,107,0,0,0,108,0,0,0);
cols_DarkRedTint:array[0..83] of byte=(99,111,108,50,1,30,15,15,2,62,55,55,50,37,32,32,51,2,2,2,52,162,162,162,53,162,162,162,54,152,152,152,55,62,62,62,56,112,112,112,57,0,0,0,58,0,0,0,100,42,32,32,101,2,2,2,102,162,162,162,103,162,162,162,104,152,152,152,105,62,62,62,106,112,112,112,107,0,0,0,108,0,0,0);
cols_DarkAquaTint:array[0..83] of byte=(99,111,108,50,1,15,30,30,2,55,62,62,50,32,37,37,51,2,2,2,52,162,162,162,53,162,162,162,54,152,152,152,55,62,62,62,56,112,112,112,57,0,0,0,58,0,0,0,100,32,42,42,101,2,2,2,102,162,162,162,103,162,162,162,104,152,152,152,105,62,62,62,106,112,112,112,107,0,0,0,108,0,0,0);
cols_DarkBlueTint:array[0..83] of byte=(99,111,108,50,1,15,15,30,2,55,55,62,50,32,32,37,51,2,2,2,52,162,162,162,53,162,162,162,54,152,152,152,55,62,62,62,56,112,112,112,57,0,0,0,58,0,0,0,100,32,32,42,101,2,2,2,102,162,162,162,103,162,162,162,104,152,152,152,105,62,62,62,106,112,112,112,107,0,0,0,108,0,0,0);
cols_DarkGreenTint:array[0..83] of byte=(99,111,108,50,1,15,30,15,2,55,62,55,50,32,37,32,51,2,2,2,52,162,162,162,53,162,162,162,54,152,152,152,55,62,62,62,56,112,112,112,57,0,0,0,58,0,0,0,100,32,42,32,101,2,2,2,102,162,162,162,103,162,162,162,104,152,152,152,105,62,62,62,106,112,112,112,107,0,0,0,108,0,0,0);
cols_DarkYellowTint:array[0..83] of byte=(99,111,108,50,1,30,30,15,2,62,62,55,50,37,37,32,51,2,2,2,52,162,162,162,53,162,162,162,54,152,152,152,55,62,62,62,56,112,112,112,57,0,0,0,58,0,0,0,100,42,42,32,101,2,2,2,102,162,162,162,103,162,162,162,104,152,152,152,105,62,62,62,106,112,112,112,107,0,0,0,108,0,0,0);
cols_Dreamy_Cream:array[0..83] of byte=(99,111,108,50,1,175,175,141,2,235,235,201,50,255,255,238,51,225,225,208,52,145,145,128,53,145,145,128,54,135,135,118,55,225,225,208,56,175,175,158,57,215,215,198,58,205,205,188,100,255,255,230,101,225,225,200,102,145,145,120,103,145,145,120,104,135,135,110,105,225,225,200,106,175,175,150,107,215,215,190,108,205,205,180);
cols_Gentle_Ginger:array[0..83] of byte=(99,111,108,50,1,160,68,59,2,236,170,163,50,236,170,163,51,206,140,133,52,126,60,53,53,126,60,53,54,116,50,43,55,255,200,193,56,156,90,83,57,196,130,123,58,186,120,113,100,237,178,172,101,207,148,142,102,127,68,62,103,127,68,62,104,117,58,52,105,255,208,202,106,157,98,92,107,197,138,132,108,187,128,122);
cols_Grumpy_Green:array[0..83] of byte=(99,111,108,50,1,16,41,0,2,116,141,81,50,104,129,71,51,74,99,41,52,10,19,10,53,10,19,10,54,0,9,0,55,134,159,101,56,24,49,0,57,64,89,31,58,54,79,21,100,100,128,86,101,70,98,56,102,10,18,10,103,10,18,10,104,0,8,0,105,130,158,116,106,20,48,6,107,60,88,46,108,50,78,36);
cols_Glowing_Grey:array[0..83] of byte=(99,111,108,50,1,136,136,127,2,236,236,220,50,235,235,227,51,205,205,197,52,125,125,117,53,125,125,117,54,115,115,107,55,255,255,255,56,155,155,147,57,195,195,187,58,185,185,177,100,255,255,249,101,225,225,219,102,145,145,139,103,145,145,139,104,135,135,129,105,225,225,219,106,175,175,169,107,215,215,209,108,205,205,199);
cols_Jovial_Mauve:array[0..83] of byte=(99,111,108,50,1,168,139,175,2,228,199,235,50,248,219,247,51,218,189,217,52,138,109,137,53,138,109,137,54,140,114,139,55,218,189,217,56,168,139,167,57,208,179,207,58,198,169,197,100,248,219,242,101,218,189,212,102,138,109,132,103,138,109,132,104,140,114,139,105,218,189,212,106,168,139,162,107,208,179,202,108,198,169,192);
cols_Luscious_Lilac:array[0..83] of byte=(99,111,108,50,1,165,90,175,2,255,122,228,50,245,170,255,51,215,140,225,52,135,60,145,53,135,60,145,54,125,50,135,55,215,140,225,56,165,90,175,57,205,130,215,58,195,120,205,100,255,122,228,101,225,92,198,102,145,12,118,103,145,12,118,104,135,2,108,105,225,92,198,106,175,42,148,107,215,82,188,108,205,72,178);
cols_Slinky_Pink:array[0..83] of byte=(99,111,108,50,1,175,42,148,2,255,47,182,50,255,117,206,51,225,87,176,52,145,10,96,53,145,10,96,54,135,0,86,55,225,87,176,56,175,37,126,57,215,77,166,58,205,67,156,100,255,47,182,101,225,17,152,102,145,10,72,103,145,10,72,104,135,0,62,105,225,17,152,106,175,0,102,107,215,7,142,108,205,0,132);
cols_Rosebud_Pink:array[0..83] of byte=(99,111,108,50,1,255,67,159,2,255,153,203,50,255,194,220,51,225,164,190,52,145,84,110,53,145,84,110,54,135,74,100,55,225,164,190,56,175,114,140,57,215,154,180,58,205,144,170,100,255,142,214,101,225,112,184,102,145,32,104,103,145,32,104,104,135,22,94,105,225,112,184,106,175,62,134,107,215,102,174,108,205,92,164);
cols_Silky_Sand:array[0..83] of byte=(99,111,108,50,1,212,167,66,2,234,215,147,50,244,224,153,51,214,194,123,52,134,114,43,53,134,114,43,54,124,104,33,55,214,194,123,56,164,144,73,57,204,184,113,58,194,174,103,100,255,239,136,101,225,209,106,102,145,129,26,103,145,129,26,104,135,119,16,105,225,209,106,106,175,159,56,107,215,199,96,108,205,189,86);
cols_Really_Red:array[0..83] of byte=(99,111,108,50,1,123,0,0,2,255,75,94,50,255,154,163,51,225,124,133,52,145,44,53,53,145,44,53,54,135,34,43,55,225,124,133,56,175,74,83,57,215,114,123,58,205,104,113,100,255,93,110,101,225,63,80,102,145,10,10,103,145,10,10,104,135,0,0,105,225,63,80,106,175,13,30,107,215,53,70,108,205,43,60);
cols_Really_Red2:array[0..83] of byte=(99,111,108,50,1,169,21,21,2,255,113,131,50,255,208,217,51,255,162,175,52,190,69,85,53,187,67,83,54,169,48,63,55,255,150,163,56,211,98,107,57,248,136,145,58,235,124,133,100,255,111,128,101,249,79,96,102,163,17,17,103,160,16,16,104,145,6,6,105,237,71,88,106,184,16,33,107,221,57,74,108,208,44,62);
cols_Robust_Red:array[0..83] of byte=(99,111,108,50,1,255,4,9,2,166,2,5,50,213,63,66,51,183,33,36,52,103,10,10,53,103,10,10,54,93,0,0,55,243,93,96,56,133,0,0,57,173,23,26,58,163,13,16,100,213,63,66,101,183,33,36,102,103,10,10,103,103,10,10,104,93,0,0,105,243,93,96,106,133,0,0,107,173,23,26,108,163,13,16);
cols_Red:array[0..83] of byte=(99,111,108,50,1,168,50,59,2,248,86,98,50,255,230,227,51,255,113,113,52,215,53,65,53,145,78,81,54,0,8,3,55,255,230,227,56,175,108,111,57,215,148,151,58,205,138,141,100,255,93,105,101,225,63,75,102,145,10,10,103,145,10,10,104,135,0,0,105,135,0,0,106,175,13,25,107,215,53,65,108,205,43,55);
cols_Red2:array[0..83] of byte=(99,111,108,50,1,80,0,0,2,235,41,0,50,255,234,232,51,193,82,59,52,145,10,10,53,145,10,10,54,0,0,0,55,225,31,0,56,175,0,0,57,215,21,0,58,205,11,0,100,255,109,78,101,193,82,59,102,145,10,10,103,145,10,10,104,135,0,0,105,225,31,0,106,175,0,0,107,215,21,0,108,205,11,0);
cols_Radiant_Yellow:array[0..83] of byte=(99,111,108,50,1,233,215,0,2,254,255,121,50,254,255,109,51,224,225,79,52,144,145,10,53,144,145,10,54,134,135,0,55,224,225,79,56,174,175,29,57,214,215,69,58,204,205,59,100,247,255,57,101,217,225,27,102,137,145,10,103,137,145,10,104,127,135,0,105,217,225,27,106,167,175,0,107,207,215,17,108,197,205,7);
cols_Peach:array[0..83] of byte=(99,111,108,50,1,255,180,136,2,255,255,255,50,255,255,255,51,255,255,255,52,255,181,136,53,255,181,136,54,157,124,106,55,255,255,255,56,227,209,201,57,255,255,255,58,255,248,244,100,255,255,255,101,255,237,216,102,140,120,100,103,140,120,100,104,140,120,100,105,255,255,255,106,192,172,153,107,192,172,153,108,192,172,153);
cols_Tangy_Tangerine:array[0..83] of byte=(99,111,108,50,1,255,183,157,2,255,122,73,50,255,145,113,51,225,115,83,52,145,35,10,53,145,35,10,54,135,25,0,55,225,115,83,56,175,65,33,57,215,105,73,58,205,95,63,100,255,110,109,101,225,80,79,102,145,10,10,103,145,10,10,104,135,0,0,105,225,80,79,106,175,30,29,107,215,70,69,108,205,60,59);
cols_Wild_White:array[0..83] of byte=(99,111,108,50,1,255,254,253,2,229,229,217,50,253,251,252,51,223,221,222,52,143,141,142,53,143,141,142,54,133,131,132,55,223,221,222,56,173,171,172,57,213,211,212,58,203,201,202,100,250,250,238,101,220,220,208,102,140,140,128,103,140,140,128,104,130,130,118,105,220,220,208,106,170,170,158,107,210,210,198,108,200,200,188);
cols_Wild_Thing:array[0..83] of byte=(99,111,108,50,1,0,106,118,2,70,206,218,50,122,221,122,51,92,191,92,52,12,111,12,53,12,111,12,54,2,101,2,55,152,251,152,56,42,141,42,57,82,181,82,58,72,171,72,100,255,192,0,101,225,162,0,102,145,82,10,103,145,82,10,104,135,72,0,105,225,162,0,106,175,112,0,107,215,152,0,108,205,142,0);
cols_black:array[0..83] of byte=(99,111,108,50,1,0,0,0,2,27,27,27,50,27,27,27,51,0,0,0,52,157,157,157,53,157,157,157,54,147,147,147,55,57,57,57,56,107,107,107,57,0,0,0,58,0,0,0,100,27,27,27,101,0,0,0,102,157,157,157,103,157,157,157,104,147,147,147,105,57,57,57,106,107,107,107,107,0,0,0,108,0,0,0);
cols_blue:array[0..83] of byte=(99,111,108,50,1,17,64,175,2,77,124,235,50,166,192,255,51,136,162,225,52,56,82,145,53,56,82,145,54,46,72,135,55,136,162,225,56,86,112,175,57,126,152,215,58,116,142,205,100,97,144,255,101,67,114,225,102,10,34,145,103,10,34,145,104,0,24,135,105,67,114,225,106,17,64,175,107,57,104,215,108,47,94,205);
cols_royal_blue:array[0..83] of byte=(99,111,108,50,1,8,0,180,2,69,105,255,50,110,138,255,51,80,108,225,52,10,28,145,53,10,28,145,54,0,18,135,55,80,108,225,56,30,58,175,57,70,98,215,58,60,88,205,100,69,105,255,101,39,75,225,102,10,10,145,103,10,10,145,104,0,0,135,105,39,75,225,106,0,25,175,107,29,65,215,108,19,55,205);
cols_pink:array[0..83] of byte=(99,111,108,50,1,209,129,196,2,255,186,244,50,255,223,252,51,224,196,221,52,255,179,243,53,255,179,243,54,122,86,117,55,255,179,243,56,186,162,177,57,255,222,243,58,186,162,177,100,255,223,252,101,224,196,221,102,0,0,0,103,255,158,240,104,122,86,117,105,123,79,147,106,185,166,183,107,255,222,243,108,0,33,12);
cols_wild_mix:array[0..83] of byte=(99,111,108,50,1,175,172,0,2,235,232,25,50,249,136,255,51,219,106,225,52,139,26,145,53,139,26,145,54,129,16,135,55,219,106,225,56,169,56,175,57,209,96,215,58,199,86,205,100,77,233,255,101,47,203,225,102,10,123,145,103,10,123,145,104,0,113,135,105,47,203,225,106,0,153,175,107,37,193,215,108,27,183,205);
cols_white:array[0..83] of byte=(99,111,108,50,1,210,210,210,2,255,255,255,50,244,244,244,51,214,214,214,52,134,134,134,53,134,134,134,54,124,124,124,55,214,214,214,56,164,164,164,57,204,204,204,58,194,194,194,100,255,255,255,101,225,225,225,102,145,145,145,103,145,145,145,104,135,135,135,105,225,225,225,106,175,175,175,107,215,215,215,108,205,205,205);
cols_satinpink:array[0..83] of byte=(99,111,108,50,1,115,83,113,2,251,223,255,50,254,248,255,51,224,218,225,52,255,196,249,53,255,196,249,54,134,128,135,55,143,111,145,56,174,168,175,57,214,208,215,58,204,198,205,100,253,221,255,101,223,191,225,102,239,165,198,103,239,165,198,104,133,101,135,105,143,111,145,106,173,141,175,107,213,181,215,108,203,171,205);
cols_purple:array[0..83] of byte=(99,111,108,50,1,50,13,77,2,153,97,193,50,206,179,225,51,176,149,195,52,96,69,115,53,96,69,115,54,86,59,105,55,236,209,255,56,126,99,145,57,166,139,185,58,156,129,175,100,153,97,193,101,123,67,163,102,43,10,83,103,43,10,83,104,33,0,73,105,183,127,223,106,73,17,113,107,113,57,153,108,103,47,143);
cols_purple2:array[0..83] of byte=(99,111,108,50,1,50,13,77,2,178,136,208,50,206,179,225,51,176,149,195,52,96,69,115,53,96,69,115,54,86,59,105,55,236,209,255,56,126,99,145,57,166,139,185,58,156,129,175,100,178,136,208,101,148,106,178,102,68,26,98,103,68,26,98,104,58,16,88,105,208,166,238,106,98,56,128,107,138,96,168,108,128,86,158);
cols_purple3:array[0..83] of byte=(99,111,108,50,1,115,31,175,2,175,91,235,50,251,248,140,51,221,218,110,52,141,138,30,53,141,138,30,54,131,128,20,55,221,218,110,56,171,168,60,57,211,208,100,58,201,198,90,100,195,111,255,101,165,81,225,102,85,10,145,103,85,10,145,104,75,0,135,105,165,81,225,106,115,31,175,107,155,71,215,108,145,61,205);
cols_brown:array[0..83] of byte=(99,111,108,50,1,31,0,0,2,131,83,35,50,251,203,155,51,221,173,125,52,141,93,45,53,141,93,45,54,131,83,35,55,221,173,125,56,171,123,75,57,211,163,115,58,201,153,105,100,183,134,85,101,153,104,55,102,73,24,10,103,73,24,10,104,63,14,0,105,213,164,115,106,103,54,5,107,143,94,45,108,133,84,35);
cols_brown2:array[0..83] of byte=(99,111,108,50,1,103,54,5,2,203,154,105,50,251,203,155,51,221,173,125,52,141,93,45,53,141,93,45,54,131,83,35,55,221,173,125,56,171,123,75,57,211,163,115,58,201,153,105,100,183,134,85,101,153,104,55,102,73,24,10,103,73,24,10,104,63,14,0,105,213,164,115,106,103,54,5,107,143,94,45,108,133,84,35);
cols_brown3:array[0..83] of byte=(99,111,108,50,1,27,0,0,2,170,123,75,50,248,208,152,51,218,178,122,52,138,98,42,53,138,98,42,54,128,88,32,55,218,178,122,56,168,128,72,57,208,168,112,58,198,158,102,100,170,123,75,101,140,93,45,102,60,13,10,103,60,13,10,104,50,3,0,105,200,153,105,106,90,43,0,107,130,83,35,108,120,73,25);
cols_brown4:array[0..83] of byte=(99,111,108,50,1,90,43,0,2,170,123,75,50,255,227,187,51,225,197,157,52,145,117,77,53,145,117,77,54,135,107,67,55,225,197,157,56,175,147,107,57,215,187,147,58,205,177,137,100,170,123,75,101,140,93,45,102,60,13,10,103,60,13,10,104,50,3,0,105,200,153,105,106,90,43,0,107,130,83,35,108,120,73,25);
cols_brown5:array[0..83] of byte=(99,111,108,50,1,90,43,0,2,206,179,152,50,255,227,187,51,225,197,157,52,145,117,77,53,145,117,77,54,135,107,67,55,225,197,157,56,175,147,107,57,215,187,147,58,205,177,137,100,206,179,152,101,176,149,122,102,96,69,42,103,96,69,42,104,86,59,32,105,236,209,182,106,126,99,72,107,166,139,112,108,156,129,102);
cols_brown6:array[0..83] of byte=(99,111,108,50,1,90,43,0,2,206,179,152,50,255,227,187,51,225,197,157,52,145,117,77,53,145,117,77,54,135,107,67,55,225,197,157,56,175,147,107,57,215,187,147,58,205,177,137,100,206,179,152,101,176,149,122,102,150,0,75,103,96,69,42,104,86,59,32,105,236,209,182,106,126,99,72,107,166,139,112,108,156,129,102);

//system fonts -----------------------------------------------------------------
{
sysfont__arial_8:array[0..8326] of byte=(
71,70,35,51,16,0,13,0,10,0,8,6,0,0,10,0,12,6,0,0,10,0,16,6,0,0,10,0,34,6,0,0,10,0,50,6,0,0,10,0,66,6,0,0,10,0,96,6,0,0,10,0,100,6,0,0,10,0,112,6,0,0,10,0,152,6,0,0,10,0,156,6,0,0,10,0,160,6,0,0,10,0,190,6,0,0,10,0,224,6,0,0,10,0,228,6,0,0,10,0,10,7,0,0,10,0,56,7,0,0,10,0,86,7,0,0,10,0,110,7,0,0,10,0,146,7,0,0,10,0,188,7,0,0,10,0,248,7,0,0,10,0,8,8,0,0,10,0,26,8,0,0,10,0,56,8,0,0,10,0,86,8,0,0,10,0,116,8,0,0,10,0,128,8,0,0,10,0,140,8,0,0,10,0,144,8,0,0,10,0,148,8,0,0,10,0,152,8,0,0,4,0,156,8,0,0,3,0,158,8,0,0,5,0,178,8,0,0,8,0,192,8,0,0,7,0,230,8,0,0,12,0,16,9,0,0,9,0,70,9,0,0,2,0,110,9,0,0,4,0,118,9,0,0,4,0,145,9,0,0,5,0,173,9,0,0,8,0,185,9,0,0,4,0,201,9,0,0,4,0,209,9,0,0,4,0,213,9,0,0,4,0,217,9,0,0,7,0,239,9,0,0,7,0,21,10,0,0,7,0,45,10,0,0,7,0,69,10,0,0,7,0,95,10,0,0,7,0,125,10,0,0,7,0,151,10,0,0,7,0,185,10,0,0,7,0,207,10,0,0,7,0,243,10,0,0,4,0,21,11,0,0,4,0,27,11,0,0,8,0,37,11,0,0,8,0,53,11,0,0,8,0,59,11,0,0,7,0,75,11,0,0,13,0,99,11,0,0,9,0,175,11,0,0,9,0,211,11,0,0,9,0,247,11,0,0,9,0,21,12,0,
0,9,0,59,12,0,0,8,0,81,12,0,0,10,0,103,12,0,0,9,0,137,12,0,0,3,0,177,12,0,0,6,0,199,12,0,0,9,0,225,12,0,0,7,0,11,13,0,0,11,0,33,13,0,0,9,0,99,13,0,0,10,0,153,13,0,0,9,0,191,13,0,0,10,0,221,13,0,0,9,0,7,14,0,0,9,0,45,14,0,0,7,0,75,14,0,0,9,0,97,14,0,0,9,0,137,14,0,0,13,0,173,14,0,0,7,0,243,14,0,0,9,0,25,15,0,0,7,0,57,15,0,0,4,0,79,15,0,0,4,0,107,15,0,0,4,0,129,15,0,0,5,0,157,15,0,0,7,0,177,15,0,0,4,0,180,15,0,0,7,0,186,15,0,0,7,0,210,15,0,0,7,0,244,15,0,0,7,0,8,16,0,0,7,0,42,16,0,0,3,0,64,16,0,0,7,0,86,16,0,0,7,0,124,16,0,0,3,0,160,16,0,0,4,0,178,16,0,0,7,0,202,16,0,0,3,0,236,16,0,0,11,0,2,17,0,0,7,0,46,17,0,0,7,0,76,17,0,0,7,0,102,17,0,0,7,0,138,17,0,0,4,0,174,17,0,0,7,0,192,17,0,0,4,0,212,17,0,0,7,0,232,17,0,0,5,0,4,18,0,0,9,0,28,18,0,0,7,0,72,18,0,0,7,0,100,18,0,0,7,0,132,18,0,0,4,0,148,18,0,0,3,0,176,18,0,0,4,0,202,18,0,0,8,0,230,18,0,0,10,0,240,18,0,0,7,0,22,19,0,0,1,0,44,19,0,0,3,0,46,19,0,0,7,0,54,19,0,0,4,0,82,19,0,0,13,0,96,19,0,0,7,0,106,19,0,0,7,0,132,19,0,0,5,0,158,19,0,0,14,0,166,19,
0,0,9,0,236,19,0,0,4,0,16,20,0,0,13,0,30,20,0,0,1,0,72,20,0,0,7,0,74,20,0,0,1,0,102,20,0,0,1,0,104,20,0,0,3,0,106,20,0,0,3,0,114,20,0,0,4,0,122,20,0,0,4,0,136,20,0,0,5,0,150,20,0,0,7,0,158,20,0,0,13,0,162,20,0,0,4,0,166,20,0,0,13,0,174,20,0,0,7,0,208,20,0,0,4,0,234,20,0,0,12,0,248,20,0,0,1,0,28,21,0,0,7,0,30,21,0,0,9,0,52,21,0,0,4,0,88,21,0,0,3,0,90,21,0,0,7,0,110,21,0,0,7,0,152,21,0,0,7,0,178,21,0,0,7,0,204,21,0,0,3,0,236,21,0,0,7,0,2,22,0,0,4,0,40,22,0,0,10,0,46,22,0,0,4,0,90,22,0,0,7,0,100,22,0,0,8,0,126,22,0,0,4,0,136,22,0,0,10,0,140,22,0,0,7,0,188,22,0,0,5,0,192,22,0,0,7,0,206,22,0,0,4,0,224,22,0,0,4,0,236,22,0,0,4,0,250,22,0,0,7,0,0,23,0,0,7,0,34,23,0,0,4,0,80,23,0,0,4,0,84,23,0,0,4,0,91,23,0,0,5,0,103,23,0,0,7,0,117,23,0,0,11,0,143,23,0,0,11,0,187,23,0,0,11,0,231,23,0,0,8,0,23,24,0,0,9,0,47,24,0,0,9,0,87,24,0,0,9,0,127,24,0,0,9,0,169,24,0,0,9,0,213,24,0,0,9,0,253,24,0,0,13,0,39,25,0,0,9,0,77,25,0,0,9,0,113,25,0,0,9,0,139,25,0,0,9,0,165,25,0,0,9,0,193,25,0,0,3,0,219,25,0,0,3,0,244,25,0,0,3,
0,14,26,0,0,3,0,38,26,0,0,9,0,64,26,0,0,9,0,102,26,0,0,10,0,164,26,0,0,10,0,206,26,0,0,10,0,248,26,0,0,10,0,36,27,0,0,10,0,82,27,0,0,8,0,124,27,0,0,10,0,140,27,0,0,9,0,194,27,0,0,9,0,238,27,0,0,9,0,26,28,0,0,9,0,72,28,0,0,9,0,116,28,0,0,9,0,152,28,0,0,9,0,182,28,0,0,7,0,224,28,0,0,7,0,252,28,0,0,7,0,24,29,0,0,7,0,54,29,0,0,7,0,86,29,0,0,7,0,114,29,0,0,12,0,146,29,0,0,7,0,180,29,0,0,7,0,206,29,0,0,7,0,232,29,0,0,7,0,2,30,0,0,7,0,30,30,0,0,3,0,56,30,0,0,3,0,76,30,0,0,3,0,96,30,0,0,3,0,114,30,0,0,7,0,134,30,0,0,7,0,170,30,0,0,7,0,208,30,0,0,7,0,238,30,0,0,7,0,12,31,0,0,7,0,44,31,0,0,7,0,78,31,0,0,7,0,108,31,0,0,7,0,116,31,0,0,7,0,148,31,0,0,7,0,180,31,0,0,7,0,212,31,0,0,7,0,246,31,0,0,7,0,22,32,0,0,7,0,58,32,0,0,7,0,96,32,0,0,0,128,0,159,0,128,0,159,0,69,3,8,0,8,0,8,0,8,0,8,0,8,0,8,0,15,0,12,0,8,0,8,0,8,0,8,0,8,0,8,3,82,0,12,0,8,0,8,0,8,0,8,0,8,0,5,3,85,0,12,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,15,0,69,6,82,0,51,2,5,4,4,4,4,4,5,2,64,0,9,6,2,6,2,6,2,6,2,1,2,1,2,0,4,0,2,0,4,0,2,0,4,0,
2,1,2,1,2,6,2,6,2,6,2,6,2,6,12,0,128,0,159,0,128,0,159,0,32,3,7,1,6,0,0,0,6,0,0,0,5,0,8,0,7,1,6,0,1,0,5,0,1,0,6,1,35,0,40,6,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,6,31,0,128,0,159,0,34,1,4,2,0,0,4,0,1,1,4,2,0,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,1,1,3,1,1,1,3,1,36,0,30,0,0,0,0,0,4,0,0,0,0,0,5,0,0,0,6,0,0,0,5,1,0,1,5,0,0,0,6,0,0,0,5,0,0,0,0,0,4,0,0,0,0,0,43,0,12,0,8,0,8,0,8,0,8,0,8,0,5,6,5,0,8,0,8,0,8,0,8,0,8,0,8,0,15,0,25,0,7,1,6,2,5,3,4,4,3,5,4,4,5,3,6,2,7,1,8,0,32,0,12,0,7,2,5,0,0,0,0,0,6,0,8,0,8,0,8,0,8,0,8,0,8,0,6,0,0,0,0,0,5,2,7,0,25,0,21,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,25,0,1,0,5,0,1,0,23,0,21,1,0,0,4,0,0,0,0,0,4,0,0,0,0,0,4,0,0,0,0,0,4,0,0,0,0,0,4,0,0,0,0,0,5,1,0,0,6,0,0,0,6,0,0,0,6,0,0,0,6,0,0,0,6,0,0,0,23,0,12,0,8,0,8,0,8,0,8,0,8,0,5,6,82,0,69,6,5,0,8,0,8,0,8,0,8,0,8,0,8,0,15,0,12,0,8,0,8,0,8,0,8,0,8,0,5,3,8,0,8,0,8,0,8,0,8,0,8,0,8,0,15,0,22,0,7,2,5,0,0,0,0,0,6,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,25,0,12,0,8,0,8,0,8,0,8,0,8,0,8,3,5,0,8,0,8,0,8,0,8,
0,8,0,8,0,15,0,63,0,9,0,4,5,7,0,7,0,54,0,62,0,7,0,7,5,4,0,9,0,55,0,128,0,159,0,128,0,159,0,128,0,159,0,128,0,159,0,63,0,9,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,4,0,9,0,15,0,0,0,1,0,0,0,1,0,0,0,50,0,26,0,1,0,3,0,1,0,2,0,2,0,0,7,1,0,1,0,3,0,1,0,1,7,0,0,1,0,3,0,1,0,3,0,1,0,26,0,22,2,2,0,0,0,0,0,1,0,0,0,3,0,0,0,3,2,5,2,3,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,2,2,4,0,16,0,37,1,3,0,3,0,1,0,1,0,4,0,1,0,1,0,4,0,1,0,0,0,6,1,1,0,9,0,1,1,6,0,0,0,1,0,4,0,1,0,1,0,4,0,1,0,1,0,3,0,3,1,37,0,29,1,5,0,1,0,4,0,1,0,4,0,1,0,5,1,5,1,5,0,1,0,1,0,1,0,2,0,0,0,1,0,2,1,3,2,1,1,26,0,6,0,0,0,0,0,19,0,14,0,1,0,2,0,1,0,2,0,2,0,2,0,2,0,2,0,2,0,3,0,2,0,3,0,0,11,0,3,0,2,0,3,0,2,0,2,0,2,0,2,0,2,0,2,0,1,0,2,0,1,0,2,0,16,0,1,4,1,0,2,0,0,0,45,0,43,0,6,0,6,0,3,6,3,0,6,0,6,0,34,0,49,0,2,0,2,0,4,0,35,2,24,0,48,0,13,0,14,0,2,0,1,0,2,0,2,0,1,0,2,0,2,0,1,0,2,0,14,0,21,3,1,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,1,3,22,0,23,0,4,1,3,0,0,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,23,0,21,3,1,0,3,0,5,0,5,0,5,0,4,0,4,0,4,0,4,0,4,5,21,0,21,3,1,0,3,0,5,
0,5,0,2,2,6,0,5,0,5,0,0,0,3,0,1,3,22,0,24,0,4,1,4,1,3,0,0,0,3,0,0,0,2,0,1,0,2,0,1,0,1,5,4,0,5,0,22,0,21,4,1,0,5,0,4,0,5,4,1,0,3,0,5,0,5,0,0,0,3,0,1,3,22,0,21,3,1,0,3,0,0,0,5,0,5,0,0,2,1,1,2,0,0,0,3,0,0,0,3,0,0,0,3,0,1,3,22,0,20,5,4,0,5,0,4,0,5,0,4,0,5,0,4,0,5,0,5,0,25,0,21,3,1,0,3,0,0,0,3,0,0,0,3,0,1,3,1,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,1,3,22,0,21,3,1,0,3,0,0,0,3,0,0,0,3,0,0,0,2,1,1,2,0,0,5,0,5,0,0,0,2,0,2,2,23,0,24,0,22,0,13,0,24,0,22,0,2,0,2,0,5,0,45,0,4,1,3,1,4,0,7,1,7,1,7,0,32,0,47,6,16,6,48,0,40,0,7,1,7,1,7,0,4,1,3,1,4,0,37,0,22,2,2,0,2,0,1,0,2,0,5,0,4,0,4,0,4,0,5,0,12,0,24,0,42,4,5,1,4,0,3,0,7,0,2,0,1,2,0,0,1,0,0,0,1,0,2,1,1,0,0,0,0,0,4,0,1,0,0,0,0,0,3,0,2,0,0,0,0,0,3,0,1,0,1,0,0,0,2,1,1,0,1,0,1,2,0,2,3,0,8,0,2,0,5,1,4,5,3,0,30,0,6,0,0,0,5,0,0,0,5,0,0,0,4,0,2,0,3,0,2,0,2,6,1,0,4,0,0,0,6,1,6,0,26,0,27,5,2,0,4,0,1,0,4,0,1,0,4,0,1,5,2,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,5,28,0,29,2,4,0,2,0,2,0,4,0,1,0,7,0,7,0,7,0,7,0,4,0,2,0,2,0,4,2,29,0,27,4,3,0,3,0,2,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,
1,0,3,0,2,4,29,0,27,6,1,0,7,0,7,0,7,6,1,0,7,0,7,0,7,0,7,6,27,0,24,5,1,0,6,0,6,0,6,4,2,0,6,0,6,0,6,0,6,0,29,0,32,3,4,0,3,0,2,0,5,0,1,0,8,0,8,0,2,3,1,0,5,0,1,0,5,0,2,0,3,0,4,3,32,0,27,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,6,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,27,0,9,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,9,0,21,0,4,0,4,0,4,0,4,0,4,0,4,0,0,0,2,0,0,0,2,0,1,2,19,0,27,0,5,0,0,0,4,0,1,0,3,0,2,0,2,0,3,0,1,0,4,0,0,1,4,1,1,0,3,0,3,0,2,0,4,0,1,0,5,0,26,0,21,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,5,20,0,33,0,6,0,1,1,4,1,1,1,4,1,1,0,0,0,2,0,0,0,1,0,0,0,2,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,2,0,2,0,1,0,2,0,2,0,33,0,27,0,4,0,1,1,3,0,1,0,0,0,2,0,1,0,0,0,2,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,2,0,0,0,1,0,2,0,0,0,1,0,3,1,1,0,4,0,27,0,32,3,4,0,3,0,2,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,2,0,3,0,4,3,32,0,27,5,2,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,5,2,0,7,0,7,0,7,0,33,0,32,3,4,0,3,0,2,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,2,1,0,0,2,0,3,0,4,3,0,0,30,0,27,5,2,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,5,2,0,2,0,
3,0,3,0,2,0,3,0,2,0,4,0,27,0,28,4,2,0,4,0,1,0,4,0,1,0,8,2,8,1,8,0,1,0,4,0,1,0,4,0,2,4,28,0,20,6,2,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,23,0,27,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,2,0,2,0,4,2,29,0,26,0,6,1,6,0,0,0,4,0,1,0,4,0,2,0,2,0,3,0,2,0,4,0,0,0,5,0,0,0,6,0,7,0,30,0,38,0,4,0,4,1,3,0,0,0,3,0,0,0,2,0,0,0,2,0,1,0,2,0,0,0,2,0,1,0,2,0,0,0,2,0,2,0,0,0,2,0,0,0,3,0,0,0,2,0,0,0,3,0,0,0,2,0,0,0,4,0,4,0,5,0,4,0,41,0,20,0,4,0,0,0,2,0,1,0,2,0,2,0,0,0,4,0,5,0,4,0,0,0,2,0,2,0,1,0,2,0,0,0,4,0,20,0,27,0,4,0,2,0,2,0,3,0,2,0,4,0,0,0,5,0,0,0,6,0,7,0,7,0,7,0,7,0,30,0,21,5,4,0,4,0,5,0,4,0,5,0,4,0,5,0,4,0,4,6,20,0,12,1,1,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,1,0,0,11,0,2,0,3,0,2,0,2,0,3,0,2,0,2,0,3,0,2,0,11,0,12,1,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,1,1,0,0,21,0,2,0,0,0,1,0,0,0,1,0,0,0,0,0,2,0,34,0,104,6,0,12,0,3,0,44,0,43,2,2,0,2,0,5,0,2,3,1,0,2,0,1,0,1,1,2,1,0,0,21,0,21,0,5,0,5,0,5,0,0,1,2,1,1,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,3,22,0,43,2,2,0,2,0,1,0,5,0,5,0,5,0,2,0,2,2,22,0,
25,0,5,0,5,0,2,1,0,0,1,0,1,1,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,2,3,21,0,43,2,2,0,2,0,1,0,2,0,1,4,1,0,5,0,2,0,2,2,22,0,10,0,0,0,1,0,0,2,0,0,1,0,1,0,1,0,1,0,1,0,9,0,43,1,0,0,1,0,1,1,1,0,2,0,1,0,2,0,1,0,2,0,1,0,1,1,2,1,0,0,5,0,1,0,2,0,2,2,1,0,21,0,5,0,5,0,5,0,0,1,2,1,1,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,21,0,9,0,7,0,1,0,1,0,1,0,1,0,1,0,1,0,9,0,13,0,10,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,0,1,1,0,21,0,5,0,5,0,5,0,2,0,1,0,1,0,2,0,0,0,3,2,3,0,1,0,2,0,1,0,2,0,2,0,21,0,9,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,9,0,66,0,0,1,1,1,2,1,1,1,1,0,1,0,2,0,2,0,1,0,2,0,2,0,1,0,2,0,2,0,1,0,2,0,2,0,1,0,2,0,2,0,33,0,42,0,0,1,2,1,1,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,21,0,43,2,2,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,2,2,22,0,42,0,0,1,2,1,1,0,1,0,2,0,1,0,2,0,1,0,2,0,1,1,1,0,1,0,0,1,2,0,5,0,5,0,4,0,43,1,0,0,1,0,1,1,1,0,2,0,1,0,2,0,1,0,2,0,1,0,1,1,2,1,0,0,5,0,5,0,5,0,0,0,24,0,0,0,0,1,1,0,2,0,2,0,2,0,2,0,13,0,43,2,2,0,2,0,1,0,6,2,6,0,1,0,2,0,2,2,22,0,16,0,2,0,1,2,1,0,2,0,2,0,2,0,2,0,2,1,12,0,42,0,2,0,1,0,2,0,1,0,2,0,
1,0,2,0,1,0,2,0,1,0,2,0,2,3,21,0,29,0,2,1,2,0,0,0,0,0,1,0,0,0,1,0,0,0,2,0,3,0,16,0,53,0,2,0,2,1,2,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,2,0,3,0,2,0,28,0,42,0,2,0,2,0,0,0,3,0,0,0,4,0,4,0,0,0,3,0,0,0,2,0,2,0,21,0,42,0,2,0,1,0,2,0,2,0,0,0,3,0,0,0,3,0,0,0,4,0,5,0,5,0,5,0,3,1,3,0,42,4,4,0,5,0,4,0,4,0,5,0,4,4,21,0,13,0,1,0,2,0,2,0,2,0,2,0,1,0,3,0,2,0,2,0,2,0,2,0,3,0,0,0,9,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,3,0,12,0,3,0,2,0,2,0,2,0,2,0,3,0,1,0,2,0,2,0,2,0,2,0,1,0,1,0,56,2,1,0,0,0,1,3,56,0,29,2,6,0,0,0,6,0,0,0,6,0,0,0,6,0,0,0,6,0,0,0,6,0,0,0,6,0,0,0,6,0,0,0,6,2,36,0,23,3,1,0,4,0,4,6,0,0,4,6,0,0,5,0,6,0,6,3,20,0,15,0,36,0,1,0,1,0,3,0,24,2,3,0,5,0,3,3,3,0,5,0,5,0,5,0,5,0,4,0,5,0,5,0,3,2,3,0,47,0,0,0,0,0,0,0,0,0,0,0,4,0,128,0,156,0,2,0,2,0,41,0,23,0,5,0,5,0,2,6,2,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,9,0,23,0,5,0,2,6,2,0,5,0,5,0,5,0,5,0,5,0,2,6,2,0,5,0,9,0,16,1,1,0,1,0,54,0,42,1,2,0,6,0,1,0,0,0,7,0,1,0,0,0,7,0,1,0,0,0,8,1,0,0,12,0,0,1,2,1,3,0,0,0,1,0,0,0,1,0,2,0,0,0,1,0,0,0,1,0,2,0,0,
0,1,0,0,0,1,0,1,0,2,1,2,1,42,0,2,0,1,0,5,1,13,4,2,0,4,0,1,0,4,0,1,0,8,2,8,1,8,0,1,0,4,0,1,0,4,0,2,4,28,0,30,0,1,0,1,0,2,0,3,0,3,0,11,0,41,2,0,4,2,0,2,1,5,0,4,0,5,0,4,0,5,0,4,4,1,0,4,0,5,0,4,0,5,0,4,0,6,0,2,1,7,2,0,4,39,0,15,0,1,0,1,0,3,1,9,5,4,0,4,0,5,0,4,0,5,0,4,0,5,0,4,0,4,6,20,0,15,0,15,0,9,0,1,0,1,0,30,0,9,0,1,0,1,0,30,0,11,0,0,0,0,0,0,0,0,0,0,0,40,0,12,0,0,0,0,0,0,0,0,0,0,0,39,0,35,2,1,2,1,2,30,0,62,6,41,0,116,12,77,0,12,0,0,1,0,0,44,0,39,4,0,0,2,0,3,0,2,1,0,1,3,0,2,1,0,1,3,0,2,1,0,1,3,0,2,0,0,0,0,0,104,0,22,0,1,0,3,1,10,2,2,0,2,0,1,0,6,2,6,0,1,0,2,0,2,2,22,0,27,0,3,0,3,0,2,0,1,0,1,0,14,0,73,2,0,3,2,0,2,0,3,0,1,0,2,0,3,0,1,0,2,5,1,0,2,0,6,0,2,0,3,0,2,2,0,3,37,0,15,0,22,0,1,0,3,1,9,4,4,0,5,0,4,0,4,0,5,0,4,4,21,0,11,0,0,0,12,0,4,0,2,0,2,0,3,0,2,0,4,0,0,0,5,0,0,0,6,0,7,0,7,0,7,0,7,0,30,0,63,0,18,0,4,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,24,0,5,0,5,0,3,2,2,0,0,0,0,0,0,0,1,0,2,0,0,0,3,0,0,0,1,0,0,2,0,0,2,2,3,0,5,0,5,0,4,0,22,2,2,0,2,0,1,0,5,0,4,4,3,0,5,0,4,0,5,2,2,0,2,1,21,0,42,0,0,0,0,0,2,0,0,0,2,0,
2,0,2,0,0,0,2,0,0,0,0,0,35,0,20,0,4,0,0,0,2,0,1,0,2,0,2,0,0,0,3,0,0,0,1,6,2,0,2,6,2,0,5,0,23,0,9,0,1,0,1,0,1,0,1,0,7,0,1,0,1,0,1,0,1,0,3,0,23,1,3,0,1,0,2,0,5,1,3,0,1,1,1,0,2,1,0,1,2,0,1,1,0,1,3,0,6,0,1,0,2,0,2,2,8,0,11,0,0,0,48,0,31,5,2,0,5,0,0,0,1,3,1,1,0,0,3,0,0,1,0,0,5,1,0,0,5,1,0,0,3,0,0,1,1,3,1,0,0,0,5,0,2,5,31,0,12,3,1,0,0,3,1,4,31,0,51,0,0,0,2,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,4,0,0,0,21,0,47,6,6,0,6,0,6,0,48,0,35,2,24,0,31,5,2,0,5,0,0,0,1,3,1,1,1,0,2,0,0,1,1,0,2,0,0,1,1,3,1,1,1,0,1,0,1,1,1,0,2,0,0,0,0,0,5,0,2,5,31,0,13,6,90,0,16,1,1,0,1,0,0,0,1,0,1,1,45,0,37,0,5,0,5,0,2,6,2,0,5,0,5,0,2,6,20,0,12,3,1,0,1,0,1,0,1,3,31,0,12,3,1,0,1,0,0,0,1,0,0,2,31,0,13,0,1,0,45,0,42,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,4,1,0,5,0,5,0,4,0,21,9,0,0,0,3,0,0,0,3,0,0,1,2,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,7,0,33,0,28,0,53,0,3,0,0,2,0,13,0,1,1,2,0,2,0,2,0,32,0,15,2,0,0,2,1,2,1,2,0,0,2,40,0,49,0,0,0,4,0,0,0,4,0,0,0,3,0,0,0,2,0,0,0,2,0,0,0,23,0,34,0,4,0,2,1,4,0,3,0,3,0,4,0,2,0,5,0,2,
0,8,0,2,0,4,0,2,1,3,0,2,0,0,0,3,0,2,3,1,0,5,0,33,0,34,0,4,0,2,1,3,0,4,0,3,0,4,0,2,0,5,0,1,0,9,0,1,1,4,0,1,0,1,0,2,0,4,0,3,0,3,0,3,0,3,3,32,0,33,2,3,0,1,0,1,0,3,0,3,0,3,0,2,0,1,0,1,0,4,2,1,0,8,0,2,0,4,0,2,1,3,0,2,0,0,0,3,0,2,3,1,0,5,0,33,0,50,0,14,0,6,0,6,0,5,0,5,0,6,0,3,0,1,0,3,0,2,3,1,0,2,0,8,0,16,0,6,0,0,0,5,0,0,0,5,0,0,0,4,0,2,0,3,0,2,0,2,6,1,0,4,0,0,0,6,1,6,0,26,0,4,0,6,0,16,0,6,0,0,0,5,0,0,0,5,0,0,0,4,0,2,0,3,0,2,0,2,6,1,0,4,0,0,0,6,1,6,0,26,0,3,1,5,0,1,0,14,0,6,0,0,0,5,0,0,0,5,0,0,0,4,0,2,0,3,0,2,0,2,6,1,0,4,0,0,0,6,1,6,0,26,0,3,0,0,0,4,0,0,0,15,0,6,0,0,0,5,0,0,0,5,0,0,0,4,0,2,0,3,0,2,0,2,6,1,0,4,0,0,0,6,1,6,0,26,0,11,0,0,0,15,0,6,0,0,0,5,0,0,0,5,0,0,0,4,0,2,0,3,0,2,0,2,6,1,0,4,0,0,0,6,1,6,0,26,0,11,2,5,0,0,0,5,2,5,0,0,0,5,0,0,0,5,0,0,0,4,0,2,0,3,0,2,0,2,6,1,0,4,0,0,0,6,1,6,0,26,0,42,7,3,0,1,0,8,0,1,0,8,0,1,0,7,0,2,5,2,0,2,0,6,5,6,0,3,0,5,0,4,0,5,0,4,5,39,0,29,2,4,0,2,0,2,0,4,0,1,0,7,0,7,0,7,0,7,0,4,0,2,0,2,0,4,2,6,0,8,0,5,2,2,0,2,0,8,0,13,6,1,0,7,0,7,0,7,6,1,0,7,0,7,0,7,0,7,6,27,0,4,0,6,0,
13,6,1,0,7,0,7,0,7,6,1,0,7,0,7,0,7,0,7,6,27,0,3,1,5,0,1,0,11,6,1,0,7,0,7,0,7,6,1,0,7,0,7,0,7,0,7,6,27,0,11,0,0,0,12,6,1,0,7,0,7,0,7,6,1,0,7,0,7,0,7,0,7,6,27,1,0,2,0,4,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,9,0,1,0,0,0,4,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,9,0,0,2,5,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,9,0,2,0,0,0,3,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,9,0,27,4,3,0,3,0,2,0,4,0,1,0,4,0,0,4,1,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,3,0,2,4,29,0,3,0,0,0,4,0,0,0,12,0,4,0,1,1,3,0,1,0,0,0,2,0,1,0,0,0,2,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,2,0,0,0,1,0,2,0,0,0,1,0,3,1,1,0,4,0,27,0,3,0,9,0,16,3,4,0,3,0,2,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,2,0,3,0,4,3,32,0,4,0,7,0,17,3,4,0,3,0,2,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,2,0,3,0,4,3,32,0,3,1,6,0,1,0,15,3,4,0,3,0,2,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,2,0,3,0,4,3,32,0,3,0,0,0,5,0,0,0,16,3,4,0,3,0,2,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,2,0,3,0,4,3,32,0,13,0,0,0,15,3,4,0,3,0,2,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,2,0,3,0,4,3,32,0,48,
0,2,0,3,2,5,0,5,2,3,0,2,0,41,0,32,3,0,0,2,0,3,0,2,0,3,0,0,0,1,0,3,0,0,0,1,0,2,0,1,0,1,0,1,0,2,0,1,0,1,0,2,0,1,0,0,0,3,0,2,0,3,0,2,0,0,3,32,0,2,0,8,0,13,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,2,0,2,0,4,2,29,0,4,0,6,0,13,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,2,0,2,0,4,2,29,0,3,1,5,0,1,0,11,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,2,0,2,0,4,2,29,0,11,0,0,0,12,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,2,0,2,0,4,2,29,0,4,0,6,0,13,0,4,0,2,0,2,0,3,0,2,0,4,0,0,0,5,0,0,0,6,0,7,0,7,0,7,0,7,0,30,0,27,0,7,0,7,5,2,0,3,1,1,0,4,0,1,0,4,0,1,0,3,1,1,5,2,0,7,0,33,0,29,2,4,0,2,0,2,0,3,0,2,0,2,0,3,0,2,0,3,0,2,0,3,0,3,0,2,0,4,0,1,0,0,0,2,0,1,0,1,2,28,0,23,0,6,0,10,2,2,0,2,0,5,0,2,3,1,0,2,0,1,0,1,1,2,1,0,0,21,0,24,0,4,0,11,2,2,0,2,0,5,0,2,3,1,0,2,0,1,0,1,1,2,1,0,0,21,0,23,1,3,0,1,0,9,2,2,0,2,0,5,0,2,3,1,0,2,0,1,0,1,1,2,1,0,0,21,0,23,0,0,0,2,0,0,0,10,2,2,0,2,0,5,0,2,3,1,0,2,0,1,0,1,1,2,1,0,0,21,0,29,0,0,0,10,2,2,0,2,0,5,0,2,3,1,0,2,
0,1,0,1,1,2,1,0,0,21,0,15,2,3,0,0,0,3,2,10,2,2,0,2,0,5,0,2,3,1,0,2,0,1,0,1,1,2,1,0,0,21,0,73,3,0,2,2,0,2,1,2,0,3,2,3,0,2,0,1,5,1,0,2,0,6,0,2,1,2,0,2,2,1,2,37,0,43,2,2,0,2,0,1,0,5,0,5,0,5,0,2,0,2,2,4,0,6,0,3,2,1,0,22,0,6,0,11,2,2,0,2,0,1,0,2,0,1,4,1,0,5,0,2,0,2,2,22,0,24,0,4,0,11,2,2,0,2,0,1,0,2,0,1,4,1,0,5,0,2,0,2,2,22,0,23,1,3,0,1,0,9,2,2,0,2,0,1,0,2,0,1,4,1,0,5,0,2,0,2,2,22,0,29,0,0,0,10,2,2,0,2,0,1,0,2,0,1,4,1,0,5,0,2,0,2,2,22,0,8,0,2,0,4,0,1,0,1,0,1,0,1,0,1,0,1,0,9,0,10,0,0,0,4,0,1,0,1,0,1,0,1,0,1,0,1,0,9,0,9,2,5,0,1,0,1,0,1,0,1,0,1,0,1,0,9,0,11,0,0,0,3,0,1,0,1,0,1,0,1,0,1,0,1,0,9,0,22,0,0,0,3,1,3,0,1,0,3,2,2,0,1,1,0,0,3,0,0,0,3,0,0,0,3,0,1,0,1,0,3,1,23,0,23,0,0,0,2,0,0,0,9,0,0,1,2,1,1,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,21,0,22,0,6,0,11,2,2,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,2,2,22,0,24,0,4,0,11,2,2,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,2,2,22,0,23,1,3,0,1,0,9,2,2,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,2,2,22,0,23,0,0,0,2,0,0,0,10,2,2,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,2,2,22,0,29,
0,0,0,10,2,2,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,2,2,22,0,44,0,9,6,9,0,37,0,43,1,0,0,1,0,1,0,2,0,1,1,1,0,0,0,0,0,1,1,1,0,2,0,1,0,1,0,0,1,22,0,22,0,6,0,10,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,2,3,21,0,24,0,4,0,10,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,2,3,21,0,23,1,3,0,1,0,8,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,2,3,21,0,29,0,0,0,9,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0,2,3,21,0,24,0,4,0,10,0,2,0,1,0,2,0,2,0,0,0,3,0,0,0,3,0,0,0,4,0,5,0,5,0,5,0,3,1,3,0,21,0,5,0,5,0,5,2,3,0,1,0,2,0,2,0,1,0,2,0,1,0,2,0,1,0,1,0,2,2,3,0,5,0,5,0,4,0,29,0,0,0,9,0,2,0,1,0,2,0,2,0,0,0,3,0,0,0,3,0,0,0,4,0,5,0,5,0,5,0,3,1,3,0,0,0);

{
sysfont__arial_10:array[0..9778] of byte=(
71,70,35,51,19,0,15,0,13,0,8,6,0,0,13,0,12,6,0,0,13,0,16,6,0,0,13,0,34,6,0,0,13,0,50,6,0,0,13,0,66,6,0,0,13,0,96,6,0,0,13,0,100,6,0,0,13,0,112,6,0,0,13,0,152,6,0,0,13,0,156,6,0,0,13,0,160,6,0,0,13,0,190,6,0,0,13,0,232,6,0,0,13,0,236,6,0,0,13,0,18,7,0,0,13,0,64,7,0,0,13,0,94,7,0,0,13,0,118,7,0,0,13,0,154,7,0,0,13,0,196,7,0,0,13,0,0,8,0,0,13,0,16,8,0,0,13,0,34,8,0,0,13,0,64,8,0,0,13,0,94,8,0,0,13,0,124,8,0,0,13,0,136,8,0,0,13,0,148,8,0,0,13,0,152,8,0,0,13,0,156,8,0,0,13,0,160,8,0,0,5,0,164,8,0,0,5,0,166,8,0,0,6,0,190,8,0,0,9,0,208,8,0,0,9,0,254,8,0,0,15,0,56,9,0,0,11,0,130,9,0,0,3,0,180,9,0,0,6,0,190,9,0,0,6,0,222,9,0,0,7,0,254,9,0,0,10,0,14,10,0,0,5,0,30,10,0,0,6,0,38,10,0,0,5,0,42,10,0,0,5,0,46,10,0,0,9,0,72,10,0,0,9,0,118,10,0,0,9,0,148,10,0,0,9,0,178,10,0,0,9,0,212,10,0,0,9,0,250,10,0,0,9,0,26,11,0,0,9,0,70,11,0,0,9,0,96,11,0,0,9,0,140,11,0,0,5,0,184,11,0,0,5,0,190,11,0,0,10,0,200,11,0,0,10,0,220,11,0,0,10,0,226,11,0,0,9,0,246,11,0,0,17,0,20,12,0,0,11,0,116,12,0,0,11,0,160,12,0,0,12,0,204,12,0,
0,12,0,238,12,0,0,11,0,28,13,0,0,10,0,54,13,0,0,12,0,80,13,0,0,11,0,120,13,0,0,5,0,168,13,0,0,9,0,194,13,0,0,11,0,226,13,0,0,9,0,22,14,0,0,13,0,48,14,0,0,11,0,130,14,0,0,12,0,196,14,0,0,11,0,242,14,0,0,12,0,22,15,0,0,11,0,72,15,0,0,11,0,118,15,0,0,9,0,154,15,0,0,11,0,180,15,0,0,11,0,228,15,0,0,17,0,18,16,0,0,11,0,106,16,0,0,11,0,154,16,0,0,9,0,192,16,0,0,5,0,218,16,0,0,5,0,250,16,0,0,5,0,20,17,0,0,7,0,52,17,0,0,9,0,80,17,0,0,6,0,86,17,0,0,9,0,92,17,0,0,9,0,126,17,0,0,9,0,170,17,0,0,9,0,198,17,0,0,9,0,242,17,0,0,5,0,16,18,0,0,9,0,42,18,0,0,9,0,88,18,0,0,4,0,132,18,0,0,4,0,154,18,0,0,8,0,182,18,0,0,3,0,226,18,0,0,13,0,252,18,0,0,9,0,52,19,0,0,9,0,90,19,0,0,9,0,124,19,0,0,9,0,168,19,0,0,6,0,212,19,0,0,8,0,234,19,0,0,4,0,2,20,0,0,9,0,28,20,0,0,7,0,66,20,0,0,11,0,98,20,0,0,7,0,158,20,0,0,9,0,194,20,0,0,8,0,236,20,0,0,6,0,0,21,0,0,5,0,32,21,0,0,6,0,66,21,0,0,10,0,98,21,0,0,13,0,108,21,0,0,9,0,142,21,0,0,1,0,172,21,0,0,4,0,174,21,0,0,9,0,182,21,0,0,6,0,214,21,0,0,17,0,228,21,0,0,9,0,238,21,0,0,9,0,14,22,
0,0,6,0,46,22,0,0,17,0,54,22,0,0,11,0,140,22,0,0,6,0,182,22,0,0,17,0,200,22,0,0,1,0,252,22,0,0,9,0,254,22,0,0,1,0,30,23,0,0,1,0,32,23,0,0,4,0,34,23,0,0,4,0,42,23,0,0,6,0,50,23,0,0,6,0,64,23,0,0,6,0,78,23,0,0,9,0,88,23,0,0,17,0,92,23,0,0,4,0,100,23,0,0,17,0,108,23,0,0,8,0,168,23,0,0,6,0,198,23,0,0,16,0,216,23,0,0,1,0,10,24,0,0,8,0,12,24,0,0,11,0,38,24,0,0,5,0,80,24,0,0,5,0,82,24,0,0,9,0,106,24,0,0,9,0,156,24,0,0,9,0,190,24,0,0,9,0,224,24,0,0,5,0,6,25,0,0,9,0,34,25,0,0,6,0,84,25,0,0,13,0,90,25,0,0,5,0,144,25,0,0,9,0,160,25,0,0,10,0,194,25,0,0,6,0,206,25,0,0,13,0,210,25,0,0,10,0,14,26,0,0,7,0,20,26,0,0,9,0,38,26,0,0,6,0,56,26,0,0,6,0,72,26,0,0,6,0,90,26,0,0,9,0,96,26,0,0,9,0,142,26,0,0,6,0,206,26,0,0,6,0,210,26,0,0,6,0,220,26,0,0,5,0,236,26,0,0,9,0,252,26,0,0,14,0,30,27,0,0,14,0,86,27,0,0,14,0,140,27,0,0,10,0,198,27,0,0,11,0,228,27,0,0,11,0,20,28,0,0,11,0,68,28,0,0,11,0,118,28,0,0,11,0,170,28,0,0,11,0,218,28,0,0,17,0,12,29,0,0,12,0,58,29,0,0,11,0,100,29,0,0,11,0,130,29,0,0,11,0,160,29,0,0,11,0,192,
29,0,0,5,0,222,29,0,0,5,0,252,29,0,0,5,0,26,30,0,0,5,0,58,30,0,0,12,0,88,30,0,0,11,0,134,30,0,0,12,0,208,30,0,0,12,0,2,31,0,0,12,0,52,31,0,0,12,0,104,31,0,0,12,0,158,31,0,0,10,0,208,31,0,0,13,0,232,31,0,0,11,0,38,32,0,0,11,0,90,32,0,0,11,0,142,32,0,0,11,0,196,32,0,0,11,0,248,32,0,0,11,0,34,33,0,0,10,0,72,33,0,0,9,0,122,33,0,0,9,0,160,33,0,0,9,0,198,33,0,0,9,0,238,33,0,0,9,0,24,34,0,0,9,0,62,34,0,0,15,0,104,34,0,0,9,0,150,34,0,0,9,0,186,34,0,0,9,0,220,34,0,0,9,0,254,34,0,0,9,0,34,35,0,0,5,0,68,35,0,0,5,0,92,35,0,0,5,0,116,35,0,0,5,0,142,35,0,0,9,0,166,35,0,0,9,0,210,35,0,0,9,0,0,36,0,0,9,0,38,36,0,0,9,0,76,36,0,0,9,0,116,36,0,0,9,0,158,36,0,0,9,0,196,36,0,0,9,0,204,36,0,0,9,0,248,36,0,0,9,0,34,37,0,0,9,0,76,37,0,0,9,0,120,37,0,0,9,0,162,37,0,0,9,0,208,37,0,0,9,0,2,38,0,0,0,128,0,246,0,128,0,246,0,116,3,11,0,11,0,11,0,11,0,11,0,11,0,11,0,34,0,41,0,11,0,11,0,11,0,11,0,11,0,11,3,122,0,41,0,11,0,11,0,11,0,11,0,11,0,8,3,125,0,41,0,11,0,11,0,11,0,11,0,11,0,11,0,11,0,11,0,11,0,11,0,11,0,11,0,11,0,34,0,116,
6,122,0,92,2,8,4,7,4,7,4,8,2,98,0,38,6,5,6,5,6,5,6,5,1,2,1,5,0,4,0,5,0,4,0,5,0,4,0,5,1,2,1,5,6,5,6,5,6,5,6,5,6,31,0,128,0,246,0,128,0,246,0,67,3,10,1,9,0,0,0,9,0,0,0,8,0,11,0,10,1,9,0,1,0,8,0,1,0,9,1,60,0,53,8,3,0,6,0,3,0,6,0,3,0,6,0,3,0,6,0,3,0,6,0,3,0,6,0,3,0,6,0,3,0,6,0,3,0,6,0,3,8,53,0,128,0,246,0,69,1,7,2,0,0,7,0,1,1,7,2,0,0,7,0,2,0,7,0,2,0,7,0,2,0,7,0,1,1,6,1,1,1,6,1,61,0,65,0,0,0,0,0,7,0,0,0,0,0,8,0,0,0,9,0,0,0,8,1,0,1,8,0,0,0,9,0,0,0,8,0,0,0,0,0,7,0,0,0,0,0,71,0,41,0,11,0,11,0,11,0,11,0,11,0,8,6,8,0,11,0,11,0,11,0,11,0,11,0,11,0,34,0,57,0,10,1,9,2,8,3,7,4,6,5,7,4,8,3,9,2,10,1,11,0,57,0,41,0,10,2,8,0,0,0,0,0,9,0,11,0,11,0,11,0,11,0,11,0,11,0,9,0,0,0,0,0,8,2,10,0,47,0,53,0,1,0,8,0,1,0,8,0,1,0,8,0,1,0,8,0,1,0,8,0,1,0,8,0,1,0,8,0,1,0,34,0,1,0,8,0,1,0,45,0,53,1,0,0,7,0,0,0,0,0,7,0,0,0,0,0,7,0,0,0,0,0,7,0,0,0,0,0,7,0,0,0,0,0,8,1,0,0,9,0,0,0,9,0,0,0,9,0,0,0,9,0,0,0,9,0,0,0,45,0,41,0,11,0,11,0,11,0,11,0,11,0,8,6,122,0,116,6,8,0,11,0,11,0,11,0,11,0,11,0,11,0,34,0,41,0,11,0,11,0,11,0,11,0,11,0,8,3,
11,0,11,0,11,0,11,0,11,0,11,0,11,0,34,0,54,0,10,2,8,0,0,0,0,0,9,0,11,0,11,0,11,0,11,0,11,0,11,0,11,0,11,0,47,0,41,0,11,0,11,0,11,0,11,0,11,0,11,3,8,0,11,0,11,0,11,0,11,0,11,0,11,0,34,0,107,0,12,0,7,5,10,0,10,0,85,0,106,0,10,0,10,5,7,0,12,0,86,0,128,0,246,0,128,0,246,0,128,0,246,0,128,0,246,0,94,0,16,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,8,0,21,0,18,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,72,0,30,0,1,0,4,0,1,0,3,0,1,0,4,0,1,0,1,8,2,0,1,0,3,0,1,0,4,0,1,0,2,8,1,0,1,0,3,0,1,0,4,0,1,0,39,0,21,0,6,3,3,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,4,0,1,0,5,2,7,2,5,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,2,0,0,0,0,0,4,2,6,0,7,0,21,0,46,2,4,0,4,0,2,0,2,0,5,0,2,0,2,0,5,0,2,0,1,0,6,0,2,0,1,0,6,0,2,0,0,0,1,2,3,2,1,0,0,0,2,0,6,0,1,0,2,0,5,0,2,0,2,0,5,0,2,0,2,0,4,0,3,0,2,0,4,0,4,2,61,0,36,2,6,0,2,0,5,0,2,0,5,0,2,0,6,0,0,0,6,2,6,0,1,0,5,0,3,0,1,0,1,0,3,0,0,0,2,0,4,0,4,0,3,1,4,3,1,0,44,0,9,0,1,0,1,0,1,0,36,0,20,0,3,0,4,0,4,0,3,0,4,0,4,0,4,0,4,0,4,0,4,0,5,0,4,0,4,0,5,0,7,0,19,0,5,0,4,0,4,0,5,0,4,0,4,0,4,0,4,0,4,0,4,0,3,0,4,0,4,0,3,0,8,0,23,0,3,4,
3,0,4,0,0,0,3,0,0,0,78,0,53,0,8,0,8,0,5,6,5,0,8,0,8,0,74,0,71,0,3,0,3,0,11,0,59,4,48,0,71,0,21,0,18,0,2,0,3,0,3,0,2,0,3,0,3,0,2,0,3,0,3,0,2,0,3,0,23,0,29,2,4,0,2,0,2,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,2,0,2,0,4,2,38,0,31,0,6,1,5,0,0,0,4,0,1,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,38,0,29,3,3,0,2,0,2,0,4,0,7,0,7,0,6,0,7,0,6,0,6,0,6,0,6,0,6,6,36,0,29,2,4,0,2,0,2,0,3,0,7,0,6,0,5,2,8,0,8,0,7,0,1,0,4,0,1,1,2,0,4,2,38,0,31,0,6,1,5,0,0,0,5,0,0,0,4,0,1,0,4,0,1,0,3,0,2,0,2,0,3,0,2,7,5,0,7,0,7,0,38,0,28,5,2,0,7,0,6,0,7,4,3,0,3,0,8,0,7,0,7,0,1,0,4,0,2,0,2,0,4,2,38,0,29,2,4,0,2,1,1,0,4,0,1,0,7,0,0,2,3,1,2,0,2,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,2,0,2,0,4,2,38,0,27,6,6,0,7,0,6,0,7,0,6,0,7,0,7,0,7,0,6,0,7,0,7,0,40,0,29,2,4,0,2,0,2,0,4,0,1,0,4,0,2,0,2,0,4,2,4,0,2,0,2,0,4,0,1,0,4,0,1,0,4,0,2,0,2,0,4,2,38,0,29,2,4,0,2,0,2,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,2,0,2,1,3,2,0,0,7,0,1,0,4,0,2,0,2,0,3,3,38,0,31,0,38,0,21,0,31,0,38,0,3,0,3,0,11,0,47,0,6,1,5,1,5,1,6,0,9,1,9,1,9,1,9,0,60,0,70,7,31,7,70,0,40,0,9,1,
9,1,9,1,9,0,6,1,5,1,5,1,6,0,67,0,29,2,4,0,2,0,2,0,4,0,1,0,4,0,7,0,6,0,6,0,6,0,7,0,7,0,16,0,39,0,56,6,7,1,6,1,4,0,10,0,2,0,3,2,1,0,1,0,2,0,2,0,2,2,2,0,1,0,1,0,4,0,3,0,0,0,1,0,5,0,3,0,0,0,1,0,5,0,3,0,0,0,1,0,4,0,4,0,0,0,1,0,4,0,3,0,1,0,2,0,2,1,2,0,3,0,2,2,0,3,4,0,12,0,2,0,10,0,4,1,6,1,7,6,3,0,37,0,8,0,0,0,7,0,0,0,6,0,2,0,5,0,2,0,5,0,2,0,4,0,4,0,3,6,2,0,6,0,1,0,6,0,0,0,8,1,8,0,43,0,33,6,3,0,5,0,2,0,6,0,1,0,6,0,1,0,5,0,2,7,2,0,5,0,2,0,6,0,1,0,6,0,1,0,6,0,1,0,5,0,2,6,46,0,39,4,5,0,4,0,3,0,6,0,1,0,10,0,10,0,10,0,10,0,10,0,11,0,6,0,3,0,4,0,5,4,50,0,36,6,4,0,5,0,3,0,6,0,2,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,6,0,2,0,5,0,3,6,51,0,33,8,1,0,9,0,9,0,9,0,9,7,2,0,9,0,9,0,9,0,9,0,9,8,44,0,30,7,1,0,8,0,8,0,8,0,8,6,2,0,8,0,8,0,8,0,8,0,8,0,47,0,39,3,6,0,3,0,4,0,5,0,2,0,10,0,10,0,10,0,3,4,1,0,7,0,1,0,7,0,2,0,5,0,4,0,3,0,6,3,51,0,33,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,8,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,44,0,16,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,21,0,33,0,7,0,7,0,7,0,7,0,7,
0,7,0,7,0,1,0,4,0,1,0,4,0,2,0,2,0,3,3,38,0,33,0,6,0,1,0,5,0,2,0,4,0,3,0,3,0,4,0,2,0,5,0,1,1,5,0,0,0,1,0,4,1,3,0,3,0,4,0,3,0,5,0,2,0,5,0,2,0,6,0,44,0,27,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,6,36,0,39,0,8,0,1,1,6,1,1,1,6,1,1,0,0,0,4,0,0,0,1,0,0,0,4,0,0,0,1,0,1,0,2,0,1,0,1,0,1,0,2,0,1,0,1,0,1,0,1,0,2,0,1,0,2,0,0,0,2,0,1,0,2,0,0,0,2,0,1,0,3,0,3,0,1,0,3,0,3,0,52,0,33,0,6,0,1,1,5,0,1,0,0,0,4,0,1,0,0,0,4,0,1,0,1,0,3,0,1,0,2,0,2,0,1,0,2,0,2,0,1,0,3,0,1,0,1,0,4,0,0,0,1,0,4,0,0,0,1,0,5,1,1,0,6,0,44,0,39,3,6,0,3,0,4,0,5,0,2,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,2,0,5,0,4,0,3,0,6,3,51,0,33,6,3,0,5,0,2,0,6,0,1,0,6,0,1,0,6,0,1,0,5,0,2,6,3,0,9,0,9,0,9,0,9,0,52,0,39,3,6,0,3,0,4,0,5,0,2,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,2,0,2,1,0,1,3,0,3,1,5,3,0,1,48,0,33,6,3,0,5,0,2,0,6,0,1,0,6,0,1,0,6,0,1,0,5,0,2,6,3,0,3,0,4,0,4,0,3,0,4,0,3,0,5,0,2,0,6,0,44,0,35,4,4,0,4,0,2,0,6,0,1,0,10,0,10,2,10,2,10,0,1,0,6,0,1,0,6,0,2,0,4,0,4,4,46,0,26,8,3,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,39,0,33,0,6,0,1,
0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,2,0,4,0,4,4,46,0,33,0,6,0,1,0,6,0,2,0,4,0,3,0,4,0,3,0,4,0,4,0,2,0,5,0,2,0,5,0,2,0,6,0,0,0,7,0,0,0,8,0,9,0,48,0,50,0,6,0,6,0,0,0,4,0,0,0,4,0,1,0,4,0,0,0,4,0,1,0,4,0,0,0,4,0,2,0,2,0,2,0,2,0,3,0,2,0,2,0,2,0,3,0,2,0,2,0,2,0,4,0,0,0,4,0,0,0,5,0,0,0,4,0,0,0,5,0,0,0,4,0,0,0,6,0,6,0,7,0,6,0,71,0,33,0,6,0,2,0,4,0,4,0,2,0,5,0,2,0,6,0,0,0,8,0,8,0,0,0,6,0,2,0,5,0,2,0,4,0,4,0,2,0,6,0,0,0,8,0,43,0,33,0,6,0,2,0,4,0,3,0,4,0,4,0,2,0,6,0,0,0,7,0,0,0,8,0,9,0,9,0,9,0,9,0,9,0,48,0,27,7,6,0,6,0,7,0,6,0,6,0,7,0,6,0,6,0,7,0,6,0,6,8,35,0,15,2,1,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,2,5,0,14,0,4,0,3,0,3,0,4,0,3,0,3,0,4,0,3,0,3,0,4,0,3,0,19,0,15,2,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,1,2,5,0,23,0,4,0,0,0,3,0,0,0,2,0,2,0,1,0,2,0,1,0,2,0,0,0,4,0,62,0,128,0,152,8,8,0,18,0,5,0,86,0,56,3,3,0,3,0,1,0,4,0,5,2,2,2,1,0,1,0,4,0,1,0,4,0,1,0,3,1,2,3,0,0,36,0,27,0,7,0,7,0,7,0,0,2,3,1,2,0,2,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,1,2,0,2,
0,0,2,38,0,56,2,4,0,2,0,2,0,4,0,1,0,7,0,7,0,7,0,4,0,2,0,2,0,4,2,38,0,33,0,7,0,7,0,3,2,0,0,2,0,2,1,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,2,0,2,1,3,2,0,0,36,0,56,2,4,0,2,0,2,0,4,0,1,0,4,0,1,6,1,0,7,0,4,0,2,0,2,0,4,2,38,0,17,1,1,0,3,0,2,3,1,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,21,0,56,2,0,0,2,0,2,1,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,2,0,2,1,3,2,0,0,7,0,1,0,3,0,3,3,11,0,27,0,7,0,7,0,7,0,0,3,2,1,3,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,36,0,12,0,10,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,17,0,13,0,10,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,0,1,5,0,24,0,6,0,6,0,6,0,4,0,0,0,3,0,1,0,2,0,2,0,1,0,3,0,0,1,3,1,1,0,2,0,3,0,1,0,3,0,1,0,4,0,31,0,9,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,12,0,78,0,0,2,1,2,2,1,2,1,2,0,1,0,3,0,3,0,1,0,3,0,3,0,1,0,3,0,3,0,1,0,3,0,3,0,1,0,3,0,3,0,1,0,3,0,3,0,1,0,3,0,3,0,52,0,54,0,0,3,2,1,3,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,36,0,56,2,4,0,2,0,2,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,2,0,2,0,4,2,38,0,54,0,0,2,3,1,2,0,2,0,4,0,1,0,4,0,1,0,4,0,
1,0,4,0,1,0,4,0,1,1,2,0,2,0,0,2,3,0,7,0,7,0,15,0,56,2,0,0,2,0,2,1,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,2,0,2,1,3,2,0,0,7,0,7,0,7,0,9,0,36,0,0,2,0,1,3,0,4,0,4,0,4,0,4,0,4,0,4,0,27,0,49,3,2,0,3,0,1,0,6,0,7,3,7,0,6,0,1,0,3,0,2,3,33,0,12,0,2,0,2,0,1,3,0,0,2,0,2,0,2,0,2,0,2,0,2,0,2,2,15,0,54,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,3,1,2,3,0,0,36,0,41,0,4,1,4,0,0,0,2,0,1,0,2,0,1,0,2,0,2,0,0,0,3,0,0,0,4,0,5,0,30,0,65,0,3,0,3,1,3,0,3,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,2,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,2,0,0,0,2,0,4,0,3,0,4,0,45,0,41,0,4,0,0,0,2,0,2,0,0,0,3,0,0,0,4,0,4,0,0,0,3,0,0,0,2,0,2,0,0,0,4,0,27,0,54,0,4,0,1,0,4,0,1,0,4,0,2,0,2,0,3,0,2,0,3,0,1,1,4,0,0,0,5,0,0,0,6,0,7,0,6,0,5,1,14,0,47,6,5,0,5,0,6,0,5,0,5,0,6,0,5,0,5,6,32,0,21,1,2,0,4,0,4,0,4,0,4,0,4,0,2,1,5,0,4,0,4,0,4,0,4,0,4,0,5,1,5,0,16,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,1,0,17,1,5,0,4,0,4,0,4,0,4,0,4,0,5,1,2,0,4,0,4,0,4,0,4,0,4,0,2,1,9,0,80,3,2,0,0,0,2,3,91,0,64,2,9,0,0,0,9,0,0,0,9,0,0,0,9,0,
0,0,9,0,0,0,9,0,0,0,9,0,0,0,9,2,74,0,30,2,3,1,2,0,1,0,7,0,6,6,2,0,7,0,6,6,2,0,7,0,8,0,3,0,3,3,37,0,18,0,56,0,2,0,2,0,9,0,31,2,4,0,7,0,5,4,5,0,6,0,7,0,7,0,7,0,7,0,7,0,6,0,7,0,7,0,5,2,14,0,84,0,0,0,2,0,0,0,2,0,0,0,13,0,128,0,239,0,3,0,3,0,71,0,30,0,7,0,7,0,4,6,4,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,7,0,12,0,30,0,7,0,7,0,4,6,4,0,7,0,7,0,7,0,7,0,7,0,7,0,4,6,4,0,7,0,7,0,12,0,19,1,2,0,1,0,84,0,51,2,2,0,8,0,2,0,1,0,8,0,2,0,0,0,9,0,2,0,0,0,9,0,2,0,0,0,10,2,0,0,15,0,0,2,2,2,4,0,0,0,2,0,0,0,2,0,3,0,0,0,2,0,0,0,2,0,2,0,1,0,2,0,0,0,2,0,2,0,1,0,2,0,0,0,2,0,2,0,2,2,2,2,68,0,3,0,1,0,7,1,17,4,4,0,4,0,2,0,6,0,1,0,10,0,10,2,10,2,10,0,1,0,6,0,1,0,6,0,2,0,4,0,4,4,46,0,38,0,3,0,4,0,3,0,4,0,5,0,4,0,5,0,31,0,54,3,1,5,2,1,3,2,7,0,5,1,6,0,7,0,6,0,7,0,6,0,7,5,1,0,7,0,6,0,7,0,6,0,7,0,7,0,5,1,8,0,3,0,0,0,9,3,1,5,68,0,18,0,2,0,1,0,5,1,12,7,6,0,6,0,7,0,6,0,6,0,7,0,6,0,6,0,7,0,6,0,6,8,35,0,18,0,18,0,12,0,2,0,2,0,53,0,12,0,2,0,2,0,53,0,18,0,0,0,2,0,0,0,2,0,0,0,79,0,18,0,0,0,2,0,0,0,2,0,0,0,79,0,43,1,2,3,1,3,2,1,49,0,89,8,71,0,
128,0,169,16,128,0,135,0,12,0,0,1,0,0,56,0,52,4,0,1,2,1,5,0,2,1,2,1,5,0,2,2,0,2,5,0,2,0,0,0,0,0,0,0,5,0,2,0,0,0,0,0,0,0,5,0,2,0,0,0,0,0,0,0,5,0,2,0,1,0,1,0,128,0,154,0,25,0,1,0,4,1,12,3,2,0,3,0,1,0,6,0,7,3,7,0,6,0,1,0,3,0,2,3,33,0,37,0,5,0,4,0,5,0,4,0,3,0,4,0,3,0,32,0,98,2,2,3,4,0,2,0,0,0,3,0,2,0,4,0,5,0,1,0,4,0,5,0,1,0,4,7,1,0,4,0,8,0,4,0,5,0,2,0,2,2,3,0,4,2,2,3,66,0,18,0,25,0,1,0,4,1,10,6,5,0,5,0,6,0,5,0,5,0,6,0,5,0,5,6,32,0,14,0,0,0,15,0,6,0,2,0,4,0,3,0,4,0,4,0,2,0,6,0,0,0,7,0,0,0,8,0,9,0,9,0,9,0,9,0,9,0,48,0,94,0,31,0,8,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,6,0,32,0,7,0,7,0,4,3,3,0,1,2,1,0,2,0,0,0,1,0,1,0,4,0,1,0,4,0,1,0,4,0,0,0,2,0,2,1,1,0,3,3,5,0,6,0,7,0,14,0,28,3,3,1,2,0,2,0,4,0,1,0,7,0,6,4,5,0,7,0,7,0,6,0,6,3,2,0,0,0,2,2,37,0,54,0,0,2,0,0,2,0,2,0,2,0,4,0,1,0,4,0,1,0,4,0,2,0,2,0,2,0,0,2,0,0,54,0,26,0,6,0,0,0,4,0,2,0,2,0,3,0,2,0,4,0,0,0,5,0,0,0,2,8,3,0,3,8,3,0,7,0,7,0,39,0,16,0,3,0,3,0,3,0,3,0,3,0,18,0,3,0,3,0,3,0,3,0,3,0,3,0,1,0,28,3,3,0,3,0,2,0,3,0,2,1,7,1,5,0,1,1,2,0,4,0,1,0,5,0,1,0,4,0,
2,1,1,0,5,1,7,1,1,0,4,0,2,0,3,0,3,3,11,0,19,0,0,0,90,0,41,6,4,0,6,0,2,0,1,4,1,0,0,0,1,0,4,0,1,1,1,0,7,1,1,0,7,1,1,0,7,1,1,0,4,0,1,1,2,4,2,0,0,0,8,0,2,0,6,0,4,6,54,0,15,2,0,0,2,0,1,4,1,1,2,0,0,3,49,0,56,0,1,0,3,0,1,0,4,0,1,0,3,0,1,0,4,0,1,0,5,0,1,0,4,0,1,0,5,0,1,0,46,0,60,7,8,0,8,0,8,0,8,0,80,0,59,4,48,0,41,6,4,0,6,0,2,0,1,4,1,0,0,0,2,0,3,0,1,1,2,0,3,0,1,1,2,4,2,1,2,0,1,0,3,1,2,0,2,0,2,1,2,0,3,0,1,0,0,0,8,0,2,0,6,0,4,6,54,0,9,9,128,0,169,0,22,2,2,0,2,0,1,0,2,0,1,0,2,0,2,2,78,0,48,0,7,0,7,0,4,6,4,0,7,0,7,0,22,6,36,0,18,2,1,0,2,0,4,0,2,1,2,0,3,4,60,0,18,3,0,0,2,0,2,1,5,0,0,0,2,0,1,2,61,0,20,0,3,0,86,0,54,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,1,2,1,1,0,0,2,0,0,1,0,7,0,7,0,15,0,28,6,0,3,1,0,0,4,1,0,0,4,1,0,0,4,1,0,1,3,1,0,2,2,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,0,0,55,0,56,0,91,0,4,1,4,0,2,1,2,0,20,0,3,1,2,0,0,0,4,0,4,0,4,0,61,0,15,2,0,0,2,1,2,1,2,1,2,0,0,2,50,0,55,0,1,0,5,0,1,0,4,0,1,0,5,0,1,0,4,0,1,0,3,0,1,0,4,0,1,0,3,0,1,0,47,0,44,0,6,0,3,1,
5,0,3,0,0,0,4,0,6,0,4,0,6,0,3,0,7,0,2,0,11,0,4,0,6,0,3,1,5,0,3,0,0,0,4,0,3,0,1,0,3,0,4,4,2,0,7,0,56,0,44,0,5,0,4,1,5,0,3,0,0,0,4,0,6,0,3,0,7,0,2,0,8,0,2,0,11,0,2,2,5,0,2,0,2,0,3,0,7,0,3,0,5,1,3,0,5,0,4,0,5,4,55,0,42,3,5,0,1,0,2,0,4,0,5,0,4,0,7,0,2,0,4,0,2,0,2,0,5,2,2,0,11,0,4,0,5,0,4,1,5,0,3,0,0,0,4,0,3,0,1,0,3,0,4,4,1,0,8,0,56,0,63,0,18,0,8,0,8,0,7,0,7,0,7,0,8,0,5,0,1,0,5,0,2,0,3,0,4,3,12,0,3,0,10,0,20,0,8,0,0,0,7,0,0,0,6,0,2,0,5,0,2,0,5,0,2,0,4,0,4,0,3,6,2,0,6,0,1,0,6,0,0,0,8,1,8,0,43,0,5,0,8,0,20,0,8,0,0,0,7,0,0,0,6,0,2,0,5,0,2,0,5,0,2,0,4,0,4,0,3,6,2,0,6,0,1,0,6,0,0,0,8,1,8,0,43,0,4,1,7,0,1,0,18,0,8,0,0,0,7,0,0,0,6,0,2,0,5,0,2,0,5,0,2,0,4,0,4,0,3,6,2,0,6,0,1,0,6,0,0,0,8,1,8,0,43,0,4,0,0,0,6,0,0,0,19,0,8,0,0,0,7,0,0,0,6,0,2,0,5,0,2,0,5,0,2,0,4,0,4,0,3,6,2,0,6,0,1,0,6,0,0,0,8,1,8,0,43,0,14,0,0,0,19,0,8,0,0,0,7,0,0,0,6,0,2,0,5,0,2,0,5,0,2,0,4,0,4,0,3,6,2,0,6,0,1,0,6,0,0,0,8,1,8,0,43,0,14,2,7,0,0,0,7,2,7,0,0,0,7,0,0,0,6,0,2,0,5,0,2,0,5,0,2,0,4,0,4,0,3,6,2,0,6,0,1,0,6,0,0,0,8,1,8,0,43,0,55,10,5,0,
1,0,11,0,2,0,11,0,2,0,10,0,3,0,10,0,3,7,2,0,4,0,9,6,8,0,5,0,8,0,5,0,7,0,6,0,7,0,6,7,68,0,39,4,5,0,4,0,3,0,6,0,1,0,10,0,10,0,10,0,10,0,10,0,11,0,6,0,3,0,4,0,5,4,8,0,10,1,10,0,8,1,4,0,4,0,10,0,15,8,1,0,9,0,9,0,9,0,9,7,2,0,9,0,9,0,9,0,9,0,9,8,44,0,5,0,8,0,16,8,1,0,9,0,9,0,9,0,9,7,2,0,9,0,9,0,9,0,9,0,9,8,44,0,4,1,7,0,1,0,14,8,1,0,9,0,9,0,9,0,9,7,2,0,9,0,9,0,9,0,9,0,9,8,44,0,14,0,0,0,15,8,1,0,9,0,9,0,9,0,9,7,2,0,9,0,9,0,9,0,9,0,9,8,44,0,0,0,4,0,8,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,21,0,2,0,2,0,8,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,21,0,1,1,1,0,1,0,6,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,21,0,5,0,0,0,7,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,21,0,36,6,4,0,5,0,3,0,6,0,2,0,7,0,1,0,7,0,0,5,3,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,6,0,2,0,5,0,3,6,51,0,4,0,0,0,6,0,0,0,15,0,6,0,1,1,5,0,1,0,0,0,4,0,1,0,0,0,4,0,1,0,1,0,3,0,1,0,2,0,2,0,1,0,2,0,2,0,1,0,3,0,1,0,1,0,4,0,0,0,1,0,4,0,0,0,1,0,5,1,1,0,6,0,44,0,4,0,11,0,20,3,6,0,3,0,4,0,5,0,2,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,2,0,
5,0,4,0,3,0,6,3,51,0,5,0,9,0,21,3,6,0,3,0,4,0,5,0,2,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,2,0,5,0,4,0,3,0,6,3,51,0,4,1,8,0,1,0,19,3,6,0,3,0,4,0,5,0,2,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,2,0,5,0,4,0,3,0,6,3,51,0,4,0,0,0,7,0,0,0,20,3,6,0,3,0,4,0,5,0,2,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,2,0,5,0,4,0,3,0,6,3,51,0,16,0,0,0,19,3,6,0,3,0,4,0,5,0,2,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,2,0,5,0,4,0,3,0,6,3,51,0,60,0,4,0,3,0,2,0,5,2,7,0,7,2,5,0,2,0,3,0,4,0,61,0,42,4,1,0,3,0,4,1,3,0,5,1,2,0,5,0,1,0,1,0,4,0,2,0,1,0,3,0,3,0,1,0,2,0,4,0,1,0,2,0,4,0,1,0,1,0,4,0,3,1,5,0,3,1,4,0,3,0,1,4,55,0,3,0,10,0,16,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,2,0,4,0,4,4,46,0,5,0,8,0,16,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,2,0,4,0,4,4,46,0,4,1,7,0,1,0,14,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,2,0,4,0,4,4,46,0,14,0,0,0,15,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,
6,0,1,0,6,0,1,0,6,0,2,0,4,0,4,4,46,0,5,0,8,0,16,0,6,0,2,0,4,0,3,0,4,0,4,0,2,0,6,0,0,0,7,0,0,0,8,0,9,0,9,0,9,0,9,0,9,0,48,0,33,0,9,0,9,6,3,0,5,0,2,0,6,0,1,0,6,0,1,0,6,0,1,0,6,0,1,0,5,0,2,6,3,0,9,0,52,0,32,2,5,0,2,0,3,0,3,0,3,0,3,0,3,0,2,0,4,0,2,0,4,0,3,0,3,0,4,0,2,0,5,0,1,0,5,0,1,0,1,0,2,0,1,0,2,2,41,0,30,0,8,0,14,3,3,0,3,0,1,0,4,0,5,2,2,2,1,0,1,0,4,0,1,0,4,0,1,0,3,1,2,3,0,0,36,0,31,0,6,0,15,3,3,0,3,0,1,0,4,0,5,2,2,2,1,0,1,0,4,0,1,0,4,0,1,0,3,1,2,3,0,0,36,0,30,1,5,0,1,0,13,3,3,0,3,0,1,0,4,0,5,2,2,2,1,0,1,0,4,0,1,0,4,0,1,0,3,1,2,3,0,0,36,0,30,0,0,0,4,0,0,0,14,3,3,0,3,0,1,0,4,0,5,2,2,2,1,0,1,0,4,0,1,0,4,0,1,0,3,1,2,3,0,0,36,0,38,0,0,0,14,3,3,0,3,0,1,0,4,0,5,2,2,2,1,0,1,0,4,0,1,0,4,0,1,0,3,1,2,3,0,0,36,0,20,2,5,0,0,0,5,2,14,3,3,0,3,0,1,0,4,0,5,2,2,2,1,0,1,0,4,0,1,0,4,0,1,0,3,1,2,3,0,0,36,0,92,3,0,3,4,0,3,1,2,0,2,0,4,0,4,0,5,2,4,0,2,2,1,6,1,0,4,0,7,0,4,0,4,0,1,0,3,2,2,0,3,3,1,3,62,0,56,2,4,0,2,0,2,0,4,0,1,0,7,0,7,0,7,0,4,0,2,0,2,0,4,2,6,0,7,1,7,0,5,1,3,0,30,0,8,0,14,2,4,0,2,0,2,0,4,0,1,0,4,0,1,6,1,0,
7,0,4,0,2,0,2,0,4,2,38,0,31,0,6,0,15,2,4,0,2,0,2,0,4,0,1,0,4,0,1,6,1,0,7,0,4,0,2,0,2,0,4,2,38,0,30,1,5,0,1,0,13,2,4,0,2,0,2,0,4,0,1,0,4,0,1,6,1,0,7,0,4,0,2,0,2,0,4,2,38,0,38,0,0,0,14,2,4,0,2,0,2,0,4,0,1,0,4,0,1,6,1,0,7,0,4,0,2,0,2,0,4,2,38,0,15,0,4,0,8,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,21,0,17,0,2,0,8,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,21,0,16,1,1,0,1,0,6,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,21,0,20,0,0,0,7,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,21,0,29,1,0,0,5,1,4,1,0,1,4,3,3,0,2,0,2,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,2,0,2,0,4,2,38,0,30,0,0,0,4,0,0,0,12,0,0,3,2,1,3,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,36,0,30,0,8,0,14,2,4,0,2,0,2,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,2,0,2,0,4,2,38,0,31,0,6,0,15,2,4,0,2,0,2,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,2,0,2,0,4,2,38,0,30,1,5,0,1,0,13,2,4,0,2,0,2,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,2,0,2,0,4,2,38,0,30,0,0,0,4,0,0,0,14,2,4,0,2,0,2,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,2,0,2,0,4,2,38,0,38,0,0,0,14,2,4,0,2,0,2,0,4,0,1,0,4,0,1,0,4,0,1,0,4,
0,1,0,4,0,2,0,2,0,4,2,38,0,57,0,13,6,13,0,75,0,56,2,0,0,2,0,2,0,2,0,3,1,1,0,2,0,0,0,1,0,1,0,1,0,1,0,0,0,2,0,1,1,3,0,2,0,2,0,2,0,0,2,38,0,29,0,8,0,13,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,3,1,2,3,0,0,36,0,31,0,6,0,13,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,3,1,2,3,0,0,36,0,30,1,5,0,1,0,11,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,3,1,2,3,0,0,36,0,38,0,0,0,12,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,3,1,2,3,0,0,36,0,31,0,6,0,13,0,4,0,1,0,4,0,1,0,4,0,2,0,2,0,3,0,2,0,3,0,1,1,4,0,0,0,5,0,0,0,6,0,7,0,6,0,5,1,14,0,27,0,7,0,7,0,7,0,0,2,3,1,2,0,2,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,0,4,0,1,1,2,0,2,0,0,2,3,0,7,0,7,0,15,0,38,0,0,0,12,0,4,0,1,0,4,0,1,0,4,0,2,0,2,0,3,0,2,0,3,0,1,1,4,0,0,0,5,0,0,0,6,0,7,0,6,0,5,1,14,0,0,0);

sysfont__arial_12:array[0..11357] of byte=(
71,70,35,51,23,0,19,0,15,0,8,6,0,0,15,0,12,6,0,0,15,0,16,6,0,0,15,0,40,6,0,0,15,0,62,6,0,0,15,0,84,6,0,0,15,0,122,6,0,0,15,0,130,6,0,0,15,0,148,6,0,0,15,0,200,6,0,0,15,0,204,6,0,0,15,0,208,6,0,0,15,0,252,6,0,0,15,0,46,7,0,0,15,0,50,7,0,0,15,0,108,7,0,0,15,0,170,7,0,0,15,0,208,7,0,0,15,0,240,7,0,0,15,0,26,8,0,0,15,0,80,8,0,0,15,0,150,8,0,0,15,0,172,8,0,0,15,0,196,8,0,0,15,0,234,8,0,0,15,0,14,9,0,0,15,0,52,9,0,0,15,0,68,9,0,0,15,0,84,9,0,0,15,0,88,9,0,0,15,0,92,9,0,0,15,0,96,9,0,0,6,0,100,9,0,0,6,0,104,9,0,0,7,0,132,9,0,0,11,0,154,9,0,0,11,0,204,9,0,0,18,0,12,10,0,0,13,0,100,10,0,0,4,0,158,10,0,0,7,0,170,10,0,0,7,0,210,10,0,0,8,0,250,10,0,0,12,0,12,11,0,0,6,0,34,11,0,0,7,0,46,11,0,0,6,0,52,11,0,0,6,0,58,11,0,0,11,0,90,11,0,0,11,0,144,11,0,0,11,0,178,11,0,0,11,0,214,11,0,0,11,0,254,11,0,0,11,0,40,12,0,0,11,0,80,12,0,0,11,0,130,12,0,0,11,0,162,12,0,0,11,0,212,12,0,0,6,0,6,13,0,0,6,0,16,13,0,0,12,0,32,13,0,0,12,0,52,13,0,0,12,0,62,13,0,0,11,0,82,13,0,0,20,0,114,13,0,0,13,0,224,13,0,0,13,0,20,14,0,0,14,
0,70,14,0,0,14,0,114,14,0,0,13,0,168,14,0,0,12,0,200,14,0,0,16,0,232,14,0,0,13,0,26,15,0,0,6,0,84,15,0,0,10,0,116,15,0,0,13,0,154,15,0,0,11,0,212,15,0,0,17,0,244,15,0,0,13,0,88,16,0,0,16,0,164,16,0,0,13,0,218,16,0,0,16,0,4,17,0,0,14,0,64,17,0,0,13,0,118,17,0,0,12,0,160,17,0,0,13,0,190,17,0,0,13,0,248,17,0,0,19,0,46,18,0,0,13,0,152,18,0,0,14,0,208,18,0,0,12,0,252,18,0,0,6,0,28,19,0,0,6,0,68,19,0,0,6,0,100,19,0,0,8,0,140,19,0,0,11,0,166,19,0,0,7,0,171,19,0,0,11,0,179,19,0,0,11,0,213,19,0,0,10,0,7,20,0,0,11,0,39,20,0,0,11,0,89,20,0,0,6,0,119,20,0,0,11,0,149,20,0,0,10,0,201,20,0,0,4,0,253,20,0,0,5,0,25,21,0,0,10,0,61,21,0,0,4,0,111,21,0,0,16,0,143,21,0,0,10,0,211,21,0,0,11,0,255,21,0,0,11,0,37,22,0,0,11,0,87,22,0,0,7,0,137,22,0,0,10,0,163,22,0,0,6,0,191,22,0,0,10,0,221,22,0,0,9,0,9,23,0,0,15,0,47,23,0,0,9,0,115,23,0,0,10,0,155,23,0,0,9,0,201,23,0,0,7,0,223,23,0,0,6,0,7,24,0,0,7,0,47,24,0,0,12,0,87,24,0,0,15,0,101,24,0,0,11,0,151,24,0,0,1,0,187,24,0,0,4,0,189,24,0,0,11,0,201,24,0,0,7,0,241,24,0,0,20,
0,7,25,0,0,11,0,23,25,0,0,11,0,61,25,0,0,7,0,99,25,0,0,21,0,109,25,0,0,13,0,213,25,0,0,7,0,7,26,0,0,20,0,27,26,0,0,1,0,89,26,0,0,12,0,91,26,0,0,1,0,131,26,0,0,1,0,133,26,0,0,4,0,135,26,0,0,4,0,147,26,0,0,7,0,159,26,0,0,7,0,181,26,0,0,7,0,203,26,0,0,11,0,215,26,0,0,20,0,221,26,0,0,7,0,229,26,0,0,20,0,237,26,0,0,10,0,49,27,0,0,7,0,85,27,0,0,19,0,105,27,0,0,1,0,159,27,0,0,9,0,161,27,0,0,13,0,191,27,0,0,6,0,243,27,0,0,6,0,247,27,0,0,11,0,19,28,0,0,11,0,77,28,0,0,11,0,115,28,0,0,11,0,149,28,0,0,6,0,189,28,0,0,11,0,223,28,0,0,7,0,25,29,0,0,15,0,35,29,0,0,7,0,109,29,0,0,11,0,127,29,0,0,12,0,165,29,0,0,7,0,179,29,0,0,15,0,185,29,0,0,12,0,11,30,0,0,8,0,17,30,0,0,11,0,35,30,0,0,7,0,61,30,0,0,7,0,79,30,0,0,7,0,99,30,0,0,11,0,107,30,0,0,11,0,161,30,0,0,7,0,229,30,0,0,7,0,235,30,0,0,7,0,247,30,0,0,7,0,9,31,0,0,11,0,31,31,0,0,17,0,69,31,0,0,17,0,135,31,0,0,17,0,199,31,0,0,12,0,9,32,0,0,13,0,41,32,0,0,13,0,99,32,0,0,13,0,157,32,0,0,13,0,217,32,0,0,13,0,23,33,0,0,13,0,83,33,0,0,20,0,149,33,0,0,14,0,203,33,0,0,13,
0,255,33,0,0,13,0,37,34,0,0,13,0,75,34,0,0,13,0,115,34,0,0,6,0,155,34,0,0,6,0,193,34,0,0,6,0,231,34,0,0,6,0,15,35,0,0,14,0,53,35,0,0,14,0,107,35,0,0,16,0,193,35,0,0,16,0,253,35,0,0,16,0,57,36,0,0,16,0,119,36,0,0,16,0,183,36,0,0,12,0,245,36,0,0,16,0,21,37,0,0,14,0,91,37,0,0,14,0,155,37,0,0,14,0,219,37,0,0,14,0,29,38,0,0,13,0,95,38,0,0,13,0,145,38,0,0,12,0,187,38,0,0,11,0,247,38,0,0,11,0,31,39,0,0,11,0,71,39,0,0,11,0,113,39,0,0,11,0,157,39,0,0,11,0,199,39,0,0,18,0,249,39,0,0,10,0,41,40,0,0,11,0,81,40,0,0,11,0,117,40,0,0,11,0,153,40,0,0,11,0,191,40,0,0,6,0,229,40,0,0,6,0,3,41,0,0,6,0,33,41,0,0,6,0,65,41,0,0,11,0,95,41,0,0,11,0,147,41,0,0,11,0,201,41,0,0,11,0,245,41,0,0,11,0,33,42,0,0,11,0,79,42,0,0,11,0,127,42,0,0,11,0,173,42,0,0,11,0,187,42,0,0,11,0,235,42,0,0,11,0,29,43,0,0,11,0,79,43,0,0,11,0,131,43,0,0,10,0,183,43,0,0,11,0,235,43,0,0,10,0,37,44,0,0,0,128,1,88,0,128,1,88,0,128,0,164,4,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,39,0,48,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,4,128,0,170,0,48,0,
13,0,13,0,13,0,13,0,13,0,13,0,13,0,9,4,128,0,174,0,48,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,39,0,128,0,164,8,128,0,170,0,122,2,10,4,8,6,7,6,7,6,8,4,10,2,128,0,128,0,44,8,5,8,5,8,5,8,5,8,5,2,2,2,5,1,4,1,5,0,6,0,5,0,6,0,5,0,6,0,5,1,4,1,5,2,2,2,5,8,5,8,5,8,5,8,5,8,5,8,35,0,128,1,88,0,128,1,88,0,78,4,12,1,11,0,0,0,11,0,0,0,10,0,1,0,10,0,12,0,13,0,11,2,10,0,2,0,9,0,2,0,9,0,2,0,9,0,2,0,10,2,69,0,91,9,4,0,7,0,4,0,7,0,4,0,7,0,4,0,7,0,4,0,7,0,4,0,7,0,4,0,7,0,4,0,7,0,4,0,7,0,4,0,7,0,4,0,7,0,4,9,62,0,128,1,88,0,65,2,8,2,1,0,8,0,3,0,8,0,3,0,8,0,1,2,8,2,1,0,8,0,3,0,8,0,3,0,8,0,3,0,8,0,3,0,8,0,2,1,7,1,1,2,6,2,1,2,6,2,1,1,7,1,71,0,63,0,13,0,10,0,1,0,1,0,7,0,0,2,0,0,8,0,2,0,9,0,2,0,9,0,2,0,8,1,2,1,8,0,2,0,9,0,2,0,9,0,2,0,8,0,0,2,0,0,7,0,1,0,1,0,10,0,13,0,69,0,48,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,9,8,9,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,39,0,67,0,12,1,11,2,10,3,9,4,8,5,7,6,6,7,7,6,8,5,9,4,10,3,11,2,12,1,13,0,65,0,63,0,12,2,10,0,0,0,0,0,11,0,13,0,13,0,13,
0,13,0,13,0,13,0,13,0,13,0,13,0,11,0,0,0,0,0,10,2,12,0,54,0,62,0,1,0,10,0,1,0,10,0,1,0,10,0,1,0,10,0,1,0,10,0,1,0,10,0,1,0,10,0,1,0,10,0,1,0,10,0,1,0,40,0,1,0,10,0,1,0,10,0,1,0,67,0,62,4,8,0,1,0,0,0,7,0,2,0,0,0,7,0,2,0,0,0,7,0,2,0,0,0,8,0,1,0,0,0,9,2,0,0,11,0,0,0,11,0,0,0,11,0,0,0,11,0,0,0,11,0,0,0,11,0,0,0,11,0,0,0,11,0,0,0,66,0,48,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,9,8,128,0,170,0,128,0,164,8,9,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,39,0,48,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,9,4,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,39,0,63,0,12,2,10,0,0,0,0,0,11,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,69,0,48,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,4,9,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,13,0,39,0,128,0,140,0,14,0,7,7,12,0,12,0,128,0,142,0,128,0,137,0,12,0,12,7,7,0,14,0,128,0,145,0,128,1,88,0,128,1,88,0,128,1,88,0,128,1,88,0,128,0,137,0,25,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,15,1,3,1,25,0,28,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,98,0,47,1,1,1,4,1,1,1,4,1,0,2,3,1,1,1,1,21,
2,1,1,1,3,1,1,1,4,1,1,1,2,21,1,1,1,1,3,2,0,1,4,1,1,1,4,1,1,1,47,0,37,0,7,4,4,6,2,2,0,0,0,2,1,1,1,0,1,1,1,1,1,0,5,2,0,0,6,4,7,4,6,0,0,2,5,0,1,1,5,0,1,1,1,1,1,0,1,1,1,2,0,0,0,2,2,6,4,4,7,0,9,0,26,0,74,2,5,1,5,1,0,1,3,1,5,1,2,1,2,1,5,1,2,1,1,1,6,1,2,1,1,1,6,1,2,1,0,1,8,1,0,1,1,1,9,2,1,1,1,2,10,1,0,1,0,1,8,1,0,1,2,1,7,1,0,1,2,1,6,1,1,1,2,1,6,1,1,1,2,1,5,1,3,1,0,1,6,1,4,2,74,0,56,2,8,4,6,1,2,1,5,1,2,1,5,1,2,1,6,0,1,1,7,3,7,3,7,1,1,1,5,1,2,1,1,1,1,1,3,1,0,1,1,1,4,2,2,2,3,2,3,6,0,2,2,4,2,0,52,0,16,1,1,1,1,1,1,1,1,1,56,0,32,0,4,0,4,1,4,0,4,1,4,1,3,1,4,1,4,1,4,1,4,1,4,1,4,1,5,1,4,1,5,0,5,1,5,0,6,0,0,0,28,0,6,0,5,1,5,0,5,1,4,1,5,1,4,1,4,1,4,1,4,1,4,1,4,1,3,1,4,1,4,0,4,1,4,0,4,0,4,0,34,0,6,0,3,6,3,0,5,0,0,0,3,1,0,1,105,0,88,1,9,1,9,1,9,1,5,9,1,9,5,1,9,1,9,1,9,1,76,0,103,1,3,1,4,0,4,0,3,0,8,0,90,5,0,5,56,0,103,1,3,1,25,0,27,1,3,1,2,1,3,1,3,1,3,1,2,1,3,1,3,1,2,1,3,1,3,1,3,1,2,1,3,1,27,0,46,4,4,6,3,1,2,1,2,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,2,1,2,1,3,6,4,4,46,0,48,1,8,1,7,2,
5,4,5,1,0,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,47,0,46,4,4,6,3,1,3,1,1,1,4,1,8,1,8,1,8,0,8,1,7,1,7,1,7,1,7,1,7,1,7,8,1,8,44,0,46,3,5,5,3,2,1,2,2,1,3,1,8,1,7,2,6,1,8,3,8,2,8,1,8,1,1,1,4,1,1,2,2,2,2,6,4,4,46,0,50,0,8,1,7,2,7,2,6,3,5,1,0,1,4,1,1,1,4,1,1,1,3,1,2,1,2,1,3,1,2,9,0,9,6,1,8,1,8,1,46,0,45,6,3,6,3,1,8,1,7,1,8,1,0,3,3,7,2,1,3,2,8,1,8,1,8,1,1,1,4,1,1,2,2,1,3,6,4,3,47,0,47,3,5,5,3,1,2,2,2,1,3,1,1,1,8,1,0,3,3,7,2,2,2,2,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,2,1,2,1,3,6,5,3,46,0,44,8,1,8,8,0,8,1,7,1,8,1,7,1,8,1,7,1,8,1,8,1,7,1,8,1,8,1,8,1,49,0,46,4,4,6,2,2,2,2,1,1,4,1,1,1,4,1,1,2,2,2,2,6,3,6,2,2,2,2,1,1,4,1,1,1,4,1,1,1,4,1,1,2,2,2,2,6,4,4,46,0,46,3,5,6,3,1,2,1,2,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,2,2,2,2,7,3,3,0,1,8,1,1,1,4,1,1,2,2,1,3,6,4,3,47,0,49,1,3,1,45,1,3,1,25,0,49,1,3,1,45,1,3,1,4,0,4,0,3,0,8,0,93,0,7,3,5,3,4,3,6,1,10,3,10,3,9,3,10,0,84,0,108,9,1,9,25,9,1,9,96,0,84,0,10,3,9,3,10,3,10,1,6,3,4,3,5,3,7,0,93,0,46,4,4,6,2,2,2,2,1,1,4,1,8,1,7,1,7,2,6,2,6,2,7,1,8,1,30,1,8,1,48,0,86,6,10,10,7,3,4,3,
5,2,8,2,3,2,2,2,1,1,0,1,3,1,2,4,0,1,1,1,2,1,1,2,1,2,2,1,1,1,2,1,3,1,2,1,1,1,1,1,4,1,2,1,1,1,1,1,4,1,2,1,1,1,1,1,4,0,2,2,1,1,1,1,3,1,2,1,2,1,1,2,1,2,1,1,4,1,1,9,5,1,2,2,0,3,1,1,3,1,10,1,4,3,6,2,7,10,10,6,5,0,56,2,9,2,8,1,0,1,7,1,0,1,7,1,0,1,6,1,2,1,5,1,2,1,5,1,2,1,4,1,4,1,3,8,2,10,1,1,6,1,1,1,6,1,0,1,8,3,8,1,51,0,53,6,5,7,4,1,3,2,3,1,4,1,3,1,4,1,3,1,3,2,3,7,4,7,4,1,4,1,3,1,5,1,2,1,5,1,2,1,5,1,2,1,4,2,2,8,3,7,54,0,60,3,7,7,4,2,3,2,3,1,5,2,1,2,6,1,1,1,11,1,11,1,11,1,11,1,11,2,6,1,2,1,5,2,2,2,3,2,4,7,7,3,60,0,57,7,5,8,4,1,4,2,3,1,5,1,3,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,5,1,3,1,4,2,3,8,4,7,59,0,53,9,2,9,2,1,10,1,10,1,10,1,10,8,3,8,3,1,10,1,10,1,10,1,10,1,10,9,2,9,52,0,49,8,2,8,2,1,9,1,9,1,9,1,9,7,3,7,3,1,9,1,9,1,9,1,9,1,9,1,9,1,55,0,68,6,7,8,5,2,4,2,3,1,7,2,2,1,8,0,2,1,13,1,13,1,4,6,1,1,4,6,1,1,9,1,2,1,8,1,2,1,8,1,3,2,4,3,4,9,7,5,67,0,52,1,6,1,1,1,6,1,1,1,6,1,1,1,6,1,1,1,6,1,1,1,6,1,1,10,1,10,1,1,6,1,1,1,6,1,1,1,6,1,1,1,6,1,1,1,6,1,1,1,6,1,1,1,6,1,52,0,25,1,3,1,3,1,3,1,3,1,3,1,
3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,25,0,45,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,2,1,2,1,2,1,2,1,2,2,1,1,3,4,5,2,43,0,53,1,4,2,2,1,3,2,3,1,2,2,4,1,1,2,5,1,1,1,6,1,0,2,6,4,7,5,6,2,0,1,6,1,1,2,5,1,2,2,4,1,3,2,3,1,4,1,3,1,4,2,2,1,5,2,51,0,45,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,7,2,7,44,0,69,2,6,2,3,3,4,3,3,3,4,3,3,3,4,3,3,1,0,1,2,1,0,1,3,1,0,1,2,1,0,1,3,1,0,1,2,1,0,1,3,1,0,1,2,1,0,1,3,1,1,1,0,1,1,1,3,1,1,1,0,1,1,1,3,1,1,1,0,1,1,1,3,1,1,1,0,1,1,1,3,1,2,2,2,1,3,1,2,2,2,1,3,1,2,2,2,1,69,0,52,1,6,1,1,2,5,1,1,3,4,1,1,3,4,1,1,1,0,1,3,1,1,1,0,1,3,1,1,1,1,1,2,1,1,1,1,2,1,1,1,1,2,1,1,1,1,1,3,1,0,1,1,1,3,1,0,1,1,1,4,3,1,1,4,3,1,1,5,2,1,1,6,1,52,0,68,5,8,7,6,2,3,2,4,1,7,1,2,2,7,2,1,1,9,1,1,1,9,1,1,1,9,1,1,1,9,1,1,1,9,1,1,2,7,2,2,1,7,1,4,2,3,2,6,7,8,5,68,0,53,7,4,8,3,1,4,2,2,1,5,1,2,1,5,1,2,1,5,1,2,1,4,2,2,8,3,7,4,1,10,1,10,1,10,1,10,1,10,1,60,0,68,5,8,8,5,2,3,3,3,1,7,1,2,2,7,2,1,1,9,1,1,1,9,1,1,1,9,1,1,1,9,1,1,1,9,1,1,2,7,1,3,1,3,2,0,1,4,2,3,2,6,9,6,5,0,2,14,0,48,0,57,7,5,8,4,1,4,2,3,1,5,1,3,
1,5,1,3,1,4,2,3,8,4,7,5,1,2,1,6,1,3,1,5,1,3,2,4,1,4,1,4,1,4,2,3,1,5,1,3,1,5,2,56,0,55,5,5,7,3,2,3,2,2,1,5,1,2,1,10,2,10,4,9,4,10,2,11,1,1,1,6,1,1,1,6,1,2,2,3,2,2,8,5,4,55,0,47,23,4,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,52,0,52,1,6,1,1,1,6,1,1,1,6,1,1,1,6,1,1,1,6,1,1,1,6,1,1,1,6,1,1,1,6,1,1,1,6,1,1,1,6,1,1,1,6,1,1,1,6,1,2,1,4,1,3,8,5,4,55,0,51,1,8,3,8,4,6,2,0,1,6,1,1,1,6,1,2,1,4,1,3,1,4,1,3,1,4,1,4,1,2,1,5,1,2,1,6,1,0,1,7,1,0,1,7,1,0,1,8,2,9,2,56,0,75,1,5,2,5,3,5,2,5,3,4,1,0,1,4,1,0,1,3,1,0,1,3,1,1,1,3,1,0,1,3,1,1,1,3,0,2,0,3,1,1,1,2,1,2,1,2,1,1,1,2,1,2,1,2,1,2,1,1,1,2,1,1,1,3,1,0,1,4,1,0,1,3,1,0,1,4,1,0,1,3,1,0,1,4,1,0,1,3,1,0,1,4,1,0,1,4,2,6,2,5,2,6,2,78,0,52,2,4,2,2,2,3,1,4,1,2,1,5,2,0,2,6,1,0,1,8,2,9,2,9,2,8,1,0,1,7,1,0,1,6,1,1,2,4,2,2,2,3,1,4,1,2,1,5,2,0,2,6,2,51,0,55,2,7,2,0,1,7,1,2,1,5,1,3,2,3,2,4,2,1,2,6,1,1,1,8,3,9,3,10,1,11,1,11,1,11,1,11,1,11,1,11,1,61,0,48,9,1,9,8,1,8,1,9,1,8,1,8,1,8,2,8,1,8,1,8,1,9,1,8,1,8,10,0,10,48,0,24,3,1,3,1,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,
3,1,3,1,3,1,3,1,3,3,1,3,0,0,23,1,3,1,4,1,3,1,3,1,3,1,4,1,3,1,3,1,4,1,3,1,3,1,3,1,4,1,3,1,23,0,24,3,1,3,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,1,3,1,3,0,0,34,1,4,3,3,3,3,3,2,1,1,1,1,1,1,1,1,1,1,1,0,1,3,1,87,0,128,0,230,21,0,28,1,5,1,5,0,114,0,90,4,3,7,2,1,3,1,8,1,6,3,3,6,2,3,1,1,2,1,3,1,2,1,2,2,2,7,3,3,1,1,44,0,44,1,8,1,8,1,8,1,8,1,0,3,3,7,2,2,2,1,2,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,2,2,1,2,7,2,1,0,3,46,0,82,3,4,5,3,1,1,2,1,1,3,1,1,1,7,1,7,1,7,1,3,1,2,1,1,2,2,5,4,3,42,0,51,1,8,1,8,1,8,1,3,3,0,1,2,7,2,1,2,2,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,2,1,2,2,2,7,3,3,0,1,44,0,90,4,4,6,3,1,2,1,2,1,4,1,1,8,1,8,1,1,8,1,9,1,3,1,2,6,4,4,46,0,26,2,1,3,1,1,3,1,1,11,1,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,25,0,90,3,0,1,2,7,2,1,2,2,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,2,1,2,2,2,7,3,3,0,1,8,1,1,1,3,2,1,7,4,4,2,0,40,1,7,1,7,1,7,1,7,1,0,3,2,7,1,2,2,1,1,1,3,1,1,1,3,1,1,1,3,1,1,1,3,1,1,1,3,1,1,1,3,1,1,1,3,1,1,1,3,1,40,0,16,1,1,1,9,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,16,0,21,1,2,1,12,1,
2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,0,3,0,2,1,0,40,1,7,1,7,1,7,1,7,1,3,2,0,1,2,2,1,1,1,2,2,1,0,2,3,4,4,5,3,1,1,1,3,1,1,2,2,1,2,2,1,1,3,1,1,1,3,2,39,0,16,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,16,0,128,0,128,1,0,3,1,3,2,6,0,5,1,2,2,2,2,1,1,1,3,1,3,1,1,1,3,1,3,1,1,1,3,1,3,1,1,1,3,1,3,1,1,1,3,1,3,1,1,1,3,1,3,1,1,1,3,1,3,1,1,1,3,1,3,1,64,0,80,1,0,3,2,7,1,2,2,1,1,1,3,1,1,1,3,1,1,1,3,1,1,1,3,1,1,1,3,1,1,1,3,1,1,1,3,1,1,1,3,1,40,0,90,4,4,6,3,1,2,1,2,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,2,1,2,1,3,6,4,4,46,0,88,1,0,3,3,7,2,2,2,1,2,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,2,2,1,2,7,2,1,0,3,3,1,8,1,8,1,8,1,7,0,90,3,0,1,2,7,2,1,2,2,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,2,1,2,2,2,7,3,3,0,1,8,1,8,1,8,1,8,1,0,0,56,1,0,2,0,5,0,2,3,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,31,0,82,3,3,6,2,1,3,1,1,1,7,3,6,5,6,3,7,1,1,1,3,1,2,5,4,3,42,0,30,1,3,1,3,1,2,4,0,4,1,1,3,1,3,1,3,1,3,1,3,1,3,1,3,3,2,2,24,0,80,1,3,1,1,1,3,1,1,1,3,1,1,1,3,1,1,1,3,1,1,1,3,1,1,1,3,1,1,1,3,1,1,1,2,2,1,7,2,3,0,1,40,0,71,1,4,
3,4,1,0,1,2,1,1,1,2,1,1,1,2,1,2,1,0,1,3,1,0,1,3,1,0,1,4,2,5,2,6,0,39,0,119,1,4,0,4,3,3,2,3,3,3,2,3,1,0,1,2,0,0,0,2,1,1,1,1,1,0,1,1,1,2,1,0,1,0,1,0,1,3,1,0,1,0,1,0,1,3,1,0,0,2,0,0,1,4,2,2,2,5,2,2,2,5,2,2,2,62,0,71,1,4,1,0,1,2,1,2,1,0,1,3,1,0,1,4,2,5,2,5,2,4,1,0,1,3,1,0,1,2,1,2,1,0,1,4,1,35,0,79,1,5,3,5,1,0,1,3,1,1,1,3,1,1,2,2,1,2,1,1,1,3,1,1,1,4,1,0,1,4,3,6,2,6,2,6,1,6,2,4,3,5,2,5,0,72,7,0,7,5,2,4,2,4,2,4,2,4,2,4,2,4,2,5,17,35,0,30,2,2,3,2,1,4,1,4,1,4,1,4,1,3,2,2,2,3,2,4,1,5,1,4,1,4,1,4,1,4,1,4,1,4,3,3,2,0,0,25,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,1,0,28,2,3,3,4,1,4,1,4,1,4,1,4,1,4,2,4,2,3,2,2,2,3,1,4,1,4,1,4,1,4,1,4,1,2,3,2,2,2,0,121,2,7,5,2,0,1,0,2,5,7,2,109,0,74,4,9,0,2,0,9,0,2,0,9,0,2,0,9,0,2,0,9,0,2,0,9,0,2,0,9,0,2,0,9,0,2,0,9,0,2,0,9,0,2,0,9,0,2,0,9,4,84,0,48,3,4,6,3,1,3,0,2,1,8,1,7,1,7,8,2,1,7,8,2,1,9,1,8,1,8,2,3,0,3,6,5,3,45,0,22,0,68,1,1,1,2,0,2,0,1,0,5,0,50,2,6,3,6,1,7,1,6,5,4,5,6,1,8,1,7,2,7,1,8,1,8,1,8,1,8,1,7,1,8,1,8,1,6,3,5,3,6,0,119,1,0,1,1,1,0,
1,2,0,1,0,2,0,1,0,1,0,1,0,8,0,128,1,85,1,4,1,4,1,3,1,4,1,4,1,81,0,48,1,8,1,8,1,8,1,4,9,0,9,4,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,14,0,48,1,8,1,8,1,8,1,4,9,0,9,4,1,8,1,8,1,8,1,8,1,8,1,4,9,0,9,4,1,8,1,8,1,8,1,14,0,30,1,3,3,1,1,1,1,111,0,84,3,3,1,9,1,1,1,1,1,10,1,1,1,1,1,10,1,1,1,1,1,10,1,1,1,0,1,11,1,1,1,0,1,12,3,0,1,18,1,18,1,0,3,2,3,5,1,0,1,1,1,0,1,1,1,4,1,0,1,1,1,0,1,1,1,3,1,1,1,1,1,0,1,1,1,3,1,1,1,1,1,0,1,1,1,3,1,1,1,1,1,0,1,1,1,2,1,3,3,2,3,84,0,3,1,1,1,7,3,9,1,21,5,5,7,3,2,3,2,2,1,5,1,2,1,10,2,10,4,9,4,10,2,11,1,1,1,6,1,1,1,6,1,2,2,3,2,2,8,5,4,55,0,66,1,3,1,3,1,4,1,3,1,5,1,4,1,5,1,5,1,35,0,83,4,1,7,3,6,0,7,2,2,3,3,8,1,5,2,7,1,7,1,7,1,7,1,7,1,7,6,2,1,7,6,2,1,7,1,7,1,7,1,7,1,7,1,8,1,5,2,8,2,3,3,9,6,0,7,4,4,1,7,80,0,22,0,2,1,1,1,6,3,8,1,17,9,1,9,8,1,8,1,9,1,8,1,8,1,8,2,8,1,8,1,8,1,9,1,8,1,8,10,0,10,48,0,22,0,22,0,17,0,1,0,2,0,2,1,1,1,56,0,16,1,1,1,2,0,2,0,1,0,57,0,29,0,1,0,1,0,1,0,2,0,1,0,2,1,0,1,1,1,0,1,98,0,28,1,0,1,1,1,0,1,2,0,1,0,2,0,1,0,1,0,1,0,99,0,64,2,2,4,1,4,1,4,2,2,64,0,128,0,
142,21,87,0,128,1,3,39,128,0,159,0,28,2,0,10,0,2,112,0,81,6,0,1,2,1,7,0,3,1,2,1,7,0,3,1,2,1,7,0,3,0,0,0,0,0,0,0,7,0,3,0,0,0,0,0,0,0,7,0,3,0,0,0,0,0,0,0,7,0,3,0,1,0,1,0,7,0,3,0,1,0,1,0,128,0,222,0,41,1,1,1,4,3,6,1,16,3,3,6,2,1,3,1,1,1,7,3,6,5,6,3,7,1,1,1,3,1,2,5,4,3,42,0,63,1,5,1,5,1,4,1,5,1,3,1,4,1,3,1,3,1,38,0,128,0,154,3,3,3,5,5,1,6,3,1,2,3,3,1,2,1,4,1,5,1,1,1,4,9,1,1,4,9,1,1,4,1,9,1,4,1,10,1,2,3,3,2,2,5,1,6,4,3,3,4,78,0,22,0,37,1,1,1,3,3,5,1,12,7,0,7,5,2,4,2,4,2,4,2,4,2,4,2,4,2,5,17,35,0,16,1,1,1,6,1,1,1,15,2,7,1,0,1,7,1,1,1,5,1,2,2,3,2,3,2,1,2,5,1,1,1,7,3,8,3,9,1,10,1,10,1,10,1,10,1,10,1,10,1,56,0,128,0,137,0,49,1,3,1,15,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,1,0,50,0,9,0,9,0,9,0,6,2,5,6,3,1,1,2,2,1,2,0,0,1,1,1,1,0,5,1,1,0,5,1,1,0,5,1,0,0,2,1,2,2,1,2,2,6,5,3,5,0,9,0,9,0,9,0,6,0,47,3,5,5,3,2,1,2,2,1,3,1,2,1,8,1,8,1,6,7,2,7,5,1,8,1,7,1,7,4,4,9,0,0,4,2,45,0,88,0,0,3,0,0,2,7,3,1,1,1,3,1,3,1,2,1,3,1,3,1,1,1,3,7,2,0,0,3,0,0,78,0,43,1,7,0,0,1,5,1,0,1,5,1,1,1,3,1,3,1,1,1,4,1,1,1,5,3,2,21,4,1,8,1,
3,21,4,1,8,1,47,0,25,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,21,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,1,0,46,3,5,6,3,1,2,1,3,1,9,1,7,3,5,1,1,2,3,1,2,2,2,1,3,2,1,2,3,1,2,2,2,1,4,1,0,1,6,2,8,1,9,1,2,1,3,1,2,2,2,1,3,5,5,3,3,0,28,1,1,1,0,1,1,1,118,0,64,4,7,1,4,1,4,0,8,0,2,0,2,4,2,0,1,0,1,0,4,0,1,0,0,0,1,0,9,1,1,0,9,1,1,0,9,1,1,0,9,1,1,0,5,0,2,0,0,0,1,0,3,0,2,0,1,0,2,3,3,0,2,0,8,0,4,1,4,1,7,4,64,0,28,4,0,1,2,1,4,1,0,7,2,3,1,2,0,5,83,0,102,1,1,1,3,1,1,1,3,1,1,1,4,1,1,1,3,1,1,1,5,1,1,1,4,1,1,1,5,1,1,1,5,1,1,1,55,0,108,9,1,9,9,1,9,1,9,1,9,1,96,0,90,5,0,5,56,0,64,4,7,1,4,1,4,0,8,0,2,0,1,4,3,0,1,0,1,0,3,0,2,0,0,0,2,0,3,0,3,1,2,0,3,0,3,1,2,4,4,1,2,0,1,0,5,1,2,0,2,0,4,0,0,0,1,0,3,0,2,0,1,0,1,0,4,0,1,0,2,0,8,0,4,1,4,1,7,4,64,0,23,23,128,0,227,0,33,2,3,0,2,0,2,0,2,0,2,0,2,0,3,2,114,0,81,1,8,1,8,1,8,1,4,9,0,9,4,1,8,1,8,1,8,1,4,9,0,9,43,0,28,3,1,1,1,1,4,1,3,1,3,1,3,1,3,5,84,0,28,3,1,1,1,1,4,1,2,1,6,1,0,1,1,1,1,3,85,0,30,1,3,1,4,0,115,0,88,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,2,2,2,1,8,1,1,0,2,0,1,1,1,8,
1,8,1,8,1,7,0,45,8,0,15,1,1,0,5,1,1,0,5,1,1,0,5,1,1,1,4,1,1,2,3,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,11,0,78,1,4,1,72,0,128,0,135,0,5,1,5,1,1,3,1,0,30,1,3,2,2,3,2,0,0,1,4,1,4,1,4,1,85,0,29,2,2,0,2,0,0,1,2,3,2,3,2,1,0,1,1,0,2,2,85,0,99,1,1,1,5,1,1,1,5,1,1,1,4,1,1,1,5,1,1,1,3,1,1,1,4,1,1,1,3,1,1,1,3,1,1,1,58,0,71,1,6,1,4,2,5,1,4,3,4,1,5,0,0,1,3,1,8,1,3,1,8,1,2,1,9,1,1,1,14,1,13,1,4,1,6,1,4,2,5,1,4,0,0,1,5,1,3,1,0,1,4,1,4,5,2,1,8,1,2,1,9,1,68,0,70,1,7,1,3,2,6,1,3,3,5,1,4,0,0,1,5,1,6,1,4,1,7,1,3,1,8,1,2,2,13,1,13,1,2,3,6,1,2,0,2,1,5,1,6,1,4,1,6,1,4,1,6,1,4,1,6,0,6,1,5,5,67,0,68,3,7,1,1,1,1,1,5,1,6,1,5,1,4,1,6,1,7,1,3,1,4,1,1,1,2,1,6,3,3,1,13,1,13,1,4,1,7,1,3,2,6,1,3,3,5,1,3,1,0,1,4,1,4,5,3,1,7,1,3,1,8,1,68,0,101,1,9,1,33,1,9,1,8,2,7,2,7,2,8,1,8,1,9,1,3,1,3,2,1,2,4,5,6,3,3,0,4,1,11,1,11,0,22,2,9,2,8,1,0,1,7,1,0,1,7,1,0,1,6,1,2,1,5,1,2,1,5,1,2,1,4,1,4,1,3,8,2,10,1,1,6,1,1,1,6,1,0,1,8,3,8,1,51,0,5,1,9,1,10,0,24,2,9,2,8,1,0,1,7,1,0,1,7,1,0,1,6,1,2,1,5,1,2,1,
5,1,2,1,4,1,4,1,3,8,2,10,1,1,6,1,1,1,6,1,0,1,8,3,8,1,51,0,5,1,9,3,7,1,1,1,20,2,9,2,8,1,0,1,7,1,0,1,7,1,0,1,6,1,2,1,5,1,2,1,5,1,2,1,4,1,4,1,3,8,2,10,1,1,6,1,1,1,6,1,0,1,8,3,8,1,51,0,3,2,0,1,5,6,5,1,0,2,21,2,9,2,8,1,0,1,7,1,0,1,7,1,0,1,6,1,2,1,5,1,2,1,5,1,2,1,4,1,4,1,3,8,2,10,1,1,6,1,1,1,6,1,0,1,8,3,8,1,51,0,16,1,1,1,6,1,1,1,20,2,9,2,8,1,0,1,7,1,0,1,7,1,0,1,6,1,2,1,5,1,2,1,5,1,2,1,4,1,4,1,3,8,2,10,1,1,6,1,1,1,6,1,0,1,8,3,8,1,51,0,4,2,8,0,2,0,7,0,2,0,7,0,2,0,8,2,9,2,8,1,0,1,7,1,0,1,7,1,0,1,6,1,2,1,5,1,2,1,5,1,2,1,4,1,4,1,3,8,2,10,1,1,6,1,1,1,6,1,0,1,8,3,8,1,51,0,86,11,6,12,6,1,1,1,12,1,2,1,12,1,2,1,11,1,3,1,11,1,3,7,4,1,4,7,4,1,4,1,9,9,9,9,8,1,6,1,8,1,6,1,7,1,7,8,0,1,7,8,80,0,60,3,7,7,4,2,3,2,3,1,5,2,1,2,6,1,1,1,11,1,11,1,11,1,11,1,11,2,6,1,2,1,5,2,2,2,3,2,4,7,7,3,10,0,12,1,12,1,8,3,5,0,4,1,11,1,11,0,19,9,2,9,2,1,10,1,10,1,10,1,10,8,3,8,3,1,10,1,10,1,10,1,10,1,10,9,2,9,52,0,6,1,9,1,10,0,20,9,2,9,2,1,10,1,10,1,10,1,10,8,3,8,3,1,10,1,10,1,10,1,10,1,10,9,2,9,52,0,5,1,9,3,7,1,1,1,17,9,2,9,2,1,10,1,10,1,
10,1,10,8,3,8,3,1,10,1,10,1,10,1,10,1,10,9,2,9,52,0,16,1,1,1,6,1,1,1,17,9,2,9,2,1,10,1,10,1,10,1,10,8,3,8,3,1,10,1,10,1,10,1,10,1,10,9,2,9,52,0,0,1,4,1,4,0,9,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,25,0,2,1,2,1,3,0,10,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,25,0,1,1,2,3,0,1,1,1,7,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,25,0,5,1,1,3,1,1,7,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,25,0,57,7,5,8,4,1,4,2,3,1,5,1,3,1,6,1,2,1,6,1,0,6,3,1,0,6,3,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,5,1,3,1,4,2,3,8,4,7,59,0,3,2,0,1,6,6,6,1,0,2,19,1,6,1,2,2,5,1,2,3,4,1,2,3,4,1,2,1,0,1,3,1,2,1,0,1,3,1,2,1,1,1,2,1,2,1,1,2,1,1,2,1,2,1,1,1,2,1,3,1,0,1,2,1,3,1,0,1,2,1,4,3,2,1,4,3,2,1,5,2,2,1,6,1,57,0,5,1,14,1,14,0,27,5,8,7,6,2,3,2,4,1,7,1,2,2,7,2,1,1,9,1,1,1,9,1,1,1,9,1,1,1,9,1,1,1,9,1,1,2,7,2,2,1,7,1,4,2,3,2,6,7,8,5,68,0,7,1,12,1,13,0,28,5,8,7,6,2,3,2,4,1,7,1,2,2,7,2,1,1,9,1,1,1,9,1,1,1,9,1,1,1,9,1,1,1,9,1,1,2,7,2,2,1,7,1,4,2,3,2,6,7,8,5,68,0,6,1,12,3,10,1,1,1,25,
5,8,7,6,2,3,2,4,1,7,1,2,2,7,2,1,1,9,1,1,1,9,1,1,1,9,1,1,1,9,1,1,1,9,1,1,2,7,2,2,1,7,1,4,2,3,2,6,7,8,5,68,0,5,2,0,1,8,6,8,1,0,2,25,5,8,7,6,2,3,2,4,1,7,1,2,2,7,2,1,1,9,1,1,1,9,1,1,1,9,1,1,1,9,1,1,1,9,1,1,2,7,2,2,1,7,1,4,2,3,2,6,7,8,5,68,0,20,1,1,1,9,1,1,1,25,5,8,7,6,2,3,2,4,1,7,1,2,2,7,2,1,1,9,1,1,1,9,1,1,1,9,1,1,1,9,1,1,1,9,1,1,2,7,2,2,1,7,1,4,2,3,2,6,7,8,5,68,0,84,1,4,1,2,2,2,2,3,2,0,2,5,4,7,2,7,4,5,2,0,2,3,2,2,2,2,1,4,1,85,0,68,5,8,7,0,1,3,2,3,3,3,1,6,2,3,1,5,3,2,1,5,1,1,1,1,1,4,1,2,1,1,1,3,1,3,1,1,1,3,1,3,1,1,1,2,1,4,1,1,2,0,1,4,2,2,3,5,1,3,3,3,3,3,10,3,1,1,5,68,0,3,1,12,1,12,0,21,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,3,1,4,1,4,8,6,4,60,0,5,1,10,1,11,0,22,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,3,1,4,1,4,8,6,4,60,0,5,1,10,3,8,1,1,1,18,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,3,1,4,1,4,8,6,4,60,0,17,1,1,1,7,1,1,1,18,1,6,1,2,1,6,1,2,1,
6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,2,1,6,1,3,1,4,1,4,8,6,4,60,0,6,1,9,1,10,0,18,2,7,1,0,1,7,1,1,1,5,1,2,2,3,2,3,2,1,2,5,1,1,1,7,3,8,3,9,1,10,1,10,1,10,1,10,1,10,1,10,1,56,0,53,1,10,1,10,1,10,7,4,8,3,1,4,2,2,1,5,1,2,1,5,1,2,1,5,1,2,1,4,2,2,8,3,7,4,1,10,1,10,1,60,0,51,3,6,5,4,2,2,1,3,1,3,1,3,1,3,1,3,1,2,1,4,1,1,1,5,1,1,1,5,1,2,2,3,1,3,2,2,1,5,1,1,1,5,1,1,1,0,1,2,1,1,1,1,4,2,1,2,2,49,0,46,1,9,1,9,0,18,4,3,7,2,1,3,1,8,1,6,3,3,6,2,3,1,1,2,1,3,1,2,1,2,2,2,7,3,3,1,1,44,0,48,1,7,1,8,0,19,4,3,7,2,1,3,1,8,1,6,3,3,6,2,3,1,1,2,1,3,1,2,1,2,2,2,7,3,3,1,1,44,0,47,1,7,3,5,1,1,1,16,4,3,7,2,1,3,1,8,1,6,3,3,6,2,3,1,1,2,1,3,1,2,1,2,2,2,7,3,3,1,1,44,0,46,2,0,1,3,6,3,1,0,2,16,4,3,7,2,1,3,1,8,1,6,3,3,6,2,3,1,1,2,1,3,1,2,1,2,2,2,7,3,3,1,1,44,0,56,1,1,1,4,1,1,1,16,4,3,7,2,1,3,1,8,1,6,3,3,6,2,3,1,1,2,1,3,1,2,1,2,2,2,7,3,3,1,1,44,0,25,2,6,0,2,0,5,0,2,0,5,0,2,0,6,2,17,4,3,7,2,1,3,1,8,1,6,3,3,6,2,3,1,1,2,1,3,1,2,1,2,2,2,7,3,3,1,1,44,0,128,0,146,4,1,4,4,13,2,1,3,2,3,1,6,3,5,1,2,14,1,4,0,9,1,1,
3,1,9,1,3,1,9,1,2,3,3,2,2,5,0,6,4,3,2,4,74,0,82,3,4,5,3,1,1,2,1,1,3,1,1,1,7,1,7,1,7,1,3,1,2,1,1,2,2,5,4,3,6,0,8,1,8,1,4,3,3,0,47,1,9,1,9,0,17,4,4,6,3,1,2,1,2,1,4,1,1,8,1,8,1,1,8,1,9,1,3,1,2,6,4,4,46,0,49,1,7,1,8,0,18,4,4,6,3,1,2,1,2,1,4,1,1,8,1,8,1,1,8,1,9,1,3,1,2,6,4,4,46,0,48,1,7,3,5,1,1,1,15,4,4,6,3,1,2,1,2,1,4,1,1,8,1,8,1,1,8,1,9,1,3,1,2,6,4,4,46,0,57,1,1,1,4,1,1,1,15,4,4,6,3,1,2,1,2,1,4,1,1,8,1,8,1,1,8,1,9,1,3,1,2,6,4,4,46,0,24,1,4,1,4,0,9,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,25,0,26,1,2,1,3,0,10,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,25,0,25,1,2,3,0,1,1,1,7,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,25,0,29,1,1,3,1,1,7,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,25,0,47,1,0,0,7,2,6,2,6,0,1,1,5,2,0,1,3,6,3,1,2,2,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,2,1,2,1,3,6,4,4,46,0,46,2,0,1,3,6,3,1,0,2,14,1,0,3,3,7,2,2,2,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,45,0,47,1,9,1,9,0,17,4,4,6,3,1,2,1,2,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,2,1,2,1,3,6,4,4,46,0,49,1,7,1,8,0,18,
4,4,6,3,1,2,1,2,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,2,1,2,1,3,6,4,4,46,0,48,1,7,3,5,1,1,1,15,4,4,6,3,1,2,1,2,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,2,1,2,1,3,6,4,4,46,0,46,2,0,1,3,6,3,1,0,2,16,4,4,6,3,1,2,1,2,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,2,1,2,1,3,6,4,4,46,0,57,1,1,1,4,1,1,1,15,4,4,6,3,1,2,1,2,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,2,1,2,1,3,6,4,4,46,0,92,1,8,1,15,9,0,9,15,1,8,1,80,0,83,1,4,5,3,5,3,2,0,2,3,1,1,3,2,1,0,1,0,1,2,1,0,1,0,1,2,3,1,1,2,3,1,1,3,1,1,2,3,5,3,1,0,2,4,0,41,0,46,1,9,1,9,0,16,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,2,2,2,7,3,3,0,1,45,0,48,1,7,1,8,0,17,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,2,2,2,7,3,3,0,1,45,0,47,1,7,3,5,1,1,1,14,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,2,2,2,7,3,3,0,1,45,0,56,1,1,1,4,1,1,1,14,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,2,2,2,7,3,3,0,1,45,0,44,1,6,1,7,0,14,1,5,3,5,1,0,1,3,1,1,1,3,1,1,2,2,1,2,1,1,1,3,1,1,1,4,1,0,1,4,3,6,2,6,2,6,1,6,2,4,
3,5,2,5,0,44,1,8,1,8,1,8,1,8,1,0,3,3,7,2,2,2,1,2,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,4,1,1,2,2,1,2,7,2,1,0,3,3,1,8,1,8,1,8,1,7,0,51,1,1,1,3,1,1,1,11,1,5,3,5,1,0,1,3,1,1,1,3,1,1,2,2,1,2,1,1,1,3,1,1,1,4,1,0,1,4,3,6,2,6,2,6,1,6,2,4,3,5,2,5,0,0,0);

sysfont__courier_new_10:array[0..9055] of byte=(
71,70,35,51,20,0,15,0,10,0,8,6,0,0,10,0,12,6,0,0,10,0,16,6,0,0,10,0,34,6,0,0,10,0,54,6,0,0,10,0,74,6,0,0,10,0,108,6,0,0,10,0,112,6,0,0,10,0,128,6,0,0,10,0,176,6,0,0,10,0,180,6,0,0,10,0,184,6,0,0,10,0,224,6,0,0,10,0,10,7,0,0,10,0,14,7,0,0,10,0,62,7,0,0,10,0,112,7,0,0,10,0,146,7,0,0,10,0,174,7,0,0,10,0,212,7,0,0,10,0,2,8,0,0,10,0,60,8,0,0,10,0,80,8,0,0,10,0,98,8,0,0,10,0,132,8,0,0,10,0,166,8,0,0,10,0,200,8,0,0,10,0,212,8,0,0,10,0,224,8,0,0,10,0,228,8,0,0,10,0,232,8,0,0,10,0,236,8,0,0,10,0,240,8,0,0,10,0,244,8,0,0,10,0,8,9,0,0,10,0,30,9,0,0,10,0,76,9,0,0,10,0,108,9,0,0,10,0,140,9,0,0,10,0,170,9,0,0,10,0,182,9,0,0,10,0,210,9,0,0,10,0,238,9,0,0,10,0,4,10,0,0,10,0,24,10,0,0,10,0,36,10,0,0,10,0,40,10,0,0,10,0,48,10,0,0,10,0,76,10,0,0,10,0,118,10,0,0,10,0,144,10,0,0,10,0,174,10,0,0,10,0,202,10,0,0,10,0,238,10,0,0,10,0,8,11,0,0,10,0,44,11,0,0,10,0,70,11,0,0,10,0,110,11,0,0,10,0,146,11,0,0,10,0,156,11,0,0,10,0,170,11,0,0,10,0,190,11,0,0,10,0,196,11,0,0,10,0,216,11,0,0,10,0,240,11,0,0,10,0,36,12,0,0,10,0,72,
12,0,0,10,0,108,12,0,0,10,0,138,12,0,0,10,0,176,12,0,0,10,0,212,12,0,0,10,0,242,12,0,0,10,0,20,13,0,0,10,0,60,13,0,0,10,0,82,13,0,0,10,0,112,13,0,0,10,0,152,13,0,0,10,0,180,13,0,0,10,0,238,13,0,0,10,0,36,14,0,0,10,0,74,14,0,0,10,0,104,14,0,0,10,0,152,14,0,0,10,0,190,14,0,0,10,0,224,14,0,0,10,0,2,15,0,0,10,0,42,15,0,0,10,0,80,15,0,0,10,0,144,15,0,0,10,0,182,15,0,0,10,0,214,15,0,0,10,0,248,15,0,0,10,0,20,16,0,0,10,0,48,16,0,0,10,0,76,16,0,0,10,0,94,16,0,0,10,0,99,16,0,0,10,0,109,16,0,0,10,0,137,16,0,0,10,0,177,16,0,0,10,0,201,16,0,0,10,0,241,16,0,0,10,0,9,17,0,0,10,0,33,17,0,0,10,0,73,17,0,0,10,0,113,17,0,0,10,0,135,17,0,0,10,0,163,17,0,0,10,0,201,17,0,0,10,0,225,17,0,0,10,0,19,18,0,0,10,0,53,18,0,0,10,0,83,18,0,0,10,0,123,18,0,0,10,0,163,18,0,0,10,0,185,18,0,0,10,0,209,18,0,0,10,0,233,18,0,0,10,0,11,19,0,0,10,0,41,19,0,0,10,0,91,19,0,0,10,0,121,19,0,0,10,0,159,19,0,0,10,0,181,19,0,0,10,0,209,19,0,0,10,0,237,19,0,0,10,0,9,20,0,0,10,0,21,20,0,0,10,0,71,20,0,0,1,0,101,20,0,0,10,0,103,20,0,0,10,0,117,
20,0,0,10,0,143,20,0,0,10,0,163,20,0,0,10,0,179,20,0,0,10,0,203,20,0,0,10,0,227,20,0,0,10,0,241,20,0,0,10,0,29,21,0,0,10,0,73,21,0,0,10,0,91,21,0,0,1,0,139,21,0,0,10,0,141,21,0,0,1,0,185,21,0,0,1,0,187,21,0,0,10,0,189,21,0,0,10,0,201,21,0,0,10,0,213,21,0,0,10,0,231,21,0,0,10,0,249,21,0,0,10,0,3,22,0,0,10,0,7,22,0,0,7,0,11,22,0,0,10,0,21,22,0,0,10,0,51,22,0,0,10,0,85,22,0,0,10,0,103,22,0,0,1,0,141,22,0,0,10,0,143,22,0,0,10,0,175,22,0,0,10,0,211,22,0,0,10,0,215,22,0,0,10,0,235,22,0,0,10,0,5,23,0,0,10,0,31,23,0,0,10,0,61,23,0,0,10,0,93,23,0,0,10,0,115,23,0,0,10,0,153,23,0,0,10,0,161,23,0,0,10,0,207,23,0,0,10,0,221,23,0,0,10,0,251,23,0,0,10,0,7,24,0,0,10,0,11,24,0,0,10,0,59,24,0,0,10,0,65,24,0,0,10,0,83,24,0,0,10,0,105,24,0,0,10,0,121,24,0,0,10,0,139,24,0,0,10,0,149,24,0,0,10,0,189,24,0,0,10,0,245,24,0,0,10,0,251,24,0,0,10,0,7,25,0,0,10,0,21,25,0,0,10,0,39,25,0,0,10,0,69,25,0,0,10,0,107,25,0,0,10,0,145,25,0,0,10,0,185,25,0,0,10,0,209,25,0,0,10,0,251,25,0,0,10,0,37,26,0,0,10,0,83,26,0,0,10,0,127,26,0,
0,10,0,167,26,0,0,10,0,215,26,0,0,10,0,9,27,0,0,10,0,47,27,0,0,10,0,89,27,0,0,10,0,131,27,0,0,10,0,177,27,0,0,10,0,217,27,0,0,10,0,245,27,0,0,10,0,17,28,0,0,10,0,49,28,0,0,10,0,75,28,0,0,10,0,113,28,0,0,10,0,175,28,0,0,10,0,219,28,0,0,10,0,7,29,0,0,10,0,55,29,0,0,10,0,101,29,0,0,10,0,143,29,0,0,10,0,165,29,0,0,10,0,219,29,0,0,10,0,9,30,0,0,10,0,55,30,0,0,10,0,105,30,0,0,10,0,149,30,0,0,10,0,187,30,0,0,10,0,217,30,0,0,10,0,9,31,0,0,10,0,43,31,0,0,10,0,77,31,0,0,10,0,115,31,0,0,10,0,151,31,0,0,10,0,183,31,0,0,10,0,223,31,0,0,10,0,255,31,0,0,10,0,31,32,0,0,10,0,61,32,0,0,10,0,91,32,0,0,10,0,125,32,0,0,10,0,153,32,0,0,10,0,177,32,0,0,10,0,201,32,0,0,10,0,229,32,0,0,10,0,251,32,0,0,10,0,35,33,0,0,10,0,77,33,0,0,10,0,113,33,0,0,10,0,149,33,0,0,10,0,189,33,0,0,10,0,227,33,0,0,10,0,5,34,0,0,10,0,13,34,0,0,10,0,55,34,0,0,10,0,95,34,0,0,10,0,135,34,0,0,10,0,179,34,0,0,10,0,217,34,0,0,10,0,5,35,0,0,10,0,51,35,0,0,0,128,0,199,0,128,0,199,0,99,4,8,0,8,0,8,0,8,0,8,0,8,0,8,0,24,0,23,0,8,0,8,0,8,0,8,0,8,0,8,0,8,
0,8,3,91,0,23,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,4,4,94,0,23,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,24,0,99,7,91,0,62,1,6,3,4,5,3,5,3,5,4,3,6,1,74,0,19,7,1,7,1,7,1,7,1,2,1,2,1,1,3,1,1,0,5,0,1,0,5,0,1,0,5,0,1,1,3,1,1,2,1,2,1,7,1,7,1,7,1,7,1,7,21,0,128,0,199,0,128,0,199,0,42,4,6,0,0,0,6,0,0,0,5,0,1,0,5,0,1,0,4,0,8,0,7,2,5,0,2,0,4,0,2,0,4,0,2,0,5,2,44,0,40,7,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,7,50,0,128,0,199,0,35,1,4,2,0,0,4,0,2,0,4,0,1,1,4,2,0,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,1,1,4,0,0,2,3,1,0,1,3,2,6,1,46,0,33,0,8,0,5,0,0,2,0,0,3,0,2,0,4,0,2,0,4,0,2,0,3,1,2,1,3,0,2,0,4,0,2,0,4,0,2,0,3,0,0,2,0,0,5,0,8,0,44,0,23,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,4,7,5,0,8,0,8,0,8,0,8,0,8,0,8,0,24,0,46,0,7,1,6,2,5,3,4,4,3,5,2,6,3,5,4,4,5,3,6,2,7,1,8,0,31,0,33,0,7,2,5,0,0,0,0,0,6,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,6,0,0,0,0,0,5,2,7,0,34,0,41,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,1,0,25,0,1,0,5,0,1,0,33,0,42,4,3,0,1,0,0,0,2,0,2,0,0,0,2,0,2,0,0,0,
2,0,2,0,0,0,3,0,1,0,0,0,4,2,0,0,6,0,0,0,6,0,0,0,6,0,0,0,6,0,0,0,6,0,0,0,41,0,23,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,4,7,91,0,99,7,5,0,8,0,8,0,8,0,8,0,8,0,8,0,24,0,23,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,4,4,8,0,8,0,8,0,8,0,8,0,8,0,8,0,24,0,33,0,7,2,5,0,0,0,0,0,6,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,34,0,23,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,3,5,0,8,0,8,0,8,0,8,0,8,0,8,0,24,0,84,0,9,0,3,6,7,0,7,0,73,0,82,0,7,0,7,6,3,0,9,0,75,0,128,0,199,0,128,0,199,0,128,0,199,0,128,0,199,0,128,0,199,0,44,0,8,0,8,0,8,0,8,0,8,0,8,0,27,2,6,2,52,0,42,1,0,1,4,1,0,1,4,0,1,0,5,0,1,0,5,0,1,0,112,0,43,0,1,0,5,0,1,0,4,0,1,0,5,0,1,0,3,7,3,0,1,0,5,0,1,0,3,7,3,0,1,0,5,0,1,0,4,0,1,0,5,0,1,0,43,0,44,0,6,4,3,0,3,0,3,0,8,0,9,3,9,0,8,0,3,0,3,0,3,4,7,0,8,0,8,0,33,0,42,1,6,0,1,0,5,0,1,0,6,1,10,1,5,1,5,1,10,1,6,0,1,0,5,0,1,0,6,1,52,0,63,2,5,0,8,0,9,0,7,1,6,0,1,0,0,0,3,0,2,0,4,0,2,0,5,2,0,1,50,0,43,2,6,2,7,0,8,0,8,0,113,0,46,0,7,0,8,0,8,0,7,0,8,0,8,0,8,0,8,0,9,0,8,0,8,0,9,0,31,0,41,0,9,0,8,0,8,0,9,0,8,0,8,0,8,0,8,0,7,0,8,0,8,0,7,0,36,0,44,0,8,0,
5,6,5,0,7,0,0,0,6,0,0,0,5,0,2,0,91,0,54,0,8,0,8,0,8,0,4,8,4,0,8,0,8,0,8,0,63,0,123,1,7,0,7,1,7,0,8,0,35,0,100,6,91,0,128,0,133,2,6,2,52,0,36,0,8,0,7,0,8,0,7,0,8,0,7,0,8,0,7,0,8,0,7,0,8,0,7,0,47,0,42,3,4,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,4,3,52,0,43,1,5,1,0,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,5,6,50,0,41,4,3,0,4,0,2,0,4,0,8,0,7,0,7,0,7,0,7,0,7,0,7,0,4,0,2,6,51,0,42,3,3,1,3,0,8,0,8,0,7,0,6,1,9,0,9,0,8,0,2,0,4,0,3,4,52,0,45,1,6,0,0,0,5,0,1,0,5,0,1,0,4,0,2,0,4,0,2,0,3,0,3,0,3,6,7,0,8,0,6,3,50,0,41,4,4,0,8,0,8,0,8,4,9,0,8,0,8,0,8,0,2,0,4,0,3,4,52,0,44,3,4,0,7,0,7,0,8,0,0,3,3,1,3,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,3,4,51,0,41,5,3,0,3,0,8,0,7,0,8,0,8,0,8,0,7,0,8,0,8,0,8,0,53,0,42,3,4,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,4,3,4,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,4,3,52,0,42,3,4,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,2,1,4,2,0,0,8,0,7,0,7,0,5,2,54,0,73,1,7,1,47,1,7,1,53,0,73,1,7,1,37,1,7,0,7,1,7,0,45,0,67,0,6,1,6,0,6,1,5,1,9,1,9,0,9,1,9,0,50,0,80,7,21,7,80,0,60,0,9,1,9,0,9,1,9,1,5,1,6,0,6,
1,6,0,57,0,52,3,4,0,3,0,3,0,3,0,8,0,7,0,7,0,8,0,17,1,7,1,53,0,33,3,4,0,3,0,2,0,4,0,2,0,4,0,2,0,2,2,2,0,1,0,1,0,2,0,1,0,1,0,2,0,1,0,1,0,2,0,2,2,2,0,8,0,9,0,2,0,5,2,42,0,50,4,7,1,6,0,1,0,5,0,1,0,5,0,1,0,4,0,3,0,3,5,3,0,3,0,2,0,5,0,0,2,3,2,49,0,50,5,4,0,3,0,3,0,3,0,3,0,3,0,3,4,4,0,3,0,3,0,4,0,2,0,4,0,2,0,4,0,1,6,51,0,52,3,0,0,2,0,3,1,1,0,5,0,1,0,8,0,8,0,8,0,8,0,9,0,4,0,3,4,51,0,50,5,4,0,3,0,3,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,3,0,2,5,52,0,50,7,2,0,4,0,2,0,4,0,2,0,1,0,5,3,5,0,1,0,5,0,4,0,2,0,4,0,2,0,4,0,1,7,50,0,50,7,2,0,4,0,2,0,4,0,2,0,1,0,5,3,5,0,1,0,5,0,8,0,8,0,7,4,53,0,52,3,0,0,2,0,3,1,1,0,8,0,8,0,8,0,2,4,0,0,5,0,1,0,5,0,2,0,4,0,3,4,51,0,50,2,2,2,1,0,4,0,2,0,4,0,2,0,4,0,2,6,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,1,2,2,2,49,0,51,6,5,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,5,6,50,0,52,5,6,0,8,0,8,0,8,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,4,3,53,0,50,2,1,2,2,0,3,0,3,0,2,0,4,0,1,0,5,0,0,0,6,3,5,0,2,0,4,0,2,0,4,0,3,0,2,2,2,1,50,0,50,4,6,0,8,0,8,0,8,0,8,0,8,0,3,0,3,0,3,0,3,0,3,0,1,7,50,0,49,2,3,2,0,1,3,1,1,
0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,5,0,1,0,5,0,0,2,3,2,49,0,50,2,2,2,1,1,3,0,2,0,0,0,2,0,2,0,0,0,2,0,2,0,1,0,1,0,2,0,1,0,1,0,2,0,2,0,0,0,2,0,2,0,0,0,2,0,3,1,1,2,2,1,50,0,53,2,5,0,2,0,3,0,4,0,1,0,6,0,0,0,6,0,0,0,6,0,0,0,6,0,1,0,4,0,3,0,2,0,5,2,52,0,51,5,4,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,4,4,0,8,0,8,0,7,4,52,0,53,2,5,0,2,0,3,0,4,0,1,0,6,0,0,0,6,0,0,0,6,0,0,0,6,0,1,0,4,0,3,0,2,0,5,2,6,0,8,2,1,0,2,0,2,1,20,0,50,5,4,0,3,1,2,0,4,0,2,0,4,0,2,0,3,0,3,4,4,0,2,0,4,0,3,0,3,0,4,0,1,2,3,1,49,0,52,2,0,0,3,0,2,1,3,0,3,0,3,0,9,3,9,0,8,0,3,0,3,0,3,1,2,0,3,0,0,2,52,0,50,8,0,0,2,0,2,0,0,0,2,0,2,0,0,0,2,0,2,0,4,0,8,0,8,0,8,0,8,0,6,4,51,0,50,2,2,2,1,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,3,0,2,0,5,2,52,0,49,2,3,2,0,0,5,0,2,0,3,0,3,0,3,0,3,0,3,0,4,0,1,0,5,0,1,0,5,0,1,0,6,1,7,1,53,0,50,3,0,3,1,0,4,0,2,0,1,0,1,0,2,0,1,0,1,0,2,0,1,0,1,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,2,0,51,0,49,2,2,2,1,0,4,0,3,0,2,0,5,0,0,0,7,0,8,0,7,0,0,0,5,0,2,
0,3,0,4,0,1,2,2,2,50,0,50,2,2,2,1,0,4,0,3,0,2,0,5,0,0,0,6,0,0,0,7,0,8,0,8,0,8,0,6,4,51,0,50,6,2,0,4,0,2,0,3,0,3,0,2,0,7,0,8,0,7,0,2,0,3,0,3,0,2,0,4,0,2,6,51,0,44,2,6,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,2,31,0,30,0,9,0,8,0,8,0,9,0,8,0,9,0,8,0,9,0,8,0,9,0,8,0,9,0,41,0,42,2,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,6,2,33,0,44,0,8,0,7,0,0,0,5,0,2,0,3,0,4,0,110,0,128,0,189,9,0,43,0,9,0,9,0,128,0,132,0,72,3,4,0,3,0,8,0,3,5,2,0,4,0,2,0,4,0,2,0,3,1,3,3,0,1,50,0,40,1,8,0,8,0,8,0,0,2,4,1,2,0,3,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,1,2,0,2,1,0,2,52,0,72,3,0,0,2,0,3,1,1,0,8,0,8,0,8,0,9,0,4,0,3,4,51,0,45,1,8,0,8,0,4,2,0,0,3,0,2,1,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,3,0,2,1,4,2,0,1,50,0,72,3,4,0,3,0,2,0,5,0,1,7,1,0,8,0,9,0,4,0,3,4,51,0,44,3,4,0,8,0,6,5,5,0,8,0,8,0,8,0,8,0,8,0,6,5,51,0,72,2,0,1,2,0,2,1,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,3,0,2,1,4,2,0,0,8,0,7,1,3,3,23,0,40,1,8,0,8,0,8,0,0,2,4,1,2,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,2,2,1,2,50,0,34,0,8,0,26,2,8,0,8,0,8,0,8,0,8,0,8,0,5,6,50,0,34,0,8,0,25,4,8,
0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,4,3,23,0,40,1,8,0,8,0,8,0,1,3,2,0,2,0,4,0,1,0,5,0,0,0,6,2,6,0,1,0,5,0,2,0,3,1,1,3,50,0,42,2,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,5,6,50,0,69,1,0,0,0,1,3,1,0,1,0,0,2,0,1,0,1,0,2,0,1,0,1,0,2,0,1,0,1,0,2,0,1,0,1,0,2,0,1,0,1,0,1,2,0,1,0,1,50,0,70,1,0,2,4,1,2,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,2,2,1,2,50,0,72,3,4,0,3,0,2,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,2,0,3,0,4,3,52,0,70,1,0,2,4,1,2,0,3,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,1,2,0,3,0,0,2,4,0,8,0,7,2,25,0,72,2,0,1,2,0,2,1,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,3,0,2,1,4,2,0,0,8,0,8,0,7,2,20,0,71,1,1,1,4,2,1,0,3,0,8,0,8,0,8,0,8,0,7,5,51,0,71,3,0,0,2,0,3,1,2,0,9,4,9,0,8,0,2,0,4,0,2,5,52,0,52,0,8,0,6,6,4,0,8,0,8,0,8,0,8,0,8,0,3,0,4,3,51,0,70,1,2,1,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,2,1,4,2,0,1,50,0,70,2,1,2,2,0,3,0,3,0,3,0,4,0,1,0,5,0,1,0,5,0,1,0,6,1,7,1,53,0,69,2,4,1,0,0,6,0,0,0,2,0,2,0,1,0,1,0,1,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,2,0,51,0,70,2,1,2,2,0,3,0,4,0,1,0,6,1,7,1,6,0,1,0,4,0,3,0,2,2,1,2,50,0,
69,3,2,2,1,0,4,0,2,0,4,0,3,0,2,0,4,0,2,0,5,0,0,0,6,0,0,0,7,0,8,0,7,0,5,4,23,0,71,5,3,0,3,0,7,0,7,0,7,0,7,0,7,0,3,0,3,5,51,0,44,0,7,0,8,0,8,0,8,0,8,0,7,0,9,0,8,0,8,0,8,0,8,0,9,0,33,0,44,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,33,0,43,0,9,0,8,0,8,0,8,0,8,0,9,0,7,0,8,0,8,0,8,0,8,0,7,0,34,0,91,1,6,0,1,0,1,0,6,1,82,0,29,4,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,4,44,0,52,3,0,0,2,0,3,1,1,0,5,0,0,6,3,0,7,6,3,0,8,0,9,0,4,0,3,4,51,0,19,0,128,0,133,1,7,0,7,1,7,0,8,0,25,0,55,3,4,1,7,0,8,0,6,4,6,0,8,0,8,0,8,0,8,0,7,1,4,3,34,0,128,0,132,1,0,1,4,0,1,0,4,1,0,1,4,0,1,0,33,0,128,0,129,1,0,1,0,1,1,1,0,1,0,1,51,0,44,0,8,0,8,0,5,6,5,0,8,0,8,0,8,0,8,0,8,0,8,0,53,0,44,0,8,0,8,0,5,6,5,0,8,0,8,0,5,6,5,0,8,0,8,0,53,0,33,0,7,0,0,0,5,0,2,0,128,0,142,0,40,0,7,0,0,0,6,0,0,0,7,0,3,1,5,2,4,1,18,0,2,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,2,0,51,0,11,0,2,0,5,0,0,0,7,0,17,2,0,0,3,0,2,1,3,0,3,0,3,0,9,3,9,0,8,0,3,0,3,0,3,1,2,0,3,0,0,2,52,0,73,0,7,0,7,0,7,0,8,0,9,0,9,0,9,0,
54,0,52,6,1,0,1,0,2,0,0,0,2,0,2,1,3,0,0,0,0,1,3,2,1,0,3,0,0,0,1,0,3,0,4,0,2,0,2,0,1,0,1,0,2,0,2,6,49,0,19,0,11,0,2,0,5,0,0,0,7,0,15,6,2,0,4,0,2,0,3,0,3,0,2,0,7,0,8,0,7,0,2,0,3,0,3,0,2,0,4,0,2,6,51,0,19,0,19,0,44,1,8,0,8,0,9,0,8,0,111,0,42,1,7,0,7,1,7,0,8,0,116,0,41,1,0,1,5,0,1,0,5,1,0,1,5,0,1,0,121,0,42,1,0,1,4,0,1,0,4,1,0,1,4,0,1,0,123,0,73,1,6,3,5,3,6,1,93,0,90,7,100,0,89,9,99,0,37,1,0,0,1,0,0,1,91,0,49,6,0,2,0,0,0,2,0,1,1,0,1,0,0,0,0,0,1,0,1,0,2,0,0,5,0,1,99,0,31,0,2,0,5,0,0,0,7,0,16,3,0,0,2,0,3,1,2,0,9,4,9,0,8,0,2,0,4,0,2,5,52,0,74,0,9,0,9,0,9,0,8,0,7,0,7,0,7,0,53,0,71,1,2,1,1,0,1,0,0,0,1,1,3,0,2,1,3,5,3,0,3,0,3,0,4,0,1,0,0,0,1,0,1,1,2,1,50,0,19,0,32,0,2,0,5,0,0,0,7,0,15,5,3,0,3,0,7,0,7,0,7,0,7,0,7,0,3,0,3,5,51,0,32,0,2,0,12,2,2,2,1,0,4,0,3,0,2,0,5,0,0,0,6,0,0,0,7,0,8,0,8,0,8,0,6,4,51,0,128,0,199,0,73,2,6,2,27,0,8,0,8,0,8,0,8,0,8,0,8,0,23,0,54,0,8,0,7,3,4,0,2,0,3,0,8,0,9,0,2,0,5,2,7,0,8,0,53,0,52,2,5,0,2,0,4,0,8,0,7,4,6,0,8,0,8,0,7,0,4,0,1,7,50,0,71,0,0,1,0,0,4,0,1,0,4,0,3,0,3,0,3,0,4,0,1,0,
4,0,0,1,0,0,71,0,50,2,2,2,1,0,4,0,3,0,2,0,5,0,0,0,6,0,0,0,4,6,5,0,5,6,5,0,6,4,51,0,44,0,8,0,8,0,8,0,8,0,38,0,8,0,8,0,8,0,8,0,33,0,52,4,3,0,3,0,3,0,3,0,2,3,5,0,1,2,3,1,3,1,3,2,1,0,5,3,2,0,3,0,3,0,3,0,3,4,42,0,41,0,2,0,128,0,152,0,52,3,4,0,3,0,2,0,1,2,0,0,0,0,1,0,1,0,1,1,1,0,4,1,1,0,4,1,1,0,4,0,0,0,1,2,0,0,2,0,3,0,4,3,52,0,42,2,8,0,5,3,5,0,1,0,5,4,112,0,83,1,1,1,2,1,1,1,2,1,1,1,2,1,1,1,4,1,1,1,4,1,1,1,4,1,1,1,49,0,89,8,8,0,8,0,8,0,8,0,60,0,100,6,91,0,52,3,4,0,3,0,2,0,0,3,0,0,0,0,2,0,0,0,1,1,2,1,2,1,2,1,2,1,2,0,0,0,1,0,0,0,0,2,0,1,2,0,3,0,4,3,52,0,29,9,128,0,159,0,33,2,5,0,2,0,4,0,2,0,4,0,2,0,5,2,122,0,54,0,8,0,8,0,8,0,4,8,4,0,8,0,8,0,8,0,4,8,49,0,43,1,6,0,1,0,8,0,7,0,7,0,7,3,102,0,43,2,5,0,1,0,6,1,9,0,5,0,1,0,6,1,103,0,45,0,7,0,7,0,128,0,134,0,70,1,2,1,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,2,1,3,3,0,1,2,0,8,0,8,0,26,0,42,5,1,1,1,0,0,0,2,0,2,0,0,0,2,0,2,0,0,0,2,1,1,0,0,0,4,2,0,0,6,0,0,0,6,0,0,0,6,0,0,0,6,0,0,0,6,0,0,0,4,2,0,1,40,0,85,1,7,1,101,0,128,0,154,0,8,1,8,0,6,2,12,0,44,0,6,2,8,0,8,0,8,
0,6,4,101,0,42,2,5,0,2,0,4,0,2,0,4,0,2,0,5,2,113,0,79,1,2,0,4,1,1,1,4,1,1,1,4,1,1,1,2,1,1,1,2,1,1,1,2,1,1,1,53,0,41,0,6,2,8,0,8,0,4,1,1,0,3,0,1,4,0,0,6,1,0,1,3,0,1,0,0,0,2,0,1,4,7,0,7,2,49,0,41,0,6,2,8,0,5,0,1,0,4,0,2,0,2,1,1,5,0,1,3,1,0,0,1,0,1,0,5,0,7,0,7,0,7,3,49,0,39,3,8,0,7,0,5,0,2,0,3,0,3,0,2,0,1,2,1,1,6,0,1,1,3,0,1,0,0,0,1,1,1,4,7,0,7,2,49,0,73,1,7,1,27,0,8,0,6,1,7,0,8,0,3,0,3,0,3,0,4,3,22,0,12,0,9,0,9,0,14,4,7,1,6,0,1,0,5,0,1,0,5,0,1,0,4,0,3,0,3,5,3,0,3,0,2,0,5,0,0,2,3,2,49,0,15,0,7,0,7,0,15,4,7,1,6,0,1,0,5,0,1,0,5,0,1,0,4,0,3,0,3,5,3,0,3,0,2,0,5,0,0,2,3,2,49,0,13,0,7,0,0,0,5,0,2,0,13,4,7,1,6,0,1,0,5,0,1,0,5,0,1,0,4,0,3,0,3,5,3,0,3,0,2,0,5,0,0,2,3,2,49,0,22,1,0,0,4,0,0,1,14,4,7,1,6,0,1,0,5,0,1,0,5,0,1,0,4,0,3,0,3,5,3,0,3,0,2,0,5,0,0,2,3,2,49,0,30,0,2,0,14,4,7,1,6,0,1,0,5,0,1,0,5,0,1,0,4,0,3,0,3,5,3,0,3,0,2,0,5,0,0,2,3,2,49,0,3,1,6,0,1,0,5,0,1,0,6,1,14,4,7,1,6,0,1,0,5,0,1,0,5,0,1,0,4,0,3,0,3,5,3,0,3,0,2,0,5,0,0,2,3,2,49,0,51,6,3,0,0,0,1,0,3,0,0,0,1,0,2,0,1,0,0,0,3,0,1,2,3,0,1,0,0,0,3,3,4,
0,2,0,1,0,1,0,2,0,1,0,0,2,0,4,50,0,52,3,0,0,2,0,3,1,1,0,5,0,1,0,8,0,8,0,8,0,8,0,9,0,4,0,3,4,6,0,8,1,8,0,6,2,12,0,12,0,9,0,9,0,14,7,2,0,4,0,2,0,4,0,2,0,1,0,5,3,5,0,1,0,5,0,4,0,2,0,4,0,2,0,4,0,1,7,50,0,15,0,7,0,7,0,15,7,2,0,4,0,2,0,4,0,2,0,1,0,5,3,5,0,1,0,5,0,4,0,2,0,4,0,2,0,4,0,1,7,50,0,14,0,7,0,0,0,5,0,2,0,12,7,2,0,4,0,2,0,4,0,2,0,1,0,5,3,5,0,1,0,5,0,4,0,2,0,4,0,2,0,4,0,1,7,50,0,31,0,2,0,13,7,2,0,4,0,2,0,4,0,2,0,1,0,5,3,5,0,1,0,5,0,4,0,2,0,4,0,2,0,4,0,1,7,50,0,13,0,9,0,9,0,14,6,5,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,5,6,50,0,16,0,7,0,7,0,15,6,5,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,5,6,50,0,14,0,7,0,0,0,5,0,2,0,13,6,5,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,5,6,50,0,32,0,2,0,13,6,5,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,5,6,50,0,50,5,4,0,3,0,3,0,4,0,2,0,4,0,1,4,1,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,3,0,2,5,52,0,23,1,0,0,4,0,0,1,13,2,2,2,1,1,3,0,2,0,0,0,2,0,2,0,0,0,2,0,2,0,1,0,1,0,2,0,1,0,1,0,2,0,2,0,0,0,2,0,2,0,0,0,2,0,3,1,1,2,2,1,50,0,13,0,9,0,9,0,16,2,5,0,2,0,3,0,4,0,1,0,6,0,0,0,6,0,0,0,6,0,0,0,6,0,1,0,4,0,3,0,2,0,5,2,52,0,15,0,7,0,
7,0,18,2,5,0,2,0,3,0,4,0,1,0,6,0,0,0,6,0,0,0,6,0,0,0,6,0,1,0,4,0,3,0,2,0,5,2,52,0,14,0,7,0,0,0,5,0,2,0,15,2,5,0,2,0,3,0,4,0,1,0,6,0,0,0,6,0,0,0,6,0,0,0,6,0,1,0,4,0,3,0,2,0,5,2,52,0,23,1,0,0,4,0,0,1,16,2,5,0,2,0,3,0,4,0,1,0,6,0,0,0,6,0,0,0,6,0,0,0,6,0,1,0,4,0,3,0,2,0,5,2,52,0,32,0,2,0,15,2,5,0,2,0,3,0,4,0,1,0,6,0,0,0,6,0,0,0,6,0,0,0,6,0,1,0,4,0,3,0,2,0,5,2,52,0,71,0,3,0,4,0,1,0,6,1,7,1,6,0,1,0,4,0,3,0,71,0,53,3,0,0,2,0,3,0,2,0,3,0,0,0,0,0,3,0,1,0,0,0,2,0,2,0,0,0,1,0,3,0,0,0,1,0,3,0,0,0,0,0,3,0,2,0,3,0,2,0,0,3,52,0,13,0,9,0,9,0,13,2,2,2,1,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,3,0,2,0,5,2,52,0,15,0,7,0,7,0,15,2,2,2,1,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,3,0,2,0,5,2,52,0,14,0,7,0,0,0,5,0,2,0,12,2,2,2,1,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,3,0,2,0,5,2,52,0,32,0,2,0,12,2,2,2,1,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,3,0,2,0,5,2,52,0,15,0,7,0,7,0,15,2,2,2,1,0,4,0,3,0,2,0,5,0,0,0,6,0,0,0,7,0,8,0,8,0,8,0,6,4,51,0,51,4,5,0,8,3,5,0,2,0,4,0,3,0,
3,0,3,0,3,0,2,0,4,3,5,0,7,4,52,0,42,2,5,0,2,0,4,0,2,0,4,0,2,0,4,0,1,0,5,0,2,0,4,0,3,0,3,0,3,0,3,0,1,0,0,0,3,0,1,0,0,0,2,2,1,0,52,0,33,0,9,0,9,0,15,3,4,0,3,0,8,0,3,5,2,0,4,0,2,0,4,0,2,0,3,1,3,3,0,1,50,0,35,0,7,0,7,0,17,3,4,0,3,0,8,0,3,5,2,0,4,0,2,0,4,0,2,0,3,1,3,3,0,1,50,0,34,0,7,0,0,0,5,0,2,0,14,3,4,0,3,0,8,0,3,5,2,0,4,0,2,0,4,0,2,0,3,1,3,3,0,1,50,0,43,1,0,0,4,0,0,1,15,3,4,0,3,0,8,0,3,5,2,0,4,0,2,0,4,0,2,0,3,1,3,3,0,1,50,0,51,0,2,0,15,3,4,0,3,0,8,0,3,5,2,0,4,0,2,0,4,0,2,0,3,1,3,3,0,1,50,0,23,1,6,0,1,0,5,0,1,0,6,1,16,3,4,0,3,0,8,0,3,5,2,0,4,0,2,0,4,0,2,0,3,1,3,3,0,1,50,0,70,2,1,1,5,1,0,0,5,0,2,0,1,7,0,0,2,0,4,0,2,0,4,0,2,1,1,0,1,6,51,0,72,3,0,0,2,0,3,1,1,0,8,0,8,0,8,0,9,0,4,0,3,4,6,0,8,1,8,0,6,2,12,0,32,0,9,0,9,0,16,3,4,0,3,0,2,0,5,0,1,7,1,0,8,0,9,0,4,0,3,4,51,0,35,0,7,0,7,0,17,3,4,0,3,0,2,0,5,0,1,7,1,0,8,0,9,0,4,0,3,4,51,0,34,0,7,0,0,0,5,0,2,0,14,3,4,0,3,0,2,0,5,0,1,7,1,0,8,0,9,0,4,0,3,4,51,0,51,0,2,0,15,3,4,0,3,0,2,0,5,0,1,7,1,0,8,0,9,0,4,0,3,4,51,0,32,0,9,0,9,0,16,2,8,0,8,0,8,0,8,0,8,0,8,0,5,6,
50,0,35,0,7,0,7,0,17,2,8,0,8,0,8,0,8,0,8,0,8,0,5,6,50,0,33,0,7,0,0,0,5,0,2,0,15,2,8,0,8,0,8,0,8,0,8,0,8,0,5,6,50,0,51,0,2,0,15,2,8,0,8,0,8,0,8,0,8,0,8,0,5,6,50,0,42,1,0,1,5,2,4,1,2,0,4,4,3,0,3,1,1,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,2,0,3,0,4,3,52,0,43,1,0,0,4,0,0,1,13,1,0,2,4,1,2,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,2,2,1,2,50,0,32,0,9,0,9,0,16,3,4,0,3,0,2,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,2,0,3,0,4,3,52,0,35,0,7,0,7,0,17,3,4,0,3,0,2,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,2,0,3,0,4,3,52,0,34,0,7,0,0,0,5,0,2,0,14,3,4,0,3,0,2,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,2,0,3,0,4,3,52,0,43,1,0,0,4,0,0,1,15,3,4,0,3,0,2,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,2,0,3,0,4,3,52,0,51,0,2,0,15,3,4,0,3,0,2,0,5,0,1,0,5,0,1,0,5,0,1,0,5,0,2,0,3,0,4,3,52,0,63,0,25,6,25,0,74,0,72,3,0,0,2,0,3,0,2,0,3,0,0,0,1,0,2,0,1,0,1,0,1,0,2,0,1,0,0,0,3,0,2,0,3,0,2,0,0,3,52,0,32,0,9,0,9,0,14,1,2,1,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,2,1,4,2,0,1,50,0,35,0,7,0,7,0,15,1,2,1,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,2,1,4,2,0,1,50,0,33,0,7,0,0,0,5,0,2,0,13,
1,2,1,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,2,1,4,2,0,1,50,0,51,0,2,0,13,1,2,1,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,2,1,4,2,0,1,50,0,36,0,7,0,7,0,13,3,2,2,1,0,4,0,2,0,4,0,3,0,2,0,4,0,2,0,5,0,0,0,6,0,0,0,7,0,8,0,7,0,5,4,23,0,40,1,8,0,8,0,8,0,0,2,4,1,2,0,3,0,4,0,2,0,4,0,2,0,4,0,2,0,4,0,2,1,2,0,3,0,0,2,4,0,8,0,7,2,25,0,52,0,2,0,11,3,2,2,1,0,4,0,2,0,4,0,3,0,2,0,4,0,2,0,5,0,0,0,6,0,0,0,7,0,8,0,7,0,5,4,23,0,0,0);

sysfont__courier_new_12:array[0..10339] of byte=(
71,70,35,51,22,0,17,0,12,0,8,6,0,0,12,0,12,6,0,0,12,0,16,6,0,0,12,0,40,6,0,0,12,0,60,6,0,0,12,0,80,6,0,0,12,0,118,6,0,0,12,0,124,6,0,0,12,0,140,6,0,0,12,0,192,6,0,0,12,0,196,6,0,0,12,0,200,6,0,0,12,0,244,6,0,0,12,0,38,7,0,0,12,0,42,7,0,0,12,0,100,7,0,0,12,0,162,7,0,0,12,0,200,7,0,0,12,0,232,7,0,0,12,0,18,8,0,0,12,0,72,8,0,0,12,0,142,8,0,0,12,0,162,8,0,0,12,0,186,8,0,0,12,0,224,8,0,0,12,0,4,9,0,0,12,0,42,9,0,0,12,0,54,9,0,0,12,0,66,9,0,0,12,0,70,9,0,0,12,0,74,9,0,0,12,0,78,9,0,0,12,0,82,9,0,0,12,0,86,9,0,0,12,0,108,9,0,0,12,0,132,9,0,0,12,0,186,9,0,0,12,0,224,9,0,0,12,0,8,10,0,0,12,0,48,10,0,0,12,0,64,10,0,0,12,0,98,10,0,0,12,0,132,10,0,0,12,0,154,10,0,0,12,0,178,10,0,0,12,0,194,10,0,0,12,0,200,10,0,0,12,0,210,10,0,0,12,0,242,10,0,0,12,0,36,11,0,0,12,0,66,11,0,0,12,0,100,11,0,0,12,0,132,11,0,0,12,0,172,11,0,0,12,0,208,11,0,0,12,0,252,11,0,0,12,0,26,12,0,0,12,0,74,12,0,0,12,0,116,12,0,0,12,0,130,12,0,0,12,0,148,12,0,0,12,0,172,12,0,0,12,0,178,12,0,0,12,0,202,12,0,0,12,0,228,12,0,0,12,0,30,13,0,0,12,
0,74,13,0,0,12,0,118,13,0,0,12,0,154,13,0,0,12,0,200,13,0,0,12,0,244,13,0,0,12,0,26,14,0,0,12,0,68,14,0,0,12,0,116,14,0,0,12,0,142,14,0,0,12,0,178,14,0,0,12,0,226,14,0,0,12,0,4,15,0,0,12,0,76,15,0,0,12,0,142,15,0,0,12,0,188,15,0,0,12,0,224,15,0,0,12,0,24,16,0,0,12,0,70,16,0,0,12,0,108,16,0,0,12,0,146,16,0,0,12,0,194,16,0,0,12,0,238,16,0,0,12,0,58,17,0,0,12,0,106,17,0,0,12,0,144,17,0,0,12,0,182,17,0,0,12,0,216,17,0,0,12,0,248,17,0,0,12,0,26,18,0,0,12,0,48,18,0,0,12,0,53,18,0,0,12,0,63,18,0,0,12,0,93,18,0,0,12,0,143,18,0,0,12,0,173,18,0,0,12,0,219,18,0,0,12,0,247,18,0,0,12,0,19,19,0,0,12,0,65,19,0,0,12,0,111,19,0,0,12,0,135,19,0,0,12,0,167,19,0,0,12,0,211,19,0,0,12,0,239,19,0,0,12,0,39,20,0,0,12,0,77,20,0,0,12,0,111,20,0,0,12,0,161,20,0,0,12,0,209,20,0,0,12,0,235,20,0,0,12,0,11,21,0,0,12,0,39,21,0,0,12,0,77,21,0,0,12,0,111,21,0,0,12,0,167,21,0,0,12,0,203,21,0,0,12,0,245,21,0,0,12,0,13,22,0,0,12,0,45,22,0,0,12,0,77,22,0,0,12,0,109,22,0,0,12,0,121,22,0,0,12,0,163,22,0,0,1,0,199,22,0,0,12,0,201,22,0,
0,12,0,217,22,0,0,12,0,247,22,0,0,12,0,15,23,0,0,12,0,31,23,0,0,12,0,61,23,0,0,12,0,91,23,0,0,12,0,105,23,0,0,12,0,151,23,0,0,12,0,199,23,0,0,12,0,219,23,0,0,1,0,19,24,0,0,12,0,21,24,0,0,1,0,69,24,0,0,1,0,71,24,0,0,12,0,73,24,0,0,12,0,89,24,0,0,12,0,105,24,0,0,12,0,129,24,0,0,12,0,153,24,0,0,12,0,165,24,0,0,12,0,171,24,0,0,9,0,177,24,0,0,12,0,189,24,0,0,12,0,231,24,0,0,12,0,17,25,0,0,12,0,37,25,0,0,1,0,87,25,0,0,12,0,89,25,0,0,12,0,123,25,0,0,12,0,169,25,0,0,12,0,173,25,0,0,12,0,195,25,0,0,12,0,225,25,0,0,12,0,1,26,0,0,12,0,35,26,0,0,12,0,73,26,0,0,12,0,99,26,0,0,12,0,145,26,0,0,12,0,157,26,0,0,12,0,215,26,0,0,12,0,237,26,0,0,12,0,19,27,0,0,12,0,33,27,0,0,12,0,39,27,0,0,12,0,101,27,0,0,12,0,107,27,0,0,12,0,127,27,0,0,12,0,153,27,0,0,12,0,173,27,0,0,12,0,195,27,0,0,12,0,205,27,0,0,12,0,251,27,0,0,12,0,61,28,0,0,12,0,69,28,0,0,12,0,81,28,0,0,12,0,99,28,0,0,12,0,123,28,0,0,12,0,161,28,0,0,12,0,207,28,0,0,12,0,253,28,0,0,12,0,47,29,0,0,12,0,73,29,0,0,12,0,123,29,0,0,12,0,173,29,0,0,12,0,227,29,0,0,12,
0,23,30,0,0,12,0,75,30,0,0,12,0,131,30,0,0,12,0,191,30,0,0,12,0,235,30,0,0,12,0,29,31,0,0,12,0,79,31,0,0,12,0,133,31,0,0,12,0,185,31,0,0,12,0,217,31,0,0,12,0,249,31,0,0,12,0,29,32,0,0,12,0,63,32,0,0,12,0,109,32,0,0,12,0,183,32,0,0,12,0,235,32,0,0,12,0,31,33,0,0,12,0,87,33,0,0,12,0,141,33,0,0,12,0,195,33,0,0,12,0,217,33,0,0,12,0,25,34,0,0,12,0,79,34,0,0,12,0,133,34,0,0,12,0,191,34,0,0,12,0,247,34,0,0,12,0,35,35,0,0,12,0,69,35,0,0,12,0,125,35,0,0,12,0,161,35,0,0,12,0,197,35,0,0,12,0,237,35,0,0,12,0,19,36,0,0,12,0,57,36,0,0,12,0,99,36,0,0,12,0,139,36,0,0,12,0,177,36,0,0,12,0,211,36,0,0,12,0,245,36,0,0,12,0,27,37,0,0,12,0,63,37,0,0,12,0,89,37,0,0,12,0,115,37,0,0,12,0,145,37,0,0,12,0,173,37,0,0,12,0,221,37,0,0,12,0,11,38,0,0,12,0,51,38,0,0,12,0,91,38,0,0,12,0,135,38,0,0,12,0,177,38,0,0,12,0,219,38,0,0,12,0,231,38,0,0,12,0,19,39,0,0,12,0,63,39,0,0,12,0,107,39,0,0,12,0,155,39,0,0,12,0,201,39,0,0,12,0,249,39,0,0,12,0,47,40,0,0,0,128,1,7,0,128,1,7,0,128,0,131,4,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,
0,18,0,39,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,4,122,0,39,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,6,4,126,0,39,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,18,0,128,0,131,8,122,0,98,2,7,4,5,6,4,6,4,6,5,4,7,2,89,0,35,8,2,8,2,8,2,8,2,8,2,2,2,2,2,1,4,1,2,0,6,0,2,0,6,0,2,0,6,0,2,1,4,1,2,2,2,2,2,8,2,8,2,8,2,8,2,8,2,8,14,0,128,1,7,0,128,1,7,0,63,4,9,1,8,0,0,0,8,0,0,0,7,0,1,0,7,0,9,0,10,0,8,2,7,0,2,0,6,0,2,0,6,0,2,0,6,0,2,0,7,2,42,0,48,9,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,9,60,0,128,1,7,0,53,2,5,2,1,0,5,0,3,0,5,0,3,0,5,0,1,2,5,2,1,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,2,1,4,1,1,2,3,2,1,2,3,2,1,1,4,1,44,0,51,0,10,0,7,0,1,0,1,0,4,0,0,2,0,0,5,0,2,0,6,0,2,0,6,0,2,0,5,1,2,1,5,0,2,0,6,0,2,0,6,0,2,0,5,0,0,2,0,0,4,0,1,0,1,0,7,0,10,0,42,0,39,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,6,8,6,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,18,0,55,0,9,1,8,2,7,3,6,4,5,5,4,6,3,7,4,6,5,5,6,4,7,3,8,2,9,1,10,0,38,0,51,0,9,2,7,0,0,0,0,0,
8,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,8,0,0,0,0,0,7,2,9,0,30,0,50,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,31,0,1,0,7,0,1,0,7,0,1,0,40,0,50,4,5,0,1,0,0,0,4,0,2,0,0,0,4,0,2,0,0,0,4,0,2,0,0,0,5,0,1,0,0,0,6,2,0,0,8,0,0,0,8,0,0,0,8,0,0,0,8,0,0,0,8,0,0,0,8,0,0,0,8,0,0,0,8,0,0,0,39,0,39,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,6,8,122,0,128,0,131,8,6,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,18,0,39,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,6,4,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,18,0,51,0,9,2,7,0,0,0,0,0,8,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,42,0,39,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,4,6,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,18,0,113,0,11,0,4,7,9,0,9,0,100,0,110,0,9,0,9,7,4,0,11,0,103,0,128,1,7,0,128,1,7,0,128,1,7,0,128,1,7,0,128,1,7,0,53,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,45,2,8,2,63,0,49,2,1,2,3,2,1,2,4,0,3,0,5,0,3,0,5,0,3,0,128,0,158,0,52,0,1,0,7,0,1,0,7,0,1,0,6,0,1,0,7,0,1,0,5,7,5,0,1,0,7,0,1,0,5,7,5,0,1,0,7,0,1,0,6,0,
1,0,7,0,1,0,7,0,1,0,52,0,52,0,9,4,5,0,3,0,4,0,10,0,10,0,11,3,11,1,10,0,4,0,4,0,4,0,3,1,4,5,8,0,10,0,10,0,41,0,50,2,7,0,2,0,6,0,2,0,6,0,2,0,7,2,12,1,6,2,6,1,12,2,7,0,2,0,6,0,2,0,6,0,2,0,7,2,63,0,75,3,6,0,10,0,10,0,11,0,9,0,0,0,1,0,4,0,1,0,0,0,5,0,2,1,5,0,3,0,5,1,1,1,6,2,1,1,61,0,51,2,8,2,8,2,9,0,10,0,10,0,128,0,149,0,55,0,10,0,9,0,10,0,9,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,11,0,10,0,11,0,10,0,26,0,50,0,10,0,11,0,10,0,11,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,9,0,10,0,9,0,10,0,31,0,52,0,10,0,10,0,7,6,7,0,10,1,8,0,0,0,7,0,2,0,123,0,76,0,10,0,10,0,10,0,10,0,6,8,6,0,10,0,10,0,10,0,10,0,65,0,128,0,171,2,8,1,9,1,8,1,9,1,9,0,31,0,128,0,133,7,121,0,128,0,171,2,8,2,8,2,64,0,56,0,9,0,10,0,9,0,10,0,9,0,10,0,9,0,10,0,9,0,10,0,9,0,10,0,9,0,10,0,44,0,51,3,6,0,3,0,5,0,3,0,4,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,4,0,5,0,3,0,6,3,63,0,52,1,6,2,0,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,7,6,61,0,51,3,6,0,3,0,4,0,5,0,10,0,10,0,9,0,9,0,9,0,9,0,9,0,9,0,9,0,5,0,3,7,61,0,51,3,5,1,3,0,11,0,10,
0,9,0,7,2,11,0,11,0,10,0,10,0,10,0,3,0,4,0,5,4,63,0,54,0,9,1,9,1,8,0,0,0,7,0,1,0,7,0,1,0,6,0,2,0,6,0,2,0,5,0,3,0,5,6,9,0,10,0,8,3,62,0,50,5,5,0,10,0,10,0,10,0,10,0,0,2,6,1,2,0,11,0,10,0,10,0,3,0,5,0,4,0,3,0,6,3,63,0,54,3,5,1,8,0,9,0,9,0,10,0,1,3,4,0,0,0,3,0,3,1,5,0,2,0,6,0,2,0,6,0,3,0,5,0,4,0,3,0,6,3,62,0,49,7,3,0,5,0,10,0,9,0,10,0,10,0,9,0,10,0,10,0,9,0,10,0,10,0,10,0,64,0,51,2,7,0,2,0,5,0,4,0,4,0,4,0,4,0,4,0,5,0,2,0,7,3,6,0,2,0,5,0,4,0,4,0,4,0,4,0,4,0,5,0,2,0,7,2,64,0,51,2,7,0,2,1,4,0,4,0,4,0,5,0,3,0,5,0,3,0,5,0,4,0,3,1,5,3,0,0,10,0,9,0,10,0,9,0,5,4,64,0,99,2,8,2,8,2,44,2,8,2,8,2,64,0,99,2,8,2,8,2,32,2,8,1,8,1,9,1,9,0,55,0,80,0,9,0,8,1,7,1,8,0,8,1,11,0,11,1,11,1,11,0,11,0,61,0,108,9,25,9,108,0,73,0,11,0,11,1,11,1,11,0,11,1,8,0,8,1,7,1,8,0,9,0,68,0,63,3,6,0,3,0,5,0,4,0,10,0,10,0,8,1,8,0,10,0,33,2,8,2,63,0,51,3,6,1,2,0,4,0,5,0,3,0,5,0,3,0,3,2,3,0,2,0,1,0,3,0,1,0,2,0,3,0,1,0,2,0,3,0,1,0,2,0,3,0,2,3,3,0,10,0,11,0,3,0,6,3,51,0,61,4,9,1,8,0,1,0,7,0,1,0,7,0,1,0,6,0,3,0,5,0,3,0,4,7,3,0,5,0,3,0,5,0,2,0,
7,0,0,3,3,3,59,0,60,7,5,0,4,0,4,0,4,0,4,0,4,0,4,0,3,0,5,5,5,0,4,0,4,0,5,0,3,0,5,0,3,0,5,0,3,0,4,0,2,7,62,0,63,3,1,0,3,0,3,2,2,0,6,0,1,0,10,0,10,0,10,0,10,0,10,0,11,0,6,0,3,0,4,0,5,4,62,0,61,6,5,0,4,0,4,0,4,0,4,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,4,0,4,0,4,0,3,6,62,0,60,9,3,0,5,0,3,0,5,0,3,0,2,0,6,0,2,0,6,4,6,0,2,0,6,0,2,0,6,0,5,0,3,0,5,0,3,0,5,0,1,9,60,0,60,9,3,0,5,0,3,0,5,0,3,0,2,0,6,0,2,0,6,4,6,0,2,0,6,0,2,0,6,0,10,0,10,0,8,5,64,0,63,3,0,0,4,0,3,1,3,0,5,0,2,0,10,0,10,0,10,0,3,4,1,0,6,0,2,0,6,0,3,0,5,0,4,0,4,0,5,4,62,0,59,4,1,4,1,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,7,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,1,4,1,4,59,0,61,6,7,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,7,6,62,0,63,6,8,0,10,0,10,0,10,0,10,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,5,0,2,0,7,2,64,0,60,3,1,4,2,0,4,0,4,0,3,0,5,0,2,0,6,0,1,0,7,0,0,0,8,3,7,0,2,0,6,0,3,0,5,0,3,0,5,0,4,0,2,3,3,2,59,0,61,4,8,0,10,0,10,0,10,0,10,0,10,0,10,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,2,8,60,0,59,2,4,2,1,1,4,1,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,
2,0,0,0,2,0,1,0,0,0,1,0,2,0,1,0,0,0,1,0,2,0,2,0,2,0,2,0,6,0,2,0,6,0,2,0,6,0,1,2,4,2,60,0,59,3,3,2,2,1,4,0,3,0,0,0,3,0,3,0,0,0,3,0,3,0,1,0,2,0,3,0,1,0,2,0,3,0,2,0,1,0,3,0,2,0,1,0,3,0,3,0,0,0,3,0,3,0,0,0,3,0,4,1,2,2,3,1,61,0,63,3,6,0,3,0,4,0,5,0,2,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,2,0,5,0,4,0,3,0,6,3,63,0,60,6,6,0,3,0,5,0,4,0,4,0,4,0,4,0,4,0,4,0,3,0,5,4,6,0,10,0,10,0,10,0,8,5,64,0,63,3,6,0,3,0,4,0,5,0,2,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,2,0,5,0,4,0,3,0,6,3,8,0,9,3,1,0,3,1,2,1,25,0,60,6,6,0,3,0,5,0,4,0,4,0,4,0,4,0,4,0,4,0,3,0,5,4,6,0,3,0,5,0,4,0,4,0,4,0,4,0,5,0,1,3,4,1,59,0,63,3,0,0,4,0,3,1,3,0,5,0,3,0,10,1,11,3,11,0,11,0,10,0,3,0,5,0,3,1,3,0,4,0,0,3,63,0,60,8,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,6,0,10,0,10,0,10,0,10,0,10,0,10,0,8,4,63,0,60,2,3,2,2,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,4,0,3,0,6,3,63,0,59,3,3,3,1,0,5,0,3,0,5,0,4,0,3,0,5,0,3,0,5,0,3,0,6,0,1,0,7,0,1,0,7,0,1,0,8,1,9,1,9,1,64,0,59,3,2,4,0,0,6,0,2,0,6,0,2,0,2,0,2,0,2,0,2,0,2,0,3,0,
1,0,1,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,2,0,63,0,59,3,2,3,2,0,4,0,5,0,2,0,6,0,2,0,7,0,0,0,9,0,9,0,0,0,7,0,2,0,6,0,3,0,4,0,4,0,3,0,6,0,1,3,2,3,60,0,60,3,2,3,1,0,6,0,3,0,4,0,5,0,2,0,7,0,0,0,8,0,0,0,9,0,10,0,10,0,10,0,10,0,8,4,62,0,61,7,3,0,5,0,3,0,4,0,4,0,3,0,10,0,9,0,9,0,9,0,10,0,3,0,4,0,4,0,3,0,5,0,3,7,61,0,52,3,7,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,3,26,0,49,0,11,0,10,0,10,0,11,0,10,0,11,0,10,0,11,0,10,0,11,0,10,0,11,0,10,0,11,0,37,0,49,3,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,7,3,29,0,64,1,8,0,1,0,7,0,1,0,6,0,3,0,4,0,5,0,128,0,145,0,128,0,251,11,0,51,0,11,0,11,0,128,0,184,0,99,4,5,0,4,0,10,0,10,0,5,5,4,0,4,0,3,0,5,0,3,0,4,1,4,4,0,1,60,0,48,1,10,0,10,0,10,0,10,0,1,3,4,0,0,0,3,0,3,1,5,0,2,0,6,0,2,0,6,0,2,0,6,0,2,1,5,0,2,0,0,0,3,0,2,1,1,3,62,0,99,4,0,0,3,0,4,1,2,0,6,0,2,0,10,0,10,0,10,0,6,0,3,0,4,0,5,4,62,0,55,1,10,0,10,0,10,0,4,3,1,0,3,0,3,2,2,0,6,0,2,0,6,0,2,0,6,0,2,0,6,0,2,0,6,0,
3,0,3,2,4,3,1,1,60,0,99,3,6,0,3,0,4,0,5,0,3,0,5,0,3,7,3,0,10,0,11,0,4,0,5,4,62,0,52,5,4,0,10,0,10,0,8,6,6,0,10,0,10,0,10,0,10,0,10,0,10,0,8,6,62,0,99,2,0,1,4,0,2,1,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,5,0,2,1,6,2,0,0,10,0,10,0,9,0,6,3,16,0,49,1,10,0,10,0,10,0,10,0,0,2,6,1,2,0,5,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,3,2,2,2,60,0,52,0,10,0,31,3,10,0,10,0,10,0,10,0,10,0,10,0,10,0,6,8,61,0,53,0,10,0,30,5,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,5,4,16,0,49,1,10,0,10,0,10,0,10,0,2,3,3,0,3,0,5,0,1,1,6,0,0,0,8,2,8,0,1,0,7,0,2,0,6,0,3,0,4,1,2,3,60,0,50,3,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,6,8,60,0,96,1,0,1,1,1,3,1,1,1,1,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,1,2,1,1,1,1,59,0,97,1,0,2,6,1,2,0,5,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,3,2,2,2,60,0,99,4,5,0,4,0,3,0,6,0,2,0,6,0,2,0,6,0,2,0,6,0,2,0,6,0,3,0,4,0,5,4,62,0,96,1,1,3,4,0,0,0,3,0,3,1,5,0,2,0,6,0,2,0,6,0,2,0,6,0,2,1,5,0,2,0,0,0,3,0,3,0,1,3,4,0,10,0,10,0,9,2,19,0,98,
3,1,1,2,0,3,0,0,0,2,0,5,1,2,0,6,0,2,0,6,0,2,0,6,0,2,0,6,0,3,0,3,2,4,3,1,0,10,0,10,0,10,0,9,2,12,0,98,1,1,2,5,0,0,0,2,0,4,1,9,0,10,0,10,0,10,0,10,0,9,5,62,0,98,4,0,0,3,0,4,1,3,0,5,0,4,4,11,0,11,0,3,0,5,0,3,1,3,0,4,0,0,3,63,0,63,0,10,0,10,0,8,7,5,0,10,0,10,0,10,0,10,0,10,0,10,0,3,1,5,3,62,0,96,1,4,1,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,4,1,4,4,0,1,60,0,95,3,3,3,1,0,5,0,4,0,3,0,5,0,3,0,5,0,3,0,6,0,1,0,7,0,1,0,8,1,9,1,64,0,95,2,4,3,0,0,6,0,2,0,2,0,2,0,2,0,2,0,2,0,3,0,1,0,1,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,2,0,63,0,96,3,1,3,2,0,5,0,4,0,3,0,6,0,1,0,8,1,8,0,1,0,6,0,3,0,4,0,5,0,2,3,1,3,60,0,95,3,3,3,1,0,5,0,3,0,4,0,5,0,3,0,5,0,3,0,6,0,1,0,7,0,1,0,8,1,9,1,9,0,10,0,9,0,7,4,17,0,97,7,3,0,4,0,9,0,9,0,9,0,9,0,9,0,9,0,5,0,3,7,61,0,66,1,8,0,10,0,10,0,10,0,10,0,10,0,8,1,11,0,10,0,10,0,10,0,10,0,10,0,11,1,26,0,52,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,41,0,62,1,11,0,10,0,10,0,10,0,10,0,10,0,11,1,8,0,10,0,10,0,10,0,10,0,10,0,8,1,30,0,122,1,8,0,1,
1,1,0,8,1,110,0,59,3,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,3,79,0,63,4,0,0,3,0,4,1,2,0,6,0,1,0,9,7,4,0,9,7,4,0,10,0,11,0,6,0,3,0,4,0,5,4,62,0,21,0,128,0,171,2,8,1,9,1,8,1,9,1,9,0,31,0,66,3,6,1,9,0,10,0,7,6,7,0,10,0,10,0,10,0,10,0,10,0,10,0,9,1,6,3,41,0,128,0,171,1,2,1,3,1,2,1,4,0,3,0,4,1,2,1,4,0,3,0,39,0,128,0,180,1,1,1,1,1,1,1,1,1,1,1,60,0,52,0,10,0,10,0,10,0,7,6,7,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,53,0,52,0,10,0,10,0,10,0,7,6,7,0,10,0,10,0,10,0,7,6,7,0,10,0,10,0,10,0,53,0,52,0,9,0,0,0,7,0,2,0,128,0,183,0,49,1,8,0,1,0,7,0,1,0,8,1,4,1,6,3,5,2,6,1,34,1,3,1,2,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,2,1,3,1,60,0,15,0,2,0,7,0,0,0,9,0,20,3,0,0,4,0,3,1,3,0,5,0,3,0,10,1,11,3,11,0,11,0,10,0,3,0,5,0,3,1,3,0,4,0,0,3,63,0,100,0,9,0,9,0,9,1,8,1,10,1,10,0,11,0,11,0,65,0,62,8,1,0,2,0,3,0,0,0,3,0,3,1,4,0,3,1,4,0,1,0,1,0,4,3,1,0,4,0,1,0,1,0,4,0,4,0,4,0,5,0,3,0,3,0,1,0,2,0,3,0,2,8,59,0,21,0,14,0,2,0,7,0,0,0,9,0,19,7,3,0,5,0,3,0,4,0,4,0,3,0,10,0,9,0,9,0,9,0,10,0,3,0,4,0,4,0,3,0,5,
0,3,7,61,0,21,0,21,0,52,2,9,1,9,1,10,1,9,1,10,0,128,0,146,0,51,2,8,1,9,1,8,1,9,1,9,0,128,0,151,0,48,1,2,1,5,1,2,1,5,0,3,0,5,1,2,1,5,0,3,0,128,0,157,0,51,1,2,1,3,1,2,1,4,0,3,0,4,1,2,1,4,0,3,0,128,0,159,0,99,2,7,4,6,4,6,4,7,2,112,0,128,0,132,8,121,0,128,0,131,11,119,0,48,1,1,0,2,0,1,1,128,0,135,0,59,4,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,2,0,0,0,0,0,2,0,2,0,2,0,1,2,0,2,0,2,128,0,143,0,50,0,2,0,7,0,0,0,9,0,20,4,0,0,3,0,4,1,3,0,5,0,4,4,11,0,11,0,3,0,5,0,3,1,3,0,4,0,0,3,63,0,101,0,11,0,11,0,10,1,10,1,8,1,9,0,9,0,9,0,64,0,98,1,2,1,3,0,1,0,0,0,1,0,1,0,3,0,3,0,0,0,3,0,3,0,0,0,3,5,0,0,3,0,5,0,3,0,6,0,1,0,0,0,2,0,2,1,2,2,60,0,21,0,51,0,2,0,7,0,0,0,9,0,18,7,3,0,4,0,9,0,9,0,9,0,9,0,9,0,9,0,5,0,3,7,61,0,27,1,1,1,5,1,1,1,14,3,2,3,1,0,6,0,3,0,4,0,5,0,2,0,7,0,0,0,8,0,0,0,9,0,10,0,10,0,10,0,10,0,8,4,62,0,128,1,7,0,100,2,8,2,45,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,16,0,65,0,10,0,10,0,8,4,5,0,3,0,4,0,10,0,10,0,11,0,3,0,6,3,9,0,10,0,64,0,62,2,7,1,1,0,6,0,2,0,6,0,10,0,11,0,8,5,7,0,10,0,10,0,9,0,4,0,3,7,62,0,86,0,0,2,
0,0,5,0,2,0,5,0,4,0,4,0,4,0,4,0,4,0,5,0,2,0,5,0,0,2,0,0,97,0,60,2,4,2,1,0,6,0,3,0,4,0,5,0,2,0,7,0,0,0,8,0,0,0,6,6,7,0,7,6,7,0,10,0,8,4,62,0,52,0,10,0,10,0,10,0,10,0,10,0,46,0,10,0,10,0,10,0,10,0,10,0,41,0,63,5,4,0,4,0,4,0,4,0,3,3,6,0,2,2,4,0,4,1,4,1,4,0,4,2,3,0,5,1,2,0,7,2,3,0,4,0,4,0,4,0,4,5,51,0,50,1,1,1,5,1,1,1,128,0,194,0,63,3,5,1,3,1,2,0,1,3,1,0,1,0,0,1,1,0,1,0,0,0,1,0,6,1,1,0,6,1,1,0,6,1,1,1,1,0,2,0,0,0,1,2,2,0,1,0,7,0,2,1,3,1,5,3,63,0,51,2,11,0,7,3,6,0,2,0,6,0,1,1,7,1,0,1,128,0,146,0,100,0,3,0,4,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,5,1,2,1,5,1,2,1,5,1,2,1,5,0,3,0,60,0,128,0,131,10,10,0,10,0,10,0,10,0,72,0,128,0,133,7,121,0,63,3,5,1,3,1,2,0,0,4,1,0,1,0,1,0,2,0,0,0,0,0,2,0,2,0,1,1,2,3,2,1,2,0,1,0,2,1,2,0,2,0,1,0,0,0,0,2,1,2,1,0,7,0,2,1,3,1,5,3,63,0,35,11,128,0,215,0,27,2,7,0,2,0,6,0,2,0,6,0,2,0,7,2,128,0,184,0,64,0,10,0,10,0,10,0,10,0,6,8,6,0,10,0,10,0,10,0,10,0,6,8,61,0,51,2,7,0,2,0,10,0,9,0,9,0,9,0,9,4,128,0,135,0,51,2,7,0,2,0,8,1,11,0,10,0,6,0,2,0,7,2,128,0,136,0,53,0,9,0,9,0,128,0,186,0,97,1,2,
1,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,2,1,5,3,0,1,4,0,10,0,10,0,10,0,19,0,51,7,2,0,1,0,1,0,3,0,2,0,1,0,3,0,2,0,1,0,3,0,2,0,1,0,4,0,1,0,1,0,5,2,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,4,3,1,2,47,0,114,1,9,1,128,0,134,0,128,0,209,0,10,1,10,0,8,2,15,0,53,0,8,2,10,0,10,0,10,0,10,0,8,4,128,0,134,0,51,3,6,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,6,3,128,0,147,0,96,0,3,0,5,1,2,1,5,1,2,1,5,1,2,1,5,1,2,1,3,1,2,1,3,1,2,1,3,1,2,1,4,0,3,0,64,0,49,0,8,2,10,0,10,0,7,0,1,0,6,0,2,0,4,1,1,4,1,0,8,1,1,1,4,0,2,0,0,0,2,1,2,0,1,0,7,4,9,0,9,2,59,0,49,0,8,2,10,0,10,0,6,1,1,0,5,0,3,0,3,1,2,4,0,0,0,2,4,1,0,0,2,0,2,0,6,0,1,0,6,0,9,0,9,0,9,4,59,0,48,2,7,0,2,0,10,0,8,1,6,0,3,0,3,1,0,0,2,0,2,0,3,2,2,0,8,1,1,1,4,0,2,0,0,0,2,1,2,0,1,0,7,4,9,0,9,2,59,0,99,2,8,2,45,0,10,0,8,1,8,0,10,0,10,0,4,0,5,0,3,0,6,3,15,0,15,0,11,0,11,0,18,4,9,1,8,0,1,0,7,0,1,0,7,0,1,0,6,0,3,0,5,0,3,0,4,7,3,0,5,0,3,0,5,0,2,0,7,0,0,3,3,3,59,0,18,0,9,0,9,0,19,4,9,1,8,0,1,0,7,0,1,0,7,0,1,0,6,0,3,0,5,0,3,0,4,7,3,0,5,0,3,0,5,0,2,0,7,0,0,3,3,3,59,
0,16,0,9,0,0,0,7,0,2,0,17,4,9,1,8,0,1,0,7,0,1,0,7,0,1,0,6,0,3,0,5,0,3,0,4,7,3,0,5,0,3,0,5,0,2,0,7,0,0,3,3,3,59,0,26,1,1,0,5,0,1,1,18,4,9,1,8,0,1,0,7,0,1,0,7,0,1,0,6,0,3,0,5,0,3,0,4,7,3,0,5,0,3,0,5,0,2,0,7,0,0,3,3,3,59,0,25,1,1,1,5,1,1,1,17,4,9,1,8,0,1,0,7,0,1,0,7,0,1,0,6,0,3,0,5,0,3,0,4,7,3,0,5,0,3,0,5,0,2,0,7,0,0,3,3,3,59,0,3,1,8,0,1,0,7,0,1,0,8,1,19,4,9,1,8,0,1,0,7,0,1,0,7,0,1,0,6,0,3,0,5,0,3,0,4,7,3,0,5,0,3,0,5,0,2,0,7,0,0,3,3,3,59,0,62,7,4,0,0,0,2,0,4,0,0,0,2,0,3,0,1,0,2,0,3,0,1,0,0,0,5,0,1,2,4,0,2,0,0,0,4,4,6,0,2,0,5,0,3,0,2,0,1,0,3,0,2,0,0,2,0,6,60,0,63,3,1,0,3,0,3,2,2,0,6,0,1,0,10,0,10,0,10,0,10,0,10,0,11,0,6,0,3,0,4,0,5,4,8,0,10,1,10,0,8,2,15,0,15,0,11,0,11,0,17,9,3,0,5,0,3,0,5,0,3,0,2,0,6,0,2,0,6,4,6,0,2,0,6,0,2,0,6,0,5,0,3,0,5,0,3,0,5,0,1,9,60,0,18,0,9,0,9,0,18,9,3,0,5,0,3,0,5,0,3,0,2,0,6,0,2,0,6,4,6,0,2,0,6,0,2,0,6,0,5,0,3,0,5,0,3,0,5,0,1,9,60,0,17,0,9,0,0,0,7,0,2,0,15,9,3,0,5,0,3,0,5,0,3,0,2,0,6,0,2,0,6,4,6,0,2,0,6,0,2,0,6,0,5,0,3,0,5,0,3,0,5,0,1,9,60,0,27,1,1,1,5,1,1,1,14,9,3,0,5,0,
3,0,5,0,3,0,2,0,6,0,2,0,6,4,6,0,2,0,6,0,2,0,6,0,5,0,3,0,5,0,3,0,5,0,1,9,60,0,15,0,11,0,11,0,18,6,7,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,7,6,62,0,18,0,9,0,9,0,19,6,7,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,7,6,62,0,16,0,9,0,0,0,7,0,2,0,17,6,7,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,7,6,62,0,26,1,1,1,5,1,1,1,16,6,7,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,10,0,7,6,62,0,61,6,5,0,4,0,4,0,4,0,4,0,5,0,3,0,5,0,2,4,2,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,4,0,4,0,4,0,3,6,62,0,27,1,1,0,5,0,1,1,15,3,3,2,2,1,4,0,3,0,0,0,3,0,3,0,0,0,3,0,3,0,1,0,2,0,3,0,1,0,2,0,3,0,2,0,1,0,3,0,2,0,1,0,3,0,3,0,0,0,3,0,3,0,0,0,3,0,4,1,2,2,3,1,61,0,15,0,11,0,11,0,20,3,6,0,3,0,4,0,5,0,2,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,2,0,5,0,4,0,3,0,6,3,63,0,18,0,9,0,9,0,21,3,6,0,3,0,4,0,5,0,2,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,2,0,5,0,4,0,3,0,6,3,63,0,17,0,9,0,0,0,7,0,2,0,18,3,6,0,3,0,4,0,5,0,2,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,2,0,5,0,4,0,3,0,6,3,63,0,27,1,1,0,5,0,1,1,19,3,6,0,3,0,4,0,5,0,2,
0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,2,0,5,0,4,0,3,0,6,3,63,0,26,1,1,1,5,1,1,1,18,3,6,0,3,0,4,0,5,0,2,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,1,0,7,0,2,0,5,0,4,0,3,0,6,3,63,0,98,0,3,0,6,0,1,0,8,1,9,1,8,0,1,0,6,0,3,0,98,0,63,3,1,0,3,0,3,1,3,0,4,1,2,1,4,0,0,0,1,0,4,0,1,0,1,0,3,0,2,0,1,0,2,0,3,0,1,0,2,0,3,0,1,0,1,0,3,1,2,1,4,0,3,1,3,0,3,0,1,3,4,0,57,0,15,0,11,0,11,0,17,2,3,2,2,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,4,0,3,0,6,3,63,0,18,0,9,0,9,0,18,2,3,2,2,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,4,0,3,0,6,3,63,0,17,0,9,0,0,0,7,0,2,0,15,2,3,2,2,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,4,0,3,0,6,3,63,0,26,1,1,1,5,1,1,1,15,2,3,2,2,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,4,0,3,0,6,3,63,0,18,0,9,0,9,0,18,3,2,3,1,0,6,0,3,0,4,0,5,0,2,0,7,0,0,0,8,0,0,0,9,0,10,0,10,0,10,0,10,0,8,4,62,0,60,5,7,0,10,0,10,5,5,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,5,5,0,10,0,8,5,64,0,51,2,7,0,2,0,6,0,2,0,6,0,2,
0,6,0,2,0,6,0,1,0,7,0,2,1,5,0,4,0,4,0,4,0,4,0,4,0,4,0,1,0,1,0,4,0,1,0,1,0,3,2,1,1,62,0,52,0,11,0,11,0,19,4,5,0,4,0,10,0,10,0,5,5,4,0,4,0,3,0,5,0,3,0,4,1,4,4,0,1,60,0,54,0,9,0,9,0,21,4,5,0,4,0,10,0,10,0,5,5,4,0,4,0,3,0,5,0,3,0,4,1,4,4,0,1,60,0,53,0,9,0,0,0,7,0,2,0,18,4,5,0,4,0,10,0,10,0,5,5,4,0,4,0,3,0,5,0,3,0,4,1,4,4,0,1,60,0,64,1,1,0,5,0,1,1,18,4,5,0,4,0,10,0,10,0,5,5,4,0,4,0,3,0,5,0,3,0,4,1,4,4,0,1,60,0,62,1,1,1,5,1,1,1,18,4,5,0,4,0,10,0,10,0,5,5,4,0,4,0,3,0,5,0,3,0,4,1,4,4,0,1,60,0,41,1,8,0,1,0,7,0,1,0,8,1,19,4,5,0,4,0,10,0,10,0,5,5,4,0,4,0,3,0,5,0,3,0,4,1,4,4,0,1,60,0,97,1,2,1,6,0,0,0,1,0,6,0,3,0,5,0,3,0,1,9,0,0,3,0,5,0,3,0,5,0,3,1,2,0,1,4,0,2,61,0,99,4,0,0,3,0,4,1,2,0,6,0,2,0,10,0,10,0,10,0,6,0,3,0,4,0,5,4,8,0,10,1,10,0,8,2,15,0,51,0,11,0,11,0,20,3,6,0,3,0,4,0,5,0,3,0,5,0,3,7,3,0,10,0,11,0,4,0,5,4,62,0,54,0,9,0,9,0,21,3,6,0,3,0,4,0,5,0,3,0,5,0,3,7,3,0,10,0,11,0,4,0,5,4,62,0,53,0,9,0,0,0,7,0,2,0,18,3,6,0,3,0,4,0,5,0,3,0,5,0,3,7,3,0,10,0,11,0,4,0,5,4,62,0,62,1,1,1,5,1,1,1,18,3,6,0,3,0,4,0,5,0,
3,0,5,0,3,7,3,0,10,0,11,0,4,0,5,4,62,0,50,0,11,0,11,0,19,3,10,0,10,0,10,0,10,0,10,0,10,0,10,0,6,8,61,0,52,0,9,0,9,0,21,3,10,0,10,0,10,0,10,0,10,0,10,0,10,0,6,8,61,0,51,0,9,0,0,0,7,0,2,0,18,3,10,0,10,0,10,0,10,0,10,0,10,0,10,0,6,8,61,0,61,1,1,1,5,1,1,1,17,3,10,0,10,0,10,0,10,0,10,0,10,0,10,0,6,8,61,0,51,1,0,1,7,2,6,1,1,0,11,0,5,3,1,0,3,0,3,2,2,0,5,1,2,0,6,0,2,0,6,0,2,0,6,0,2,0,5,0,4,0,4,0,5,4,63,0,64,1,1,0,5,0,1,1,16,1,0,2,6,1,2,0,5,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,4,0,3,2,2,2,60,0,52,0,11,0,11,0,19,4,5,0,4,0,3,0,6,0,2,0,6,0,2,0,6,0,2,0,6,0,2,0,6,0,3,0,4,0,5,4,62,0,54,0,9,0,9,0,21,4,5,0,4,0,3,0,6,0,2,0,6,0,2,0,6,0,2,0,6,0,2,0,6,0,3,0,4,0,5,4,62,0,53,0,9,0,0,0,7,0,2,0,18,4,5,0,4,0,3,0,6,0,2,0,6,0,2,0,6,0,2,0,6,0,2,0,6,0,3,0,4,0,5,4,62,0,64,1,1,0,5,0,1,1,18,4,5,0,4,0,3,0,6,0,2,0,6,0,2,0,6,0,2,0,6,0,2,0,6,0,3,0,4,0,5,4,62,0,63,1,1,1,5,1,1,1,17,4,5,0,4,0,3,0,6,0,2,0,6,0,2,0,6,0,2,0,6,0,2,0,6,0,3,0,4,0,5,4,62,0,88,1,9,1,30,7,30,1,9,1,76,0,99,3,1,0,2,1,3,1,2,1,4,1,2,0,4,0,1,0,1,0,2,1,2,0,1,0,1,
0,4,0,2,1,4,1,2,1,3,1,2,0,1,3,63,0,51,0,11,0,11,0,17,1,4,1,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,4,1,4,4,0,1,60,0,54,0,9,0,9,0,18,1,4,1,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,4,1,4,4,0,1,60,0,52,0,9,0,0,0,7,0,2,0,16,1,4,1,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,4,1,4,4,0,1,60,0,62,1,1,1,5,1,1,1,15,1,4,1,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,5,0,3,0,4,1,4,4,0,1,60,0,54,0,9,0,9,0,17,3,3,3,1,0,5,0,3,0,4,0,5,0,3,0,5,0,3,0,6,0,1,0,7,0,1,0,8,1,9,1,9,0,10,0,9,0,7,4,17,0,48,1,10,0,10,0,10,0,10,0,1,3,4,2,2,1,3,1,4,1,2,0,6,0,2,0,6,0,2,0,6,0,2,1,4,1,2,2,2,1,3,0,1,3,4,0,10,0,10,0,9,2,19,0,62,1,1,1,5,1,1,1,14,3,3,3,1,0,5,0,3,0,4,0,5,0,3,0,5,0,3,0,6,0,1,0,7,0,1,0,8,1,9,1,9,0,10,0,9,0,7,4,17,0,0,0);
{}//not used for Windows

//system variable support ------------------------------------------------------
var
   //.system state support
   siinited              :boolean=false;
   siclosing             :boolean=false;
   sicloseprompting      :boolean=false;//26aug2021
   sicloseviapostDONE    :boolean=false;
   sihalted              :boolean=false;
   app__initing          :boolean=false;//01jan2021
   app__running          :boolean=false;
   visyncing             :boolean=false;
   visyncid              :longint=0;//changes each time system updates - 13feb2022
   vimustsync            :boolean=false;
   vimustloadid          :boolean=false;
   visyssettingsloaded   :boolean=false;
   viprgsettingsloaded   :boolean=false;
   //.0 or 1 based string handling
   stroffset             :longint=1;//Win32
   //.gui support
   stschemedata          :string='';//for stsync
   stlastschemedata      :string='*';
   vidataid              :longint=0;//increments each time "visync" fires with new data
   viloadid              :longint=0;//increments each time "visync" fires due to siLoadsettings
   vinormal              :tvirtualinfo;//set by "stsync"
   vititle               :tvirtualinfo;
   vimorecolors          :tvirtualmorecolors;//25may2021
   vizoom__root          :longint=0;//automatic - 14mar2021
   vizoom                :longint=1;//read-only -> generated by "vizoom__root" with a range of 1..4 (100% to 400%) - 14mar2021
   vifontnameraw         :string='';//includes custom "?" - 26mar2022
   vifontnameraw2        :string='';//includes custom "?"
   vifontname            :string='';
   vifontname2           :string='';
   vifontsize__root      :longint=8;//used for system settings etc without scaling applied - 14mar2021
   vifontsize__root2     :longint=8;//used for system settings etc without scaling applied - 14mar2021
   vifontsize            :longint=8;
   vifontsize2           :longint=8;
   vifontheight          :word=14;
   vititleheight         :word=22;
   vititleheight2        :word=32;
   vilineheight          :longint=20;
   vilinevsp             :longint=2;
   viheadlarge           :boolean=true;//34 or 26 - 01mar2022
   viheadcenter          :boolean=false;//11oct2022
   viautoscroll          :boolean=true;//28sep2022
   vifontwidthratio      :single=1;//FontSize=8 is normal "1", larger fontsizes increase ratio and the reverse is true
   vitabratio            :single=1;//feeds from "viFontWidthRatio" but with safe range enforced
   viscrollsize__root    :longint=16;//14mar2021
   viscrollsize          :longint=16;
   viwheelspeed          :longint=1;
   vitouch               :boolean=false;
   vidoubleclicks        :boolean=true;
   viframemax            :boolean=false;//14mar2021
   vidragtrigger         :longint=20;//was 10px, now 20 pixels before "dragging=true" - 05sep2020, 31mar2020
   vidragtriggerfine     :longint=1;//2 pixels before "draggingfine=true" - 17may2020
   viround               :boolean=false;
   vidragfast            :boolean=false;
   visoftclose           :boolean=false;
   vifeather             :longint=1;//0=none, 1=low, 2=medium, 3=high
   vifeatherf            :longint=0;//0=off
   visafearea            :boolean=true;//28aug2020
   visplash              :boolean=true;//29aug2020
   vihelp                :boolean=false;
   viontop               :boolean=false;
   vihelp_bw             :boolean=false;//24jul2021
   vihelp_show           :boolean=false;//24jul2021
   vihelp_max            :boolean=false;//18dec2021, 24jul2021
   viecomode             :boolean=false;//09may2021
   vi32bit               :boolean=true;//09may2021
   vicoloriseimages      :boolean=false;
   vishadeglow           :boolean=false;//true=Win7 style shading - 12jun2022
   vishaderound          :boolean=true;
   vishadestyle          :string='g-50';
   vistartlink           :boolean=false;
   videsktoplink         :boolean=false;
   vienhanced            :boolean=true;
   vispecialcolors       :boolean=true;
   vicolorname           :string='';//default
   viclicklock           :boolean=false;//once a button is clicked down, it will always fire even if the mouse cursor on the up stroke is nowhere in the region of the original down click - 14mar2020
   visparkle             :longint=0;//0=off, 1..20=sparkle range
   vibordersize__temp    :longint=32;//default - 07jun2021
   vibordersize__root    :longint=5;//14mar2021
   vibordersize          :longint=5;
   viLockposition        :boolean=false;
   viWinemode            :longint=0;//02feb2022
   viWine                :boolean=false;//determines whether or not the system should use wine
   viminimal__scrollbar  :boolean=false;//08feb2022
   viSplashdone          :boolean=false;//system changes value to TRUE when splash has finished displaying OR it wasn't set to display on program stratup - 15mar2022
   //.midi device
   vimididevice          :longint=0;//05mar2022
   vimidideviceNEW       :longint=-1;//used to trigger an update to support controls etc - 05mar2022
   //.wave device
   viwavedevice          :longint=0;//05mar2022
   viwavedeviceNEW       :longint=-1;//used to trigger an update to support controls etc - 05mar2022
   //.frame support - 23feb2022
   viframename           :string='';
   viframeCODE           :tstr8=nil;
   viframeID             :longint=0;
   viFrameminsize        :longint=0;//for information purposes only - 27feb2022
   //.events
   visyncevent           :tnotifyevent=nil;
   //system vars
   programactivedebugger :boolean=false;

   //tdynamiclist and others - global "incsize" override for intial creation, allows for easy coordinated INCSIZE increase e.g. "incsize=10,000" for much better RAM usage - 22MAY2010
   globaloverride_incSIZE:longint=0;//set to 1 or higher to override controls (only when is first created)
   //64bit system timer - Delphi 3
   ms64init              :boolean=false;
   ms64LAST              :comp=0;
   ms64OFFSET            :comp=0;
   //idle trackers
   syskeytime            :comp=0;
   sysclicktime          :comp=0;
   sysmovetime           :comp=0;
   sysmovetime_global    :comp=0;
   sysmovetime_globalx   :longint=minint;
   sysmovetime_globaly   :longint=minint;
   sysdowntime           :comp=0;
   syswheeltime          :comp=0;
   //relative 64bit timer
   msr64__ref            :comp=0;
   msr64__speed          :longint=100;//10%...1,000% where 100% is normal speed - 20feb2021
   //.crc32 support
   sys_crc32             :array[0..255] of longint;
   sys_initcrc32         :boolean=false;
   //.ref support
   p4INT32               :array[0..32] of longint;
   p4CUR256              :array[0..256] of currency;
   //.temp buffer support
   systmpstyle           :array[0..99] of byte;//0=free, 1=available, 2=locked
   systmpid              :array[0..99] of string;//?????????????????????????//xxxxxxxxxxxxxxxx
   systmptime            :array[0..99] of currency;
   systmpbmp             :array[0..99] of tbasicimage;//23may2020
   systmppos             :longint;
   //.temp int buffer support
   sysintstyle           :array[0..99] of byte;//0=free, 1=available, 2=locked
   sysintid              :array[0..99] of string;//xxxxxxxxxxxxx//???????????????????
   sysinttime            :array[0..99] of currency;
   sysintobj             :array[0..99] of tdynamicinteger;
   sysintpos             :longint;
   //.temp byte buffer support
   sysbytestyle          :array[0..99] of byte;//0=free, 1=available, 2=locked
   sysbyteid             :array[0..99] of string;//xxxxxxxxxxxxxxx//???????????????????
   sysbytetime           :array[0..99] of currency;
   sysbyteobj            :array[0..99] of tdynamicbyte;
   sysbytepos            :longint;
   //ref65025_div_255
   ref65025_div_255      :array[0..65025] of byte;//06apr2017
   //tfilters
   fb255                 :array[-1024..1024] of byte;
   fbwrap255             :array[-1024..1024] of byte;
   //system debug support ------------------------------------------------------
   debug_msstart         :comp=0;
   debug_msstop          :comp=0;
   debug_mstimetotal     :comp=0;
   debug_mstimecount     :comp=0;
   debug_mstimetotal2    :comp=0;
   debug_mstimecount2    :comp=0;
   debug_mstimeavefast   :comp=0;
   debug_msstartave      :comp=0;
   debug_form            :array[0..49] of tobject;
   debug_info            :array[0..49] of string;
   debug_junk1           :string='';//22feb2022
   debug_junk2           :longint=0;//15mar2022
   debug_junk3           :comp=0;//22apr2022
   debug_junk4           :tobject=nil;//22apr2022
   //mis support
   system_default_ai     :tanimationinformation;//29may2019
   programdisablegraphics:boolean=false;//used to disable ALL graphic support for debug purposes
   //system translations
   tsBytes,tsB,tsKB,tsMB,tsGB:string;
   //system keybord support ----------------------------------------------------
   syskeyboard_laststate :byte=0;
   //system mouse support ------------------------------------------------------
   sysmouse_fine         :boolean=false;
   sysmouse_downxy       :tpoint=(x:0;y:0);
   sysmouse_movexy       :tpoint=(x:0;y:0);
   sysmouse_down         :boolean=false;
   //.used when "getcursorpos" is not possible - 10may2020
   miscursorpos_x        :longint=0;
   miscursorpos_y        :longint=0;
   //system font support -------------------------------------------------------
   sysfont_data          :array[0..39] of tstr8;//font data -> LGF
   sysfont_dref          :array[0..39] of tstr8;//data ref
   sysfont_time          :array[0..39] of currency;
   sysfont_avew          :array[0..39] of longint;
   sysfont_minw          :array[0..39] of longint;
   sysfont_maxw          :array[0..39] of longint;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//ffffffffffffffffffff
   //system menu support -------------------------------------------------------
   sysmenu_name          :array[0..19] of string;
   sysmenu_pos           :array[0..19] of longint;
   sysmenu_hover         :array[0..19] of longint;
   sysmenu_selstart      :array[0..19] of longint;
   sysmenu_selcount      :array[0..19] of longint;
   sysmenu_ref64         :array[0..19] of currency;
   //system support ------------------------------------------------------------
   sysprogram            :tbasicprg2=nil;//used for debugging etc - 21dec2021
   sysnewnameid          :longint=0;//unique system wide -> general purpose NAME BASED id -> range: 0..N -> used with "low__newnameid()" proc - 25jun2022
   sysnewid              :longint=0;//unique system wide -> general purpose id -> range: 0..N
   sysnewid1             :longint=1;//unique system wide -> general purpose id -> range: 1..N
   syscode               :longint=osNone;
   system_mustpaint      :longint=0;
   system_mustpaintSLOW  :longint=0;
   system_mustalign      :longint=0;
   system_mustid         :longint=0;
   system_mustidSLOW     :longint=0;
   system_program        :tobject=nil;//24jul2021
   system_winepresent    :boolean=false;//TRUE when Wine is detected, i.e we are running inside Wine on Linux - 02feb2022
   system_sysid32_tany   :longint=0;//used to assign a unique ID to each new copy of a "tany" object, designed for easier debugging specifically instance tracking as the ID is not copied or cloned between new instances or via any "man__" procs usage - 09feb2022
   system_instanceid     :longint=0;//set by "siInit"
   system_defaultcolors  :string='';//27mar2022
   system_storeapp       :boolean=false;//siInit detects status and sets to TRUE when this program is wrapped up/installed as a Micrsoft Windows Store App -> looks for "sys-<programname>.app" in the "BE\settings\" subfolder - 30mar2022
   system_paid           :boolean=false;//false=Free to Use, true=Licensed - 30mar2022
   system_onshowoptions1 :tnotifyevent=nil;//open
   system_onshowoptions2 :tnotifyevent=nil;//close
   system_onshowoptionsNEWWIDTH:longint=0;//optionally increase width of "Options" window - 06nov2022
   system_onshowoptionsNEWHEIGHT:longint=0;//optionally increase height of "Options" window - 06nov2022
   system_onshowoptionsCLOSEDELAY:longint=0;//optionally close dialog after X seconds - 12nov2022
   system_onshowoptionsINITPAGENAME:string='';//intital page name to show - 06nov2022

   //.realtime process (program) support - 25mar2022
   system_realtimeSYNCING:boolean=false;
   system_realtime64     :comp=0;//determines whether realtime mode should be ON or OFF
   system_realtime642    :comp=0;//time cycle before re-syncing realtime mode (incase Task Manager manually overrides us) - 25mar2022
   //.random sparkle shader list -> stores a list of random shades 0..100 - 27feb2022
   system_sparklelist   :array[0..9999] of byte;
   system_sparklepos    :longint=0;
   system_sparkleref    :longint=-1;
   system_sparklecount  :longint=0;//tracks number of times low__sparkfill fills the list - 27feb2022
   //.frame code slots
   system_framename     :array[0..99] of string;
   system_framecode     :array[0..99] of string;
   system_framecount    :longint=0;
   //system integrated status support - 04oct2022 ------------------------------
   sysstatus_fromfile               :longint=-1;//off
   sysstatus_tofile                 :longint=-1;
   sysstatus_encrypt                :longint=-1;
   sysstatus_blaizfolder            :longint=-1;//07oct2022
   sysstatus_blaizfolder_setpert    :boolean=false;
   sysstatus_painttime  :longint=350;//every 350ms
   //system debug support ------------------------------------------------------
   system_debugPaintcount:comp=0;
   system_debugPainttime :comp=0;
   system_debugwidth     :longint=0;
   system_debugheight    :longint=0;
   system_debug_testlock1:longint=0;
   system_debug_val1     :longint=0;
   system_debug_val2     :longint=0;
   system_debug_val3     :longint=0;
   system_debug_str1     :string='';
   system_debug_str2     :string='';
   //.system wide object tracking - 01may2021
   systrack_objcount     :longint=0;
   systrack_obj          :array[0..999] of tobject;
   systrack_ptrcount     :longint=0;
   systrack_ptr          :array[0..9999] of pointer;
   systrack_ptrbytes     :comp=0;//total memory allocated for pointers

   //system thread support -----------------------------------------------------
   //.core
   systhread_initall   :boolean=false;
   systhread_running   :array[0..9] of boolean;
   systhread_ready     :array[0..9] of boolean;
   systhread_muststop  :array[0..9] of boolean;
   systhread_handle    :array[0..9] of hwnd;
   systhread_id        :array[0..9] of longint;
   systhread_timerid   :array[0..9] of longint;
   systhread_timerms   :array[0..9] of longint;
   systhread_usingtimer:array[0..9] of boolean;
   systhread_fast64    :array[0..9] of comp;//0=use full specified speed, 1..N=use either full speed (if >=ms64FAST) or throttle back to slower speed when ( <ms64FAST) - 05mar2022
   //.lag time
   systhread_lag       :array[0..9] of comp;
   systhread_lastlag   :array[0..9] of comp;
   systhread_lagref    :array[0..9] of comp;
   systhread_ref1000   :array[0..9] of comp;
   //.io buffers
   systhread_bufferid  :array[0..9] of longint;//set by sender
   systhread_bufferid2 :array[0..9] of longint;//set by thread when it's read the buffer and then replied
   systhread_cmd       :array[0..9] of longint;//what to do with buffer -> send by sender
   systhread_bufferlen :array[0..9] of longint;
   systhread_buffer    :array[0..9] of tsysthread_buffer;

   //common global filenames ---------------------------------------------------
   sysfile_colorscheme          :string='';
   sysfile_teaimg               :string='';
   sysfile_teaimg_openfilter    :longint=0;//open filter index
   sysfile_cursor               :string='';
   sysfile_cursor_openfilter    :longint=0;

   //system handlers support ---------------------------------------------------
   system_options_str1   :string='';
   system_options_pos1   :longint=0;
   //.sound volume support
   sys_sndvol32          :string='';
   //.system flash support
   sysflash              :boolean=false;
   sysflash_timer        :comp=0;
   //.system close support
   syslist               :array[0..39] of tobject;
   sysclose_count        :longint=0;//low level version in addition to basicsystem.closelocked (count) - 03apr2021
   systimer_enabled      :boolean=true;
   syswait_focus         :tobject=nil;//used for tbasicsystem.xshowwait to set/detect if it's the main tbasicsystem in use, and whether to cancel any showing dialog windows etc -> prevents 2 or more simultanous tbasicsystem's from locking in a cyclic "xshowwait()" reference stall or unexpected behaviour - 03apr2021

   //special clipboard formats -------------------------------------------------
   cf_bwd                :word=0;//26sep2022
   cf_bwp                :word=0;

   //system  built-in drive ----------------------------------------------------
   sysdisk_inuse         :boolean=false;//not used by default
   sysdisk_char          :char='!';//e.g. "!:\"
   sysdisk_label         :string='Samples';//volume label
   sysdisk_name          :array[0..199] of string;
   sysdisk_data          :array[0..199] of tstr8;//nil by default
   sysdisk_date          :array[0..199] of tdatetime;
   sysdisk_readonly      :array[0..199] of boolean;

   //system fast references ----------------------------------------------------
   sysfast_root          :string='';
   sysfast_settings      :string='';
   sysfast_schemes       :string='';
   sysfast_startmenu     :string='';
   sysfast_desktop       :string='';
   sysfast_programs      :string='';
   sysfast_blaiz         :string='';

   //system dynamic tep's (tea) ------------------------------------------------
   syslist_tep20         :tstr8=nil;//list of dynamically allocated TEA images with a max size of 20w x 20h (smaller sizes allowed) - 06apr2021

   //system multi-tab support --------------------------------------------------
   //.optional -> used for general reference and return values for host application
   system_plus0          :array[0..programplusmax] of tobject;
   system_plus1          :array[0..programplusmax] of tobject;
   system_plus2          :array[0..programplusmax] of tobject;
   system_plus3          :array[0..programplusmax] of tobject;
   system_plus4          :array[0..programplusmax] of tobject;
   system_plus5          :array[0..programplusmax] of tobject;
   system_plus6          :array[0..programplusmax] of tobject;
   system_plus7          :array[0..programplusmax] of tobject;
   system_plus8          :array[0..programplusmax] of tobject;
   system_plus9          :array[0..programplusmax] of tobject;

   //system stats (internal dubugger support) ----------------------------------
   //.controls
   sysstats_total        :longint=0;//all instances counter
   sysstats_active       :array[0..satMax] of longint;
   sysstats_create       :array[0..satMax] of longint;
   sysstats_destroy      :array[0..satMax] of longint;
   sysstats_ratec        :array[0..satMax] of longint;//controls create/second
   sysstats_rated        :array[0..satMax] of longint;//controls destroyed/second
   //.special stat trackers -> use to hunt down any system leaks - 28jan2021
   sysleak_start         :array[0..29] of array[0..satMax] of longint;
   sysleak_stop          :array[0..29] of array[0..satMax] of longint;
   sysleak_label         :array[0..29] of string;
   sysleak_counter       :array[0..29] of longint;//this number is simply increment each time data is changed to indicate change (a cleaner and shorter alternative to ms64str) - 28jan2021
   sysleak_show          :boolean;

   //system settings -----------------------------------------------------------
   syssettings           :tvars8=nil;
   prgsettings           :tvars8=nil;
   //system cursor support -----------------------------------------------------
   syscursor_sizeref     :string='';//tracks change in Windows cursor size - 28may2022
   syscursor_name        :string='';
   syscursor_ref64       :comp=0;//5s
   syscursor_sizeref64   :comp=0;//5s - 28may2022
   syscursor_loadname    :string='';
   syscursor_loadid      :longint=0;

   //system timer --------------------------------------------------------------
   //.normal timer control - 30sep2021
   systimer_nomax64       :comp=0;//for checking D3's blank black form during program execution - 14may2022 
   systimer64             :comp=0;//normal timer - (16ms/turbo) or (30-500ms/normal)
   systimer_turbo64       :comp=0;//turbo booster option for normal timer
   systimer1000           :comp=0;
   systimerTICK           :comp=0;
   systimerLAG            :comp=0;
   systimerlasttick       :comp=0;
   systimerlastlag        :comp=0;
   systimerlagref         :comp=0;
   //..events
   systimer_owner        :array[0..199] of tobject;
   systimer_event        :array[0..199] of tnotifyevent;
   systimer_busy         :array[0..199] of boolean;
   systimer_delay        :array[0..199] of comp;
   systimer_ref64        :array[0..199] of comp;
   //.ultra timer control - realtime timer - 30sep2021
   sysfasttimerBUSY      :boolean=false;
   sysfasttimer64        :comp=0;//fast timer - (1ms or 50ms)
   sysfasttimer_on64     :comp=0;//on trigger for fast timer
   sysfasttimer1000      :comp=0;
   sysfasttimerTICK      :comp=0;
   sysfasttimerLAG       :comp=0;
   sysfasttimerlasttick  :comp=0;
   sysfasttimerlastlag   :comp=0;
   sysfasttimerlagref    :comp=0;
   //..booster support
   sysfasttimer_xcount   :longint=0;
   sysfasttimer_xtrigger :longint=1000;
   sysfasttimer_ycount   :longint=0;
   sysfasttimer_ytrigger :longint=100;
   //..events
   sysfasttimer1         :tnotifyevent=nil;
   sysfasttimer2         :tnotifyevent=nil;
   sysfasttimer3         :tnotifyevent=nil;
   //.high speed timer in use status - for all subsystems that adapt to higher speed timing cycles - 30sep2021
   sysfasttiminginuse    :boolean=false;


   //system dlg value caching --------------------------------------------------
   sysdlg_popcolor_color :longint=0;
   sysdlg_popcolor_page  :string='';
   //system history support ----------------------------------------------------
   syshis_nam:array[0..39] of string;
   syshis_val:array[0..39] of array[0..99] of string;//each value is NIL(not used), "A<value>" active, "N<normal>"
   syshis_ref1:array[0..39] of array[0..99] of longint;
   syshis_ref2:array[0..39] of array[0..99] of longint;
   syshis_last:longint=0;

   //system drop support -------------------------------------------------------
   sysdrop_shut       :boolean=false;
   sysdrop_showing    :boolean=false;
   sysdrop_code2      :string='';
   sysdrop_x          :longint=minint;
   sysdrop_y          :longint=minint;
   sysdrop_w          :longint=0;
   sysdrop_h          :longint=0;
   sysdrop_power255   :longint=190;//opacity
   sysdrop_lastarea   :trect;
   sysdrop_lastareaOK :boolean=false;
   sysdrop_mustpaint  :boolean=false;
   sysdrop_buffer     :tbmp=nil;
   sysdrop_image      :tbasicimage=nil;

   //memory mapped file support ------------------------------------------------
   sysmemfile_slotsinit     :boolean=false;
   sysmemfile_slots         :array[0..9] of thandle;
   sysmemfile_slotdata      :array[0..9] of pointer;
   sysmemfile_slotsize      :array[0..9] of longint;

   //link1 support -------------------------------------------------------------
   syslink1_slot            :longint=1;
   syslink1_hdrsize         :longint=15;//state.1 + reply.bol.1 + bol1.1 + int1.4 + nlen.4 + vlen.4 = 15 bytes
   syslink1_size            :longint=60015;//60k
   syslink1_startref64      :comp=0;
   syslink1_DEADPUSHref64   :comp=0;
   syslink1_DEADPULLref64   :comp=0;
   syslink1_pushbusy        :boolean=false;


//system status support --------------------------------------------------------
function sysstatus_settext(xindex:longint;xvalue:string):boolean;//07oct2022
function sysstatus_setpert(xpert:double):boolean;//07oct2022
function sysstatus_paintnow:boolean;//07oct2022
function sysstatus_stopped:boolean;//07oct2022
function sysstatus0(xindex:longint;xvalue:string):boolean;//07oct2022
function sysstatus(var xref64:comp;xindex:longint;xvalue:string):boolean;//04oct2022
function sysstatus2(var xref64:comp;xindex:longint;xvalue,xnewtitle:string;xnewpert:double):boolean;//07oct2022

//system procedures and functions ----------------------------------------------
//.system support
function low__ver:longint;
function low__verstr:string;
procedure low__centerform(x:tcustomform);
function low__newmsgwindow(xclassname:string;xowner:hwnd;xproc:twndmethod):hwnd;
procedure low__freewindow(var x:hwnd);
procedure low__wmerasebkgnd(xform:tobject;var message:twmerasebkgnd);
procedure low__wmmousewheel(xsystem:tbasicsystem;var message:tmessage);
//.system stats
procedure satinc(xindex,xcreate:longint);
function satval(xindex:longint):longint;
function satstr(xindex:longint):string;//value as str
function satlabel(x:longint):string;
function satsum:string;
//.system close support - 03apr2021
procedure low__sysadd(x:tobject);
procedure low__sysdel(x:tobject);
function low__closecount:longint;
procedure low__closelock;
procedure low__closeunlock;
//.system leak hunters
procedure leakhunt(x:longint;xlabel:string);//1..N => start tracking, -1..-N=stop tracking and show
function leakinfo(x:longint;var xdata:string):boolean;
//.other
function siFontname2_deffont:string;//12jun2022
function siFiltersettings(x:tvars8):boolean;
function siLoadsyssettings:boolean;
function siLoadprgsettings:boolean;
procedure siLoadsyssettingsfrom(x:tstr8);
procedure siLoadprgsettingsfrom(x:tstr8);
function siSavesyssettings:boolean;
function siSaveprgsettings:boolean;
procedure siSaveallsettings;//23mar2022
function sifindframe(xname:string):string;//07jun2022
procedure siframes;//loads frames into system storage ready for use - 27feb2022
procedure siInit;//low level version - 12sep2021, 10mar2020
procedure siCloseprompt(x:tbasicsystem);
procedure siClose;
procedure siHalt;
procedure viSyncandsave;//24jul2021
procedure viSync;
procedure vicopy(var s,d:tvirtualinfo);
//.security
procedure xcodecheck;//11oct2022
//procedure low__makecodecheck;


//system wide tracking procs - 01may2021 ------------------------------ TRACKING
//.pointer tracking
procedure ppadd(x:pointer);
procedure ppdel(x:pointer);
function ppok(x:pointer;xid:longint):boolean;
function ppnil(x:pointer;xid:longint):boolean;
procedure ppcheck(x:pointer;xid:longint);
procedure pperr(xreason,xlevel:string;x:pointer;xid:longint);
//.object tracking
procedure zzadd(x:tobject);
procedure zzdel(x:tobject);
procedure zzobjerr(xreason,xlevel,sclass2:string;xsatlabel,xid:longint);
function zzok(x:tobject;xid:longint):boolean;
function zzok2(x:tobject):boolean;
function zznil(x:tobject;xid:longint):boolean;
function zznil2(x:tobject):boolean;
function zzobj(x:tobject;xid:longint):tobject;
function zzobj2(x:tobject;xsatlabel,xid:longint):tobject;
function zzvars(x:tvars8;xid:longint):tvars8;
function zzstr(x:tstr8;xid:longint):tstr8;
//.tbasicimage
function zzimg(x:tobject):boolean;//12feb2202
function asimg(x:tobject):tbasicimage;//12feb2202
//.tany
function zzany(x:tobject):boolean;//13feb2202
function asany(x:tobject):tany;//13feb2202
{$ifdef jpeg}
function zzjpg(x:tjpegimage;xid:longint):tjpegimage;
{$endif}

//.idle trackers
function low__inputidle:comp;
function low__inputidle_nomove:comp;
function low__inputidle_nomove_nodown:comp;
function low__keyidle:comp;
function low__clickidle:comp;
function low__moveidle:comp;
function low__moveidle_global:comp;
function low__downidle:comp;
function low__wheelidle:comp;
function low__canecopaint(var xtime64:comp):boolean;
//.reset idle trackers
procedure low__resetkeytime;
procedure low__resetclicktime;
procedure low__resetmovetime;
procedure low__resetdowntime;
procedure low__resetwheeltime;
//.universial object destructor
procedure low__showhelp(dshow:boolean);
procedure low__createlink(df,sf,dswitches,iconfilename:string);//10apr2019, 14NOV2010
procedure runLOW(fDOC,fPARMS:string);//stress tested on Win98/WinXP - 27NOV2011, 06JAN2011, low__run(
function low__vol(var xfilename:string):boolean;//check once only - 10OCT2010
function low__canshowvol:boolean;//07mar2022
procedure low__showvol;
function stableobj(x:tobject):boolean;//07mar2021
function freeobj(x:pobject):boolean;//02feb2021, 05DEC2011, 14JAN2011, 15OCT2004
//.64bit timing
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
function ms64FAST:comp;//64bit millisecond system timer, 01-SEP-2006
function ms64:comp;//64bit millisecond system timer, 01-SEP-2006
function ms64str:string;//06NOV2010
//.relative 64bit timing
function msr64:comp;//relative 64bit millisecond system timer - 20feb2021
function msr64str:string;//20feb2021
procedure low__setmsr64(xnewtime64:comp;xnewspeed:longint);
//.now support
function nowmin:longint;//03mar2022
//.system object creators
function newmask8(w,h:longint):tmask8;
//.memory manager links
procedure low__newpstring(var z:pstring);//29NOV2011
procedure low__despstring(var z:pstring);//29NOV2011
function low__getmem(var p:pointer;size,xid:longint):boolean;//27apr2021, 29apr2020
function low__reallocmem(var p:pointer;oldsize,newsize,xid:longint):boolean;//27apr2021, 29apr2020
function low__reallocmemCLEAR(var p:pointer;oldsize,newsize,xid:longint):boolean;//29apr2021, 29NOV2011
function low__freemem(var x:pointer;oldsize,xid:longint):boolean;//27apr2021, 29apr2020
//.animation information handlers
function low__aicopy(var s,d:tanimationinformation):boolean;


//.keyboard support ------------------------------------------------------------
function low__shortcutOK(xcode:longint):boolean;//true=ak_key is assumed to be a shortcut key, false=else not
function low__akstr(xcode:longint;var xtext:string):boolean;//convert action key "ak*" -> "text char or text label" - 01apr2020
function low__akstrb(xcode:longint):string;//convert action key "ak*" -> "text char or text label" - 01apr2020
function low__keyboard__fromak(xcode:longint;var xctrl,xalt,xshift,xkeyx:boolean;var xkey:longint;var xhavekey:boolean):boolean;
function low__keyboard(xstyle:char;xkey:longint;xshift,xctrl,xalt:boolean;var xoutkey:longint):boolean;
function low__keyboard2(xstyle:char;xkey:longint;xshift,xctrl,xalt:boolean;var xoutkey:longint;var xlaststate:byte):boolean;


//.mouse support -> fine control - 17mar2020 -----------------------------------
procedure low__mousefine_turnon(x:boolean);
function low__mousefine:boolean;
function low__mouse(x:tobject;xstyle:string):tpoint;
procedure low__mouse2(x:tobject;xstyle:string;var dx,dy:longint);
function low__getcursorpos(var x:tpoint):boolean;
function low__getcursorposb:tpoint;
function low__getcursordownpos(var x:tpoint):boolean;
function low__getcursordownposb:tpoint;


//.drop support -> our version of drag and drop support - 26jul2021 ------------
//xxxxxxxxxxxxxxxxxxxxxxxxxx//ddddddddddddddddddddddddddddddddddddddddd
function drop_init(ximage:tobject;xcode2:string):boolean;
function drop_init2(ximage:tobject;xarea:trect;xcode2:string):boolean;
function drop_init3(ximage:tobject;xarea:trect;xcode2:string;xonce:boolean):boolean;
function drop_showing:boolean;
function drop_show(dx,dy:longint):boolean;
function drop_hide:boolean;
procedure drop_drawcancel;
function drop_draw(xscreenbuffer:tbmp;xscreencanvas:tcanvas):boolean;
function drop_draw2(xscreenbuffer:tbmp;xscreencanvas:tcanvas;var xundraw,xdraw:trect):boolean;
procedure drop_shut;


//.text picture support --------------------------------------------------------
function low__teamake(x:tobject;xout:tstr8;var e:string):boolean;
function low__teamake2(x:tobject;xver2,xtransparent,xsyscolors:boolean;xval1,xval2:longint;xout:tstr8;var e:string):boolean;//07apr2021
function low__teainfo(var adata:tlistptr;xsyszoom:boolean;var aw,ah,aSOD,aversion,aval1,aval2:longint;var atransparent,asyscolors:boolean):boolean;
function low__teainfo2(adata:tstr8;xsyszoom:boolean;var aw,ah,aSOD,aversion,aval1,aval2:longint;var atransparent,asyscolors:boolean):boolean;
function low__teadraw(xcolorise,xsyszoom:boolean;dx,dy,dc,dc2:longint;xarea,xarea2:trect;d:tobject;xtea:tlistptr;xfocus,xgrey,xround:boolean;xroundstyle:longint):boolean;//curved corner support - 07may2020, 09apr2020, 29mar2020
function low__teadraw2(xcolorise,xsyszoom:boolean;dx,dy,dc,dc2:longint;xarea,xarea2:trect;dbits,dw,dh:longint;drows24:pcolorrows24;drows32:pcolorrows32;xmask:tmask8;xmaskval:longint;xtea:tlistptr;xfocus,xgrey,xround:boolean;xroundstyle:longint):boolean;//curved corner support - 13may2020, 07may2020, 09apr2020, 29mar2020
function low__teatoraw24(xtea:tlistptr;xdata:tstr8;var xw,xh:longint):boolean;
function low__teaTLpixel(xtea:tlistptr):longint;//top-left pixel of TEA image - 01aug2020
function low__teaTLpixel2(xtea:tlistptr;var xw,xh,xcolor:longint):boolean;//top-left pixel of TEA image - 01aug2020
function low__teatoimg(xtea:tlistptr;d:tbasicimage;var xw,xh:longint):boolean;//23may2020
function low__teatobmp(sdata:tstr8;d:tbmp;var xw,xh:longint):boolean;//12apr2021, 21aug2020


//.gif support - 14may2022, 22sep2021, 28jul2021 ------------------------------------------------------
//compiler tag: "gif" check with need_gif
//cost: ?
function low__fromgif(x:tbmp;y:tstr8;var e:string):boolean;//28jul2021, 20JAN2012, 22SEP2009
function low__fromgif1(x:tbmp;y:tstr8;xuse32:boolean;var e:string):boolean;//28jul2021, 20JAN2012, 22SEP2009
function low__fromgif2(x:tbmp;y:tstr8;var xcellcount,xcellwidth,xcellheight,xdelay,xbpp:longint;var xtransparent:boolean;var e:string):boolean;//28jul2021, 20JAN2012, 22SEP2009
function low__fromgif3(x:tbmp;y:tstr8;var xcellcount,xcellwidth,xcellheight,xdelay,xbpp:longint;xuse32:boolean;var xtransparent:boolean;var e:string):boolean;//28jul2021, 20JAN2012, 22SEP2009
function low__togif(x:tobject;y:tstr8;var e:string):boolean;//11SEP2007
function low__togif2(x:tobject;xtranscol:longint;y:tstr8;var e:string):boolean;//permit transparent color override - 09sep2021, 11SEP2007
function low__togif3(x:tobject;xtranscol:longint;xlocalpalettes,xuse32:boolean;y:tstr8;var e:string):boolean;//14may2022 - now supports 32bit mask channel for transparency, 22sep2021 (now supports localpalettes - each cell of an animation has it's own separate color palette), 11SEP2007
{$ifdef gif}//these procs only enable when GIF is enabled for the program
procedure gif_decompress(x:tstr8);//28jul2021, 11SEP2007
procedure gif_decompressex(var xlenpos1:integer;x,imgdata:tstr8;_width,_height:integer;interlaced:boolean);//11SEP2007
function gif_compress(x:tstr8;var e:string):boolean;//12SEP2007
function gif_compressex(x,imgdata:tstr8;e:string):boolean;//12SEP2007
{$endif}

//.encryption support - 13jun2022 -----------------------------------------------------------------------
function low__encrypt(s:tstr8;xpass:string;xpower:longint;xencrypt:boolean;var e:string):boolean;
function low__encrypt2(s,d:tstr8;xpass:string;xpower:longint;xencrypt:boolean;var e:string):boolean;

//.system tab support -> use "tbXXX" codes for "xtab" to define which tab to use - 23feb2021
function low__tab(xtab,xcolindex,xfontheight:longint;var xcolalign,xcolcount,xcoltrim,xcolwidth,xtotalwidth,x1,x2:longint):boolean;//23feb2021


//.raw support -----------------------------------------------------------------
function low__imgdraw2432(s:tobject;stransparent:boolean;d:tobject;dx,dy,dswapblack:longint;dclip:trect;xgreyscale,xfocus:boolean):boolean;


//.font support -> LGF "linear graphic font" - 18apr2020, 08apr2020 ------------
function low__toLGF(xfontname:string;xfontsize:longint;xgreyscale,xbold:boolean;xdata:tstr8;var e:string):boolean;//$claude.* patch - 02feb2022
function low__fromLGF_height(x:tobject):longint;
function low__fromLGF_height1(x:tobject):longint;
function low__fromLGF_charw(x:tobject;xindex:longint):longint;
function low__fromLGF_textwidth(x,xtext:tobject):longint;
function low__fromLGF_textwidthTAB(xtab:longint;x,xtext:tobject):longint;
function low__fromLGF_textwidth2(x:tobject;xtext:string):longint;
function low__fromLGF_textwidthTAB2(xtab:longint;x:tobject;xtext:string):longint;
procedure low__fromLGF_avew(x:tobject;var xave,xmin,xmax:longint);//11apr2020
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//tttttttttttttttttttttttttttt
function low__fromLGF_drawchar2432(x:tobject;xindex,ax,ay,aw,ah,dcolor:longint;xarea,xarea2:trect;ar24:pcolorrows24;ar32:pcolorrows32;xmask:tmask8;xmaskval:longint;xfc:tstr8;xfeather:longint;xbold,xitalic,xunderline,xlink,xstrikeout,xround:boolean;xroundstyle:longint):boolean;//27feb2021, 23jan2020
function low__fromLGF_drawtext2432(x,xtext:tobject;ax,ay,aw,ah,dcolor:longint;xarea,xarea2:trect;ar24:pcolorrows24;ar32:pcolorrows32;xmask:tmask8;xmaskval:longint;xfc:tstr8;xfeather:longint;xbold,xitalic,xunderline,xlink,xstrikeout,xround:boolean;xroundstyle:longint):boolean;
function low__fromLGF_drawtext2432TAB(xtab:longint;x,xtext:tobject;ax,ay,aw,ah,dcolor:longint;xarea,xarea2:trect;ar24:pcolorrows24;ar32:pcolorrows32;xmask:tmask8;xmaskval:longint;xfc:tstr8;xfeather:longint;xbold,xitalic,xunderline,xlink,xstrikeout,xround:boolean;xroundstyle:longint):boolean;//23feb2021
function low__fromLGF_drawtext2432TAB2(xtab:longint;x,xtext:tobject;ax,ay,aw,ah,dcolor:longint;xarea,xarea2:trect;s:tobject;xmask:tmask8;xmaskval:longint;xfc:tstr8;xfeather:longint;xbold,xitalic,xunderline,xlink,xstrikeout,xround:boolean;xroundstyle:longint):boolean;//23feb2021


//.system font support ---------------------------------------------------------
function low__haveprinter:boolean;//03DEC2009 - safely check if we have a default printer, raises no error or "SPOOL32 error" on a Win98 machine
procedure low__fontlist(x:tstr8);//26mar2022
procedure low__fontlist2(x:tstr8;xscreen,xprinter:boolean);//26mar2022
function low__findfontname2(xname,xsysname,xsysname2:string;var xoutname:string):boolean;
function low__findfontname(xname:string;var xoutname:string):boolean;
function low__findfontnameb(xname:string):string;
function low__font0(xname:string;xsize:longint):longint;
function low__font1(xname:string;xsize:longint;xbold:boolean):longint;
function low__font2(xsysname,xname:string;xsize:longint;xbold:boolean):longint;
function low__font3(xsysname:string):longint;
function low__fontdata(xindex:longint):longint;
function low__fontmaxh(xindex:longint):longint;
function low__fontavew(xindex:longint):longint;
function low__fonttextwidth(xindex:longint;xtext:tobject):longint;
function low__fonttextwidth2(xindex:longint;xtext:string):longint;
function low__fonttextwidthTAB(xtab,xindex:longint;xtext:tobject):longint;//tab version
function low__fonttextwidthTAB2(xtab,xindex:longint;xtext:string):longint;//tab version
function low__fontcount:longint;
function low__fontbytes:longint;
function low__font(sstyle,ssysname,sname:string;xsize:longint;xgrey,xbold:boolean;xval:longint;var xoutval:longint):boolean;//05feb2022
procedure low__syszoom(var aw,ah:longint);
function low__syszoomlimit:longint;//15apr2021


//.0 and 1 based string handling support ---------------------------------------
//note: process strings consistently over zero-based systems (Android) and one-based systems (Windows)
function strbyte0(x:string;xpos:longint):byte;//1based always -> backward compatible with D3 - 02may2020
function strbyte1(x:string;xpos:longint):byte;//1based always -> backward compatible with D3 - 02may2020
function strbyte1x(var x:string;xpos:longint):byte;//1based always -> backward compatible with D3 - 02may2020
function strcopy0(x:string;xpos,xlen:longint):string;//0based always -> forward compatible with D10 - 02may2020
function strcopy0x(var x:string;xpos,xlen:longint):string;//0based always -> forward compatible with D10 - 02may2020
function strcopy1(x:string;xpos,xlen:longint):string;//1based always -> backward compatible with D3 - 02may2020
function strcopy1x(var x:string;xpos,xlen:longint):string;//1based always -> backward compatible with D3 - 02may2020
function strdel0(var x:string;xpos,xlen:longint):boolean;//0based
function strdel1(var x:string;xpos,xlen:longint):boolean;//1based
function strlastMatch(var x:string;xvaluetomatch:string):boolean;//07jan2022
function strlastx(var x:string):string;//returns last char of string or nil if string is empty
function strlast(x:string):string;//returns last char of string or nil if string is empty


//.number and string support ---------------------------------------------------
function createstringlist:tstringlist;//02feb2021
function createbitmap:tbitmap;
function createfilestream(x:string;xmode:word):tfilestream;
function low__programname:string;
function low__newtempname(dpre,dext:string):string;//temp filenames - 25jun2022
function low__newnameid(dpre,dext:string):string;//for temp filenames - 25jun2022
function low__newid:longint;
function low__newid1:longint;
function frcmin(x,min:longint):longint;//14-SEP-2004
function frcmin64(x,min:comp):comp;//24jan2016
function frccurmin(x,min:currency):currency;
function smallest(a,b:longint):longint;
function largest(a,b:longint):longint;
function largestrect(a,b:trect):trect;//12nov2017
function low__xyinarea(sx,sy:longint;xarea:trect):boolean;
function low__ptinarea(x:tpoint;xarea:trect):boolean;
function low__areaequal(a,b:trect):boolean;
function smallest64(a,b:comp):comp;
function largest64(a,b:comp):comp;
function largestcur(a,b:currency):currency;//20jan2016
function csmallestex(a:array of currency):currency;//22JAN2008
function clargestex(a:array of currency):currency;//22JAN2008
function frcmax(x,max:longint):longint;//14-SEP-2004
function frcmax64(x,max:comp):comp;//24jan2016
function restrict64(x:comp):comp;//24jan2016
function restrict32(x:comp):longint;//limit32 - 24jan2016
function low__sum32(x:array of longint):longint;
function frccurmax(x,max:currency):currency;
function frcrange(x,min,max:longint):longint;//13-SEP-2004
function frcrange2(var x:longint;xmin,xmax:longint):boolean;//29apr2020
function frcrange64(x,min,max:comp):comp;//24jan2016
function frcrangeex(x,min,max,defvalue:longint):longint;//14-JAN-2007
function frccurrange(x,min,max:currency):currency;//date: 02-APR-2004
function frcextmin(x,min:extended):extended;//07NOV20210
function frcextrange(x,min,max:extended):extended;//06JUN2007
function low__intr(x:longint):longint;//reverse longint
function low__wrdr(x:word):word;//reverse word
function low__posn(x:longint):longint;
procedure low__iroll(var x:longint;by:longint);//continuous incrementer with safe auto. reset
procedure low__croll(var x:currency;by:currency);//continuous incrementer with safe auto. reset
procedure low__roll64(var x:comp;by:comp);//continuous incrementer with safe auto. reset to user specified value - 05feb2016
function low__nrw(x,y,r:longint):boolean;//number within range
function low__udv(v,dv:string):string;//use default value
function low__thousands64(x:comp):string;//handles full 64bit whole number range of min64..max64 - 24jan2016
function low__64(x:comp):string;//handles full 64bit whole number range of min64..max64 - 24jan2016
function low__64ex(x:comp;xsep:boolean):string;//handles full 64bit whole number range of min64..max64 - 24jan2016
function low__mult64(xval,xval2:comp):comp;//multiply
function low__add64(xval,xval2:comp):comp;//add
function low__sub64(xval,xval2:comp):comp;//subtract
function low__sub32(xval,xval2:comp):longint;//30sep2022, subtract
function low__div64(xval,xdivby:comp):comp;//28dec2021, proper "comp division" -> fixes Delphi's "comp" division error -> which raises POINTER EXCEPTION and MEMORY ERRORS when used at speed and repeatedly - 13jul2021, 19apr2021
function low__div32(xval,xdivby:comp):longint;//proper "comp division" - 19apr2021
function low__pert32(xval,xlimit:comp):longint;//09sep2021
function low__makepertD0(xpos,xlen:longint):double;//06mar2022
function low__digpad20(v:comp;s:longint):string;//1 -> 01
function low__digpad11(v,s:longint):string;//1 -> 01
function rthtranslate(x:string):string;//31JAN2011, 05OCT2007 - don't translate, just mark the text for "sniffer", since text will be translated in realtime on demand
function ntranslate(x:string):string;//31JAN2011
function translate(x:string):string;//31JAN2011, 03NOV2010
function xlang(x:string):string;//06may2020
function low__uptime(xtime:comp;xforcehr,xforcemin,xshowms,xshowsec:boolean;xsep:string):string;//fixed - 27dec2021, fixed 10mar2021, 22feb2021, 22jun2018, 03MAY2011, 07SEP2007
function low__b(x:comp;sym:boolean):string;//fixed - 30jan2016
function low__bDOT(x:currency;sym:boolean):string;
function low__kb(x:currency;sym:boolean):string;
function low__kbb(x:currency;p:byte;sym:boolean):string;
function low__mb(x:currency;sym:boolean):string;//28MAR2010
function low__mbb(x:currency;p:byte;sym:boolean):string;//21APR2011
function low__gb(x:currency;sym:boolean):string;
function low__gbb(x:currency;p:byte;sym:boolean):string;
function low__mbAUTO(x:currency;sym:boolean):string;//auto range - 08DEC2011, 14NOV2010
function low__mbAUTO2(x:currency;p:byte;sym:boolean):string;//auto range - 08DEC2011, 14NOV2010
function low__mbAUTO3(x:currency;pKB,pMB,pGB:byte;sym:boolean):string;//auto range - 08DEC2011, 14NOV2010
function low__ipercentage(a,b:longint):extended;
function low__percentage64(a,b:comp):extended;//24jan2016
function low__percentage64str(a,b:comp;xsymbol:boolean):string;//04oct2022
function low__rateASstatus(_starttime64:currency;_totalBYTES:comp):string;
function low__rateASbytes32(_starttime64:currency;_totalBYTES:comp):longint;
procedure low__netencode_str(var x:string);
procedure low__netencode_strslash(var x:string;leaveslash:boolean);//12-jun-2006
function low__hexchar(x:byte):char;
function low__hex(x:byte):string;
function low__swapstrs(var x:string;a,b:string):boolean;
function low__firstline(var _data:string):string;//08oct2018
procedure low__checkfilebadchars(xfilename:string);//30jul2021
function low__findtext(var _pos:longint;var _data:string;_find:string):boolean;
function low__findtextL(var _pos:longint;_len:longint;var _data:string;_find:string):boolean;//22apr2014
function low__readline(var _pos,_start,_length:longint;var _data:string):boolean;
function low__readlineb(var _pos,_start,_length:longint;var _data:string;var _winrc:boolean):boolean;
function low__readlinec(var _pos,_start,_length:longint;var _data:string;_datalen:longint;var _winrc:boolean):boolean;//16may2022
function strint(x:string):longint;//skip over pluses "+" - 22jan2022, skip over commas - 05jun2021, date: 16aug2020, 25mar2016 v1.00.50 / 10DEC2009, v1.00.045
function low__lowercase(x:string):string;
function low__uppercase(x:string):string;
function low__aswin95(x:string):string;//31mar2021, 21-AUG-2004
function low__asname(x:string):string;//02mar2022
function cround(x:extended):currency;//19DEC2007
procedure safeinc(var x:longint);//16jun2014
function int32RANGE(x,xmin,xmax:comp):longint;
function int32(x:comp):longint;
function intstr64(x:comp):string;//30jan2017
function strint64(x:string):comp;//v1.00.035 - 05jun2021, v1.00.033 - 28jan2017
function curdec(x:currency;y:byte;xcomma:boolean):string;
function strdec(x:string;y:byte;xcomma:boolean):string;
function curcomma(x:currency):string;{same as "Thousands" but for "double"}
function curstrex(x:currency;sep:string):string;//01aug2017, 07SEP2007
function strcur(x:string):currency;//v1.00.070 - 07NOV2010
function curstr(x:currency):string;//27nov2017
function extstr(x:extended):string;//17sep2018
function bn(x:boolean):byte;
function bnc(x:boolean):char;
function nb(x:byte):boolean;
function nbs(x:string):boolean;
procedure swapchars(var x:string;a,b:char);//20JAN2011
function swapcharsb(x:string;a,b:char):string;
function low__lastext(x:string):string;//returns last extension - 03mar2021
function low__lastext2(x:string;xifnodotusex:boolean):string;//returns last extension - 03mar2021
function remlastext(x:string):string;//remove last extension
function readfileext(x:string;fu:boolean):string;{Date: 24-DEC-2004, Superceeds "ExtractFileExt"}
function lowercase__readfileext(x:string):string;//30jan2022
function scandownto(x:string;y,stopA,stopB:char;var a,b:string):boolean;
function fromnullstr(a:pointer;asize:longint):string;
function low__nullstr(x:longint;y:char):string;
function floattostrex2(x:extended):string;//19DEC2007
function floattostrex(x:extended;dig:byte):string;//07NOV20210
function strtofloatex(x:string):extended;//triggers less errors (x=nil now covered)
function low__remcharb(x:string;c:char):string;//26apr2019
function low__remchar(var x:string;c:char):boolean;//26apr2019
function low__rembinary(var x:string):boolean;//07apr2020
function low__rembinaryb(x:string):string;//07apr2020
function strint_filtered(x:string):longint;//removes "comma,space" automatically
function strint_filtered64(x:string):comp;//removes "comma,space" automatically
function low__point(x,y:longint):tpoint;
procedure low__minwh(var a:trect;aminwidth,aminheight:longint);//25feb2021
function nilrect:trect;
function nilarea:trect;//25jul2021
function maxarea:trect;//27jul2021
function validrect(x:trect):boolean;
function validarea(x:trect):boolean;//26jul2021
function low__shiftarea(xarea:trect;xshiftx,xshifty:longint):trect;
function low__withinrect(x,y:longint;z:trect):boolean;
function low__withinrect2(xy:tpoint;z:trect):boolean;
function low__withinrect2LR(xy:tpoint;z:trect):boolean;
function low__rect(xleft,xtop,xright,xbottom:longint):trect;
function low__rectgrow(x:trect;xby:longint):trect;//07apr2021
function low__rectstr(x:trect):string;
function low__ref32u(x:string):longint;{1..32}
function low__ref256(x:string):currency;
function low__ref256U(x:string):currency;
function low__cap2432(xpos,ypos,dw,dh:longint;d:tobject):boolean;//low version - 07mar2020, 30may2019, 21jan2015, 17-JAN-2007
function low__cap2432b(d:tobject):boolean;
function low__cap2432c(xpos,ypos,dw,dh,doutofrangeColor:longint;d:tobject):boolean;//low version - 09sep2021, 07mar2020, 30may2019, 21jan2015, 17-JAN-2007
function low__capcolor(xpos,ypos:longint;xfromcursor:boolean):longint;
function low__firstnbl(xdata,xoutdata:tstr8):boolean;//first non-blank line
function low__firstnbl2(xtext:string):string;
function low__nextline0(xdata,xlineout:tstr8;var xpos:longint):boolean;//17oct2018
function low__matchmask(var xline,xmask:string):boolean;//04nov2019
function low__matchmaskb(xline,xmask:string):boolean;//04nov2019
function low__matchmasklist(var xline,xmasklist:string):boolean;//04oct2020
function low__matchmasklistb(xline:string;var xmasklist:string):boolean;//04oct2020


//.compression support -> standard ZIP - 26jan2021
function low__compress(x:tstr8;var e:string):boolean;
function low__decompress(x:tstr8;var e:string):boolean;
function low__compress2(x:tstr8;var e:string;xcompress,xfast:boolean):boolean;//05feb2021


//.zero checkers - integrated debugging - 29jul2016 ----------------------------
function nozero(xdebugID,x:longint):longint;
function nozero_byt(xdebugID:longint;x:byte):byte;
function nozero_dbl(xdebugID:longint;x:double):double;
function nozero_ext(xdebugID:longint;x:extended):extended;
function nozero_cur(xdebugID:longint;x:currency):currency;
function nozero_sig(xdebugID:longint;x:single):single;
function nozero_rel(xdebugID:longint;x:real):real;
function nozero_cmp(xdebugID:longint;x:comp):comp;


//.platform support ------------------------------------------------------------
function low__plat(xcmd,xprgname:string;xrunaction:boolean):string;
function low__platroot:string;
function low__platfolder(xname:string):string;
function low__platsyssettings:string;//system settings
function low__platprgsettings:string;//prorgam settings - 05oct2020
function low__platimages:string;//images folder - 12feb2022
function low__plattemp:string;//tep folder - 19feb2022
function low__platonce:string;
function low__platactive:string;
function low__platsysext(xext:string):string;//29aug2021
function low__platprgext(xext:string):string;//29aug2021
function low__platDLLname(xname:string):string;//26sep2021


//.support checkers ------------------------------------------------------------
procedure need_chimes;//02mar2022
procedure need_mm;
procedure need_jpeg;
procedure need_gif;//cost: 13k - 31may2022
procedure need_ico;//cost: 6k - 07feb2022
function have_ico:boolean;//22may2022
procedure need_tbt;//13jun2022
procedure need_man;//cost: 4K - 09feb2022
procedure need_mfile;//cost: 4K - 09feb2022


//.color support ---------------------------------------------------------------
function low__rgb(r,g,b:byte):longint;
function low__rgb24(r,g,b:byte):tcolor24;
function low__rgb32to24(var x:tcolor32):tcolor24;//21jun2022
function low__rgb24to32(var x:tcolor24;xa:byte):tcolor32;//21jun2022
function low__rgba(r,g,b,a:byte):longint;
function low__colbright(x:longint):longint;
function low__colsplice(x,c1,c2:longint):longint;
function low__colsplice1(xpert:extended;s,d:longint):longint;//13nov2022
function low__rgbsplice24(xpert:extended;s,d:tcolor24):tcolor24;//17may2022
function low__sc(sc,dc,pert:longint):longint;//shift color
function low__sc1(xpert:extended;sc,dc:longint):longint;//shift color
function low__dc(x,y:longint):longint;//differential color
function low__cv(col,bgcolor,by:longint):boolean;//color visible
function low__ecv(col,bgcolor,by:longint):longint;//ensure color visible
function low__brightness(x:longint;var xout:longint):boolean;
function low__brightnessb(x:longint):longint;
function low__brightness2(x:longint;var xout:longint):boolean;
function low__brightness2b(x:longint):longint;
function low__invert(x:longint;var xout:longint):boolean;
function low__invert2(x:longint;xgreycorrection:boolean;var xout:longint):boolean;
function low__invertb(x:longint):longint;
function low__invert2b(x:longint;xgreycorrection:boolean):longint;
procedure low__int3toRGB(x:longint;var r,g,b:byte);
function low__intrgb(x:longint):tcolor24;
function low__intrgb32(x:longint;aval:byte):tcolor32;
function low__intrgba32(x:longint):tcolor32;
procedure low__blendcolor32(var f,b:tcolor32);//7,703ms -> 6,047ms -> 5,782ms -> 5,234 -> 3,781ms -> 3,875ms
function low__iseven(x:longint):boolean;
procedure low__msb16(var s:word);//most significant bit first - 22JAN2011
procedure low__msb32(var s:longint);//most significant bit first - 22JAN2011
function low__compare24(s,d:tcolor24):boolean;


//.system timer support --------------------------------------------------------
//uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//ttttttttttttttttttttttttttt
procedure low__timerflush;
function low__timerfound(xowner:tobject;x:tnotifyevent):boolean;
function low__timerset(xowner:tobject;x:tnotifyevent;xdelay:comp):boolean;//auto create/maintain a timer
function low__timerdelay(xowner:tobject;x:tnotifyevent;xnewdelay:comp):boolean;//set new delay of existing timer (if deleted, it won't be auto-created) - 19feb2021
function low__timerfinddelay(xowner:tobject;x:tnotifyevent;var xdelay:comp):boolean;
function low__timerdel(xowner:tobject;x:tnotifyevent):boolean;//delete timer


//xxxxxxxxxxxxxxxxxxxxxxxxxxxxx//fffffffffffffffffffffffff
//.fast timer support - non-threaded hyper-fast timer --------------------------
procedure fasttimer_ystep(xby:longint);
procedure fasttimer_ycheck;
procedure fasttimer_xstep(xby:longint);
procedure fasttimer_xcheck;


//.logic helpers support -------------------------------------------------------
//special note: low__true* and low__or* designed to execute ALL input values fully
//note: force predictable logic and proc execution by forcing ALL supplied inbound values to be fully processed BEFORE a result is returned, thus allowing for muiltiple and compled dynamic value processing and yet yeilding stable and consistent output
function low__true1(v1:boolean):boolean;
function low__true2(v1,v2:boolean):boolean;//all must be TRUE to return TRUE
function low__true3(v1,v2,v3:boolean):boolean;
function low__true4(v1,v2,v3,v4:boolean):boolean;
function low__true5(v1,v2,v3,v4,v5:boolean):boolean;
function low__or2(v1,v2:boolean):boolean;//only one must be TRUE to return TRUE
function low__or3(v1,v2,v3:boolean):boolean;//only one must be TRUE to return TRUE


//.misc support ----------------------------------------------------------------
function low__fireevent(xsender:tobject;x:tnotifyevent):boolean;
procedure low__swapbol(var x,y:boolean);//05oct2018
procedure low__swapbyt(var x,y:byte);//22jan2011
procedure low__swapint(var x,y:longint);
procedure low__swapcomp(var x,y:comp);//07apr2016
procedure low__swapcur(var x,y:currency);
procedure low__swapext(var x,y:extended);//06jun2007
function low__setobj(var xdata:tobject;xnewvalue:tobject):boolean;//15mar2021
function low__setbc(var xdata:tbasiccontrol;xnewvalue:tbasiccontrol):boolean;//15mar2021
function low__setstr(var xdata:string;xnewvalue:string):boolean;
function low__setcmp(var xdata:comp;xnewvalue:comp):boolean;//10mar2021
function low__setint(var xdata:longint;xnewvalue:longint):boolean;
function low__setbol(var xdata:boolean;xnewvalue:boolean):boolean;
function low__color(xname:string):longint;
function low__rgbint(x:tcolor24):longint;
function low__rgbaint(x:tcolor32):longint;
procedure low__greyscale(var x:tcolor24);
function low__greyscale2(var x:tcolor24):byte;
function low__greyscale2b(x:tcolor24):byte;
function low__greyscale3(x:longint):longint;
function low__greyscale4(x:longint):longint;
function low__focus3(x:longint):longint;
function low__rgbtohex(xrgb:longint):string;//ultra-fast int->hex color converter - 15aug2019
function low__hextorgb(sx:string;xdef:longint):longint;//12jan2022, 27feb2021
function low__rgbatohex(xrgba:longint;xhash:boolean):string;//ultra-fast int->hex color converter - 22jul2021
function low__hextorgba(sx:string;xdef:longint):longint;//27feb2021
function low__vifontscale(xwidth:longint):longint;//use to scale width of columns and height of other items according to current "vifontheight" setting based on a default value of "16"
function low__t(x:boolean):longint;
function low__maplist(const x:array of byte):tlistptr;
function low__maplist2(x:tstr8):tlistptr;//07apr2021
function low__compareint(x,xval:longint):boolean;
function low__strASarray__debugonly(xdata:string):string;
function low__year(xmin:longint):longint;
function low__yearstr(xmin:longint):string;
function low__leapyear(xyear:longint):boolean;
function low__monthdaycount0(xmonth,xyear:longint):longint;
function low__monthdayfilter0(xdayOfmonth,xmonth,xyear:longint):longint;
procedure low__scaledown(maxw,maxh,sw,sh:longint;var dw,dh:longint);//29jul2016
procedure low__scale(maxw,maxh,sw,sh:integer;var dw,dh:integer);//27feb2022
procedure low__orderint(var x,y:longint);
function low__insint(x:longint;y:boolean):longint;
function low__touchlarge:longint;
function low__touchnormal:longint;
function low__touchsmall:longint;
procedure low__winzoom(var dw,dh:longint);//20mar2021
procedure low__winzoom2(var dw,dh:longint;xminw,xminh:longint);//20mar2021
function low__findext(s:string;var xoutlabel,xoutext,xoutmask:string):boolean;
function low__forceext(xfilename,xforceext:string):string;
function low__forceext2(xfilename,xforceext:string;xappend:boolean):string;
function low__remdup(x:string):string;//remove duplicates
function low__remdup2(x:string;xremblanklines,xsort:boolean):string;//remove duplicates
function low__exename:string;
function low__ownname:string;
function low__paramstr1:string;
function low__limitlines(x:string;xlimit:longint):string;//14apr2021
function low__insstr(x:string;y:boolean):string;
function low__repeatstr(x:string;xcount:longint):string;//15nov2022
function low__swapvals0(x,v0:string):string;
function low__swapvals01(x,v0,v1:string):string;
function low__swapvals012(x,v0,v1,v2:string):string;
function low__swapvals0123(x,v0,v1,v2,v3:string):string;
function low__swapvals01234(x,v0,v1,v2,v3,v4:string):string;
function low__trimdec(x:string):string;//01aug2021
function low__urlok(xurl:string;xmailto:boolean):boolean;//19apr2021
function low__findchar(var x:string;c:char):longint;//27feb2021, 14SEP2007
function low__havechar(var x:string;c:char):boolean;//27feb2021, 02FEB2008
function low__havecharb(x:string;c:char):boolean;//09mar2021
function low__comparearray(a,b:array of byte):boolean;//27jan2021
function low__instouch(xval,xtouchval:longint):longint;//06may2020
function low__instouch2(xval,xtouchval:longint;xallowtouch:boolean):longint;//06may2020
function low__randomstr(x:tstr8;xlen:longint):boolean;
//clipboard support
//.wordcore
function low__copymulti(xformat:array of word;xdata:array of tstr8):boolean;
function low__copywordcore(xall:boolean;var x:twordcore):boolean;
function low__pasteformat(xformat:word;xout:tstr8):boolean;
//.text
function low__canpastetxt:boolean;//16mar2021
function low__pastetxt(xdata:tstr8):boolean;//16mar2021
function low__pastetxt2(var xdata:string):boolean;//16mar2021
function low__pastetxt2b:string;//25jul2021
function low__cancopytxt:boolean;//20mar2021
function low__copytxt(xdata:tstr8):boolean;
function low__copytxt2(var xdata:string):boolean;
function low__copytxt2b(xdata:string):boolean;
//.image
function low__canpasteimg:boolean;//07apr2021
function low__canpasteimg2(xfromimg:tobject):boolean;//12apr2021
function low__pasteimg(d:tbasicimage):boolean;//07apr2021
function low__pasteimg2(d:tbasicimage;xfromimg:tobject;xfit:boolean):boolean;//12apr2021
function low__pasteimg3(d:tbasicimage;xfromimg:tobject;xfit:boolean;xfitmaxW,xfitmaxH:longint):boolean;//14apr2021, 12apr2021
function low__cancopyimg:boolean;//12apr2021
function low__copyimg(d:tobject;xoptions:currency):boolean;//12apr2021
function low__copyimg2(d:tobject;ddw,ddh:longint;xoptions:currency;xmirror,xflip:boolean;xtransparentcolor,xfeather:longint;xtransframe:boolean):boolean;//18jun2021, 07jun2021, 02jun2021
function low__copyimgto(s,d:tbasicimage;xoptions:currency):boolean;//18jun2021
function low__copyimgto2(s,d:tbasicimage;ddw,ddh:longint;xoptions:currency;xmirror,xflip:boolean;xtransparentcolor,xfeather:longint;xtransframe:boolean;var dtranscol:longint):boolean;//07jun2021, 02jun2021

//error messages
function gec__taskfailed(var e:string):boolean;//pass-thru support
//tep handling
function tep__tick(x:boolean):longint;//colored arrow
function tep__tick2(x:boolean):longint;//font colored circle
function tep__tick3(x:boolean):longint;//font colored square
function tep__yes(x:boolean):longint;


//-- Multimedia Support --------------------------------------------------------
//Note: requires "gossmm" unit to work
//compiler tag: "mm" check with need_mm
//cost: ?
//.core
procedure mm_init;
procedure mm_shut;
function mm_ok:boolean;
function mm_inited:boolean;

//.use with "tbasicnav" and optional "tbasicjump" for a complete play management setup - 22feb2022
function mm_playmanagement_init(var xmuststop,xmustplay,xplaying:boolean;var xmustpertpos:double;var xmustpos,xlastpos:longint;var xlastfilename:string):boolean;
function mm_playmanagement(xstyle:string;xmode,xintroms:longint;var xmuststop,xmustplay,xplaying,xhostupdate:boolean;var xmustpertpos:double;var xmustpos,xlastpos:longint;var xlastfilename:string;xnav:tbasicnav;xplaylist:tbasicmenu;xplaylistmask:string;xjump:tbasicjump):boolean;

//.wave support
function wav_ok:boolean;
function wav_vol:longint;
function wav_setvol(x:longint):boolean;
procedure wav_devicelist;
function wav_deviceindex:longint;
function wav_setdeviceindex(x:longint):boolean;
function wav_devicelimit:longint;
function wav_devicecount:longint;//exclude wave mapper
function wav_deviceok(xindex:longint):boolean;
function wav_devicename(xindex:longint;xdefval:string):string;
function wav_flush44:boolean;
function wav_push44(x:tstr8):boolean;
function wav_len44:longint;

//.midi support
function mid_ok:boolean;
procedure mid_devicelist;
function mid_canstop:boolean;
procedure mid_stop;
function mid_canplay:boolean;
procedure mid_play;
function mid_canplaymidi:boolean;
function mid_playmidi(xmiddata:tstr8):boolean;
function mid_playfile(xfilename:string):boolean;
function mid_speed:longint;
function mid_speed2:longint;
function mid_setspeed(x:longint):boolean;
function mid_setspeed2(x:longint):boolean;
function mid_style:longint;
function mid_setstyle(x:longint):boolean;
function mid_deviceindex:longint;
function mid_setdeviceindex(x:longint):boolean;
function mid_devicelimit:longint;//exclude midi mapper
function mid_devicecount:longint;//exclude midi mapper
function mid_deviceok(xindex:longint):boolean;
function mid_devicename(xindex:longint;xdefval:string):string;
function mid_seeking:boolean;
function mid_vol:longint;//system volume
function mid_vol1:longint;//modifies volume of notes
function mid_vol2:longint;//modifies volume of notes
function mid_setvol(x:longint):boolean;
function mid_setvol1(x:longint):boolean;//modifies volume of notes
function mid_setvol2(x:longint):boolean;//modifies volume of notes
function mid_canpertpos:boolean;//true=system supports percentage positioning, else not - 06mar2022
function mid_pos:longint;
function mid_pertpos:double;
function mid_setpos(x:longint):boolean;
function mid_setpertpos(x:double):boolean;
function mid_len:longint;
function mid_lyriccount:longint;//24feb2022
function mid_lyric(xpos:longint;xshowsep:boolean):string;
function mid_format:longint;
function mid_tracks:longint;
function mid_msgs:longint;//total number of messages in midi
function mid_msgssent:longint;//number of message sent to midi hardware
function mid_lag:longint;
function mid_bytes:longint;//size of midi in bytes
function mid_midbytes:longint;//size of midi in bytes
function mid_phandle:longint;//handle of midi device
function mid_deviceactive:boolean;//have access to midi device - 15apr2021
function mid_usingtimer:boolean;
function mid_playing:boolean;
function mid_keepopen:boolean;
function mid_setkeepopen(x:boolean):boolean;
function mid_loop:boolean;
function mid_setloop(x:boolean):boolean;

//.chimes support - 09nov2022
function chm_ok:boolean;
function chm_info(xindex:longint;var xname:string;var xstyle,xtep:longint;var xintro,xdong,xdong2:tstr8):boolean;
function chm_findname(xname:string;var xindex:longint):boolean;
function chm_safename(xname,xdefname:string):string;//15nov2022
function chm_count:longint;//total count
function chm_numberfrom1:longint;//standard count - 09nov2022
function chm_numberfrom2:longint;//ships bells count - 09nov2022
function chm_numberfrom3:longint;//grande sonnerie count - 09nov2022
function chm_name(xindex:longint):string;
function chm_canintro(xindex:longint):boolean;
function chm_candong(xindex:longint):boolean;
function chm_candong2(xindex:longint):boolean;
function chm_canstop:boolean;
procedure chm_stop;
function chm_chimingpert:double;
function chm_chiming:boolean;
function chm_playing:boolean;//same as "chm_chiming" - 02mar2022
function chm_testing:boolean;
function chm_mustplayname(xname:string;xmins:longint):boolean;
function chm_mustplayindex(xindex,xmins:longint):boolean;
function chm_canplay:boolean;
procedure chm_playname(xname:string;xmins:longint;x0,x15,x30,x45,xtest:boolean);
procedure chm_playname2(xname:string);
procedure chm_playname3(xname:string;xmins:longint;n0,n15,n30,n45,b0,s0,s15,s30,s45,xtest:boolean);
procedure chm_playindex(xindex,xmins:longint;x0,x15,x30,x45,xtest:boolean);
procedure chm_playindex2(xindex:longint);
function chm_buzzercount:longint;
function chm_buzzer:longint;//0=off
procedure chm_setbuzzer(x:longint);
function chm_buzzerlabel(x:longint):string;
function chm_vol:longint;//chimes volume, not buzzer
procedure chm_setvol(x:longint);//chimes volume, not buzzer

//.mm "mci" support -> microsoft support
//function mm_ok:boolean;
function mm_canstop:boolean;
procedure mm_stop;
function mm_canplay:boolean;
function mm_play:boolean;
function mm_playfile(xfilename:string):boolean;
function mm_bytes:longint;
function mm_seeking:boolean;
function mm_canpertpos:boolean;//true=system supports percentage positioning, else not - 06mar2022
function mm_pos:longint;
function mm_setpos(x:longint):boolean;
function mm_setpertpos(x:double):boolean;//06mar2022
function mm_len:longint;
function mm_deviceactive:boolean;//have access to midi device - 15apr2021
function mm_playing:boolean;
function mm_loop:boolean;
function mm_setloop(x:boolean):boolean;
function mm_autostop:boolean;
function mm_setautostop(x:boolean):boolean;
function mm_mode:tmmodes;
function mm_state:byte;

//history support --------------------------------------------------------------
function his__found(xname:string):boolean;
function his__find(xname:string;var xindex:longint):boolean;
function his__clear(xname:string):boolean;
//.prev
function his__canprev(xname:string):boolean;
function his__prev(xname:string;var xoutval:string;xmove:boolean):boolean;
function his__prev2(xname:string;var xoutval:string;var v1,v2:longint;xmove:boolean):boolean;
//.next
function his__cannext(xname:string):boolean;
function his__next(xname:string;var xoutval:string;xmove:boolean):boolean;
function his__next2(xname:string;var xoutval:string;var v1,v2:longint;xmove:boolean):boolean;
//.active
function his__active(xname:string;var xoutval:string):boolean;
function his__active2(xname:string;var xoutval:string;var v1,v2:longint):boolean;
function his__setactiveref(xname:string;v1,v2:longint):boolean;//sets ref of active item
//.add
function his__add(xname,xval:string):boolean;
function his__add2(xname,xval:string;v1,v2:longint;xstorev12:boolean):boolean;


//system disk support ----------------------------------------------------------
procedure dk_init(xnewlabel:string);
function dk_findnext(var xpos:longint;xfolder:string;xfolders,xfiles:boolean;var xoutname,xoutnameonly:string;var xoutfolder,xoutfile:boolean;var xoutdate:tdatetime;var xoutsize:longint;var xoutreadonly:boolean):boolean;
function dk_havescope(xname:string):boolean;
function dk_makefolder(xname:string;var e:string):boolean;
function dk_folderexists(xname:string):boolean;
function dk_fileexists(xname:string):boolean;
function dk_find(xname:string;xcreatenew:boolean;var xindex:longint):boolean;
function dk_remfile(xname:string):boolean;
function dk_tofile(xname:string;xdata:tstr8;var e:string):boolean;//30sep2021
function dk_tofile2(xname:string;xdata:array of byte;var e:string):boolean;//14apr2021
function dk_fromfile(xname:string;xdata:tstr8;var e:string):boolean;

//ecap + stdencrypt - 19aug2020
function low__stdencrypt(x,ekey:tstr8;mode1:longint):boolean;//updated 19aug2020
function low__glseEDK:tstr8;
function low__ecapk:tstr8;
function low__ecap(x:tstr8;e:boolean):boolean;
function low__ecapbin(x:tstr8;e,bin:boolean):boolean;
function low__aorb(a,b:longint;xuseb:boolean):longint;
function low__aorbcur(a,b:currency;xuseb:boolean):currency;//07oct2022
function low__yes(x:boolean):string;//16sep2022
function low__aorbstr(a,b:string;xuseb:boolean):string;
function low__aorbchar(a,b:char;xuseb:boolean):char;
function low__aorbbol(a,b:boolean;xuseb:boolean):boolean;
//special unlock support for Ethan Ashman Electronic Book - 19aug2020, 05mar2018
function low__xysort(xstyle:longint;xdata,x:tstr8):boolean;
function low__xysort2(xstyle:array of byte;xdata,x:tstr8):boolean;
//.encrypt
function low__lestrb(x:tstr8):tstr8;//lite-encoder
function low__lestr(x:tstr8):boolean;//lite-encoder
function low__cestrb(x:tstr8):tstr8;//lite-decoder
function low__cestr(x:tstr8):boolean;//critical-encoder
function low__cemix(x:tstr8):boolean;//critical-encoder dual layer
function low__cemixb(x:tstr8):tstr8;//critical-encoder dual layer
function low__cemixc(x:string;xasarray:boolean):string;//critical-encoder dual layer
//.decrypt
function low__ldstrb(x:tstr8):tstr8;//lite-decoder
function low__ldstr(x:tstr8):boolean;//lite-decoder
function low__cdstrb(x:tstr8):tstr8;//lite-decoder
function low__cdstr(x:tstr8):boolean;//critical-decoder
function low__cdstr2(x:tstr8;xshow,xclose:boolean):boolean;//critical-decoder BUT doesn't shutdown! - 09nov2019, 08mar2018
function low__cdmix(x:tstr8):boolean;//critical-decoder dual layer
function low__cdmixb(x:tstr8):tstr8;//critical-decoder dual layer
//.make value checkers -> these generate a code that represents a value
function amakecheck(x:array of byte):longint;
function smakecheck(x:string):longint;
function imakecheck(x:longint):longint;
function xmakecheck(x:tstr8):longint;
//.value checkers -> these check a value against a "check code" (from make above)
procedure acheck(x:array of byte;xuserval:longint);
function scheck(x:string;xuserval:longint):boolean;
procedure icheck(x,xuserval:longint);
function xcheck(x:tstr8;xuserval:longint):boolean;

//.crc32 support
procedure low__initcrc32;
procedure low__crc32inc(var _crc32:longint;x:byte);//23may2020, 31-DEC-2006
procedure low__crc32(var _crc32:longint;x:tstr8;s,f:longint);//31-DEC-2006, updated 27-MAR-2007
function low__crc32c(x:tstr8;s,f:longint):longint;
function low__crc32b(x:tstr8):longint;
function low__crc32nonzero(x:tstr8):longint;//02SEP2010
function low__crc32seedable(x:tstr8;xseed:longint):longint;//14jan2018


//protect support --------------------------------------------------------------
function protect_text(xcode:longint;xtext:string):string;


//draw support -----------------------------------------------------------------
function tepext(xfilenameORext:string):longint;
function tepext2(xfilenameORext:string;xdeftep:longint):longint;
function tepext3(xfilenameORext:string;xdeftep:longint;var xfound:boolean):longint;
function tepfindbyname(xname:string;var xindex:longint):boolean;
function tepfound(xindex:longint):boolean;
function tepfind(xindex:longint;var xdata:tlistptr):boolean;
function tepfind2(xindex:longint):tlistptr;
function tepfind3(xindex:longint;var xdata:tlistptr;xmusthavedata:boolean):boolean;//16sep2022
function tepinfosys(xindex:longint;var aw,ah:longint;var xtransparent,xsyscolors:boolean):boolean;//14mar2021
function tepinfo(xindex:longint;xsyszoom:boolean;var aw,ah:longint;var xtransparent,xsyscolors:boolean):boolean;
function tepinfo2(xindex:longint;xsyszoom:boolean;var adata:tlistptr;var aw,ah:longint;var xtransparent,xsyscolors:boolean):boolean;
function tepdraw(xindex:longint;xsyszoom:boolean;dx,dy,dc,dc2:longint;xarea,xarea2:trect;d:tobject;xfocus,xgrey,xround:boolean;xroundstyle:longint):boolean;
function tepdraw2(var xdata:tlistptr;xsyszoom:boolean;dx,dy,dc,dc2:longint;xarea,xarea2:trect;d:tobject;xfocus,xgrey,xround:boolean;xroundstyle:longint):boolean;
function low__tepdata(xname:string;var xdata:tstr8;var xw,xh:longint;var e:string):boolean;//07jan2022
//.system dynamically allocated TEA's -> ma xof 20w x 20h - 06apr2021
function tep__find20(xindex:longint;var xdata:tlistptr):boolean;
function tep__addone20(xownerid:longint;xdata:tstr8;var xtep:longint):boolean;
procedure tep__delall20(xownerid:longint);


//system object checkers -------------------------------------------------------
function sbwpok(x:tobject):boolean;
function sbwp(x:tobject):tbasicbwp;


//graphics subsystem support ---------------------------------------------------
//note: mis stands for "multi-image support" -> most "mis" procs support multiple image objects such as tbasicimage, tbmp, tbitmap etc -> mainly used for tbasicimage (system independent)
//.canvas support
function misset_brushcolor(x:tobject;xval:longint):boolean;
function misset_brushclear(x:tobject;xval:boolean):boolean;
function misset_fontcolor(x:tobject;xval:longint):boolean;
function misset_fontname(x:tobject;xval:string):boolean;
function misset_fontsize(x:tobject;xval:longint):boolean;
function misset_fontheight(x:tobject;xval:longint):boolean;
function misset_fontstyle(x:tobject;xbold,xitalic,xunderline,xstrikeout:boolean):boolean;
function misset_textextent(x:tobject;xval:string):tpoint;
function misset_textwidth(x:tobject;xval:string):longint;
function misset_textheight(x:tobject;xval:string):longint;
function mis_textrect(x:tobject;xarea:trect;dx,dy:longint;xval:string):boolean;
//.image support
function misbitmap(dbits,dw,dh:longint):tbitmap;//Note: Only format that can be relied upon is 32bit under Android via FireMonkey - 21aug2020
function misbitmap32(dw,dh:longint):tbitmap;
{$ifdef jpeg}
function misjpg:tjpegimage;//01may2021
{$endif}
function misbmp(dbits,dw,dh:longint):tbmp;
function misbmp32(dw,dh:longint):tbmp;
function misbmp24(dw,dh:longint):tbmp;
function misimg(dbits,dw,dh:longint):tbasicimage;
function misimg8(dw,dh:longint):tbasicimage;//26jan2021
function misimg24(dw,dh:longint):tbasicimage;
function misimg32(dw,dh:longint):tbasicimage;
function misv(s:tobject):boolean;//valid
function misb(s:tobject):longint;//bits 0..N
procedure missetb(s:tobject;sbits:longint);
function missetb2(s:tobject;sbits:longint):boolean;
function misf(s:tobject):longint;//color format
function misw(s:tobject):longint;
function mish(s:tobject):longint;
function miscells(s:tobject;var sbits,sw,sh,scellcount,scellw,scellh,sdelay:longint;var shasai:boolean;var stransparent:boolean):boolean;//27jul2021
function miscellsFPS10(s:tobject;var sbits,sw,sh,scellcount,scellw,scellh,sfps10:longint;var shasai:boolean;var stransparent:boolean):boolean;//27jul2021
function miscell(s:tobject;sindex:longint;var scellarea:trect):boolean;
function miscell2(s:tobject;sindex:longint):trect;
function miscellarea(s:tobject;sindex:longint):trect;
function misonecell(s:tobject):boolean;//26apr2022
function mishasai(s:tobject):boolean;
function misaiclear(var x:tanimationinformation):boolean;
function misaiclear2(s:tobject):boolean;
function misai(s:tobject):panimationinformation;
function misaicopy(s,d:tobject):boolean;
function miscopy(s,d:tobject):boolean;//12feb2022
function misokex(s:tobject;var sbits,sw,sh:longint;var shasai:boolean):boolean;
function misok(s:tobject;var sbits,sw,sh:longint):boolean;
function misokk(s:tobject):boolean;
function misokai(s:tobject;var sbits,sw,sh:longint):boolean;
function misokaii(s:tobject):boolean;
function misok8(s:tobject;var sw,sh:longint):boolean;
function misokai8(s:tobject;var sw,sh:longint):boolean;
function misok24(s:tobject;var sw,sh:longint):boolean;
function misokk24(s:tobject):boolean;
function misokai24(s:tobject;var sw,sh:longint):boolean;
function misok824(s:tobject;var sbits,sw,sh:longint):boolean;
function misok82432(s:tobject;var sbits,sw,sh:longint):boolean;
function misokk824(s:tobject):boolean;
function misokk82432(s:tobject):boolean;
function misokai824(s:tobject;var sbits,sw,sh:longint):boolean;
function mismustlock(s:tobject):boolean;
function mislock(s:tobject):boolean;
function misunlock(s:tobject):boolean;
function mislocked(s:tobject):boolean;//27jan2021
function misinfo(s:tobject;var sbits,sw,sh:longint;var shasai:boolean):boolean;
function misinfo2432(s:tobject;var sbits,sw,sh:longint;var shasai:boolean):boolean;
function misinfo82432(s:tobject;var sbits,sw,sh:longint;var shasai:boolean):boolean;
function misinfo8162432(s:tobject;var sbits,sw,sh:longint;var shasai:boolean):boolean;
function misinfo824(s:tobject;var sbits,sw,sh:longint;var shasai:boolean):boolean;
function misrows8(s:tobject;var xout:pcolorrows8):boolean;
function misrows16(s:tobject;var xout:pcolorrows16):boolean;
function misrows24(s:tobject;var xout:pcolorrows24):boolean;
function misrows32(s:tobject;var xout:pcolorrows32):boolean;
function misrows82432(s:tobject;var xout8:pcolorrows8;var xout24:pcolorrows24;var xout32:pcolorrows32):boolean;//26jan2021
function mispixel8(s:tobject;sy,sx:longint):tcolor8;//31jan2021
function mispixel24(s:tobject;sy,sx:longint):tcolor24;
function mispixel32(s:tobject;sy,sx:longint):tcolor32;
function mispixel8VAL(s:tobject;sy,sx:longint):byte;
function mispixel24VAL(s:tobject;sy,sx:longint):longint;
function mispixel32VAL(s:tobject;sy,sx:longint):longint;
function missetpixel32VAL(s:tobject;sy,sx,xval:longint):boolean;//31jul2021
function missetpixel32(s:tobject;sy,sx:longint;xval:tcolor32):boolean;//31jul2021
function misscan8(s:tobject;sy:longint;var sr8:pcolorrow8):boolean;//26jan2021
function misscan24(s:tobject;sy:longint;var sr24:pcolorrow24):boolean;//26jan2021
function misscan32(s:tobject;sy:longint;var sr32:pcolorrow32):boolean;//26jan2021
function misscan824(s:tobject;sy:longint;var sr8:pcolorrow8;var sr24:pcolorrow24):boolean;//26jan2021
function misscan2432(s:tobject;sy:longint;var sr24:pcolorrow24;var sr32:pcolorrow32):boolean;//26jan2021
function misscan82432(s:tobject;sy:longint;var sr8:pcolorrow8;var sr24:pcolorrow24;var sr32:pcolorrow32):boolean;//26jan2021
function misscan832(s:tobject;sy:longint;var sr8:pcolorrow8;var sr32:pcolorrow32):boolean;//14feb2022
function misatleast(s:tobject;dw,dh:longint):boolean;//26jul2021
function missize(s:tobject;dw,dh:longint):boolean;
function missize2(s:tobject;dw,dh:longint;xoverridelock:boolean):boolean;
function miscountcolors(i:tobject):longint;//full color count - uses dynamic memory (2mb) - 15OCT2009
function miscountcolors2(da_clip:trect;i,xsel:tobject):longint;//full color count - uses dynamic memory (2mb) - 19sep2018, 15OCT2009
function mismove82432(s:tobject;xmove,ymove:longint):boolean;//19jun2021
function mismatch82432(s,d:tobject;xtol,xfailrate:longint):boolean;//10jul2021
function mismatcharea82432(s,d:tobject;sa,da:trect;xtol,xfailrate:longint):boolean;//10jul2021
function misclean(s:tobject;scol,stol:longint):boolean;//19sep2022
function miscls(s:tobject;xcolor:longint):boolean;
function misclsarea(s:tobject;sarea:trect;xcolor:longint):boolean;
function misclsarea2(s:tobject;sarea:trect;xcolor,xcolor2:longint):boolean;
function misclsarea3(s:tobject;sarea:trect;xcolor,xcolor2,xalpha,xalpha2:longint):boolean;
function misdrawcanvas(d:tcanvas;dx,dy:longint;s:tgraphic;scanvas:tcanvas):boolean;
function miscopyarea(d,s:tcanvas;a:trect):boolean;
function miscopyarea2(d,s:tcanvas;da,sa:trect):boolean;
function miscopypixels(var drows,srows:pcolorrows8;xbits,xw,xh:longint):boolean;
function miscopyareaxx(da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s:tobject;xpower255,xtrans,xtc:longint;xoptions:currency):boolean;//05sep2017, 25jul2017
function miscopyareaxx1(ddx,ddy,ddw,ddh:currency;sa:trect;d,s:tobject):boolean;//01jun2019
function miscopyareaxx1A(ddx,ddy,ddw,ddh:currency;sa:trect;d,s:tobject;xusealpha:boolean):boolean;//support 32bit alpha channel - 27jan2021
function miscopyareaxx1B(ddx,ddy,ddw,ddh:currency;sa:trect;d,s:tobject;xpower255:longint;xusealpha:boolean):boolean;//support 32bit alpha channel - 27jan2021
function miscopyareaxx2(da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s:tobject;xpower255,xtrans,xtc:longint;xoptions:currency;xscroll,yscroll:longint):boolean;//27sep2017, 26sep2017, 25sep2017, 25jul2017
function miscopyareaxx3(da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s,dm,sm:tobject;xpower255,xtrans,xtc:longint;xoptions:currency;xscroll,yscroll:longint):boolean;//27sep2017, 26sep2017, 25sep2017, 25jul2017
function miscopyareaxx3b(da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s,dm,dm2,sm:tobject;xpower255,xtrans,xtc:longint;xoptions:currency;xscroll,yscroll:longint):boolean;//27sep2017, 26sep2017, 25sep2017, 25jul2017
function miscopyareaxx4(da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s,dm,sm:tobject;xpower255,xtrans,xtc:longint;xoptions:currency;xscroll,yscroll:longint;refOP,refRGB,refR,refG,refB,refX,refY:tstr8):boolean;//22aug2018, 27sep2017, 26sep2017, 25sep2017, 25jul2017
function miscopyareaxx5(da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s,dm,dm2,sm,sm2:tobject;xpower255,xtrans,xtc:longint;xoptions:currency;xscroll,yscroll:longint;refOP,refRGB,refR,refG,refB,refX,refY:tstr8):boolean;//15may2019, 22aug2018, 27sep2017, 26sep2017, 25sep2017, 25jul2017
function miscopyareaxx6(da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s,dm,dm2,sm,sm2,sselshow:tobject;xselshowSTRIDE:longint;xselshowEVENINIT:boolean;xpower255,xtrans,xtc:longint;xoptions:currency;xscroll,yscroll:longint;refOP,refRGB,refR,refG,refB,refX,refY:tstr8):boolean;//32bit support - 25apr2020, 15may2019, 22aug2018, 27sep2017, 26sep2017, 25sep2017, 25jul2017
function miscopyareaxx7(da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s,dm,dm2,sm,sm2,sselshow:tobject;dmask:tmask8;dmaskval:longint;xselshowSTRIDE:longint;xselshowEVENINIT:boolean;xpower255,xtrans,xtc:longint;xoptions:currency;xscroll,yscroll:longint;refOP,refRGB,refR,refG,refB,refX,refY:tstr8):boolean;//32bit alpha channel support - 26jan2021, 30aug2020, 25apr2020, 15may2019, 22aug2018, 27sep2017, 26sep2017, 25sep2017, 25jul2017
function miscopyareaxx8(da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s,dm,dm2,sm,sm2,sselshow:tobject;dmask:tmask8;dmaskval:longint;xselshowSTRIDE:longint;xselshowEVENINIT:boolean;xpower255,xtrans,xtc:longint;xoptions:currency;xscroll,yscroll:longint;refOP,refRGB,refR,refG,refB,refX,refY:tstr8;xusealpha:boolean):boolean;//32bit alpha channel support - 29jan2021, 27jan2021, 30aug2020, 25apr2020, 15may2019, 22aug2018, 27sep2017, 26sep2017, 25sep2017, 25jul2017
function misoptions(xinvert,xgrey,xsepia,xnoise:boolean):currency;
function miscopyareaxx9(xcolorise1,xcolorise2:longint;da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s,dm,dm2,sm,sm2,sselshow:tobject;dmask:tmask8;dmaskval:longint;xselshowSTRIDE:longint;xselshowEVENINIT:boolean;xpower255,xtrans,xtc:longint;xoptions:currency;xscroll,yscroll:longint;refOP,refRGB,refR,refG,refB,refX,refY:tstr8;xusealpha:boolean):boolean;//xinvert put last for better results - 05jun2021, colorise - 27mar2021, "round()" instead of "trunc()" - 16mar2021, dsysinfo support - 10mar2021, 32bit alpha channel support - 29jan2021, 27jan2021, 30aug2020, 25apr2020, 15may2019, 22aug2018, 27sep2017, 26sep2017, 25sep2017, 25jul2017
function miscopyareaxx10(xcolorise1,xcolorise2:longint;da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s,dm,dm2,sm,sm2,sselshow:tobject;dmask:tmask8;dmaskval:longint;xselshowSTRIDE:longint;xselshowEVENINIT:boolean;xpower255,xtrans,xtc,xwriteShadesofcolor:longint;xoptions:currency;xscroll,yscroll:longint;refOP,refRGB,refR,refG,refB,refX,refY:tstr8;xusealpha:boolean):boolean;//xinvert put last for better results - 05jun2021, "round()" instead of "trunc()" - 16mar2021, dsysinfo support - 10mar2021, 32bit alpha channel support - 29jan2021, 27jan2021, 30aug2020, 25apr2020, 15may2019, 22aug2018, 27sep2017, 26sep2017, 25sep2017, 25jul2017
//.full 32bit RGBA support - 15feb2022
function miscopyarea32(ddx,ddy,ddw,ddh:currency;sa:trect;d,s:tobject):boolean;//can copy ALL 32bits of color
function miscopyarea322(da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s:tobject;xscroll,yscroll:longint):boolean;//can copy ALL 32bits of color
function misscreenw:longint;
function misscreenh:longint;
function misscreenresin248K:longint;//returns 2(K), 4(K) or 8(K) - 14mar2021
function misrect(x,y,x2,y2:longint):trect;
function misarea(s:tobject):trect;
function misworkarea:trect;//supports multiple horizontal monitors
function misworkh:longint;
function misworkw:longint;
function misscreenarea:trect;
function miscursorpos:tpoint;
function low__comparetext(a,b:string):boolean;
function low__comparetext2(a,b:string):longint;
function low__comparetext3(a,b:string;var xmatched:boolean):boolean;//28dec2021
function low__comparetextcase(a,b:string):boolean;
function low__comparetextcase2(a,b:string):longint;
function anyformatb(xdata:tstr8):string;//same as "result:=comparetext(a,b)=0" - 31jan2021
function anyformat(xdata:tstr8;var xformat:string):boolean;//returns EXT of any known format, image, sound, frame, etc - 30jan2021
function misformat(xdata:tstr8;var xformat:string;var xbase64:boolean):boolean;
function mistodata(s:tobject;ddata:tstr8;dformat:string;var e:string):boolean;//02jun2020
function mistodata2(s:tobject;ddata:tstr8;dformat:string;dtranscol,dfeather,dlessdata:longint;dtransframe:boolean;var e:string):boolean;//04sep2021, 03jun2020
function mistodata3(_s:tobject;ddata:tstr8;dformat:string;dtranscol,dfeather,dlessdata:longint;dtransframe,xuseacopy:boolean;var e:string):boolean;//04sep2021, 03jun2020
function misempty(s:tobject):boolean;
function misbytes(s:tobject):comp;
function misbytes32(s:tobject):longint;
function misfromfile(s:tobject;xfilename:string;var e:string):boolean;//09jul2021
function mistofile(s:tobject;xfilename,dformat:string;var e:string):boolean;//12feb2022, 02jun2020
function mistofile2(s:tobject;xfilename,dformat:string;xusecopy:boolean;var e:string):boolean;//02jun2020
function mistofile3(s:tobject;xfilename,dformat:string;dtranscol,dfeather,dlessdata:longint;dtransframe,xusecopy:boolean;var e:string):boolean;//03jun2020
function misfromdata(s:tobject;xdata:tstr8;var e:string):boolean;//21aug2020
function misfromdata2(s:tobject;xdata:array of byte;var e:string):boolean;//02jun2020
function misblur82432(s:tobject):boolean;//03sep2021
function misblur82432b(s:tobject;xwraprange:boolean;xpower255,xtranscol:longint):boolean;//11sep2021, 03sep2021
function misblur82432c(s:tobject;scliparea:trect;xwraprange:boolean;xpower255,xtranscol:longint):boolean;//17may2022 - cell-based clipping, 27apr2022, 11sep2021, 03sep2021
function misIconArt82432(s,s2:tobject;xzoom,xbackcolor,xtranscolor:longint;xpadding:boolean):boolean;//17sep2022 - fixed integer overflow error, 27apr2022
function miscrop82432(s:tobject):boolean;
function miscrop82432b(s:tobject;t32:tcolor32;var l,t,r,b:longint;xcalonly,xusealpha,xretainT32:boolean):boolean;//21jun20221
function mismakesplashart2432(s:tobject;xtitle,xtext,xborder,xback,xback2,xminW,xminH,xmaxW,xmaxH:longint):boolean;//27jun2022, 27apr2022

//splash support - 27apr2022 ---------------------------------------------------
function splash__findvalue(x:longint;xreverse,xsep:boolean;var xvalue:string):boolean;


//mask (alpha) support - 15feb2022, 05jun2021 ----------------------------------
function mask__empty(s:tobject):boolean;
function mask__transparent(s:tobject):boolean;//replaces "misAlphatransparent832()"
function mask__range(s:tobject;var xmin,xmax:longint):boolean;//15feb2022
function mask__range2(s:tobject;var v0,v255,vother:boolean;var xmin,xmax:longint):boolean;//15feb2022
function mask__maxave(s:tobject):longint;//0..255
function mask__setval(s:tobject;xval:longint):boolean;//replaces "missetAlphaval32()"
function mask__setopacity(s:tobject;xopacity255:longint):boolean;//06jun2021
function mask__multiple(s:tobject;xby:currency):boolean;//18sep2022
function mask__copy(s,d:tobject):boolean;//15feb2022 - was "missetAlpha32(()"
function mask__copy2(s,d:tobject;stranscol:longint):boolean;
function mask__copy3(s,d:tobject;stranscol,sremove:longint):boolean;
function mask__copymin(s,d:tobject):boolean;//15feb2022
function mask__feather(s,d:tobject;sfeather,stranscol:longint;var xouttranscol:longint):boolean;//20jan2021
function mask__feather2(s,d:tobject;sfeather,stranscol:longint;stransframe:boolean;var xouttranscol:longint):boolean;//15feb2022, 18jun2021, 08jun2021, 20jan2021 - was "misalpha82432b()"

//-- ICO/CUR/ANI image support - 07feb2022 ---------------------------------------------
//compiler tag: "ico" check with need_ico
//cost: 6K - 07feb2022
function low__findbpp82432(i:tobject;iarea:trect;imask32:boolean):longint;//limited color count 07feb2022, 19jan2021, 21-SEP-2004
function low__palfind24(var a:array of tcolor24;acount:longint;var z:tcolor24):byte;
{$ifdef ico}
type
  {icons AND cursors}
   pcursororicon=^tcursororicon;
   tcursororicon=packed record
     Reserved:word;
     wtype:word;//0,1 or 2
     count:word;
   end;
   piconrec=^ticonrec;
   ticonrec=packed record
     width:byte;
     height:byte;
     colors:word;
     reserved1:word;
     reserved2:word;
     dibsize:longint;
     diboffset:longint;
   end;
   panirec=^tanirec;
   tanirec=packed record
     cbSizeOf:dword;// Num bytes in AniHeader (36 bytes)
     cFrames:dword;// Number of unique Icons in this cursor
     cSteps:dword;// Number of Blits before the animation cycles
     cx:dword;// reserved, must be zero.
     cy:dword;// reserved, must be zero.
     cBitCount:dword;// reserved, must be zero.
     cPlanes:dword;// reserved, must be zero.
     JifRate:dword;//Note: 1xJiffy=1/60s=16.666ms - Default Jiffies (1/60th of a second) if rate chunk not present.
     flags:dword;// Animation Flag (see AF_ constants) - #define AF_ICON =3D 0x0001L // Windows format icon/cursor animation
   end;
{$endif}
function low__icosizes(x:longint):longint;//18JAN2012, 25APR2011
//.1-32bit using transparent color - old/original tech
function low__toico(s:tobject;dcursor:boolean;dsize,dBPP,dtranscol,dfeather:longint;dtransframe:boolean;dhotX,dhotY:longint;xdata:tstr8;var e:string):boolean;//handles 1-32 bpp icons - 03jan2019, 14mar2015, 16JAN2012
function low__toani(s:tobject;slist:tfindlistimage;dsize,dBPP,dtranscolor,dfeather:longint;dtransframe:boolean;ddelay,dhotX,dhotY:longint;xdata:tstr8;var e:string):boolean;//07aug2021 (disabled repeat checker as it breaks the ANI file!), 24JAN2012
//.1-32bit using mask - new/updated tech - 15feb2022
function low__fromico32(d:tobject;sdata:tstr8;dsize:longint;xuse32:boolean;var e:string):boolean;//handles 1-32 bpp icons - 26JAN2012
function low__fromani32(d:tobject;sdata:tstr8;dsize:longint;xuse32:boolean;var e:string):boolean;//handles 1-32 bpp animated icons - 23may2022, 26JAN2012
function low__toico32(s:tobject;dcursor,dpng:boolean;dsize,dBPP,dhotX,dhotY:longint;var xouthotX,xouthotY,xoutBPP:longint;xdata:tstr8;var e:string):boolean;//handles 1-32 bpp icons - 03jan2019, 14mar2015, 16JAN2012
function low__toani32(s:tobject;slist:tfindlistimage;dformat:string;dpng:boolean;dsize:longint;ddelay,dhotX,dhotY:longint;xonehotspot:boolean;xdata:tstr8;var e:string):boolean;//15feb2022
function low__toani32b(s:tobject;slist:tfindlistimage;dformat:string;dpng:boolean;dsize,dForceBPP:longint;ddelay,dhotX,dhotY:longint;xonehotspot:boolean;var xoutbpp:longint;xdata:tstr8;var e:string):boolean;//15feb2022


//-- PNG image support - 17jan2021 ---------------------------------------------
//.png
procedure low__PNGfilter_textlatin1(x:tstr8);//21jan2021
function low__PNGfilter_nullsplit(xdata:tstr8;xfilterlatin1:boolean;xname,xval:tstr8):boolean;
function low__PNGfilter_fromsettings(xdata:tstr8;var stranscol,sfeather,slessdata:longint;var shadsettings:boolean):boolean;
function mistopng82432(x:tobject;stranscol,sfeather,slessdata:longint;stransframe:boolean;xdata:tstr8;var e:string):boolean;//20jan2021
function mistopng82432b(x:tobject;stranscol,sfeather,slessdata:longint;stransframe:boolean;var xoutbpp:longint;xdata:tstr8;var e:string):boolean;//OK=27jan2021, 20jan2021
function misfrompng82432(s:tobject;sbackcol:longint;sdata:tstr8;var e:string):boolean;//26jan2021
function misfrompng82432ex(s:tobject;sbackcol:longint;var stranscol,sfeather,slessdata:longint;var shadsettings:boolean;sdata:tstr8;var e:string):boolean;//26jan2021, 21jan2021
//.png cells support - 28jan2021
function mistoPngcells82432(s:tobject;sdelay,scellcount,stranscol,sfeather,slessdata:longint;stransframe,xbestsize:boolean;xdata:tstr8;var e:string):boolean;//28jan2021
function misfromPngcells82432(s:tobject;sbackcol:longint;xdata:tstr8;var e:string):boolean;//28jan2021
function misfromPngcells82432ex(s:tobject;sbackcol:longint;var sdelay,scellcount,scellwidth,scellheight,stranscol,sfeather,slessdata:longint;xdata:tstr8;var e:string):boolean;//28jan2021


//-- JPG image support - 29jan2021 ---------------------------------------------
//.jpg
function mistojpg82432(s:tobject;xdata:tstr8;var e:string):boolean;//28jan2021
function mistojpg82432ex(s:tobject;stranscol,sfeather,slessdata:longint;xforceenhanced:boolean;xdata:tstr8;var e:string):boolean;//28jan2021
function misfromjpg82432(s:tobject;sbackcol:longint;xdata:tstr8;var e:string):boolean;//29jan2021
function misfromjpg82432ex(s:tobject;sbackcol:longint;var stranscol,sfeather,slessdata:longint;var swasenhanced:boolean;xdata:tstr8;var e:string):boolean;//29jan2021

//.jpg cells support - 29jan2021
function mistoJpgcells82432(s:tobject;sdelay,scellcount,stranscol,sfeather,slessdata:longint;xbestsize:boolean;xdata:tstr8;var e:string):boolean;//29jan2021
function misfromJpgcells82432(s:tobject;sbackcol:longint;xdata:tstr8;var e:string):boolean;//28jan2021
function misfromJpgcells82432ex(s:tobject;sbackcol:longint;var sdelay,scellcount,scellwidth,scellheight,stranscol,sfeather,slessdata:longint;xdata:tstr8;var e:string):boolean;//28jan2021

//.bmp support
function mistobmp82432(s:tobject;dbits:longint;xdata:tstr8;var e:string):boolean;//28jan2021
function misfrombmp82432(s:tobject;xdata:tstr8;var e:string):boolean;//28jan2021
//.transparent color support (multiple colors supported) - 28jan2021
function mistransNEXT(var xindex:longint;var xoutlabel:string;xstart:boolean):boolean;
function mistransNEXT2(var xindex,xoutindex:longint;var xoutlabel:string;var xoutcustomok:boolean;xcustom:string;xstart:boolean):boolean;
function mistransLABEL(stranscolORstyle:longint;xcustom:string):string;
function mistransCUSTOM(stranscolORstyle:longint):boolean;
function mistransISOK(a,b:longint):boolean;
function mistranscol(s:tobject;stranscolORstyle:longint;senable:boolean):longint;
function misfindtranscol82432(s:tobject;stranscol:longint):longint;
function misfindtranscol82432ex(s:tobject;stranscol:longint;var tr,tg,tb:longint):boolean;
//.frame "universal" drawer
function misframe82432(s:tobject;da_cliparea,xouterarea:trect;xautoouterarea:boolean;var slist:array of longint;scount:longint;var e:string):boolean;//28jan2021
function misframe82432ex(s:tobject;da_cliparea,xouterarea:trect;xautoouterarea:boolean;var slist:array of longint;scount:longint;var e:string):boolean;//28jan2021
procedure low__framecols(xback,xframe,xframe2:longint;var xminsize,xcol1,xcol2:longint);//24feb2022
function low__frameset(var xpos:longint;xdata:tstr8;var sremsize:longint;sframesize,scolor,scolor2:longint;var dminsize,dsize,dcolor,dcolor2:longint):boolean;
function mislimitcolors82432(x:tobject;xtranscolor,colorlimit:longint;fast:boolean;var a:array of tcolor24;var acount:longint;var e:string):boolean;//01aug2021, 15SEP2007
function mislimitcolors82432ex(x:tobject;sx,xcellw,xtranscolor,colorlimit:longint;fast,xreducetofit:boolean;var a:array of tcolor24;var acount:longint;var e:string):boolean;//01aug2021, 15SEP2007
function misreduce82432(s:tobject;stranscol,slessdata:longint;var e:string):boolean;
//.sparkle support - rapid random pixels - upto 4x faster - 27feb2022
procedure low__sparklefill(xrichlevel:longint);
function low__sparklestart:longint;
procedure low__sparklestop(xpos:longint);
//.brush curves - low level support
function degtorad2(deg:extended):extended;//20OCT2009
function miscurveAirbrush2(var x:array of longint;xcount,valmin,valmax:longint;xflip,yflip:boolean):boolean;//20jan2021, 29jul2016
//.other
function low__mask8_drawto(s:tmask8;x:tbmp):boolean;
function low__draw(xdynamicCorners:boolean;xbits,xw,xh:longint;xrows:tstr8;xmask:tmask8;xmaskval:longint;xstyle:char;xclip,xclip2,xarea:trect;xcol,xcol2,xcol3,xval1,xval2,xval3,xrich:longint;xdata,xoptions:tstr8;xroundstyle:longint;xround:boolean):boolean;
function low__draw2(xdynamicCorners:boolean;xtab,xbits,xw,xh:longint;xrows:tstr8;xmask:tmask8;xmaskval:longint;xstyle:char;xclip,xclip2,xarea:trect;xcol,xcol2,xcol3,xval1,xval2,xval3,xval4,xval5,xrich:longint;xdata,xoptions:tstr8;xroundstyle:longint;xround,xbol1,xbol2,xbol3,xbol4:boolean):boolean;
function low__draw3(xdynamicCorners:boolean;xcolorise,xsyszoom:boolean;xtab,xbits,xw,xh:longint;xrows:tstr8;xmask:tmask8;xmaskval:longint;xstyle:char;xclip,xclip2,xarea:trect;xcol,xcol2,xcol3,xval1,xval2,xval3,xval4,xval5,xrich:longint;xdata,xoptions:tstr8;xroundstyle:longint;xround,xbol1,xbol2,xbol3,xbol4:boolean):boolean;//12jun2022, 22may2022, 01mar2022
function low__cornerMaxwidth:longint;//used by some patch systems to work around corner restrictions such as "statusbar.cellpert.round/square" - 07ul2021
function low__cornersolid(xdynamicCorners:boolean;var a:trect;amin,ay,xmin,xmax,xroundstyle:longint;xround:boolean;var lx,rx:longint):boolean;//29mar2021
procedure low__cornerhollow(xdynamicCorners:boolean;var a:trect;amin,ay,xroundstyle:longint;xround:boolean;var lx,lx2,rx,rx2:longint);//29mar2021, compensates for missed corner pixels -> hollow fits snugly over solid without any missed pixels now - 12apr2020
//.ref support
function ref_blankX(x:tstr8;xlabel:string;xsize:longint):boolean;
function ref_blank1000(x:tstr8;xlabel:string):boolean;
function ref_valid(x:tstr8):boolean;
function ref_id(x:tstr8):longint;
procedure ref_setid(x:tstr8;y:longint);
procedure ref_incid(x:tstr8);
function ref_count(x:tstr8):longint;
procedure ref_setcount(x:tstr8;xcount:longint);
function ref_use(x:tstr8):boolean;
procedure ref_setuse(x:tstr8;y:boolean);
function ref_style(x:tstr8):byte;
procedure ref_setstyle(x:tstr8;y:byte);
function ref_stylelabel(x:tstr8):string;
function ref_stylelabel2(x:longint):string;
function ref_stylelabel3(x:longint;var xcount:longint):string;
function ref_stylecount:longint;//slow
function ref_proc(xstyle:longint;xval,xmin,xmax,xref:extended;xpos,xcount:longint):extended;
function ref_label(x:tstr8):string;
procedure ref_setlabel(x:tstr8;y:string);
procedure ref_paste(xref,xnew:tstr8;xfit:boolean);
procedure ref_paste2(xref,xnew:tstr8;xfit,xretainlabel:boolean);
procedure ref_smooth(x:tstr8;xmore:boolean);
procedure ref_texture(x:tstr8;xmore:boolean);
procedure ref_mirror(x:tstr8);
procedure ref_flip(x:tstr8);
procedure ref_shiftx(x:tstr8;xby:longint);
procedure ref_shifty(x:tstr8;xby:extended);
procedure ref_zoom(x:tstr8;xby:extended);
function ref_val(x:tstr8;xindex:longint):extended;//raw only, no style
function ref_valex(x:tstr8;xindex:longint;xloop:boolean):extended;//raw only, no style
function ref_val2(x:tstr8;xindex,xval,xmin,xmax:longint):longint;//raw only, no style
function ref_val2ex(x:tstr8;xindex,xval,xmin,xmax:longint;xloop:boolean):longint;//raw only, no style
function ref_val32(x:tstr8;xindex,xval,xmin,xmax:longint):longint;
function ref_val0255(x:tstr8;xval:longint):longint;
function ref_val255255(x:tstr8;xval:longint):longint;
function ref_valrange32(x:tstr8;xval,xmin,xmax,zpos:longint;var zmin,zmax,zoff,zcount:longint):longint;
function ref_val80(x:tstr8;xindex:longint;xval,xmin,xmax:extended):extended;
function ref_valrange80(x:tstr8;xval,xmin,xmax:extended;zpos:longint;var zmin,zmax,zoff,zcount:longint):extended;
procedure ref_setval(x:tstr8;xindex:longint;y:extended);
procedure ref_setall(x:tstr8;y:extended);
//.temp support
function low__createimg24(var x:tbasicimage;xid:string;var xwascached:boolean):boolean;
procedure low__freeimg(var x:tbasicimage);
procedure low__checkimg;
function low__createint(var x:tdynamicinteger;xid:string;var xwascached:boolean):boolean;
procedure low__freeint(var x:tdynamicinteger);
procedure low__checkint;
function low__createbyte(var x:tdynamicbyte;xid:string;var xwascached:boolean):boolean;
procedure low__freebyte(var x:tdynamicbyte);
procedure low__checkbyte;
//.pixel modifiers
procedure fbNoise3(var r,g,b:byte);//faster - 29jul2017
procedure fbInvert(var r,g,b:byte);
procedure fbGreyscale(var r,g,b:byte);
procedure fbSepia(var r,g,b:byte);
//.menu support -> normal sequence: init() + title()/item()/sep() + end()
procedure low__menuinit(x:tstr8);
function low__menutitle(x:tstr8;xtep:longint;xcaption,xhelp:string):boolean;
function low__menuitem(x:tstr8;xtep:longint;xcaption,xhelp,xcode2:string;xcode:longint;xenabled:boolean):boolean;
function low__menuitem2(x:tstr8;xtep:longint;xcaption,xhelp,xcode2:string;xcode,xshortcut:longint;xenabled:boolean):boolean;
function low__menuitem2b(x:tstr8;xtep:longint;xcaption,xhelp,xcode2:string;xcode,xshortcut:longint;xenabled:boolean;xindentLevel:longint):boolean;//07jun2021
function low__menuitem3(x:tstr8;xtep:longint;xcaption,xhelp,xcode2:string;xcode,xshortcut:longint;xflash,xenabled:boolean):boolean;
function low__menuitem4(x:tstr8;xtep:longint;xcaption,xhelp,xcode2:string;xcode,xshortcut,xindent:longint;xflash,xenabled:boolean):boolean;
//..custom tep color support
function low__menutitlex(x:tstr8;xtep,xtepcolor:longint;xcaption,xhelp:string):boolean;
function low__menuitemx(x:tstr8;xtep,xtepcolor:longint;xcaption,xhelp,xcode2:string;xcode:longint;xenabled:boolean):boolean;
function low__menuitemx2(x:tstr8;xtep,xtepcolor:longint;xcaption,xhelp,xcode2:string;xcode,xshortcut:longint;xenabled:boolean):boolean;
function low__menuitemx3(x:tstr8;xtep,xtepcolor:longint;xcaption,xhelp,xcode2:string;xcode,xshortcut:longint;xflash,xenabled:boolean):boolean;
function low__menuitemx4(x:tstr8;xtep,xtepcolor:longint;xcaption,xhelp,xcode2:string;xcode,xshortcut,xindent:longint;xflash,xenabled:boolean):boolean;
//..continue
function low__menusep(x:tstr8):boolean;
function low__menuend(x:tstr8):boolean;
function low__menucount(x:tstr8):longint;//number of items in menu
function low__menuget(x:tstr8;xindex:longint;var xtep,xtepcolor:longint;var xcaption,xhelp,xcode2:string;var xcode,xshortcut,xindent:longint;var xflash,xenabled,xtitle,xsep:boolean):boolean;
function low__menuadd(x:tstr8;xtep,xtepcolor:longint;xcaption,xhelp,xcode2:string;xcode,xshortcut,xindent:longint;xflash,xenabled,xtitle,xsep:boolean):boolean;
function low__menufindbycode2(x:tstr8;xfindval:string;var xindex:longint):boolean;
function low__menucode2(x:tstr8;xindex:longint):string;


//file support -----------------------------------------------------------------
function faISfolder(x:longint):boolean;//05JUN2013
function safename(x:string):string;//07mar2021
function safefilename(x:string;allowpath:boolean):string;//07mar2021, 08mar2016
function issafefilename(x:string):boolean;//07mar2021, 10APR2010
function hack_dangerous_filepath_allow_mask(x:string):boolean;
function hack_dangerous_filepath_deny_mask(x:string):boolean;
function hack_dangerous_filepath(x:string;xstrict_no_mask:boolean):boolean;
function low__makeportablefilename(filename:string):string;//11sep2021, 06oct2020, 14APR2011
function low__readportablefilename(filename:string):string;//11sep2021
function asfolder(x:string):string;//enforces trailing "\"
function asfolderNIL(x:string):string;//enforces trailing "\" AND permits NIL - 03apr2021, 10mar2014
function low__folderaslabel(x:string):string;
function low__isfile(x:string):boolean;
function low__local(x:string):boolean;
function low__canshowfolder(x:string):boolean;
function low__nn(x:string):boolean;//14apr2021
function low__dk(x:string):boolean;//14apr2021
function low__extractfilepath(x:string):string;//04apr2021
function low__extractfilename(x:string):string;//05apr2021
function low__extractfileext(x:string):string;//12apr2021
function low__extractfileext2(x,xdefext:string;xuppercase:boolean):string;//12apr2021
function low__extractfileext3(x,xdefext:string):string;//lowercase version - 15feb2022
procedure low__reloadfastvars;
function low__getfolderimg(xfolder:string;xdata:tstr8):boolean;//14apr2021
function low__setfolderimg(xfolder:string;xdata:tstr8):boolean;//14apr2021
function low__setfolderimg2(xfolder:string;xdata:array of byte):boolean;//14apr2021
function low__foldertep(xfolder:string):longint;
function low__foldertep2(xownerid:longint;xfolder:string):longint;
function low__drivetype(x:string):string;//15apr2021, 05apr2021
function low__drivelabel(x:string;xfancy:boolean):string;//05apr2021
function low__driveexists(x:string):boolean;//true=drive has content - 16feb2016, 25feb2015, 17AUG2010
function low__renamefile(s,d:string):boolean;//local only, soft check - 27nov2016
function low__shortfile(xlongfilename:string):string;//translate long filenames to short filename, using MS api, for "MCI playback of filenames with 125+c" - 23FEB2008
function low__makerelative(xfilename,xauthoritiveFilenameORfolder:string):string;//20mar2022
function low__readrelative(xfilename,xauthoritiveFilenameORfolder:string):string;//fixed 31may2022, 20mar2022
function low__fileexists(x:string):boolean;//15mar2020, 19may2019
function low__filedate(x:string;var xdate:tdatetime):boolean;//27jan2022
function low__filedateb(x:string):tdatetime;//27jan2022
function low__filesize(x:string):longint;//19dec2021
function low__remfile(x:string):boolean;
procedure low__filesetattr(x:string;xval:longint);
function low__folderexists(x:string):boolean;//15mar2020, 14dec2016
function low__makefolder(x:string):boolean;//15mar2020, 19may2019
function low__copyfile(sf,df:string;var e:string):boolean;
function low__tofile(x:string;xdata:tstr8;var e:string):boolean;//fast and basic low-level
function low__tofilestr(x,xdata:string;var e:string):boolean;//fast and basic low-level
function low__tofileappend(x:string;xdata:tstr8;var xpersistenthandler:tfilestream;var e:string):boolean;//20jun2021 - fast and basic low-level
function low__tofileappend2(x:string;xpos:longint;xdata:tstr8;var xpersistenthandler:tfilestream;var e:string):boolean;//20jun2021 - fast and basic low-level
function low__tofileappend3(x:string;xpos:longint;xdata:tstr8;var e:string):boolean;//19feb2022
function low__fromfile(x:string;xdata:tstr8;var e:string):boolean;
function low__fromfileb(x:string;xdata:tstr8;var e:string;var _filesize,_from:longint;_size:longint):boolean;//20-OCT-2006
function low__fromfilestr(x:string;var xdata,e:string):boolean;
function low__fromfilestrb(x:string;var e:string):string;//30mar2022
function low__fromfiletime(x:tfiletime):tdatetime;
function low__drivelist:tdrivelist;
function low__safedate(x:tdatetime):tdatetime;
procedure low__decodedate2(x:tdatetime;var y,m,d:word);//safe range
procedure low__decodetime2(x:tdatetime;var h,min,s,ms:word);//safe range
function low__encodedate2(y,m,d:word):tdatetime;//safe range
function low__encodetime2(h,min,s,ms:word):tdatetime;//safe range
function low__dayofweek1(x:tdatetime):longint;//27feb2022
function low__dayofweek0(x:tdatetime):longint;//09mar2022
function low__dayofweekstr(x:tdatetime;xfullname:boolean):string;
function low__month0(x:longint;xfullname:boolean):string;//08mar2022
function low__month1(x:longint;xfullname:boolean):string;//08mar2022
function low__weekday0(x:longint;xfullname:boolean):string;//08mar2022
function low__weekday1(x:longint;xfullname:boolean):string;//08mar2022
function low__datestr(xdate:tdatetime;xformat:longint;xfullname:boolean):string;//09mar2022
function low__date1(xyear,xmonth1,xday1:longint;xformat:longint;xfullname:boolean):string;
function low__date0(xyear,xmonth,xday:longint;xformat:longint;xfullname:boolean):string;
function low__time0(xhour,xminute:longint;xsep,xsep2:string;xuppercase,xshow24:boolean):string;
function low__hour0(xhour:longint;xsep:string;xuppercase,xshowAMPM,xshow24:boolean):string;


//nav support -----------------------------------------------------------------
//note: builds a filelist with support for (a) nav list, (b) folders, (c) files, (d) fav folders etc - used by open/save/folder windows and low level file listing procs
//note: normal sequence: init() + add()/add()/add() + end() -> packs a 4 way sorted (name,size,date,type) nav/folder/file list(s) into a single compact data structure with rapid data access via low__navget - 25sep2020
//version: 1.00.250 / date: 06apr2021, 20feb2021, 25sep2020
function low__navinit(x:tstr8):boolean;
function low__navadd(x:tstr8;xstyle,xtep:longint;xsize:comp;xname,xlabel:string):boolean;
function low__navadd2(x:tstr8;xstyle,xtep:longint;xsize:comp;xyear,xmonth,xday,xhr,xmin,xsec:longint;xname,xlabel:string):boolean;
function low__navsort(x:tstr8;xsortstyle:longint):boolean;
function low__navend(x:tstr8;xsortstyle:longint):boolean;
function low__navinfo(x:tstr8;var xnavcount,xfoldercount,xfilecount,xtotalcount:longint):boolean;
function low__navget(x:tstr8;xindex:longint;var xstyle,xtep:longint;var xsize:comp;var xname,xlabel:string):boolean;
function low__navget2(x:tstr8;xindex:longint;var xstyle,xtep:longint;var xsize:comp;var xyear,xmonth,xday,xhr,xmin,xsec:longint;var xname,xlabel:string):boolean;
function low__navlist(x:tstr8;xsortstyle:longint;xfolder,xmasklist,xemasklist:string;xnav,xfolders,xfiles:boolean):boolean;//04oct2020
function low__navlist2(xownerid:longint;x:tstr8;xsortstyle:longint;xfolder,xmasklist,xemasklist:string;xnav,xfolders,xfiles:boolean):boolean;//supports custom folder images when "xownerid>=1" - 06apr2021, 04oct2020
function low__navlist3(xownerid:longint;x:tstr8;xsortstyle:longint;xfolder,xmasklist,xemasklist:string;xnav,xfolders,xfiles:boolean;xminsize,xmaxsize:comp;xminmax_emasklist:string):boolean;//04oct2020
function low__nav(x:tstr8;xcmd:string;xindex:longint;var xstyle,xtep,xval1,xval2,xval3:longint;var xsize,xdate:comp;var xname,xlabel:string):boolean;//04apr2021, 25mar2021, 20feb2021
//.simple file list support - 06oct2022
function low__filelist(xoutlist:tdynamicstring;xfullfilenames:boolean;xfolder,xmasklist,xemasklist:string):boolean;//06oct2022
function low__filelist2(xoutlist:tdynamicstring;xfullfilenames:boolean;xfolder,xmasklist,xemasklist:string;xtotalsizelimit,xminsize,xmaxsize:comp;xminmax_emasklist:string):boolean;//06oct2022


//xxxxxxxxxxxxxxxxx//666666666666666
//.base64 support
function low__tob641(s,d:tstr8;xpos1,linelength:longint;var e:string):boolean;//to base64
function low__tob64(s,d:tstr8;linelength:longint;var e:string):boolean;//to base64
function low__tob64b(s:tstr8;linelength:longint):tstr8;
function low__fromb64(s,d:tstr8;var e:string):boolean;//from base64
function low__fromb641(s,d:tstr8;xpos1:longint;var e:string):boolean;//from base64
function low__fromb64b(s:tstr8):tstr8;


//system support ---------------------------------------------------------------
//.talk indirectly to all active "tbasicsystem" controls
procedure system_paintallnowSLOW;
procedure system_paintallnow;
procedure system_paintnow;
procedure system_alignallnow;
procedure system_alignnow;
procedure system_sizenow;
//.debug support
procedure showerror(e:string);//01jan2020
procedure showbasic(x:string);
procedure showa(x:longint);
procedure showa1;
procedure showa2;
procedure showa3;
procedure showa4;
procedure showa5;
procedure showa6;
procedure showa7;
procedure showa8;
procedure showa9;
procedure showb1;
procedure showb2;
procedure showb3;
procedure showb4;
procedure showc1;
procedure showc2;
procedure showc3;
procedure showc4;
procedure showerror8(e:tstr8);//19aug2020
procedure showbasic8(x:tstr8);//19aug2020
function appdata:string;//out of date
function windrive:string;//14DEC2010
function winroot:string;//11DEC2010
function winsystem:string;//11DEC2010
function wintemp:string;//11DEC2010
function wincommontemp:string;//27NOV2010
function windesktop:string;//17MAY2013
function winstartup:string;
function winprograms:string;//start button > programs > - 11NOV2010
function winstartmenu:string;
procedure dbRGBA(x:longint);//26jun2021
procedure dbimage(s:tobject;szoom:longint;susealpha:boolean);//strictly debug purposes only - 21dec2021, 07jun2021 -> misshow/low__show/imageshow
procedure dbimage2(s,s2:tobject;szoom:longint);//strictly debug purposes only
procedure dbstatus(p:longint;x:string);
procedure dbstart;
procedure dbstop;
function dbtime:string;
function dbtimeave:string;
function dbtimeavefast:string;
procedure dbshow(xlabel:string);//show label + dbtime


//-- system thread support -----------------------------------------------------
//host app workers
//updated: 05mar2022
procedure systhread__initall;
function systhread__start(xstartproc:TFNThreadStartRoutine;xms:longint;xfast:comp;var xslot:longint):boolean;
function systhread__canstop(xslot:longint):boolean;
procedure systhread__stop(xslot:longint);
procedure systhread__stopwait(xslot:longint);
procedure systhread__stopall(xwait:boolean);
function systhread__lag(xslot:longint):longint;
function systhread__fast(xslot:longint):boolean;//05mar2022
procedure systhread__setfast(xslot:longint;xre64:comp);
//.push (host -> thread -> host)
function systhread__pushing(xslot:longint):boolean;
function systhread__push(xslot:longint;xcmd:longint;xdata:string;var xreplycmd:longint;var xreplydata:string):boolean;
function systhread__pushstart(xslot:longint;xcmd:longint;xdata:string):boolean;
function systhread__pushfinish(xslot:longint;xwait:boolean;var xreplycmd:longint;var xreplydata:string):boolean;
//.reply (thread -> host) - reply to a host's push request -> only fires when a host sends a push request - 11oct2021
function systhread__mustreply(xslot:longint;var xcmd:longint;var xdata:string):boolean;
function systhread__reply(xslot:longint;xcmd:longint;xdata:string):boolean;
//.support
function systhread__slotOK(xslot:longint):boolean;
procedure systhread__timerproc(uTimerID, uMsg: Integer; dwUser, dwParam1, dwParam2: longint); stdcall;
procedure systhread__stoptimer(xslot:longint);
procedure systhread__synclag(xslot:longint;xms64:comp);


//-- low level support for "twordcore" -----------------------------------------
//Version: 1.00.4967 - 27sep2022 (multi-format clipboard support), 05jul2022 (multi-undo support), 29jun2022, 22apr2022, 09mar2022, 05feb2022, 11jan2022, 27aug2021, 25jul2021, 19apr2021, 31mar2021, 12mar2021 - added wwsNone/wwsWindow/wwsPage and PaperSize support, 11oct2020 - fixed slow longlines wrapper, 26aug2020, 29feb2020
//Notes: Converted from "string" based data structures to full binary
//       on 28aug2021, 21-22aug2020.
//Notes: Upgraded to support "pageoverride2" which uses system colors and system colorise settings to color the contents of the text box in system colors/styles - 19apr2021
function low__wordcore__inited(var x:twordcore):boolean;
procedure low__wordcore__lgfFILL(var x:twordcore;lgfINDEX:longint;xwine_remake:boolean);
function low__wordcore__style(x:char):char;
function low__wordcore__transform(var x:twordcore;xstyle:string;xshowerrors:boolean):boolean;//30mar2022, 25jul2021
function low__wordcore__transform2(var x:twordcore;xstyle,xappTitle,xappWebname,xappVersion:string;xappStoreAPP,xappPaid,xclaudeTAGs,xshowerrors:boolean):boolean;//13nov2022, 30mar2022, 07jan2022
procedure low__wordcore__filtertext(x:tstr8);
function low__wordcore__isplaintext(var x:twordcore):boolean;//19jun2022
function low__wordcore__findformatlevel(var x:twordcore):longint;//19jun2022
function low__wordcore__charinfo(var x:twordcore;xpos:longint;var xout:twordcharinfo):boolean;
function low__wordcore__charinfo2(var x:twordcore;d1,d2,d3:tstr8;xpos:longint;var xout:twordcharinfo):boolean;
function low__wordcore__charinfoULTRA(var x:twordcore;xpos:longint;var xout:twordcharinfo;var xlastWID,xlastWID2:longint):boolean;//12jun2022 (7.30pm), 22apr2022
function low__wordcore__charinfoFAST(var x:twordcore;xpos:longint;var xout:twordcharinfo):boolean;
function low__wordcore__findalignFAST(var x:twordcore;xpos1:longint):longint;//22apr2022, 28dec2021
function low__wordcore__paint2432(var x:twordcore;aw,ah:longint;xcliparea,xpaintarea:trect;ar24:pcolorrows24;ar32:pcolorrows32;xdebug:tbmp;xmask:tmask8;xmaskval:longint;xround:boolean;xroundstyle,xrowcolor:longint):boolean;//19apr2021
procedure low__wordcore__keyboard(var x:twordcore;xctrl,xalt,xshift,xkeyX:boolean;xkey:byte);
procedure low__wordcore__keyboard2(var x:twordcore;akcode:longint);
procedure low__wordcore__mouse(var x:twordcore;xmousex,xmousey:longint;xmousedown,xmouseright:boolean);
function low__wordcore(var x:twordcore;xcmd:string;xval:tstr8):boolean;//return result: true/false
function low__wordcore_str(var x:twordcore;xcmd,xval:string):boolean;
function low__wordcore2(var x:twordcore;xcmd:string;xval:tstr8):longint;//return result: longint
function low__wordcore_str2(var x:twordcore;xcmd,xval:string):longint;
function low__wordcore3(var x:twordcore;xcmd:string;xval:tstr8;var xoutval,e:string):boolean;//return result: true=OK, false=error, result stored in "xoutval" - 25aug2019
function low__wordcore4(var x:twordcore;xcmd:string;xval,xoutbin:tstr8;var xoutval,e:string):boolean;//return result: true=OK, false=error, result stored in "xoutval" - 25aug2019


//-- color generators ----------------------------------------------------------
function low__white24:longint;
function low__black24:longint;
function low__grey24:longint;
function low__nonwhite24(x:tcolor24):tcolor24;//make sure color is never white


//-- ease of use tstr8 system handlers -----------------------------------------
function bif(s,d:tstr8):boolean;
function bifnot(s,d:tstr8):boolean;
function blen(x:tstr8):longint;
function bsetlen(x:tstr8;xlen:longint):boolean;
function _blen(x:tstr8):longint;//does not destroy "x"
procedure bdel1(x:tstr8;xpos1,xlen:longint);
function bchar(xval:longint):tstr8;
function bcopy1(x:tstr8;xpos1,xlen:longint):tstr8;
function bcopystr1(x:string;xpos1,xlen:longint):tstr8;
function bcopystrall(x:string):tstr8;
function bstr(x:tstr8):string;
function bgetstr1(x:tstr8;xpos1,xlen:longint):string;
function bcopyarray(x:array of byte):tstr8;
procedure bclear(var x:tstr8);//25jun2022
procedure bfree(var x:tstr8);
procedure bautofree(var x:tstr8);
procedure bautofreeb(x:tstr8);
function bnew:tstr8;
function bnew2(var x:tstr8):boolean;
function bnewlen(xlen:longint):tstr8;
function bnewstr(xtext:string):tstr8;
function breuse(var x:tstr8;xtext:string):tstr8;//also acts as a pass-thru - 05jul2022
function bnewfrom(xdata:tstr8):tstr8;
function bnew_autofree:tstr8;
function bcheck(x:tstr8;xpos:longint):boolean;//05may2021
function bcheck2(x:tstr8;xpos,xdebugid:longint):boolean;//05may2021
function block(x:tstr8):boolean;
function bunlock(x:tstr8):boolean;
procedure bunlockautofree(x:tstr8);
function vnew:tvars8;
function vnew2(xdebugid:longint):tvars8;
procedure bmplock(x:tobject);
procedure bmpunlock(x:tobject);
//access system values by name - 07sep2020
function sfromname(n:string):string;
function ifromname(n:string):longint;
function bfromname(n:string):boolean;


//color list support - 09mar2021 -----------------------------------------------
//Note: direct and rapid access to all colors in color list
function low__colorsarray(xdata:string):string;
function low__fixcolors(xdata:string):string;//fixes any errors by filtering out bad data
function low__validcolor(xindex:longint;var xdefcol:longint):boolean;
function low__criticalcolor(xindex:longint):boolean;//22jul2021
function low__getcolor(xdata:string;xindex:longint;var xcolor:longint):boolean;
function low__getcolor2(var xdata:string;xindex:longint;var xcolor:longint):boolean;
function low__setcolor(xdata:string;xindex,xcolor:longint):string;//outputs entire color stream
function low__setcolorb(xdata:string;xindex,xcolor:longint;xadjBrightness100:longint):string;//outputs entire color stream
function low__setcolor2(var xdata:string;xindex,xcolor:longint):string;//outputs entire color stream
function low__setcolor3(var xdata:string;xindex,xcolor:longint;xadjBrightness100:longint):string;//18sep2022 outputs entire color stream
function low__getcolors(xnormal,xtitle:pvirtualinfo;xmorecolors:pvirtualmorecolors):string;
procedure low__setcolors(xdata:string;xnormal,xtitle:pvirtualinfo;xmorecolors:pvirtualmorecolors);
function low__setcolorsbyname(xname:string;xnormal,xtitle:pvirtualinfo;xmorecolors:pvirtualmorecolors):boolean;
function low__findbuiltincolor(n:string;xexpand:boolean;var xadjBrightness100:longint):string;
function low__tocompactcolors(xdata:string):string;
function low__fromcompactcolors(xdata:string;var xout:string):boolean;
function low__fromcompactcolors2(xdata:string;xadjBrightness100:longint;var xout:string):boolean;
function low__coloradjBrightness(x:byte;xadjBrightness100:longint):byte;


//external support -------------------------------------------------------------
function low__clienttoscreen(x:tobject;s:tpoint):tpoint;
procedure low__setcursor(xhost:tbasicsystem;xname:string;xdata:tstr8);//29aug2021
procedure low__loadcursor;
procedure low__loadcursor2(var xname:string;xloadcursor:boolean);


//zip support - 26jan2021 ------------------------------------------------------
function zlibAllocMem(AppData: Pointer; Items, Size: longint): Pointer;
procedure zlibFreeMem(AppData, Block: Pointer);
//.deflate compresses data
function deflateInit_(var strm: TZStreamRec; level: longint; version: PChar; recsize: longint): longint; external;
function deflate(var strm: TZStreamRec; flush: longint): longint; external;
function deflateEnd(var strm: TZStreamRec): longint; external;
//.inflate decompresses data
function inflateInit_(var strm: TZStreamRec; version: PChar; recsize: longint): longint; external;
function inflate(var strm: TZStreamRec; flush: longint): longint; external;
function inflateEnd(var strm: TZStreamRec): longint; external;
function inflateReset(var strm: TZStreamRec): longint; external;

const
  Z_NO_FLUSH      = 0;
  Z_PARTIAL_FLUSH = 1;
  Z_SYNC_FLUSH    = 2;
  Z_FULL_FLUSH    = 3;
  Z_FINISH        = 4;
  Z_OK            = 0;
  Z_STREAM_END    = 1;
  Z_NEED_DICT     = 2;
  Z_ERRNO         = (-1);
  Z_STREAM_ERROR  = (-2);
  Z_DATA_ERROR    = (-3);
  Z_MEM_ERROR     = (-4);
  Z_BUF_ERROR     = (-5);
  Z_VERSION_ERROR = (-6);
  Z_NO_COMPRESSION       =   0;
  Z_BEST_SPEED           =   1;
  Z_BEST_COMPRESSION     =   9;
  Z_DEFAULT_COMPRESSION  = (-1);
  Z_FILTERED            = 1;
  Z_HUFFMAN_ONLY        = 2;
  Z_DEFAULT_STRATEGY    = 0;
  Z_BINARY   = 0;
  Z_ASCII    = 1;
  Z_UNKNOWN  = 2;
  Z_DEFLATED = 8;


//memory mapped file AND link1 support -----------------------------------------
//compiler tag: "mfile" check with need_mfile
//cost:
procedure memfile_init;
function memfile_start(xname:string;xsize,xslot:longint):boolean;
procedure memfile_stop(xslot:longint);
function memfile_read(xslot,xpos,xlen:longint;var xoutval:shortstring):boolean;
function memfile_write(xslot,xpos:longint;xval:shortstring):boolean;

//also enables "link1" support below:
//.push
function low__pushlink1c(n:string;v:string;int1:longint;bol1:boolean):boolean;
function low__pushlink1b(n:string;v:string;var int1:longint;var bol1:boolean):boolean;
function low__pushlink1(n:string;var v:string;var int1:longint;var bol1:boolean):boolean;
function low__deadpushlink1:boolean;
//.pull
function low__pulllink1(x:tpulleventfunc):boolean;
function low__deadpulllink1:boolean;

//PLUS support -----------------------------------------------------------------
//date   : 27jun2022
//version: 1.00.050
function plus_index:longint;
function plus_indexb(var x:longint):boolean;//pass-thru
function plus_index2(x:tobject;xrangecheck:boolean):longint;
procedure plus_setindex(x:tobject;xindex:longint);
function plus_pagename(xpageindex:longint):string;
function plus_stamppagename(x:tobject;xpageindex:longint):boolean;//pass-thru - use to set a controls "opagename" to a value of "scPlus0..7"
function plus_scpagecode(xpageindex:longint):string;//for adding "scPage" control codes to toolbars -> tells toolbar button to SHOW a particular set of controls with then "opagename=scPlusN" where N is "0..7" - 27jun2022
function plus_toolbar(x:tobject;var y:tbasictoolbar):boolean;
function plus_toolbar2(x:tobject;var y:tbasictoolbar):boolean;
procedure plus_bhighlight(x:tobject);
procedure plus_bhighlight2(x:tobject);
procedure plus_addlinks(x:tobject;xtep:longint;xmaincap,xhelp:string;xnewline,xmorepadding:boolean);
procedure plus_addlinks2(x:tobject;xtep:longint;xmaincap,xhelp:string;xnewline,xmorepadding:boolean);

//management support - 09feb2022 -----------------------------------------------
//compiler tag: "man" check with need_man
//cost: 4K - 09feb2022
//note: set of low level procs designed to cut/copy/paste/move/del/delall a select range of
//      objects within a "pdlobject" array with little additional support code
//special note: recommended all objects are of the same type, best object to use
//              is "tany" which can carry multiple different objects and maintain
//              independent memory and datastreams for each and every copy
//requires: the "man" compiler tag, otherwise all key procs fail and return FALSE
function man__any:tany;//new any
function man__makecopy(s:tobject):tobject;
function man__copyfrom(s:tobject;d:pobject):boolean;
function man__init(uid:string;x:pdlobject;xhigh:longint;var xlimit,xcount:longint):boolean;
function man__edit(uid:string;x:pdlobject;var xholder:tobject;xstyle:string;xlimit,xfocus:longint;var xcount,xnewfocus:longint):boolean;
function man__can(x:pdlobject;xfocus,xcount:longint;xnotnil:boolean):boolean;
function man__new(uid:string;x:pdlobject;xnewobj:tobject;xlimit,xfocus:longint;var xcount:longint):boolean;
function man__del(uid:string;x:pdlobject;xfocus:longint;var xcount:longint):boolean;
function man__delall(uid:string;x:pdlobject;var xcount:longint):boolean;
function man__move(uid:string;x:pdlobject;xcount,xfrom,xto:longint):boolean;
function man__movestr(x:pdlstring;xcount,xfrom,xto:longint):boolean;
function man__moveint(x:pdllongint;xcount,xfrom,xto:longint):boolean;

//mult-undo support - 25jun2022 ------------------------------------------------
function low__minit(x:tstr8;xlimit:longint):boolean;
function low__mstartsplit(x:tstr8;var u,r,f:tstr8):boolean;
function low__mstart(var u,r,f:tstr8):boolean;
function low__mfinish(var x,u,r,f:tstr8):boolean;
function low__mmake(x,u,r,f:tstr8):boolean;
function low__msplit(x,u,r,f:tstr8):boolean;
function low__mclear(x:tstr8):boolean;
function low__mnewslot(x:tstr8):longint;
function low__minsertslotREDO(x:tstr8):longint;//02jul2022
function low__mcanundo(x:tstr8):boolean;
function low__mundo(x:tstr8;var xslot:longint):boolean;
function low__mcanredo(x:tstr8):boolean;
function low__mredo(x:tstr8;var xslot:longint):boolean;
function low__mdebug(x:tstr8):string;
//.redo support
function low__mredocount(x:tstr8):longint;
function low__mredofind(x:tstr8;xindex:longint;var xslot:longint):boolean;//
//.undo support
function low__mundocount(x:tstr8):longint;
function low__mundofind(x:tstr8;xindex:longint;var xslot:longint):boolean;//


//app support ------------------------------------------------------------------
procedure app__nomax;//hide D3's blank black window if it happens to show for whatever reason - 14may2022
procedure app__init;//20feb2202
function app__processmessages:boolean;
function app__processallmessages:boolean;
procedure app__timer;
procedure app__fasttimer;
procedure app__turbo;
procedure app__fast;
function app__turboOK:boolean;
function app__fastOK:boolean;
//.realtime support - 25mar2022
function app__realtimeOK:boolean;
procedure app__realtime;
procedure app__realtimeSYNC;//internally called by system procs - 19apr2022

//basic registry support ------------------------------------------------------- 28may2022
function reg__readval(xrootstyle:longint;xname:string;xuseint:boolean):string;

//xxxxxxxxxxxxxxxxxxxxxxx//mmmmmmmmmmmmmmmmmmmm
//multimedia support -----------------------------------------------------------
{$ifdef mm}
var
   //system support - 29mar2021
   mmsys_midi:tbasicmidi=nil;
   mmsys_chimes:tbasicchimes=nil;//02mar2022
   mmsys_wave:taudiobasic=nil;
   mmsys_mm:tmm=nil;
   mmsys_mode:longint=0;//0=not in use, 1=initing, 2=inited, 3=shuting, 4=shut
   //support refs
   //.mid
   mmsys_mid_devicetime:comp=0;//not init'ed yet - 18apr2021
   mmsys_mid_devicecount:longint=0;
   mmsys_mid_deviceok  :array[0..10] of boolean;//0=midi-mapper, 1..N=device #0..(n-1) - 18apr2021
   mmsys_mid_devicename:array[0..10] of string;//12may2021
   mmsys_mid_basevol   :longint=50;//0=off, 100=100% (default) upto 200% - 23mar2022
   //.wav
   mmsys_wav_devicetime:comp=0;//not init'ed yet - 18apr2021
   mmsys_wav_devicecount:longint=0;
   mmsys_wav_deviceok  :array[0..10] of boolean;//0=wave-mapper, 1..N=device #0..(n-1) - 18apr2021
   mmsys_wav_devicename:array[0..10] of string;//12may2021
   //.mm
   mmsys_mm_lastfilename:string='';
   mmsys_mm_lastsize:longint=0;
   mmsys_mm_lastpos:longint=0;
   mmsys_mm_lastlen:longint=0;
   
//.system support
function mm_midi:tbasicmidi;
function mm_chimes:tbasicchimes;
function mm_wave:taudiobasic;
function mm_mm:tmm;
//.wave out
function waveOutOpen(lphWaveOut: PHWaveOut; uDeviceID: UINT; lpFormat: PWaveFormatEx; dwCallback, dwInstance, dwFlags: DWORD): MMRESULT;
function waveOutClose(hWaveOut: HWAVEOUT): MMRESULT;
//.wave in
function waveInOpen(lphWaveIn: PHWAVEIN; uDeviceID: UINT; lpFormatEx: PWaveFormatEx; dwCallback, dwInstance, dwFlags: DWORD): MMRESULT;
function waveInClose(hWaveIn: HWAVEIN): MMRESULT;
//.midi - out - 20JAN2011
function midiOutOpen(lphMidiOut:PHMIDIOUT; uDeviceID: UINT; dwCallback, dwInstance, dwFlags: DWORD): MMRESULT;
function midiOutClose(hMidiOut: HMIDIOUT): MMRESULT;
function midiOutShortMsg2(hMidiOut:HMIDIOUT;xmsg,xval1,xval2,xval3:byte):MMRESULT;
function midioutflush(xhandle:hmidiout):boolean;
//.volume support
function low__getvol:longint;//0..100% - 29mar2021,07OCT2010
procedure low__setvol(x:longint);//0..100% - 29mar2021, 07OCT2010

//** Low level midi note storage procs for use with "tstr8" - 14feb2021
function low__midcount(x:tstr8):longint;
function low__midbytes(x:tstr8):longint;
function low__midtime(x:tstr8):longint;
function low__midget(x:tstr8;xindex:longint;var xtimeuSEC:comp;var xmsg,xval1,xval2,xval3:byte):boolean;
function low__midset(x:tstr8;xindex:longint;xtimeuSEC:comp;xmsg,xval1,xval2,xval3:byte):boolean;
function low__midadd(x:tstr8;xtimeuSEC:comp;xmsg,xval1,xval2,xval3:byte):boolean;
function low__makemid(x:string;var xdata:tstr8;var e:string):boolean;//make a simple, single track midi - 15nov2022, 16mar2022
function low__txttomid(x,xtext:tstr8;var e:string):boolean;

//** tsnd32 support procs and system handlers
function nsnd32:tsnd32;
procedure fsnd32(var x:tsnd32);
function snd_toformat(xhz,xbits,xchs:longint):string;
function snd_fromformat(x:string;var xhz,xbits,xchs:longint):boolean;
function snd_safechs(x:longint):longint;
function snd_safebits(x:longint):longint;
function snd_safekhz(x:longint):longint;
function snd_safehz(x:longint):longint;
function snd_tokhz(xfromHZ:longint):longint;
function snd_tohz(xfromKHZ:longint):longint;
function snd_validkhz(x:longint):boolean;
function snd_validhz(x:longint):boolean;
function snd_waveheaderlen:longint;
function snd_waveheader(format:string;datalen:longint;xoutpos:longint;xout:tstr8):boolean;

//.playlist support - 25mar2022
function playlist__onelen:longint;//was 1028 but was reduced to 516 on 25mar2022 -> 86,000 items was consuming 180Mb or RAM, now more like 90Mb
function playlist__titlestart:longint;
function playlist__namestart:longint;
function playlist__namelen:longint;
function playlist__count(x:tstr8):longint;
function playlist__getone(xplaylistfilename:string;x:tstr8;xindex:longint;var xsec:longint;var xtitle,xfilename:string):boolean;
function playlist__addone(xplaylistfilename:string;x:tstr8;xsec:longint;xtitle,xfilename,xmask:string):boolean;
function playlist__addall(xroot,xlistroot:string;x,xlistoffiles:tstr8;xmask:string):boolean;

//** general
function to32bit(x:string):longint;//29AUG2007
function from32bit(x:longint):string;//29AUG2007
{$endif}


//-- Microsoft Windows DLL References -------------------------------------------
//winmm.dll
function timeGetTime: DWORD; stdcall; external mmsyst name 'timeGetTime';
function timeSetEvent(uDelay, uResolution: UINT;  lpFunction: TFNTimeCallBack; dwUser: DWORD; uFlags: UINT): UINT; stdcall; external mmsyst name 'timeSetEvent';
function timeKillEvent(uTimerID: UINT): UINT; stdcall; external mmsyst name 'timeKillEvent';
function timeBeginPeriod(uPeriod: UINT): MMRESULT; stdcall; external mmsyst name 'timeBeginPeriod';
function timeEndPeriod(uPeriod: UINT): MMRESULT; stdcall; external mmsyst name 'timeEndPeriod';
{$ifdef mm}
//.wave - out
function waveOutGetDevCaps(uDeviceID: UINT; lpCaps: PWaveOutCaps; uSize: UINT): MMRESULT; stdcall; external mmsyst name 'waveOutGetDevCapsA';
function _waveOutOpen(lphWaveOut: PHWaveOut; uDeviceID: UINT; lpFormat: PWaveFormatEx; dwCallback, dwInstance, dwFlags: DWORD): MMRESULT; stdcall; external mmsyst name 'waveOutOpen';
function _waveOutClose(hWaveOut: HWAVEOUT): MMRESULT; stdcall; external mmsyst name 'waveOutClose';
function waveOutPrepareHeader(hWaveOut: HWAVEOUT; lpWaveOutHdr: PWaveHdr; uSize: UINT): MMRESULT; stdcall; external mmsyst name 'waveOutPrepareHeader';
function waveOutUnprepareHeader(hWaveOut: HWAVEOUT; lpWaveOutHdr: PWaveHdr; uSize: UINT): MMRESULT; stdcall; external mmsyst name 'waveOutUnprepareHeader';
function waveOutWrite(hWaveOut: HWAVEOUT; lpWaveOutHdr: PWaveHdr; uSize: UINT): MMRESULT; stdcall; external mmsyst name 'waveOutWrite';
//.wave - in
function _waveInOpen(lphWaveIn: PHWAVEIN; uDeviceID: UINT; lpFormatEx: PWaveFormatEx; dwCallback, dwInstance, dwFlags: DWORD): MMRESULT; stdcall; external mmsyst name 'waveInOpen';
function _waveInClose(hWaveIn: HWAVEIN): MMRESULT; stdcall; external mmsyst name 'waveInClose';
function waveInPrepareHeader(hWaveIn: HWAVEIN; lpWaveInHdr: PWaveHdr; uSize: UINT): MMRESULT; stdcall; external mmsyst name 'waveInPrepareHeader';
function waveInUnprepareHeader(hWaveIn: HWAVEIN; lpWaveInHdr: PWaveHdr; uSize: UINT): MMRESULT; stdcall; external mmsyst name 'waveInUnprepareHeader';
function waveInAddBuffer(hWaveIn: HWAVEIN; lpWaveInHdr: PWaveHdr; uSize: UINT): MMRESULT; stdcall; external mmsyst name 'waveInAddBuffer';
function waveInStart(hWaveIn: HWAVEIN): MMRESULT; stdcall; external mmsyst name 'waveInStart';
function waveInStop(hWaveIn: HWAVEIN): MMRESULT; stdcall; external mmsyst name 'waveInStop';
function waveInReset(hWaveIn: HWAVEIN): MMRESULT; stdcall; external mmsyst name 'waveInReset';
//.midi
function midiOutGetDevCaps(uDeviceID: UINT; lpCaps: PMidiOutCaps; uSize: UINT): MMRESULT; stdcall; external mmsyst name 'midiOutGetDevCapsA';
function _midiOutOpen(lphMidiOut: PHMIDIOUT; uDeviceID: UINT; dwCallback, dwInstance, dwFlags: DWORD): MMRESULT; stdcall; external mmsyst name 'midiOutOpen';
function _midiOutClose(hMidiOut: HMIDIOUT): MMRESULT; stdcall; external mmsyst name 'midiOutClose';
function midiOutShortMsg(hMidiOut: HMIDIOUT; dwMsg: DWORD): MMRESULT; stdcall; external mmsyst name 'midiOutShortMsg';
function midiOutReset(hMidiOut: HMIDIOUT): MMRESULT; stdcall; external mmsyst name 'midiOutReset';//for midi streams only? -> hence the "no effect" for volume reset between songs - 15apr2021
//function midiOutPrepareHeader(hMidiOut: HMIDIOUT; lpMidiOutHdr: PMidiHdr; uSize: UINT): MMRESULT; stdcall; external mmsyst name 'midiOutPrepareHeader';
//function midiOutUnprepareHeader(hMidiOut: HMIDIOUT; lpMidiOutHdr: PMidiHdr; uSize: UINT): MMRESULT; stdcall; external mmsyst name 'midiOutUnprepareHeader';
//function midiOutLongMsg(hMidiOut: HMIDIOUT; lpMidiOutHdr: PMidiHdr; uSize: UINT): MMRESULT; stdcall; external mmsyst name 'midiOutLongMsg';
//.mci
function mciSendCommand(mciId:MCIDEVICEID;uMessage:UINT;dwParam1,dwParam2:DWORD):MCIERROR; stdcall; external 'winmm.dll' name 'mciSendCommandA';
function mciGetErrorString(mcierr: MCIERROR; pszText: PChar; uLength: UINT): BOOL; stdcall; external 'winmm.dll' name 'mciGetErrorStringA';

//.mixer - volumes
function waveOutGetVolume(hwo: longint; lpdwVolume: PDWORD): MMRESULT; stdcall; external mmsyst name 'waveOutGetVolume';
function waveOutSetVolume(hwo: longint; dwVolume: DWORD): MMRESULT; stdcall; external mmsyst name 'waveOutSetVolume';
function midiOutGetVolume(hmo: longint; lpdwVolume: PDWORD): MMRESULT; stdcall; external mmsyst name 'midiOutGetVolume';
function midiOutSetVolume(hmo: longint; dwVolume: DWORD): MMRESULT; stdcall; external mmsyst name 'midiOutSetVolume';
function auxSetVolume(uDeviceID: UINT; dwVolume: DWORD): MMRESULT; stdcall; external mmsyst name 'auxSetVolume';
function auxGetVolume(uDeviceID: UINT; lpdwVolume: PDWORD): MMRESULT; stdcall; external mmsyst name 'auxGetVolume';
{$endif}

//kernel32.dll
function GetTickCount: DWORD; stdcall; external kernel32 name 'GetTickCount';
function CreateThread(lpThreadAttributes: Pointer;dwStackSize: DWORD; lpStartAddress: TFNThreadStartRoutine;lpParameter: Pointer; dwCreationFlags: DWORD; var lpThreadId: DWORD): THandle; stdcall; external kernel32 name 'CreateThread';
procedure ExitThread(dwExitCode: DWORD); stdcall; external kernel32 name 'ExitThread';
procedure Sleep(dwMilliseconds: DWORD); stdcall; external kernel32 name 'Sleep';
//.io support
function CreateFileMapping(hFile: THandle; lpFileMappingAttributes: PSecurityAttributes; flProtect, dwMaximumSizeHigh, dwMaximumSizeLow: DWORD; lpName: PChar): THandle; stdcall; external kernel32 name 'CreateFileMappingA';
function MapViewOfFile(hFileMappingObject: THandle; dwDesiredAccess: DWORD; dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap: DWORD): Pointer; stdcall; external kernel32 name 'MapViewOfFile';
function UnmapViewOfFile(lpBaseAddress: Pointer): BOOL; stdcall; external kernel32 name 'UnmapViewOfFile';
function CloseHandle(hObject: THandle): BOOL; stdcall; external kernel32 name 'CloseHandle';
//user32.dll
function PostThreadMessage(idThread: DWORD; Msg: UINT; wParam: WPARAM; lParam: LPARAM): BOOL; stdcall; external user32 name 'PostThreadMessageA';
function GetMessage(var lpMsg: TMsg; hWnd: HWND; wMsgFilterMin, wMsgFilterMax: UINT): BOOL; stdcall; external user32 name 'GetMessageA';
function TranslateMessage(const lpMsg: TMsg): BOOL; stdcall; external user32 name 'TranslateMessage';
function DispatchMessage(const lpMsg: TMsg): Longint; stdcall; external user32 name 'DispatchMessageA';
function PeekMessage(var lpMsg: TMsg; hWnd: HWND; wMsgFilterMin, wMsgFilterMax, wRemoveMsg: UINT): BOOL; stdcall; external user32 name 'PeekMessageA';
function LoadCursor(hInstance: HINST; lpCursorName: PAnsiChar): HCURSOR; stdcall; external user32 name 'LoadCursorA';
function LoadCursorFromFile(lpFileName: PAnsiChar): HCURSOR; stdcall; external user32 name 'LoadCursorFromFileA';
function GetCursorPos(var lpPoint: TPoint): BOOL; stdcall; external user32 name 'GetCursorPos';
function ClientToScreen(hWnd: HWND; var lpPoint: TPoint): BOOL; stdcall; external user32 name 'ClientToScreen';
function ScreenToClient(hWnd: HWND; var lpPoint: TPoint): BOOL; stdcall; external user32 name 'ScreenToClient';


implementation

uses Harmony1, Harmony2;

const
   //security checkid 2 of 2 -> put it here to space it out inside the EXE - harder to track - 11oct2022
   programcode_checkid2:array[0..76] of byte=(142,88,4,180,254,35,190,243,149,89,240,162,42,159,186,115,112,51,195,169,123,246,172,72,78,167,82,63,140,200,151,89,174,17,183,190,78,100,87,69,110,170,215,252,216,5,164,152,230,55,114,169,90,83,181,216,30,229,196,128,11,62,102,94,8,148,192,71,51,30,243,253,210,91,204,166,71);

//## System Procedures and Functions ###########################################

{$L deflate.obj}
{$L inflate.obj}
{$L inftrees.obj}
{$L trees.obj}
{$L adler32.obj}
{$L infblock.obj}
{$L infcodes.obj}
{$L infutil.obj}
{$L inffast.obj}

//## zip support ###############################################################
procedure _tr_init; external;
procedure _tr_tally; external;
procedure _tr_flush_block; external;
procedure _tr_align; external;
procedure _tr_stored_block; external;
procedure adler32; external;

procedure inflate_blocks_new; external;
procedure inflate_blocks; external;
procedure inflate_blocks_reset; external;
procedure inflate_blocks_free; external;
procedure inflate_set_dictionary; external;
procedure inflate_trees_bits; external;
procedure inflate_trees_dynamic; external;
procedure inflate_trees_fixed; external;
procedure inflate_trees_free; external;
procedure inflate_codes_new; external;
procedure inflate_codes; external;
procedure inflate_codes_free; external;
procedure _inflate_mask; external;
procedure inflate_flush; external;
procedure inflate_fast; external;

procedure _memset(P: Pointer; B: Byte; count: longint);cdecl;
begin
FillChar(P^, count, B);
end;

procedure _memcpy(dest, source: Pointer; count: longint);cdecl;
begin
Move(source^, dest^, count);
end;

function zlibAllocMem(AppData: Pointer; Items, Size: longint): Pointer;
begin
//was: low__getmem(Result, Items*Size,80021);//15may2021
getmem(Result, Items*Size);//15may2021
end;

procedure zlibFreeMem(AppData, Block: Pointer);
begin
freemem(Block);
//was: low__freemem(block,0,80020);//04may2021
end;


//system threads ---------------------------------------------------------------
//## systhread__initall ##
procedure systhread__initall;
var
   p:longint;
begin
try
//check
if systhread_initall then exit else systhread_initall:=true;
//get
for p:=0 to high(systhread_running) do
begin
systhread_running[p]   :=false;
systhread_ready[p]     :=false;
systhread_muststop[p]  :=false;
systhread_handle[p]    :=0;
systhread_id[p]        :=0;
systhread_timerid[p]   :=0;
systhread_timerms[p]   :=0;
systhread_usingtimer[p]:=false;
systhread_fast64[p]    :=0;//fast always by default
//lag time
systhread_lag[p]       :=0;
systhread_lastlag[p]   :=0;
systhread_lagref[p]    :=0;
systhread_ref1000[p]   :=0;
//io buffers
systhread_bufferid[p]  :=0;
systhread_bufferid2[p] :=0;
systhread_cmd[p]       :=0;
systhread_bufferlen[p] :=0;
end;//p
except;end;
end;
//## systhread__start ##
function systhread__start(xstartproc:TFNThreadStartRoutine;xms:longint;xfast:comp;var xslot:longint):boolean;
var//Note: xms can be negative (no timer) or positive (with timer): - 05mar2022
   //      -N..0 = use sleep() in thread loop (no mmtimer) -> about 3-4ms intervals on Win98 = STABLE (Win98)
   //      1..N  = use mmtimer -> about 20ms (drifting up to 40ms) intervals on Win98 = UNSTABLE (Win98)
   p:longint;
   xusetimer:boolean;
begin
try
//defaults
result:=false;
xslot:=0;
//check
if (xstartproc=nil) then exit;
//range
xusetimer:=(xms>=1);
if (xms<0) then xms:=-xms;
xms:=frcrange(xms,1,5000);//always 1..N
//get
for p:=0 to high(systhread_handle) do
begin
if not systhread_running[p] then
   begin
   //core support
   systhread_running[p]    :=true;
   systhread_ready[p]      :=false;
   xslot                   :=p;
   systhread_muststop[p]   :=false;
   systhread_id[p]         :=0;
   systhread_timerid[p]    :=0;
   systhread_timerms[p]    :=xms;
   systhread_usingtimer[p] :=false;
   systhread_fast64[p]     :=xfast;//0=fast always, ms64+N=fast for N milliseconds
   //lag support
   systhread_lag[p]        :=-1;
   systhread_lastlag[p]    :=0;
   systhread_lagref[p]     :=0;
   systhread_ref1000[p]    :=0;
   //buffer support
   systhread_bufferid[p]   :=0;
   systhread_bufferid2[p]  :=0;
   systhread_cmd[p]        :=0;
   systhread_bufferlen[p]  :=0;

   //get
   systhread_handle[p]     :=createthread(nil,0,xstartproc,pointer(p),0,systhread_id[p]);
   if (systhread_handle[p]<>0) and xusetimer then
      begin
      //Special Note: 2nd "xms" is resolution and must exacltly match the value used in "stoptimer" to "timeEndPeriod()" else program will HANG - 05mar2022
      systhread_timerid[p]:=timesetevent(xms,xms,@systhread__timerproc,systhread_id[p],1);//last "1" => "TIME_PERIODIC" - 18apr2021
      systhread_usingtimer[p]:=(systhread_timerid[p]<>0);
      end;

//this is wrong: was:  setthreadpriority(systhread_id[p],THREAD_PRIORITY_TIME_CRITICAL);//This is WRONG, we need to use HANDLE and not ID
//let timer proc itself handle this priority stuff: was:   setthreadpriority(systhread_handle[p],THREAD_PRIORITY_TIME_CRITICAL);//Correct as of 05mar2022

   //.start thread
   systhread_ready[p]      :=true;
   result                  :=true;
   //quit
   break;
   end;
end;//p
except;end;
end;
//## systhread__canstop ##
function systhread__canstop(xslot:longint):boolean;
begin
try;result:=systhread__slotOK(xslot) and systhread_running[xslot] and (not systhread_muststop[xslot]);except;end;
end;
//## systhread__stop ##
procedure systhread__stop(xslot:longint);
begin
try;if systhread__canstop(xslot) then systhread_muststop[xslot]:=true;except;end;
end;
//## systhread__stopwait ##
procedure systhread__stopwait(xslot:longint);
begin
try
if systhread__canstop(xslot) then
   begin
   systhread_muststop[xslot]:=true;
   while systhread_running[xslot] do
   begin
   app__processmessages;
   sleep(10);
   end;//loop
   end;
except;end;
end;
//## systhread__stopall ##
procedure systhread__stopall(xwait:boolean);
var
   p:longint;
   bol1:boolean;
begin
try
//stop
for p:=0 to high(systhread_muststop) do if systhread__canstop(p) then systhread_muststop[p]:=true;
//wait
while true do
begin
bol1:=false;
for p:=0 to high(systhread_muststop) do if systhread_running[p] then
   begin
   bol1:=true;
   break;
   end;
if not bol1 then break;
app__processmessages;
sleep(10);
end;//loop

except;end;
end;
//## systhread__lag ##
function systhread__lag(xslot:longint):longint;
begin
try
//defaults
result:=-1;
//get
if systhread__slotOK(xslot) then result:=trunc(systhread_lag[xslot]);
except;end;
end;
//## systhread__fast ##
function systhread__fast(xslot:longint):boolean;//05mar2022
begin
try;result:=systhread__slotOK(xslot) and ((systhread_fast64[xslot]=0) or (systhread_fast64[xslot]>=ms64FAST));except;end;
end;
//## systhread__setfast ##
procedure systhread__setfast(xslot:longint;xre64:comp);
begin
try;if systhread__slotOK(xslot) and (xre64<>systhread_fast64[xslot]) then systhread_fast64[xslot]:=xre64;except;end;
end;
//##systhread__synclag ##
procedure systhread__synclag(xslot:longint;xms64:comp);
var
   tmp64:comp;
begin
try
if systhread__slotOK(xslot) then
   begin
   if (systhread_lagref[xslot]=0) then tmp64:=0 else tmp64:=xms64-systhread_lagref[xslot];
   if (tmp64>systhread_lastlag[xslot]) then systhread_lastlag[xslot]:=tmp64;
   systhread_lagref[xslot]:=xms64;
   if (xms64>=systhread_ref1000[xslot]) then
      begin
      systhread_ref1000[xslot]:=xms64+1000;
      systhread_lag[xslot]:=systhread_lastlag[xslot];
      systhread_lastlag[xslot]:=0;
      end;
   end;
except;end;
end;
//## systhread__pushing ##
function systhread__pushing(xslot:longint):boolean;
begin
try
//defaults
result:=false;
//check
if not systhread__slotOK(xslot) then
   begin
   result:=true;
   exit;
   end;
//get
if (systhread_bufferid[xslot]=systhread_bufferid2[xslot]) or (systhread_muststop[xslot]) or (not (systhread_running[xslot])) then result:=false
else result:=true;
except;end;
end;
//## systhread__push ##
function systhread__push(xslot:longint;xcmd:longint;xdata:string;var xreplycmd:longint;var xreplydata:string):boolean;
var
   xlen,p:longint;
begin
try
//defaults
result:=false;
xreplycmd:=0;
xreplydata:='';
//get
if not systhread__pushstart(xslot,xcmd,xdata) then exit;
if not systhread__pushfinish(xslot,true,xreplycmd,xreplydata) then exit;
//successful
result:=true;
except;end;
end;
//## systhread__pushstart ##
function systhread__pushstart(xslot:longint;xcmd:longint;xdata:string):boolean;
var
   xlen,p:longint;
begin
try
//defaults
result:=false;
//check
if not systhread__slotOK(xslot) then exit;
if not systhread_running[xslot] then exit;
if (systhread_bufferid[xslot]<>systhread_bufferid2[xslot]) then exit;
//init
xlen:=frcmax(length(xdata),1+high(tsysthread_buffer));
//fill
if (xlen>=1) then
   begin
   systhread_bufferlen[xslot]:=xlen;
   for p:=1 to xlen do
   begin
   systhread_buffer[xslot][p-1]:=ord(xdata[p-1+stroffset]);//22feb2022
   end;//p
   end;
systhread_cmd[xslot]:=xcmd;
//inc
if (systhread_bufferid[xslot]>=maxint) then systhread_bufferid[xslot]:=0 else inc(systhread_bufferid[xslot]);
//successful
result:=true;
except;end;
end;
//## systhread__pushfinish ##
function systhread__pushfinish(xslot:longint;xwait:boolean;var xreplycmd:longint;var xreplydata:string):boolean;
label
   redo;
var
   xlen,p:longint;
begin
try
//defaults
result:=false;
xreplycmd:=0;
xreplydata:='';
//check
if not systhread__slotOK(xslot) then
   begin
   result:=true;
   exit;
   end;
if not systhread_running[xslot] then
   begin
   result:=true;
   exit;
   end;
//wait
redo:
if (systhread_bufferid[xslot]=systhread_bufferid2[xslot]) or (systhread_muststop[xslot]) or (not (systhread_running[xslot])) then
   begin
   //set
   xreplycmd:=systhread_cmd[xslot];
   xlen:=frcmax(systhread_bufferlen[xslot],1+high(tsysthread_buffer));
   if (xlen>=1) then
      begin
      setlength(xreplydata,xlen);
      for p:=1 to xlen do xreplydata[p-1+stroffset]:=char(systhread_buffer[xslot][p-1]);
      end;
   //successful
   result:=true;
   end
else if xwait then
   begin
   app__processmessages;
   sleep(10);
   goto redo;
   end;
except;end;
end;
//## systhread__mustreply ##
function systhread__mustreply(xslot:longint;var xcmd:longint;var xdata:string):boolean;
var
   p,xlen:longint;
begin
try
//defaults
result:=false;
xcmd:=0;
xdata:='';
//check
if not systhread__slotOK(xslot) then exit;
if (systhread_bufferid[xslot]=systhread_bufferid2[xslot]) then exit;
//get
result:=true;
xlen:=frcmax(systhread_bufferlen[xslot],1+high(tsysthread_buffer));
if (xlen>=1) then
   begin
   setlength(xdata,xlen);
   xcmd:=systhread_cmd[xslot];
   for p:=1 to xlen do xdata[p-1+stroffset]:=char(systhread_buffer[xslot][p-1]);
   end;
except;end;
end;
//## systhread__reply ##
function systhread__reply(xslot:longint;xcmd:longint;xdata:string):boolean;
var
   p,xlen:longint;
begin
try
//defaults
result:=false;
//check
if not systhread__slotOK(xslot) then exit;
if (systhread_bufferid[xslot]=systhread_bufferid2[xslot]) then exit;
//get
result:=true;
systhread_cmd[xslot]:=xcmd;
xlen:=frcmax(length(xdata),1+high(tsysthread_buffer));
systhread_bufferlen[xslot]:=xlen;
if (xlen>=1) then
   begin
   for p:=1 to xlen do systhread_buffer[xslot][p-1]:=ord(xdata[p-1+stroffset]);
   end;
//successful
result:=true;
//inc
systhread_bufferid2[xslot]:=systhread_bufferid[xslot];
except;end;
end;
//## systhread__timerproc ##
procedure systhread__timerproc(uTimerID, uMsg: Integer; dwUser, dwParam1, dwParam2: longint); stdcall;
begin
postthreadmessage(HWND(dwUser), WM_MULTIMEDIA_TIMER, 0, 0);
end;
//## systhread__slotOK ##
function systhread__slotOK(xslot:longint):boolean;
begin
result:=(xslot>=0) and (xslot<=high(systhread_muststop));
end;
//## systhread__stoptimer ##
procedure systhread__stoptimer(xslot:longint);
var
   int1,int2:longint;
begin
try
if systhread__slotOK(xslot) and (systhread_timerid[xslot]<>0) then
   begin
   int1:=systhread_timerid[xslot];
   int2:=systhread_timerms[xslot];
   systhread_usingtimer[xslot]:=false;//05mar2022
   systhread_timerid[xslot]:=0;
   systhread_timerms[xslot]:=0;
   timeKillEvent(int1);
   timeEndPeriod(int2);//Absolutely required -> checked on 05mar2022 -> AND if not used here then calling "stoptimer" will make the program HANG - 05mar2022
   end;
except;end;
end;

//-- App Support - 30sep2021 ---------------------------------------------------
//## app__nomax ##
procedure app__nomax;//hide D3's black blank window if it happens to show for whatever reason - 14may2022
var
   v:longint;
begin
try
//check
if (application.handle=0) then exit;
//get
v:=getwindowlong(application.handle,gwl_style);
if ((ws_maximize and v)<>0) then showwindow(application.Handle, sw_shownormal);
except;end;
end;
//## app__init ##
procedure app__init;//20feb2202
label
   redo;
var
   bol1:boolean;
begin
try
//check
if app__running then exit else app__running:=true;
//start
app__initing:=true;
application.initialize;
application.createform(TForm1, Form1);
//init
syscursor_sizeref64:=ms64+5000;

//show
//AddExitProc(DoneApplication);//?????????????????????????????????
if (application.mainform<>nil) then
   begin
   application.mainform.visible:=true;
{//was:
   case cmdshow of
   SW_SHOWMINNOACTIVE:application.mainform.windowstate:=wsminimized;
   SW_SHOWMAXIMIZED:application.mainform.windowstate:=wsmaximized;
   end;
   //was: if FShowMainForm then
   if (application.mainform.windowstate=wsminimized) then application.minimize else application.mainform.visible:=true;
{}
   end;

//event loop
redo:
bol1:=app__processmessages;
app__timer;
if app__running then goto redo;

//close main form - fixed 20feb2022
if (application.mainform<>nil) then freeobj(@application.mainform);
except;end;
end;
//## app__processmessages ##
function app__processmessages:boolean;
label
   redo;
var
   xhandled,xok:boolean;
   msg:tmsg;
   v64:comp;
begin
//defaults
result:=false;
xok:=false;
v64:=ms64FAST;

//get
redo:
if peekmessage(msg,0,0,0,PM_REMOVE) then
   begin
   result:=true;//13mar2022
   xok:=true;
   if (msg.message=WM_QUIT) then app__running:=false
   else
      begin
      xhandled:=false;
      //if assigned(application.onmessage) then application.onmessage(msg,xhandled);
      if not xhandled then
         begin
         translatemessage(msg);
         dispatchmessage(msg);
         end;
      //loop - process multiple message for upto just less than 2ms - 30sep2021
      if ((ms64FAST-v64)<=5) then goto redo;
      end;
   end;

//Note: waitmessage puts program into idle mode (normal method) BUT absorbs 16ms, so ONLY use this when ultratimer is NOT in use - 30sep2021
if not xok then
   begin
   if (sysfasttimer_on64>=v64)      then sleep(1)
   else if (systimer_turbo64>=ms64) then sleep(1)//30sep2021
   else                                  sleep(16);
   end;
end;
//## app__processallmessages ##
function app__processallmessages:boolean;
label
   redo;
var
   xhandled,xok:boolean;
   msg:tmsg;
   v64:comp;
begin
//defaults
result:=false;
xok:=false;
v64:=ms64FAST;

//get
redo:
if peekmessage(msg,0,0,0,PM_REMOVE) then
   begin
   result:=true;
   xok:=true;
   if (msg.message=WM_QUIT) then siclose
   else
      begin
      xhandled:=false;
      //if assigned(application.onmessage) then application.onmessage(msg,xhandled);
      if not xhandled then
         begin
         translatemessage(msg);
         dispatchmessage(msg);
         end;
      //loop - process multiple message for upto just less than 2ms - 30sep2021
      goto redo;
      end;
   end;

//Note: waitmessage puts program into idle mode (normal method) BUT absorbs 16ms, so ONLY use this when ultratimer is NOT in use - 30sep2021
if not xok then
   begin
   if (sysfasttimer_on64>=v64)      then sleep(1)
   else if (systimer_turbo64>=ms64) then sleep(1)//30sep2021
   else                                  sleep(16);
   end;
end;
//## app__timer ##
procedure app__timer;
var
   tmp64,d64,v64:comp;
   p:longint;
begin
try
//shutdown - thread safe - 30sep2021
if siclosing and (not sicloseviapostDONE) and (low__closecount<=0) then
   begin
   sicloseviapostDONE:=true;//do only once - 30sep2021
   systimer_enabled:=false;
   postmessage(application.handle,wm_quit,0,0);//thread friendly shutdown signal - 26may2021
   exit;
   end;


//check
if (not systimer_enabled) or sihalted or (not app__running) then exit;


//fast timers ------------------------------------------------------------------
v64:=ms64FAST;//1ms accuracy

if (v64>=sysfasttimer64) and (not sysfasttimerBUSY) then
   begin
   //lock
   sysfasttimerBUSY:=true;
   //reset
   if (sysfasttimer_on64>=v64) then sysfasttimer64:=v64+1 else sysfasttimer64:=v64+50;
   //lag
   if (sysfasttimerLAGref<>0) then
      begin
      tmp64:=low__sub64(v64,sysfasttimerLAGref);
      if (tmp64>sysfasttimerlastlag) then sysfasttimerlastlag:=tmp64;
      end;
   sysfasttimerLAGref:=v64;
   //tick counter
   sysfasttimerlasttick:=sysfasttimerlasttick+1;
   if (v64>=sysfasttimer1000) then
      begin
      sysfasttimer1000:=v64+1000;
      sysfasttimerTICK:=sysfasttimerlasttick;
      sysfasttimerlasttick:=0;
      sysfasttimerLAG:=sysfasttimerlastlag;//07oct2021
      sysfasttimerlastlag:=0;
      end;
   //event 1
   if assigned(sysfasttimer1) then try;sysfasttimer1(nil);except;end;
   //event 2
   if assigned(sysfasttimer2) then try;sysfasttimer2(nil);except;end;
   //event 3
   if assigned(sysfasttimer3) then try;sysfasttimer3(nil);except;end;
   //unlock
   sysfasttimerBUSY:=false;
   end;

//normal timers ----------------------------------------------------------------
v64:=ms64;//16ms accuracy

//.nomax checker
if (v64>=systimer_nomax64) then
   begin
   app__nomax;
   systimer_nomax64:=v64+200;
   end;

//.normal timers
if (v64>=systimer64) then
   begin
   //sync realtime - 25mar2022
   app__realtimeSYNC;

   //sysfasttiminginuse
   sysfasttiminginuse:=(sysfasttimer_on64>=v64);// or (systimer_turbo64>=v64);
   //lag
   if (systimerLAGref<>0) then
      begin
      tmp64:=low__sub64(v64,systimerLAGref);
      if (tmp64>systimerlastLAG) then systimerlastLAG:=tmp64;
      end;
    systimerLAGref:=v64;
   //tick counter
   systimerlasttick:=systimerlasttick+1;
   if (v64>=systimer1000) then
      begin
      systimer1000:=v64+1000;
      systimerTICK:=systimerlasttick;
      systimerlasttick:=0;
      systimerLAG:=systimerlastlag;//07oct2021
      systimerlastlag:=0;
      end;
   //speed + events
   d64:=100;
   for p:=0 to high(systimer_event) do if (not sihalted) and assigned(systimer_event[p]) then
      begin
      //smallest system delay
      if (systimer_delay[p]>=1) and (systimer_delay[p]<d64) then d64:=systimer_delay[p];
      //fire timer event
      if (systimer_delay[p]>=1) and (v64>=systimer_ref64[p]) and (not systimer_busy[p]) then
         begin
         //Critical Note: This is the only pointer other than within "siInit()" that a timer's busy state is modified -> all other timer procs work around it - 19feb2021
         systimer_busy[p]:=true;//lock the timer
         systimer_ref64[p]:=v64+systimer_delay[p];
         try;if not sihalted then systimer_event[p](nil);except;end;
         systimer_busy[p]:=false;//unlock the timer (even if it has been deleted)
         end;
      end;//p
   //.min delay for normal timers is 30ms
   d64:=low__div64(d64,2);//divide smallest delay in half for a better, rounder delay
   if (d64<30) then d64:=30;
   //.turbo mode is on
   if (systimer_turbo64>=v64) then d64:=1;
   //.finalise speed
   systimer64:=v64+d64;
   end;//p

//.reload CURSOR whenever we are NOT running the default system cursor -> Changes to the size of the Windows cursor causes damaging distortion to a ready loaded and active cursor, thus ANY custom based cursor MUST be reloaded to allow for windows to resample the cursor at the new system dimensions - 28may2022
if (ms64>=syscursor_sizeref64) then
   begin
   if (not low__comparetext(syscursor_loadname,'default')) and (syscursor_sizeref<>reg__readval(0,'Control Panel\Cursors\CursorBaseSize',true)) then low__loadcursor;
   syscursor_sizeref64:=ms64+5000;
   end;
except;end;
end;
//## app__fasttimer ##
procedure app__fasttimer;
var
   tmp64,v64:comp;
begin
try
//check
if (not systimer_enabled) or sihalted or (not app__running) then exit;

//fast timers ------------------------------------------------------------------
v64:=ms64FAST;//1ms accuracy

if (v64>=sysfasttimer64) and (not sysfasttimerBUSY) then
   begin
   //lock
   sysfasttimerBUSY:=true;
   //reset
   if (sysfasttimer_on64>=v64) then sysfasttimer64:=v64+1 else sysfasttimer64:=v64+50;
   //lag
   if (sysfasttimerLAGref<>0) then
      begin
      tmp64:=low__sub64(v64,sysfasttimerLAGref);
      if (tmp64>sysfasttimerlastlag) then sysfasttimerlastlag:=tmp64;
      end;
   sysfasttimerLAGref:=v64;
   //tick counter
   sysfasttimerlasttick:=sysfasttimerlasttick+1;
   if (v64>=sysfasttimer1000) then
      begin
      sysfasttimer1000:=v64+1000;
      sysfasttimerTICK:=sysfasttimerlasttick;
      sysfasttimerlasttick:=0;
      sysfasttimerLAG:=sysfasttimerlastlag;//07oct2021
      sysfasttimerlastlag:=0;
      end;
   //event 1
   if assigned(sysfasttimer1) then try;sysfasttimer1(nil);except;end;
   //event 2
   if assigned(sysfasttimer2) then try;sysfasttimer2(nil);except;end;
   //event 3
   if assigned(sysfasttimer3) then try;sysfasttimer3(nil);except;end;
   //unlock
   sysfasttimerBUSY:=false;
   end;
except;end;
end;
//## app__turboOK ##
function app__turboOK:boolean;
begin
try;result:=(systimer_turbo64>=ms64);except;end;
end;
//## app__fastOK ##
function app__fastOK:boolean;
begin
try;result:=(sysfasttimer_on64>=ms64);except;end;
end;
//## app__turbo ##
procedure app__turbo;
begin
try;systimer_turbo64:=ms64+5000;except;end;
end;
//## app__fast ##
procedure app__fast;
begin
try;sysfasttimer_on64:=ms64+5000;except;end;
end;

//realtime process (program) support -------------------------------------------
//## app__realtimeOK ##
function app__realtimeOK:boolean;
begin
try;result:=(system_realtime64>=ms64);except;end;
end;
//## app__realtime ##
procedure app__realtime;
var
   bol1:boolean;
begin
try
//get
bol1:=app__realtimeOK;
system_realtime64:=ms64+5000;//turn on realtime for 5s
//sync immediately
if not bol1 then
   begin
   system_realtime642:=0;
   app__realtimeSYNC;
   end;
except;end;
end;
//## app__realtimeSYNC ##
procedure app__realtimeSYNC;//internally called by system procs - 19apr2022
label//Special Note: Realtime mode can only be achivied when program is "Run as Administrator" - 19apr2022
   skipend;
var
   bol1:boolean;
   sv,dv:dword;
   st,dt:longint;
begin
try
//check
if system_realtimeSYNCING then exit else system_realtimeSYNCING:=true;
if (system_realtime642>ms64) then goto skipend else system_realtime642:=ms64+5000;
//get
sv:=getpriorityclass(getcurrentprocess);
st:=getthreadpriority(getcurrentprocess);
case app__realtimeOK of
true:begin
   dv:=REALTIME_PRIORITY_CLASS;//process
   dt:=THREAD_PRIORITY_TIME_CRITICAL;//thread
   end;
false:begin
   dv:=NORMAL_PRIORITY_CLASS;
   dt:=THREAD_PRIORITY_NORMAL;
   end;
end;//case
//set
if (sv<>dv) or (st<>dt) then
   begin
   setpriorityclass(getcurrentprocess,dv);
   setthreadpriority(getcurrentprocess,dt);
   end;
skipend:
except;end;
try;system_realtimeSYNCING:=false;except;end;
end;

//--basic registry support -----------------------------------------------------
//## reg__readval ##
function reg__readval(xrootstyle:longint;xname:string;xuseint:boolean):string;
label//xrootstyle: 0=current user, 1=current machine
   skipend;
//  HKEY_CLASSES_ROOT     = $80000000;
//  HKEY_CURRENT_USER     = $80000001;
//  HKEY_LOCAL_MACHINE    = $80000002;
//  HKEY_USERS            = $80000003;
//  HKEY_PERFORMANCE_DATA = $80000004;
//  HKEY_CURRENT_CONFIG   = $80000005;
//  HKEY_DYN_DATA         = $80000006;
var
   k:hkey;
   xbuf:array[0..255] of char;
   xbuflen:cardinal;
   xlen,p:longint;
   xvalname:string;
   v:tint4;
begin
try
//defaults
result:='';
//init
xvalname:='';
xlen:=length(xname);
if (xlen<=0) then goto skipend;
//split
for p:=xlen downto 1 do
begin
if (xname[p-1+stroffset]='\') then
   begin
   xvalname:=strcopy1(xname,p+1,xlen);
   xname:=strcopy1(xname,1,p-1);
   break;
   end;
end;//p
//.enforcing trailing slash for xname - 28may2022
if (strcopy1(xname,length(xname),1)<>'\') then xname:=xname+'\';
//get
xbuflen:=sizeof(xbuf);
case xrootstyle of
0:if (regopenkeyex(HKEY_CURRENT_USER,pchar(xname),0,KEY_READ,k)<>ERROR_SUCCESS) then goto skipend;
1:if (regopenkeyex(HKEY_LOCAL_MACHINE,pchar(xname),0,KEY_READ,k)<>ERROR_SUCCESS) then goto skipend;
else goto skipend;
end;
//set
try
fillchar(xbuf,sizeof(xbuf),0);
if (regqueryvalueex(k,pchar(xvalname),nil,nil,@xbuf,@xbuflen)=ERROR_SUCCESS) then
   begin
   if xuseint then
      begin
      v.bytes[0]:=ord(xbuf[0]);
      v.bytes[1]:=ord(xbuf[1]);
      v.bytes[2]:=ord(xbuf[2]);
      v.bytes[3]:=ord(xbuf[3]);
      result:=inttostr(v.val);
      end
   else result:=string(xbuf);
   end;
except;end;
//close
regclosekey(k);
skipend:
except;end;
end;

//-- cursor support ------------------------------------------------------------
//## low__clienttoscreen ##
function low__clienttoscreen(x:tobject;s:tpoint):tpoint;
begin
try
result:=s;
if (x is tcommonform) then clienttoscreen((x as tcommonform).handle,result);
except;end;
end;
//## low__setcursor ##
procedure low__setcursor(xhost:tbasicsystem;xname:string;xdata:tstr8);//29aug2021
const
   i=crArrow;
var
   n,sname,df,e:string;
   a:tstr8;
   b:tbasicimage;
   int1,int2,int3:longint;
   //## xusea ##
   procedure xusea;
   begin
   try
   if (a=nil) then a:=bnew;
   a.clear;
   except;end;
   end;
   //## xdefcursor ##
   procedure xdefcursor;
   var
      e:string;
   begin
   try
   xname:='default';
   low__tofilestr(low__platsysext('cur.inf'),xname,e);
   except;end;
   end;
   //## xsavecursor ##
   procedure xsavecursor(xval:array of byte);
   var
      a:tstr8;
      e,df:string;
   begin
   try
   a:=nil;
   a:=bnew;
   a.aadd(xval);
   df:=low__platsysext('cur');
   low__tofile(df,a,e);
   low__tofilestr(low__platsysext('cur.inf'),xname,e);
   except;end;
   try;bfree(a);except;end;
   end;
begin
try
//init
xname:=low__lowercase(xname);
sname:=xname;
block(xdata);
df:=low__platsysext('cur');
a:=nil;
b:=nil;
//get
if      (xname='default')    then xdefcursor
else if (xname='black')      then xsavecursor(cur_black)
else if (xname='white')      then xsavecursor(cur_white)//05feb2022
else if (xname='orange')     then xsavecursor(cur_orange)
else if (xname='pink')       then xsavecursor(cur_pink)
else if (xname='yellow')     then xsavecursor(cur_yellow)
else if (xname='purple')     then xsavecursor(cur_purple)
else if (xname='navy')       then xsavecursor(cur_navy)
else if (xname='green')      then xsavecursor(cur_green)
else if (xname='grey')       then xsavecursor(cur_grey)
else if (xname='custom') or (xname='custom.prompt') or (xdata<>nil) then
   begin
   xname:='custom';
   case (sname='custom.prompt') of
//was:   true:if (xhost<>nil) and xhost.popopencur(sysfile_cursor,sysfile_cursor_openfilter,'') then low__copyfile(sysfile_cursor,low__platprgext('cur'),e);
   true:begin
      if (xhost<>nil) and xhost.popopencur(sysfile_cursor,sysfile_cursor_openfilter,'',true) then
         begin
         n:=lowercase__readfileext(sysfile_cursor);
         //.png
         if (n='png') then
            begin
            xusea;
            b:=misimg32(1,1);
            if misfromfile(b,sysfile_cursor,e) then
               begin
               low__toico32(b,true,false,0,32,-1,-1,int1,int2,int3,a,e);
               low__tofile(low__platprgext('cur'),a,e);
               end;
            end
         //.gif
         else if (n='gif') then
            begin
            xusea;
            b:=misimg32(1,1);
            b.ai.use32:=true;
            if misfromfile(b,sysfile_cursor,e) then
               begin
               if b.ai.transparent then mask__feather(b,b,0,mispixel24VAL(b,0,0),int1);
               low__toani32(b,nil,'ani',false,0,b.ai.delay,-1,-1,true,a,e);
               low__tofile(low__platprgext('cur'),a,e);
               end;
            end
         //.cur + ani
         else low__copyfile(sysfile_cursor,low__platprgext('cur'),e);
         end;
      end;
   false:low__tofile(low__platprgext('cur'),xdata,e);//store custom cursor under program e.g. "prg-???.cur" - 29aug2021
   end;
   //set as custom
   low__tofilestr(low__platsysext('cur.inf'),xname,e);
   end
else xdefcursor;
//set
syscursor_ref64:=0;//immediate load - 29aug2021
syscursor_loadname:='';//force reload
except;end;
try
bunlockautofree(xdata);
bfree(a);
freeobj(@b);
except;end;
end;
//## low__loadcursor ##
procedure low__loadcursor;
var
   str1:string;
begin
try;low__loadcursor2(str1,true);except;end;
end;
//## low__loadcursor2 ##
procedure low__loadcursor2(var xname:string;xloadcursor:boolean);
const
   i=crArrow;
var
   xcursorsize,df,e:string;
   bol1:boolean;
   //## xdefcursor ##
   procedure xdefcursor;
   begin
   try;if xloadcursor then screen.cursors[i]:=loadcursor(0,IDC_ARROW);except;end;
   end;
begin
try
//init
xname:='default';
bol1:=false;
//get
if (syscursor_name<>'') and (syscursor_ref64>=ms64) then xname:=syscursor_name else low__fromfilestr(low__platsysext('cur.inf'),xname,e);
if (xname='') then xname:='default';
xname:=low__lowercase(xname);
if xloadcursor then xcursorsize:=reg__readval(0,'Control Panel\Cursors\CursorBaseSize',true) else xcursorsize:='';
//decide
if      (xname='default')    then bol1:=true
else if (xname='black')      then bol1:=true
else if (xname='white')      then bol1:=true//05feb2022
else if (xname='orange')     then bol1:=true
else if (xname='pink')       then bol1:=true
else if (xname='yellow')     then bol1:=true
else if (xname='purple')     then bol1:=true
else if (xname='navy')       then bol1:=true
else if (xname='green')      then bol1:=true
else if (xname='grey')       then bol1:=true
else if (xname='custom')     then bol1:=true;
//.check
if not bol1                  then xname:='default';
//set
if low__setstr(syscursor_loadname,xname) or (xloadcursor and (xname<>'default') and (syscursor_sizeref<>xcursorsize)) then
   begin
   if (xname='default')         then xdefcursor
   else if (xname='custom')     then
      begin
      if xloadcursor then
         begin
         df:=low__platprgext('cur');
         if low__fileexists(df) then screen.cursors[i]:=loadcursorfromfile(pchar(df)) else xdefcursor;
         end;
      end
   else
      begin
      if xloadcursor then
         begin
         df:=low__platsysext('cur');
         if low__fileexists(df) then screen.cursors[i]:=loadcursorfromfile(pchar(df)) else xdefcursor;
         end;
      end;
   //inc
   low__iroll(syscursor_loadid,1);
   end;
//sizeref
if xloadcursor then syscursor_sizeref:=xcursorsize;
//set
syscursor_name:=xname;
syscursor_ref64:=ms64+5000;
except;end;
end;


//-- memfile and link1 support -------------------------------------------------
//compiler tag: "mfile" check with need_mfile
//cost: 0K -> could not get a reading - 09feb2022
{$ifdef mfile}
//## memfile_init ##
procedure memfile_init;
var
   p:longint;
begin
try
if not sysmemfile_slotsinit then
   begin
   for p:=0 to high(sysmemfile_slots) do
   begin
   sysmemfile_slots[p]:=0;
   sysmemfile_slotdata[p]:=nil;
   sysmemfile_slotsize[p]:=0;
   end;//p
   sysmemfile_slotsinit:=true;
   end;
except;end;
end;
//## memfile_start ##
function memfile_start(xname:string;xsize,xslot:longint):boolean;
label
   skipend;
begin
try
//defaults
result:=false;

//sys init
memfile_init;

//check
if (xname='') then exit;

//range
xsize:=frcmin(xsize,0);
xslot:=frcrange(xslot,0,high(sysmemfile_slots));

//stop existing
if (sysmemfile_slots[xslot]<>0) then memfile_stop(xslot);

//create file
sysmemfile_slots[xslot]:=CreateFileMapping($FFFFFFFF,nil,PAGE_READWRITE,0,xsize,pchar(xname));
if (sysmemfile_slots[xslot]=0) then goto skipend;

//map file
sysmemfile_slotdata[xslot]:=MapViewOfFile(sysmemfile_slots[xslot],FILE_MAP_READWRITE,0,0,xsize);
if (sysmemfile_slotdata[xslot]=nil) then goto skipend;

//size
sysmemfile_slotsize[xslot]:=xsize;

//successful
result:=true;
skipend:
except;end;
try
if not result then memfile_stop(xslot);
except;end;
end;
//## memfile_stop ##
procedure memfile_stop(xslot:longint);
var
   p:pointer;
   h:thandle;
begin
try
//sys init
memfile_init;

//range
xslot:=frcrange(xslot,0,high(sysmemfile_slots));

//unmap file
if (sysmemfile_slotdata[xslot]<>nil) then
   begin
   p:=sysmemfile_slotdata[xslot];
   sysmemfile_slotdata[xslot]:=nil;
   try;UnmapViewOfFile(p);except;end;
   end;

//free file
if (sysmemfile_slots[xslot]<>0) then
   begin
   h:=sysmemfile_slots[xslot];
   sysmemfile_slots[xslot]:=0;
   try;closehandle(h);except;end;
   end;

//size
sysmemfile_slotsize[xslot]:=0;
except;end;
end;
//## memfile_read ##
function memfile_read(xslot,xpos,xlen:longint;var xoutval:shortstring):boolean;
label
   skipend;
var
   p,xmin,xmax:longint;
   a:pdlbyte;
begin
try
//defaults
result:=false;
xoutval:='';

//range
xslot:=frcrange(xslot,0,high(sysmemfile_slots));
xpos:=frcmin(xpos,0);
xlen:=frcrange(xlen,0,255);

//check
if (sysmemfile_slotdata[xslot]=nil) then goto skipend;

//get
if (xlen>=1) and (sysmemfile_slotsize[xslot]>=1) and (xpos<sysmemfile_slotsize[xslot]) then
   begin
   //init
   xmin:=xpos;
   xmax:=frcmax(xpos+(xlen-1),sysmemfile_slotsize[xslot]-1);
   setlength(xoutval,xmax-xmin+1);
   a:=sysmemfile_slotdata[xslot];

   //get
   for p:=xmin to xmax do xoutval[p-xmin+1]:=char(a[p]);
   end;

//successful
result:=true;
skipend:
except;end;
end;
//## memfile_write ##
function memfile_write(xslot,xpos:longint;xval:shortstring):boolean;
label
   skipend;
var
   p,xlen,xmin,xmax:longint;
   a:pdlbyte;
begin
try
//defaults
result:=false;

//range
xslot:=frcrange(xslot,0,high(sysmemfile_slots));
xpos:=frcmin(xpos,0);
xlen:=length(xval);

//check
if (sysmemfile_slotdata[xslot]=nil) then goto skipend;

//get
if (xlen>=1) and (sysmemfile_slotsize[xslot]>=1) and (xpos<sysmemfile_slotsize[xslot]) then
   begin
   //init
   xmin:=xpos;
   xmax:=frcmax(xpos+(xlen-1),sysmemfile_slotsize[xslot]-1);
   a:=sysmemfile_slotdata[xslot];

   //get
   for p:=xmin to xmax do a[p]:=ord(xval[p-xmin+1]);
   end;

//successful
result:=true;
skipend:
except;end;
end;
//## low__deadpushlink1 ##
function low__deadpushlink1:boolean;
begin
try;result:=(syslink1_DEADPUSHref64>ms64);except;end;
end;
//## low__pushlink1c ##
function low__pushlink1c(n:string;v:string;int1:longint;bol1:boolean):boolean;
begin
try;result:=low__pushlink1(n,v,int1,bol1);except;end;
end;
//## low__pushlink1b ##
function low__pushlink1b(n:string;v:string;var int1:longint;var bol1:boolean):boolean;
begin
try;result:=low__pushlink1(n,v,int1,bol1);except;end;
end;
//## low__pushlink1 ##
function low__pushlink1(n:string;var v:string;var int1:longint;var bol1:boolean):boolean;
label
   redo,skipend;
var
   xdata:string;
   xint,nlen,vlen:tint4;
   a:pdlbyte;
   xref:comp;
   xpos,p:longint;
   //## xbolchar ##
   function xbolchar(x:boolean):char;
   begin
   if x then result:=#1 else result:=#0;
   end;
begin
try
//defaults
result:=false;
//check
if (syslink1_DEADPUSHref64>ms64) then exit;//we are being told to ignore for X ms since the last comminication failed - 28sep2021
//start
if (sysmemfile_slotdata[syslink1_slot]=nil) and (ms64>=syslink1_startref64) then
   begin
   syslink1_startref64:=ms64+30000;//next start attempt time point - 28sep2021
   memfile_start('link1',syslink1_size,syslink1_slot);
   end;
//check
if (sysmemfile_slotdata[syslink1_slot]=nil) or (sysmemfile_slotsize[syslink1_slot]<syslink1_size) then exit;
//init
xint.val:=int1;
nlen.val:=length(n);
vlen.val:=length(v);
//check
if ((syslink1_hdrsize+nlen.val+vlen.val)>syslink1_size) then exit;

//busy check
if syslink1_pushbusy then exit else syslink1_pushbusy:=true;


//get -> state.1 + reply.bol.1 + bol1.1 + int1.4 + nlen.4 + vlen.4 = 15 bytes
xdata:=
#1+//data sent and we are waiting for reply
xbolchar(false)+//reply was false
xbolchar(bol1)+//user boolean
char(xint.bytes[0])+char(xint.bytes[1])+char(xint.bytes[2])+char(xint.bytes[3])+//user longint
char(nlen.bytes[0])+char(nlen.bytes[1])+char(nlen.bytes[2])+char(nlen.bytes[3])+//n.len
n+//v
char(vlen.bytes[0])+char(vlen.bytes[1])+char(vlen.bytes[2])+char(vlen.bytes[3])+//v.len
v;//v

//write
a:=sysmemfile_slotdata[syslink1_slot];
for p:=0 to (length(xdata)-1) do a[p]:=ord(xdata[p+1]);

//wait
xref:=ms64+10*1000;//10 second timeout - 28sep2021
redo:
if (a[0]<>2) and (xref>=ms64) then
   begin
   sleep(1);
   goto redo;
   end;

//error -> should be a "2"
if (a[0]<>2) then
   begin
   syslink1_DEADPUSHref64:=ms64+30*1000;//shutdown the communication link for 30 seconds -> gives client chance to restart the external EXE or stop using the comm-link
   goto skipend;
   end;

//read
//.result
result:=(a[1]<>0);
if not result then goto skipend;

//.bol1
bol1:=(a[2]<>0);

//.int1
xint.bytes[0]:=a[3];
xint.bytes[1]:=a[4];
xint.bytes[2]:=a[5];
xint.bytes[3]:=a[6];
int1:=xint.val;

//.nlen - not used in reply -> skip over
xpos:=7;
nlen.bytes[0]:=a[xpos+0];
nlen.bytes[1]:=a[xpos+1];
nlen.bytes[2]:=a[xpos+2];
nlen.bytes[3]:=a[xpos+3];
inc(xpos,4);
if (nlen.val>=1) then inc(xpos,nlen.val);

//.vlen - reply value -> optional, can be zero
vlen.bytes[0]:=a[xpos+0];
vlen.bytes[1]:=a[xpos+1];
vlen.bytes[2]:=a[xpos+2];
vlen.bytes[3]:=a[xpos+3];
inc(xpos,4);
v:='';//clear
if (vlen.val>=1) then
   begin
   vlen.val:=frcmax(vlen.val,sysmemfile_slotsize[syslink1_slot]-(xpos+1));
   if (vlen.val>=1) then
      begin
      setlength(v,vlen.val);
      for p:=1 to vlen.val do v[p]:=char(a[xpos+p-1]);
      end;
   end;

skipend:
except;end;
try
if not result then
   begin
   bol1:=false;
   int1:=0;
   v:='';
   end;
except;end;
try;syslink1_pushbusy:=false;except;end;
end;
//## low__deadpulllink1 ##
function low__deadpulllink1:boolean;
begin
try;result:=(syslink1_DEADPULLref64<>0) and (ms64>=syslink1_DEADPULLref64);except;end;
end;
//## low__pulllink1 ##
function low__pulllink1(x:tpulleventfunc):boolean;
label
   skipend;
var
   bol0,bol1:boolean;
   n,v,xdata:string;
   xint,nlen,vlen:tint4;
   a:pdlbyte;
   xref:comp;
   int1,xpos,p:longint;
   //## xbolchar ##
   function xbolchar(x:boolean):char;
   begin
   if x then result:=#1 else result:=#0;
   end;
   //## xnotdead ##
   procedure xnotdead;
   begin
   syslink1_DEADPULLref64:=ms64+(60*1000);
   end;
begin
try
//defaults
result:=false;
//engage dead detector
if (syslink1_DEADPULLref64<=0) then xnotdead;

//start
if (sysmemfile_slotdata[syslink1_slot]=nil) and (ms64>=syslink1_startref64) then
   begin
   syslink1_startref64:=ms64+30000;//next start attempt time point - 28sep2021
   memfile_start('link1',syslink1_size,syslink1_slot);
   end;
//check
if (sysmemfile_slotdata[syslink1_slot]=nil) or (sysmemfile_slotsize[syslink1_slot]<syslink1_size) then exit;

//init
a:=sysmemfile_slotdata[syslink1_slot];

//only access when "1" -> means an inbound request to US the link1.puller - 28sep2021
if (a[0]<>1) then goto skipend;

//prevent pull link from going dead -> after 60s of NO PUSH requests we assume we are no longer required and should shutdown - 28sep2021
xnotdead;

//read
//.result "a[1]" not used for inbound pull request -> only on the outbound.reply

//.bol1
bol1:=(a[2]<>0);

//.int1
xint.bytes[0]:=a[3];
xint.bytes[1]:=a[4];
xint.bytes[2]:=a[5];
xint.bytes[3]:=a[6];
int1:=xint.val;

//.nlen - not used in reply -> skip over
xpos:=7;
nlen.bytes[0]:=a[xpos+0];
nlen.bytes[1]:=a[xpos+1];
nlen.bytes[2]:=a[xpos+2];
nlen.bytes[3]:=a[xpos+3];
inc(xpos,4);
if (nlen.val>=1) then inc(xpos,nlen.val);

//.vlen - reply value -> optional, can be zero
vlen.bytes[0]:=a[xpos+0];
vlen.bytes[1]:=a[xpos+1];
vlen.bytes[2]:=a[xpos+2];
vlen.bytes[3]:=a[xpos+3];
inc(xpos,4);
v:='';//clear
if (vlen.val>=1) then
   begin
   vlen.val:=frcmax(vlen.val,sysmemfile_slotsize[syslink1_slot]-(xpos+1));
   if (vlen.val>=1) then
      begin
      setlength(v,vlen.val);
      for p:=1 to vlen.val do v[p]:=char(a[xpos+p-1]);
      end;
   end;

//process the link1 request ----------------------------------------------------
if assigned(x) then bol0:=x(n,v,int1,bol1)
else
   begin
   bol0:=true;
   bol1:=false;
   int1:=0;
   v:='';
   end;

//send back reply -> state.1 + reply.bol.1 + bol1.1 + int1.4 + nlen.4 + vlen.4 = 15 bytes
xint.val:=int1;
n:='';//n not used in a pull reply
nlen.val:=length(n);
vlen.val:=length(v);

xdata:=
#1+//leave as #1 since we ONLY change this to a #2 when we have finished writing ALL THE DATA to the memory mapped file - 28sep2021
xbolchar(bol0)+//reply was false
xbolchar(bol1)+//user boolean
char(xint.bytes[0])+char(xint.bytes[1])+char(xint.bytes[2])+char(xint.bytes[3])+//user longint
char(nlen.bytes[0])+char(nlen.bytes[1])+char(nlen.bytes[2])+char(nlen.bytes[3])+//n.len
n+//v
char(vlen.bytes[0])+char(vlen.bytes[1])+char(vlen.bytes[2])+char(vlen.bytes[3])+//v.len
v;//v

//write
a:=sysmemfile_slotdata[syslink1_slot];
for p:=0 to (length(xdata)-1) do a[p]:=ord(xdata[p+1]);

//signal pusher we have finished by changing the state byte from #1 to #2
a[0]:=2;

//successful
result:=true;
skipend:
except;end;
end;
{$else}
//## memfile_init ##
procedure memfile_init;
begin

end;
//## memfile_start ##
function memfile_start(xname:string;xsize,xslot:longint):boolean;
begin
result:=false;
end;
//## memfile_stop ##
procedure memfile_stop(xslot:longint);
begin

end;
//## memfile_read ##
function memfile_read(xslot,xpos,xlen:longint;var xoutval:shortstring):boolean;
begin
result:=false;
end;
//## memfile_write ##
function memfile_write(xslot,xpos:longint;xval:shortstring):boolean;
begin
result:=false;
end;
//## low__deadpushlink1 ##
function low__deadpushlink1:boolean;
begin
result:=false;
end;
//## low__pushlink1c ##
function low__pushlink1c(n:string;v:string;int1:longint;bol1:boolean):boolean;
begin
result:=false;
end;
//## low__pushlink1b ##
function low__pushlink1b(n:string;v:string;var int1:longint;var bol1:boolean):boolean;
begin
result:=false;
end;
//## low__pushlink1 ##
function low__pushlink1(n:string;var v:string;var int1:longint;var bol1:boolean):boolean;
begin
result:=false;
end;
//## low__deadpulllink1 ##
function low__deadpulllink1:boolean;
begin
result:=false;
end;
//## low__pulllink1 ##
function low__pulllink1(x:tpulleventfunc):boolean;
begin
result:=false;
end;
{$endif}


//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//88888888888888888888888

//-- PLUS support - 27jun2022 --------------------------------------------------
//## plus_index ##
function plus_index:longint;
begin
try;result:=plus_index2(nil,false);except;end;
end;
//## plus_indexb ##
function plus_indexb(var x:longint):boolean;//pass-thru
begin
try;result:=true;x:=plus_index2(nil,false);except;end;
end;
//## plus_index2 ##
function plus_index2(x:tobject;xrangecheck:boolean):longint;
begin
try
//defaults
result:=0;
//check
if (programplusmax<=0) then exit;
//range
if (x=nil) and (sysprogram<>nil) then x:=sysprogram.rootwin;
//get
if (x<>nil) and (x is tbasicscroll) and low__comparetext(strcopy1((x as tbasicscroll).page,1,length(scplus)),scplus) then
   begin
   result:=frcrange(strint(strcopy1((x as tbasicscroll).page,length(scplus)+1,length((x as tbasicscroll).page))),0,programplusmax);
   if (result>=1) and xrangecheck and (system_plus0[result]=nil) then result:=0;
   end;
except;end;
end;
//## plus_setindex ##
procedure plus_setindex(x:tobject;xindex:longint);
var
   a:tbasicscroll;
   n:string;
begin
try
//range
xindex:=frcrange(xindex,0,programplusmax);
if (x=nil) and (sysprogram<>nil) then x:=sysprogram.rootwin;
//get
if (x<>nil) and (x is tbasicscroll) then
   begin
   a:=(x as tbasicscroll);
   n:=plus_pagename(xindex);
   if a.xhavetoolbar  then a.xtoolbar.setparentpage(n);//but ALSO need to sync "A's" top/bottom toolbars as these aren't synced by the search and set "toolbar.setparentpage" handler
   if a.xhavetoolbar2 then a.xtoolbar2.setparentpage(n);
   //Oonly needs to be done IF either of the toolbars above haven't already set it - i.e. they have no buttons that are using a "scPage+scPlus" instruction set - 28jun2022
   a.page:=n;//main page SHOW/HIDE handler
   end;
except;end;
end;
//## plus_pagename ##
function plus_pagename(xpageindex:longint):string;
begin
try;result:=scplus+inttostr(frcrange(xpageindex,0,programplusmax));except;end;
end;
//## plus_stamppagename ##
function plus_stamppagename(x:tobject;xpageindex:longint):boolean;//pass-thru
begin
try;result:=true;if (x<>nil) and (x is tbasiccontrol) then (x as tbasiccontrol).opagename:=plus_pagename(xpageindex);except;end;
end;
//## plus_scpagecode ##
function plus_scpagecode(xpageindex:longint):string;//for adding "scPage" control codes to toolbars
begin
try;result:=scpage+scplus+inttostr(frcrange(xpageindex,0,programplusmax));except;end;
end;
//## plus_toolbar ##
function plus_toolbar(x:tobject;var y:tbasictoolbar):boolean;
begin
try
//defaults
result:=false;
y:=nil;
//get
if      (x<>nil) and (x is tbasictoolbar)                                                    then y:=(x as tbasictoolbar)
else if (sysprogram<>nil) and (sysprogram.rootwin<>nil) and sysprogram.rootwin.xhavetoolbar  then y:=sysprogram.rootwin.xtoolbar
else if (sysprogram<>nil) and (sysprogram.rootwin<>nil) and sysprogram.rootwin.xhavetoolbar2 then y:=sysprogram.rootwin.xtoolbar2;
//set
result:=(y<>nil);
except;end;
end;
//## plus_toolbar2 ##
function plus_toolbar2(x:tobject;var y:tbasictoolbar):boolean;
begin
try
//defaults
result:=false;
y:=nil;
//get
if      (x<>nil) and (x is tbasictoolbar) then y:=(x as tbasictoolbar)
else if (sysprogram<>nil) and (sysprogram.rootwin<>nil) and sysprogram.rootwin.xhavetoolbar2 then y:=sysprogram.rootwin.xtoolbar2
else if (sysprogram<>nil) and (sysprogram.rootwin<>nil) and sysprogram.rootwin.xhavetoolbar  then y:=sysprogram.rootwin.xtoolbar;
//set
result:=(y<>nil);
except;end;
end;
//## plus_bhighlight ##
procedure plus_bhighlight(x:tobject);
var
   a:tbasictoolbar;
   v,p:longint;
begin
try;if plus_toolbar(x,a) and plus_indexb(v) then for p:=0 to programplusmax do (x as tbasictoolbar).bhighlight2[plus_scpagecode(p)]:=(p=v);except;end;
end;
//## plus_bhighlight2 ##
procedure plus_bhighlight2(x:tobject);
var
   a:tbasictoolbar;
   v,p:longint;
begin
try;if plus_toolbar2(x,a) and plus_indexb(v) then for p:=0 to programplusmax do (x as tbasictoolbar).bhighlight2[plus_scpagecode(p)]:=(p=v);except;end;
end;
//## plus_addlinks ##
procedure plus_addlinks(x:tobject;xtep:longint;xmaincap,xhelp:string;xnewline,xmorepadding:boolean);
var
   a:tbasictoolbar;
   p:longint;
begin
try
if plus_toolbar(x,a) then
   begin
   //range
   if (xtep=tepNone) then xtep:=tepPanel20;
   //init
   xmaincap:=low__udv(xmaincap,'Panel %0%');
   xhelp:=low__udv(xhelp,'Show panel %0%');
   //get
   for p:=0 to programplusmax do a.hcsadd(low__swapvals0(xmaincap,inttostr(p+1)),xtep,0,plus_scpagecode(p),low__swapvals0(xhelp,inttostr(p+1)),-10);//malfunctions with 7 items each at -13 -> can't make it mind up if it's ONE or TWO rows - 05jul2022
   if xnewline then
      begin
      a.addhline;
      a.newline;
      end;

   if xmorepadding then a.ovpad:=6;
   end;
except;end;
end;
//## plus_addlinks2 ##
procedure plus_addlinks2(x:tobject;xtep:longint;xmaincap,xhelp:string;xnewline,xmorepadding:boolean);
var
   a:tbasictoolbar;
   p:longint;
begin
try
if plus_toolbar2(x,a) then
   begin
   //range
   if (xtep=tepNone) then xtep:=tepPanel20;
   //init
   xmaincap:=low__udv(xmaincap,'Panel %0%');
   xhelp:=low__udv(xhelp,'Show panel %0%');
   //get
   for p:=0 to programplusmax do a.hcsadd(low__swapvals0(xmaincap,inttostr(p+1)),xtep,0,plus_scpagecode(p),low__swapvals0(xhelp,inttostr(p+1)),0);
   if xnewline then a.newline;
   if xmorepadding then a.ovpad:=6;
   end;
except;end;
end;

//-- management procs for low level array of objects "pdlobject" ---------------
//## man__any ##
function man__any:tany;//new any
begin
try;result:=tany.create;except;end;
end;
{$ifdef man}
//Approximate code cost: 4K - 09feb2022
//## man__makecopy ##
function man__makecopy(s:tobject):tobject;
begin
try;result:=nil;man__copyfrom(s,@result);except;end;
end;
//## man__copyfrom ##
function man__copyfrom(s:tobject;d:pobject):boolean;
begin
try
//defaults
result:=false;
//check
if (s=nil) or ( (s=nil) and ((d=nil) or (d^=nil)) ) then
   begin
   if (s=nil) and (d^<>nil) then freeobj(@d^);//required in-order to maintain consisten layout when using "tany" or another object - 09feb2022
   result:=true;
   exit;
   end;

//create
if (d^=nil) then
   begin
   if      (s is tany) then d^:=man__any
   else if (s is tstr8) then d^:=bnew
   else if (s is tbasicimage) then d^:=tbasicimage.create
   else if (s is tdynamicstring) then d^:=tdynamicstring.create
   else if (s is tdynamicinteger) then d^:=tdynamicinteger.create
   else exit;//unknown class
   end;

//tany
if      (s is tany) and (d^ is tany) then result:=(d^ as tany).copyfrom(s as tany)
//tstr8
else if (s is tstr8) and (d^ is tstr8) then result:=(d^ as tstr8).copyfrom(s as tstr8)
//tbasicimage
else if (s is tbasicimage) and (d^ is tbasicimage) then result:=(d^ as tbasicimage).copyfrom(s as tbasicimage)
//tdynamicstring
else if (s is tdynamicstring) and (d^ is tdynamicstring) then result:=(d^ as tdynamicstring).copyfrom(s as tdynamicstring)
//tdynamicinteger
else if (s is tdynamicinteger) and (d^ is tdynamicinteger) then result:=(d^ as tdynamicinteger).copyfrom(s as tdynamicinteger);
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//uuuuuuuuuuuuuuuuuuuuuuuu
//## man__undoadd ##
function man__undoadd(uid:string;u:tobject;ufocus:longint;udelete,uappend,unewpos:boolean):boolean;
label
   skipend;
var
   e,v,n1:string;
   xinfo,xdata:tstr8;
   xtmp:tstr8;//pointer only
   p,xpos:longint;
   xmustinfo:boolean;
begin
try
//defaults
result:=false;
xdata:=nil;
xmustinfo:=false;
//check
if (uid='') or (not zzany(u)) then
   begin
   result:=true;
   goto skipend;//ingore
   end;
//init
xinfo:=bnew;
xdata:=bnew;
//info
low__fromfile(uid+'.tmp',xinfo,e);
if (xinfo.len<4) then
   begin
   //format style: #255+ilist+#255 => undolist+#255+freelist+#255+redolist -> special low-mem low-math format - 19feb2022, 07may2019
   xinfo.clear;
   xinfo.addbyt1(255);
   for p:=0 to 99 do xinfo.addbyt1(p);
   xinfo.addbyt1(255);
   xmustinfo:=true;
   end;
//if unewpos then inc(xpos);
//xxxxxxxxxxxxxxxxxxxxxxxxxxx undolist + freelist + redolist -> see tblaizimage.undo/canundo....

//get
xtmp:=asany(u).todata;
case udelete of
true:xdata.addint4(0);//delete
false:xdata.addint4(1);//add
end;
xdata.addint4(ufocus);
xdata.addint4(xtmp.len);
xdata.add(xtmp);
//set
case uappend of
true:result:=low__tofileappend3(uid+'-'+inttostr(xpos)+'.tmp',maxint,xdata,e);
false:result:=low__tofile(uid+'-'+inttostr(xpos)+'.tmp',xdata,e);
end;
//info
if xmustinfo then low__tofile(uid+'.tmp',xinfo,e);
skipend:
except;end;
try
bfree(xinfo);
bfree(xdata);
except;end;
end;
//## man__undopull ##
function man__undopull(uid:string;u:tobject;ufocus,ustyle:longint;uappend,unewpos:boolean):boolean;
label
   skipend;
var
   e,v,n1:string;
   xdata:tstr8;
   xtmp:tstr8;//pointer only
   xpos:longint;
begin
try
//defaults
result:=false;
xdata:=nil;
//check
if (uid='') or (not zzany(u)) then
   begin
   result:=true;
   goto skipend;//ingore
   end;
//init
xdata:=bnew;
low__fromfilestr(uid+'-pos.tmp',v,e);
xpos:=frcmin(strint(v),0);
//get
xtmp:=asany(u).todata;
xdata.addint4(ustyle);
xdata.addint4(ufocus);
xdata.addint4(xtmp.len);
xdata.add(xtmp);
//set
case uappend of
true:result:=low__tofileappend3(uid+'-'+inttostr(xpos)+'.tmp',maxint,xdata,e);
false:result:=low__tofile(uid+'-'+inttostr(xpos)+'.tmp',xdata,e);
end;

skipend:
except;end;
try;bfree(xdata);except;end;
end;

//## man__edit ##
function man__edit(uid:string;x:pdlobject;var xholder:tobject;xstyle:string;xlimit,xfocus:longint;var xcount,xnewfocus:longint):boolean;
   //## xmakecopy ##
   function xmakecopy(s:tobject):boolean;
   var
      a:tobject;
   begin
   try
   //defaults
   result:=false;
   //get
   //.same class -> can do a simple copy
   if (s<>nil) and (xholder<>nil) and (s.classname=xholder.classname) then result:=man__copyfrom(s,@xholder)
   //.two different classes, make a new matching class and copy
   else
      begin
      a:=xholder;//take copy of handle
      xholder:=man__makecopy(s);//create a new object with a different handle
      freeobj(@a);//free the previous handle -> no longer in use
      result:=true;
      end;
   except;end;
   end;
   //## xchangefocus ##
   function xchangefocus(x:longint):boolean;
   begin
   result:=true;//pass-thru
   xnewfocus:=frcrange(x,0,frcmin(xcount-1,0));
   end;
begin
try
//defaults
result:=false;
//filter
xstyle:=low__lowercase(xstyle);
xnewfocus:=xfocus;
//get
if (xstyle='cannew') then
   begin
   if (xcount<=0) then result:=(xcount<xlimit)
   else                result:=(xcount<xlimit) and (xholder<>nil);
   end
else if (xstyle='new') then result:=man__new(uid,x,man__makecopy(xholder),xlimit,xfocus,xcount) and xchangefocus(xfocus+1)
else if (xstyle='cancopy') then result:=man__can(x,xfocus,xcount,true)
else if (xstyle='copy') then
   begin
   if man__can(x,xfocus,xcount,true) then result:=xmakecopy(x[xfocus]);
   end
else if (xstyle='cancut') then result:=man__can(x,xfocus,xcount,true)
else if (xstyle='cut') then
   begin
   if man__can(x,xfocus,xcount,false) then result:=xmakecopy(x[xfocus]) and man__del(uid,x,xfocus,xcount) and xchangefocus(xfocus);
   end
else if (xstyle='canpaste') or (xstyle='canpaste.left') then result:=(xcount<xlimit) and (xholder<>nil)
else if (xstyle='paste') or (xstyle='paste.left') then result:=man__new(uid,x,man__makecopy(xholder),xlimit,xfocus,xcount)
else if (xstyle='canpaste.right') then result:=(xcount<xlimit) and (xholder<>nil)
else if (xstyle='paste.right') then result:=man__new(uid,x,man__makecopy(xholder),xlimit,xfocus+1,xcount) and xchangefocus(xfocus+1);
except;end;
end;
//## man__init ##
function man__init(uid:string;x:pdlobject;xhigh:longint;var xlimit,xcount:longint):boolean;
var//Note: proc wipes array "x", settings all slots to "nils" ready for use
   p:longint;
begin
try
//defaults
result:=false;
xcount:=0;
xlimit:=0;
//check
if (xhigh<0) then
   begin
   result:=true;
   exit;
   end;
//get
xlimit:=xhigh+1;
for p:=0 to (xlimit-1) do x[p]:=nil;
except;end;
end;
//## man__can ##
function man__can(x:pdlobject;xfocus,xcount:longint;xnotnil:boolean):boolean;
begin
try;result:=(xfocus>=0) and (xfocus<xcount) and ((not xnotnil) or (x[xfocus]<>nil));except;end;
end;
//## man__new ##
function man__new(uid:string;x:pdlobject;xnewobj:tobject;xlimit,xfocus:longint;var xcount:longint):boolean;
label
   skipend;
var
   p:longint;
begin
try
//defaults
result:=false;
//filter
if (xcount<0) then xcount:=0;
//check
if (xcount>=xlimit) then
   begin
   freeobj(@xnewobj);//free the object
   result:=true;
   exit;
   end;
//add
x[xcount]:=xnewobj;//add first
inc(xcount);//then enlarge list
//move
if not man__move(uid,x,xcount,xcount-1,xfocus) then goto skipend;
//successful
result:=true;
skipend:
except;end;
end;
//## man__del ##
function man__del(uid:string;x:pdlobject;xfocus:longint;var xcount:longint):boolean;
begin
try
//defaults
result:=false;
//check
if (xcount<0) then
   begin
   result:=true;
   exit;
   end;
//get
if man__move(uid,x,xcount,xfocus,xcount-1) then
   begin
   dec(xcount);//shrink first
   freeobj(@x[xcount]);//then free the object - 09feb2022
   result:=true;
   end;
except;end;
end;
//## man__delall ##
function man__delall(uid:string;x:pdlobject;var xcount:longint):boolean;
var
   int1,p:longint;
begin
try
//defaults
result:=false;
//check
if (xcount<0) then
   begin
   result:=true;
   exit;
   end;
//get
int1:=xcount;
xcount:=0;//shrink first
for p:=0 to (int1-1) do freeobj(@x[p]);//then free the object - 09feb2022
//successful
result:=true;
except;end;
end;
//## man__move ##
function man__move(uid:string;x:pdlobject;xcount,xfrom,xto:longint):boolean;
var
   p:longint;
   a:tobject;
begin
try
//defaults
result:=false;
//check
if (xcount<=0) then
   begin
   result:=true;
   exit;
   end;
//init
xfrom:=frcrange(xfrom,0,xcount-1);
xto  :=frcrange(xto,0,xcount-1);
//get
if (xto>xfrom) then//up
   begin
   for p:=xfrom to (xto-1) do
   begin
   a     :=x[p];
   x[p]  :=x[p+1];
   x[p+1]:=a;
   end;//p
   end
else if (xto<xfrom) then//down
   begin
   for p:=xfrom downto (xto+1) do
   begin
   a     :=x[p];
   x[p]  :=x[p-1];
   x[p-1]:=a;
   end;//p
   end;
//successful
result:=true;
except;end;
end;
//## man__movestr ##
function man__movestr(x:pdlstring;xcount,xfrom,xto:longint):boolean;
var
   p:longint;
   a:pstring;
begin
try
//defaults
result:=false;
//check
if (xcount<=0) then
   begin
   result:=true;
   exit;
   end;
//init
xfrom:=frcrange(xfrom,0,xcount-1);
xto  :=frcrange(xto,0,xcount-1);
//get
if (xto>xfrom) then//up
   begin
   for p:=xfrom to (xto-1) do
   begin
   a     :=x[p];
   x[p]  :=x[p+1];
   x[p+1]:=a;
   end;//p
   end
else if (xto<xfrom) then//down
   begin
   for p:=xfrom downto (xto+1) do
   begin
   a     :=x[p];
   x[p]  :=x[p-1];
   x[p-1]:=a;
   end;//p
   end;
//successful
result:=true;
except;end;
end;
//## man__moveint ##
function man__moveint(x:pdllongint;xcount,xfrom,xto:longint):boolean;
var
   p:longint;
   a:longint;
begin
try
//defaults
result:=false;
//check
if (xcount<=0) then
   begin
   result:=true;
   exit;
   end;
//init
xfrom:=frcrange(xfrom,0,xcount-1);
xto  :=frcrange(xto,0,xcount-1);
//get
if (xto>xfrom) then//up
   begin
   for p:=xfrom to (xto-1) do
   begin
   a     :=x[p];
   x[p]  :=x[p+1];
   x[p+1]:=a;
   end;//p
   end
else if (xto<xfrom) then//down
   begin
   for p:=xfrom downto (xto+1) do
   begin
   a     :=x[p];
   x[p]  :=x[p-1];
   x[p-1]:=a;
   end;//p
   end;
//successful
result:=true;
except;end;
end;
{$else}
//## man__makecopy ##
function man__makecopy(s:tobject):tobject;
begin
result:=nil;
end;
//## man__copyfrom ##
function man__copyfrom(s:tobject;d:pobject):boolean;
begin
result:=false;
end;
//## man__edit ##
function man__edit(uid:string;x:pdlobject;var xholder:tobject;xstyle:string;xlimit,xfocus:longint;var xcount,xnewfocus:longint):boolean;
begin
result:=false;
end;
//## man__init ##
function man__init(uid:string;x:pdlobject;xhigh:longint;var xlimit,xcount:longint):boolean;
begin
result:=false;
end;
//## man__can ##
function man__can(x:pdlobject;xfocus,xcount:longint;xnotnil:boolean):boolean;
begin
result:=false;
end;
//## man__new ##
function man__new(uid:string;x:pdlobject;xnewobj:tobject;xlimit,xfocus:longint;var xcount:longint):boolean;
begin
result:=false;
end;
//## man__del ##
function man__del(uid:string;x:pdlobject;xfocus:longint;var xcount:longint):boolean;
begin
result:=false;
end;
//## man__delall ##
function man__delall(uid:string;x:pdlobject;var xcount:longint):boolean;
begin
result:=false;
end;
//## man__move ##
function man__move(uid:string;x:pdlobject;xcount,xfrom,xto:longint):boolean;
begin
result:=false;
end;
//## man__movestr ##
function man__movestr(x:pdlstring;xcount,xfrom,xto:longint):boolean;
begin
result:=false;
end;
//## man__moveint ##
function man__moveint(x:pdllongint;xcount,xfrom,xto:longint):boolean;
begin
result:=false;
end;
{$endif}

//-- multi-undo support --------------------------------------------------------
//## low__minit ##
function low__minit(x:tstr8;xlimit:longint):boolean;
var//stores data as: "<undo slots>[255]<redo slots>[255]<unused slots>"
   p:longint;
begin
try
//defaults
result:=false;
//check
if not block(x) then exit;
//range
xlimit:=frcrange(xlimit,2,255);//Note: 2..255 => 0..254 with 255 reserved as a boundary value
//get
x.setlen(xlimit+2);
x.pbytes[0]:=255;
x.pbytes[1]:=255;
for p:=2 to (x.len-1) do x.pbytes[p]:=p-2;//0..254
//successful
result:=true;
except;end;
try;bunlockautofree(x);except;end;
end;
//## low__mstartsplit ##
function low__mstartsplit(x:tstr8;var u,r,f:tstr8):boolean;
begin
try
//defaults
result:=false;
u:=nil;
r:=nil;
f:=nil;
//check
if not block(x) then exit;
//init
u:=bnew;
r:=bnew;
f:=bnew;
//get
result:=low__msplit(x,u,r,f);
except;end;
end;
//## low__mstart ##
function low__mstart(var u,r,f:tstr8):boolean;
begin
try
result:=true;//pass-thru
//init
u:=nil;
r:=nil;
f:=nil;
//get
u:=bnew;
r:=bnew;
f:=bnew;
except;end;
end;
//## low__mfinish ##
function low__mfinish(var x,u,r,f:tstr8):boolean;
begin
try
result:=true;//pass-thru
bfree(u);
bfree(r);
bfree(f);
bunlockautofree(x);
except;end;
end;
//## low__mmake ##
function low__mmake(x,u,r,f:tstr8):boolean;
label
   skipend;
begin
try
//defaults
result:=false;
//check
if not low__true4(block(x),block(u),block(r),block(f)) then goto skipend;
//get
x.clear;
x.add(u);
x.aadd([255]);
x.add(r);
x.aadd([255]);
x.add(f);
//successful
result:=true;
skipend:
except;end;
try
bunlockautofree(u);
bunlockautofree(r);
bunlockautofree(f);
bunlockautofree(x);
except;end;
end;
//## low__msplit ##
function low__msplit(x,u,r,f:tstr8):boolean;
label
   skipend;
var//u=undo slots, r=redo slot, f=free slots
   bc,p:longint;
   v:byte;
begin
try
//defaults
result:=false;
//check
if not low__true4(block(x),block(u),block(r),block(f)) then goto skipend;
u.clear;
r.clear;
f.clear;
if (x.len<3) then goto skipend;
//get
bc:=0;
for p:=0 to (x.len-1) do
begin
v:=x.pbytes[p];
if (v=255) then inc(bc)
else
   begin
   case bc of
   0:u.aadd([v]);
   1:r.aadd([v]);
   2:f.aadd([v]);
   end;//case
   end;
end;//p
//successful
result:=true;
skipend:
except;end;
try
bunlockautofree(u);
bunlockautofree(r);
bunlockautofree(f);
bunlockautofree(x);
except;end;
end;
//## low__mclear ##
function low__mclear(x:tstr8):boolean;
label
   skipend;
var
   u,r,f:tstr8;
begin
try
result:=false;
low__mstart(u,r,f);
if not low__msplit(x,u,r,f) then goto skipend;
x.clear;
x.aadd([255,255]);
x.add(u);
x.add(r);
x.add(f);
result:=true;
skipend:
except;end;
try;low__mfinish(x,u,r,f);except;end;
end;
//## low__minsertslotREDO ##
function low__minsertslotREDO(x:tstr8):longint;//02jul2022
label
   skipdone;
var
   u,r,f:tstr8;
   xlen,dp,p:longint;
   v:byte;
begin
try
//defaults
result:=0;
//check
if not block(x) then exit;
low__mstart(u,r,f);
if not low__msplit(x,u,r,f) then goto skipdone;
//roll
if (r.len>=1) then
   begin
   result:=r.pbytes[r.len-1];
   r.del3(r.len-1,1);
   r.ains([result],0);//at top of redo list
   low__mmake(x,u,r,f);
   goto skipdone;
   end;
//new slot from "f=free" list
if (f.len>=1) then
   begin
   result:=f.pbytes[0];
   r.ains([result],0);//at top of redo list
   f.del3(0,1);
   low__mmake(x,u,r,f);//remake
   goto skipdone;
   end;
skipdone:
except;end;
try;low__mfinish(x,u,r,f);except;end;
end;
//## low__mnewslot ##
function low__mnewslot(x:tstr8):longint;
label
   skipdone;
var
   u,r,f:tstr8;
   xlen,dp,p:longint;
   v:byte;
begin
try
//defaults
result:=0;
//check
if not block(x) then exit;
low__mstart(u,r,f);
if not low__msplit(x,u,r,f) then goto skipdone;
//flush redo
if (r.len>=1) then
   begin
   f.ins(r,0);
   r.clear;
   end;
//new slot from "f=free" list
if (f.len>=1) then
   begin
   result:=f.pbytes[0];
   u.aadd([result]);
   f.del3(0,1);
   low__mmake(x,u,r,f);//remake
   goto skipdone;
   end;
//roll
if (u.len>=2) then
   begin
   result:=u.pbytes[0];
   u.del3(0,1);
   u.aadd([result]);
   end;
//remake
low__mmake(x,u,r,f);
skipdone:
except;end;
try;low__mfinish(x,u,r,f);except;end;
end;
//## low__mredocount ##
function low__mredocount(x:tstr8):longint;
var
   u,r,f:tstr8;
begin
try;if low__mstartsplit(x,u,r,f) then result:=r.len else result:=0;except;end;
try;low__mfinish(x,u,r,f);except;end;
end;
//## low__mredofind ##
function low__mredofind(x:tstr8;xindex:longint;var xslot:longint):boolean;//
var
   u,r,f:tstr8;
begin
try
//defaults
result:=false;
xslot:=0;
//get
if low__mstartsplit(x,u,r,f) and (r.len>=1) and (xindex>=0) then
   begin
   xslot:=f.pbytes[frcrange(xindex,0,r.len-1)];
   result:=true;
   end;
except;end;
try;low__mfinish(x,u,r,f);except;end;
end;
//## low__mundocount ##
function low__mundocount(x:tstr8):longint;
var
   u,r,f:tstr8;
begin
try;if low__mstartsplit(x,u,r,f) then result:=u.len else result:=0;except;end;
try;low__mfinish(x,u,r,f);except;end;
end;
//## low__mundofind ##
function low__mundofind(x:tstr8;xindex:longint;var xslot:longint):boolean;//
var
   u,r,f:tstr8;
begin
try
//defaults
result:=false;
xslot:=0;
//get
if low__mstartsplit(x,u,r,f) and (u.len>=1) and (xindex>=0) then
   begin
   xslot:=f.pbytes[frcrange(xindex,0,u.len-1)];
   result:=true;
   end;
except;end;
try;low__mfinish(x,u,r,f);except;end;
end;
//## low__mcanundo ##
function low__mcanundo(x:tstr8):boolean;
var
   p:longint;
begin
try
result:=false;
if (x<>nil) and (x.len>=3) then
   begin
   for p:=0 to (x.len-1) do if (x.pbytes[p]=255) then break else result:=true;
   end;
except;end;
end;
//## low__mundo ##
function low__mundo(x:tstr8;var xslot:longint):boolean;
label
   skipend;
var
   u,r,f:tstr8;
   xlen,dp,p:longint;
   v:byte;
begin
try
//defaults
result:=false;
xslot:=0;
//check
if not block(x) then exit;
//get
if low__mstart(u,r,f) and low__msplit(x,u,r,f) and (u.len>=1) then
   begin
   xslot:=u.pbytes[u.len-1];
   u.del3(u.len-1,1);
   r.ains([xslot],0);
   low__mmake(x,u,r,f);
   result:=true;
   end;
skipend:
except;end;
try;low__mfinish(x,u,r,f);except;end;
end;
//## low__mcanredo ##
function low__mcanredo(x:tstr8):boolean;
var
   xlen,p:longint;
begin
try
result:=false;
if (x<>nil) and (x.len>=3) then
   begin
   xlen:=x.len;
   for p:=0 to (xlen-1) do
   begin
   if (x.pbytes[p]=255) then
      begin
      result:=((p+1)<xlen) and (x.pbytes[p+1]<>255);
      break;
      end;
   end;//p
   end;
except;end;
end;
//## low__mredo ##
function low__mredo(x:tstr8;var xslot:longint):boolean;
label
   skipend;
var
   u,r,f:tstr8;
   xlen,dp,p:longint;
   v:byte;
begin
try
//defaults
result:=false;
xslot:=0;
//check
if not block(x) then exit;
//get
if low__mstart(u,r,f) and low__msplit(x,u,r,f) and (r.len>=1) then
   begin
   xslot:=r.pbytes[0];
   r.del3(0,1);
   u.aadd([xslot]);
   low__mmake(x,u,r,f);
   result:=true;
   end;
skipend:
except;end;
try;low__mfinish(x,u,r,f);except;end;
end;
//## low__mdebug ##
function low__mdebug(x:tstr8):string;
var
   u,r,f:tstr8;
   p:longint;
begin
try
result:='';
low__mstart(u,r,f);
if low__msplit(x,u,r,f) then
   begin
   result:='u( ';
   if (u.len>=1) then for p:=0 to (u.len-1) do result:=result+inttostr(u.pbytes[p])+' ';
   result:=result+') r( ';
   if (r.len>=1) then for p:=0 to (r.len-1) do result:=result+inttostr(r.pbytes[p])+' ';
   result:=result+') f( ';
   if (f.len>=1) then for p:=0 to (f.len-1) do result:=result+inttostr(f.pbytes[p])+' ';
   result:=result+')';
   end;
except;end;
try;low__mfinish(x,u,r,f);except;end;
end;

//-- color generators ----------------------------------------------------------
function low__white24:longint;
begin
result:=low__rgb(255,255,255);
end;
function low__black24:longint;
begin
result:=low__rgb(0,0,0);
end;
function low__grey24:longint;
begin
result:=low__rgb(127,127,127);
end;
//## low__nonwhite24 ##
function low__nonwhite24(x:tcolor24):tcolor24;//make sure color is never white
begin
//get
result:=x;
//filter
if (result.r=255) and (result.g=255) and (result.b=255) then
   begin
   result.r:=254;
   result.g:=254;
   result.b:=254;
   end;
end;

//-- ease of use tstr8 system handlers -----------------------------------------
//## bif ##
function bif(s,d:tstr8):boolean;
begin
try;result:=low__true2(block(s),block(d)) and (zzstr(s,60).len=zzstr(d,61).len) and s.same(d);except;end;
try
bunlockautofree(s);
bunlockautofree(d);
except;end;
end;
//## bifnot ##
function bifnot(s,d:tstr8):boolean;
begin
try;result:=not bif(s,d);except;end;
end;
//## blen ##
function blen(x:tstr8):longint;
begin
try
result:=0;
if zzok(x,1000) then result:=x.len;
except;end;
try;bautofree(x);except;end;
end;
//## _blen ##
function _blen(x:tstr8):longint;//does NOT destroy "x", keeps "x"
begin
try
result:=0;
if zzok(x,1001) then result:=x.len;
except;end;
end;
//## bsetlen ##
function bsetlen(x:tstr8;xlen:longint):boolean;
begin
try;result:=zzok(x,1002) and x.setlen(frcmin(xlen,0));except;end;
try;bautofree(x);except;end;
end;
//## bdel1 ##
procedure bdel1(x:tstr8;xpos1,xlen:longint);
begin
try;if (xpos1>=1) and (xlen>=1) and zzok(x,1003) then x.del(xpos1-1,xpos1-1+xlen-1);except;end;
try;bautofree(x);except;end;
end;
//## bchar ##
function bchar(xval:longint):tstr8;
begin
try
if (xval<0) then xval:=0 else if (xval>255) then xval:=255;
result:=bnew_autofree;
result.addbyt1(byte(xval));
except;end;
end;
//## bcopy1 ##
function bcopy1(x:tstr8;xpos1,xlen:longint):tstr8;//fixed - 26apr2021
begin
try
result:=bnew_autofree;
if block(x) then result.add3(x,xpos1-1,xlen);
except;end;
try;bunlockautofree(x);except;end;
end;
//## bcopystr1 ##
function bcopystr1(x:string;xpos1,xlen:longint):tstr8;
begin
try
result:=bnew_autofree;
if (x<>'') then result.sadd3(x,xpos1-1,xlen);
except;end;
end;
//## bcopystrall ##
function bcopystrall(x:string):tstr8;
begin
try
result:=bnew_autofree;
if (x<>'') then result.sadd(x);
except;end;
end;
//## bstr ##
function bstr(x:tstr8):string;
begin
try
result:='';
if zzok(x,1004) and (not x.empty) then result:=x.text;
except;end;
try;bautofree(x);except;end;
end;
//## bgetstr1 ##
function bgetstr1(x:tstr8;xpos1,xlen:longint):string;
begin
try
result:='';
if zzok(x,1005) and (not x.empty) then result:=x.str1[xpos1,xlen];
except;end;
try;bautofree(x);except;end;
end;
//## bcopyarray ##
function bcopyarray(x:array of byte):tstr8;
begin
try
result:=bnew_autofree;
result.aadd(x);
except;end;
end;
//## bclear ##
procedure bclear(var x:tstr8);//25jun2022
begin
try;if zzok(x,1006) then x.clear;except;end;
end;
//## bfree ##
procedure bfree(var x:tstr8);
begin
try;if zzok(x,1006) then freeobj(@x);except;end;
end;
//## bautofree ##
procedure bautofree(var x:tstr8);
begin
try;if zzok(x,1007) and x.oautofree and (x.lockcount=0) then bfree(x);except;end;
end;
//## bautofreeb ##
procedure bautofreeb(x:tstr8);
begin
try;bautofree(x);except;end;
end;
//## bnew ##
function bnew:tstr8;
begin
try
result:=nil;
result:=tstr8.create(0);
except;end;
end;
//## bnew2 ##
function bnew2(var x:tstr8):boolean;//21mar2022
begin
try
result:=false;
x:=nil;
x:=tstr8.create(0);
result:=(x<>nil);
except;end;
end;
//## bnewlen ##
function bnewlen(xlen:longint):tstr8;
begin
try
result:=nil;
result:=tstr8.create(frcmin(xlen,0));
except;end;
end;
//## bnewstr ##
function bnewstr(xtext:string):tstr8;
begin
try
result:=nil;
result:=tstr8.create(0);
result.replacestr:=xtext;
except;end;
end;
//## breuse ##
function breuse(var x:tstr8;xtext:string):tstr8;//also acts as a pass-thru - 05jul2022
begin//Warning: Use with care, auto-creates, but never destroys -> that is upto the host
try
result:=nil;
if (x=nil) then x:=bnew;
x.replacestr:=xtext;
result:=x;
except;end;
end;
//## bnewfrom ##
function bnewfrom(xdata:tstr8):tstr8;
begin
try
result:=nil;
result:=tstr8.create(0);
result.replace:=xdata;
except;end;
end;
//## bnew_autofree ##
function bnew_autofree:tstr8;
begin
try
result:=nil;
result:=tstr8.create(0);
result.oautofree:=true;
except;end;
end;
//## bcheck ##
function bcheck(x:tstr8;xpos:longint):boolean;//05may2021
begin
try;result:=bcheck2(x,xpos,0);except;end;
end;
//## bcheck2 ##
function bcheck2(x:tstr8;xpos,xdebugid:longint):boolean;//05may2021
begin
try
result:=true;//pass-thru
case zzok(x,8023) of
false:showerror('bCheck: Object not valid'+rcode+'Ref ID: '+low__64(xdebugid));
true:if (xpos<0) or (xpos>=x.datalen) then showerror('bCheck: Pos('+low__64(xpos)+') out of range (0...'+low__64(x.datalen-1)+')'+rcode+'Ref ID: '+low__64(xdebugid));
end;
except;end;
end;
//## block ##
function block(x:tstr8):boolean;
begin
try
result:=zzok(x,1008);
if result then x.lock;
except;end;
end;
//## bunlock ##
function bunlock(x:tstr8):boolean;
begin
try
result:=zzok(x,1009);
if result then x.unlock;
except;end;
end;
//## bunlockautofree ##
procedure bunlockautofree(x:tstr8);
begin
try
if zzok(x,1010) then
   begin
   x.unlock;
   bautofree(x);
   end;
except;end;
end;
//## bmplock ##
procedure bmplock(x:tobject);
begin
try;if zzok(x,1011) and (x is tbmp) then (x as tbmp).lock;except;end;
end;
//## bmpunlock ##
procedure bmpunlock(x:tobject);
begin
try;if zzok(x,1012) and (x is tbmp) then (x as tbmp).unlock;except;end;
end;
//## vnew ##
function vnew:tvars8;
begin
try;result:=tvars8.create;except;end;
end;
//## vnew2 ##
function vnew2(xdebugid:longint):tvars8;
begin
try;result:=tvars8.create;except;end;
end;

//-- Access system values by name - 07sep2020 ----------------------------------
//## sfromname ##
function sfromname(n:string):string;
begin
try
//defaults
result:='';
n:=low__lowercase(n);
//get
if        (n='colorname')      then result:=vicolorname
else if   (n='startlink')      then result:=bnc(vistartlink)
else if   (n='desktoplink')    then result:=bnc(videsktoplink)
else if   (n='round')          then result:=bnc(viround)
else if   (n='minimalscroll')  then result:=bnc(viminimal__scrollbar)
else if   (n='softclose')      then result:=bnc(visoftclose)
else if   (n='framemax')       then result:=bnc(viframemax)//04mar2022, 14mar2021
else if   (n='ecomode')        then result:=bnc(viecomode)//09may2021
else if   (n='32bit')          then result:=bnc(vi32bit)//09may2021
else if   (n='lockposition')   then result:=bnc(viLockposition)//27feb2022
else if   (n='winemode')       then result:=inttostr(viwinemode)//02feb2022
else if   (n='wine')           then result:=bnc(viwine)//02feb2022
else if   (n='safearea')       then result:=bnc(visafearea)
else if   (n='splash')         then result:=bnc(visplash)
else if   (n='help')           then result:=bnc(vihelp)
else if   (n='ontop')          then result:=bnc(viontop)
else if   (n='help.bw')        then result:=bnc(vihelp_bw)
else if   (n='help.show')      then result:=bnc(vihelp_show)
else if   (n='help.max')       then result:=bnc(vihelp_max)//18dec2021, 24jul2021
else if   (n='coloriseimages') then result:=bnc(vicoloriseimages)//10mar2021
else if   (n='headlarge')      then result:=bnc(viheadlarge)//01mar2022
else if   (n='headcenter')      then result:=bnc(viheadcenter)//11oct2022
else if   (n='autoscroll')     then result:=bnc(viautoscroll)//28sep2022
else if   (n='touch')          then result:=bnc(vitouch)
else if   (n='doubleclicks')   then result:=bnc(vidoubleclicks)
else if   (n='specialcolors')  then result:=bnc(vispecialcolors)
else if   (n='enhanced')       then result:=bnc(vienhanced)
else if   (n='shaderound')     then result:=bnc(vishaderound)
else if   (n='shadeglow')      then result:=bnc(vishadeglow)//12jun2022
else if   (n='sparkle')        then result:=inttostr(visparkle)//09mar2021
else if   (n='bordersize')     then result:=inttostr(vibordersize__root)
else if   (n='scrollsize')     then result:=inttostr(viscrollsize__root)
else if   (n='cursorname')     then low__loadcursor2(result,false)//load name only - 29aug2021
else if   (n='zoom')           then result:=inttostr(vizoom__root)//14mar2021
else if   (n='framename')      then result:=viframename//23feb2022
else if   (n='fontnameraw')    then result:=vifontnameraw//26mar2022
else if   (n='fontnameraw2')   then result:=vifontnameraw2
else if   (n='fontname')       then result:=vifontname
else if   (n='fontname2')      then result:=vifontname2//for text boxes etc - 05feb2022
else if   (n='fontsize')       then result:=inttostr(vifontsize__root)//14mar2021
{
else if   (n='fontsize.2')      then//not used at the momemt - 26feb2022
   begin
   case vifontsize__root of
   6:result:='0';
   8:result:='1';
   9:result:='2';
   10:result:='3';
   11:result:='4';
   12:result:='5';
   14:result:='6';
   16:result:='7';
   22:result:='8';
   24:result:='9';
   else result:='1';
   end;//case
   end
{}
else if   (n='fontsize2')         then result:=inttostr(vifontsize__root2)//14mar2021
{
else if   (n='fontsize2.2')      then//not used at the momemt - 26feb2022
   begin
   case vifontsize__root2 of
   6:result:='0';
   8:result:='1';
   9:result:='2';
   10:result:='3';
   11:result:='4';
   12:result:='5';
   14:result:='6';
   16:result:='7';
   22:result:='8';
   24:result:='9';
   else result:='1';
   end;//case
   end
{}
else if   (n='fontfeather')       then result:=inttostr(vifeather)
else if   (n='fontfeatherf')      then result:=inttostr(vifeatherf);
except;end;
end;
//## ifromname ##
function ifromname(n:string):longint;
begin
try;result:=strint(sfromname(n));except;end;
end;
//## bfromname ##
function bfromname(n:string):boolean;
begin
try;result:=(ifromname(n)<>0);except;end;
end;
//## low__colorsarray ##
function low__colorsarray(xdata:string):string;
var
   xcount,xlinelen,p:longint;
   xcolor:tint4;
   //## xadd ##
   procedure xadd(x:byte);
   begin
   if (result<>'') then
      begin
      result:=result+',';
      inc(xlinelen);
      end;
   result:=result+inttostr(x);
   inc(xlinelen);
   inc(xcount);
   //line limit
   if (xlinelen>=200) then
      begin
      xlinelen:=0;
      result:=result+rcode;
      end;
   end;
begin
try
//defaults
result:='';
xcount:=0;
xlinelen:=0;
//init
xdata:=low__fixcolors(xdata);
//header -> "col2"
xadd(llc);
xadd(llo);
xadd(lll);
xadd(nn2);
//colors -> "index,r,g,b" all byte
for p:=0 to 255 do
begin
if low__getcolor2(xdata,p,xcolor.val) then
   begin
   xadd(p);
   xadd(xcolor.r);
   xadd(xcolor.g);
   xadd(xcolor.b);
   end;
end;//p
//finish
result:=':array[0..'+inttostr(xcount-1)+'] of byte=('+result+');';
except;end;
end;
//## low__fixcolors ##
function low__fixcolors(xdata:string):string;//fixes any errors by filtering out bad data
var
   p,dlen,slen:longint;
   v:byte;
   //## xadd ##
   procedure xadd;
   begin
   inc(dlen);
   if (dlen<>p) then xdata[dlen-1+stroffset]:=char(v);
   end;
begin
try
//defaults
result:='';
//init
xdata:=low__lowercase(xdata);
slen:=length(xdata);
dlen:=0;
//check
if (slen<4) then exit;
//get
for p:=1 to slen do
begin
v:=strbyte1x(xdata,p);
//header
case dlen of
0:if (v=llc) then xadd;
1:if (v=llo) then xadd;
2:if (v=lll) then xadd;
3:if (v=nn2) then xadd;
else if (v>=nn0) and (v<=nn9) then xadd;
end;//case
end;//p
//set
if (dlen>=4) then result:=strcopy1(xdata,1,dlen);
except;end;
end;
//## low__validcolor ##
function low__validcolor(xindex:longint;var xdefcol:longint):boolean;
const
   xwhite=255+(255*256)+(255*256*256);
begin
try
//defaults
result:=false;
xdefcol:=clnone;
//get
case xindex of
cnFrame     :xdefcol:=15;
cnFrame2    :xdefcol:=255;
//.standard colors
cnBack1     :xdefcol:=0;
cnBorder1   :xdefcol:=21;
cnHigh1     :xdefcol:=0;
cnHover1    :xdefcol:=0;
cnText1     :xdefcol:=0;
cnTexthigh1 :xdefcol:=0;
cnTextdis1  :xdefcol:=0;
cnDis1      :xdefcol:=0;
cnDisbr1    :xdefcol:=0;
//.title colors
cnBack2     :xdefcol:=0;
cnBorder2   :xdefcol:=0;
cnHigh2     :xdefcol:=0;
cnHover2    :xdefcol:=0;
cnText2     :xdefcol:=0;
cnTexthigh2 :xdefcol:=0;
cnTextdis2  :xdefcol:=0;
cnDis2      :xdefcol:=0;
cnDisbr2    :xdefcol:=0;
//.more colors
cnsFrame    :xdefcol:=xwhite;
cnsTitle    :xdefcol:=xwhite;
cnsStandard :xdefcol:=xwhite;
cnsAllinone :xdefcol:=xwhite;
cnsDark_light:xdefcol:=xwhite;
cnsLight_dark:xdefcol:=xwhite;
end;//case
//successful
result:=(xdefcol<>clnone);
except;end;
end;
//## low__criticalcolor ##
function low__criticalcolor(xindex:longint):boolean;//22jul2021
begin
try
//defaults
result:=false;
//get
case xindex of
cnFrame     :result:=true;
cnFrame2    :result:=true;
//.standard colors
cnBack1     :result:=true;
cnBorder1   :result:=true;
cnHigh1     :result:=true;
cnHover1    :result:=true;
cnText1     :result:=true;
cnTexthigh1 :result:=true;
cnTextdis1  :result:=true;
cnDis1      :result:=true;
cnDisbr1    :result:=true;
//.title colors
cnBack2     :result:=true;
cnBorder2   :result:=true;
cnHigh2     :result:=true;
cnHover2    :result:=true;
cnText2     :result:=true;
cnTexthigh2 :result:=true;
cnTextdis2  :result:=true;
cnDis2      :result:=true;
cnDisbr2    :result:=true;
end;//case
except;end;
end;
//## low__tocompactcolors ##
function low__tocompactcolors(xdata:string):string;
var//Note: Returns only the most basic colors in HEX format to keep output small to fit on Twitter - 22jul2021
   p:longint;
   int1:tint4;
begin
try
//defaults
result:='(col3';
//get
for p:=0 to 255 do if low__criticalcolor(p) and low__getcolor(xdata,p,int1.val) then
   begin
   int1.a:=p;//insert color index
   result:=result+low__rgbatohex(int1.val,false);
   end;
//finalise
result:=low__lowercase(result+')');
except;end;
end;
//## low__fromcompactcolors ##
function low__fromcompactcolors(xdata:string;var xout:string):boolean;
begin
try;result:=low__fromcompactcolors2(xdata,0,xout);except;end;
end;
//## low__fromcompactcolors2 ##
function low__fromcompactcolors2(xdata:string;xadjBrightness100:longint;var xout:string):boolean;
label
   redo,skipend;
var
   int1:tint4;
   xindex,v,xpos,xlen,xdatalen,p:longint;
   xclean:string;
   xwithin:boolean;
begin
try
//defaults
result:=false;
xdata:=strcopy1(xdata,1,5000);//limit inbound data to max of 5K - 22jul2021
xdatalen:=length(xdata);
xout:=low__getcolors(@vinormal,@vititle,@vimorecolors);
//check
if (xdatalen<4) then goto skipend;
//clean -> expects "(....)"
xwithin:=false;
xclean:='';
for p:=1 to length(xdata) do
begin
v:=strbyte1(xdata,p);
if (v=ssLRoundbracket) then xwithin:=true;//start
if xwithin and (v=ssRRoundbracket) then break;//stop
//.scan
if xwithin then
   begin
   if ((v>=nn0) and (v<=nn9)) or ((v>=llA) and (v<=llZ)) or ((v>=uuA) and (v<=uuZ)) then xclean:=xclean+char(v);
   end;
end;//p
//clean2 - assumes "...." (no brackets) - 22jul2021
if not xwithin then
   begin
   for p:=1 to length(xdata) do
   begin
   v:=strbyte1(xdata,p);
   if (v=uuC) or (v=llC) then xwithin:=true;//start
   //.scan
   if xwithin then
      begin
      if ((v>=nn0) and (v<=nn9)) or ((v>=llA) and (v<=llZ)) or ((v>=uuA) and (v<=uuZ)) then xclean:=xclean+char(v);
      end;
   end;//p
   end;

//header
if low__comparetext(strcopy1(xclean,1,4),'col2') then//already in native format -> use as is
   begin
   xout:=xclean;
   result:=true;
   goto skipend;
   end;
if not low__comparetext(strcopy1(xclean,1,4),'col3') then goto skipend;
//get
xpos:=5;//start past header
xlen:=length(xclean);
redo:
if ((xpos+7)<=xlen) then
   begin
   int1.val:=low__hextorgba(strcopy1(xclean,xpos,8),0);
   xindex:=int1.a;
   int1.a:=0;
   if low__criticalcolor(xindex) then
      begin
      xout:=low__setcolor(xout,xindex,int1.val);
      result:=true;//successful
      end;
   //inc
   inc(xpos,8);
   goto redo;
   end;
skipend:
//brighten colors
if (xadjBrightness100<>0) then xout:=low__setcolorb(xout,-1,0,xadjBrightness100);
//filter
xout:=low__fixcolors(xout);
except;end;
end;
//## low__getcolor ##
function low__getcolor(xdata:string;xindex:longint;var xcolor:longint):boolean;
begin
try;result:=low__getcolor2(xdata,xindex,xcolor);except;end;
end;
//## low__getcolor2 ##
function low__getcolor2(var xdata:string;xindex:longint;var xcolor:longint):boolean;
label
   dodef,redo,redo2;
var
   xadjBrightness100,int1,p,xlen,dlen:longint;
   str1:string;
   //## xval255 ##
   function xval255(xpos:longint):byte;
   begin
   result:=frcrange(strint(strcopy1x(xdata,xpos,3)),0,255);
   end;
   //## dval255 ##
   function dval255(xpos:longint):byte;
   begin
   result:=frcrange(strint(strcopy1(system_defaultcolors,xpos,3)),0,255);
   end;
begin
try
//defaults
result:=false;
xcolor:=0;
xlen:=length(xdata);
dlen:=length(system_defaultcolors);
xadjBrightness100:=0;

//check
if not low__validcolor(xindex,xcolor) then exit;
if (xlen<4) or (strcopy1x(xdata,1,4)<>'col2') then goto dodef;

//get
p:=5;//jump over 4byte header
redo:
if ((p+11)<=xlen) then//1..3=index, 4..6=red, 7..9=green, 10..12=blue = 12 bytes
   begin
   case (xindex=xval255(p+0)) of
   true:begin
      xcolor:=low__rgb(xval255(p+3),xval255(p+6),xval255(p+9));
      result:=true;
      end;
   false:begin//loop
      inc(p,12);
      goto redo;
      end;
   end;//case
   end;

//fallback to "xdefdata" -> system default colors - 09mar2021
dodef:
//prime "system_defaultcolors" -> this stores the system DEFAULT color scheme -> now set to the program's default - 27mar2022
if (dlen<=0) then
   begin
   str1:=low__findbuiltincolor(cols__defaultname,true,xadjBrightness100);//brightness handled within
   system_defaultcolors:=str1;
   dlen:=length(system_defaultcolors);
   end;

p:=5;//jump over 4byte header
redo2:
if (not result) and (dlen>=1) and ((p+11)<=dlen) then//1..3=index, 4..6=red, 7..9=green, 10..12=blue = 12 bytes
   begin
   case (xindex=dval255(p+0)) of
   true:begin
      xcolor:=low__rgb(dval255(p+3),dval255(p+6),dval255(p+9));
      result:=true;
      end;
   false:begin//loop
      inc(p,12);
      goto redo2;
      end;
   end;//case
   end;
except;end;
end;
//## low__setcolor ##
function low__setcolor(xdata:string;xindex,xcolor:longint):string;//outputs entire color stream
begin
try;result:=low__setcolor2(xdata,xindex,xcolor);except;end;
end;
//## low__setcolorb ##
function low__setcolorb(xdata:string;xindex,xcolor:longint;xadjBrightness100:longint):string;//outputs entire color stream
begin
try;result:=low__setcolor3(xdata,xindex,xcolor,xadjBrightness100);except;end;
end;
//## low__setcolor2 ##
function low__setcolor2(var xdata:string;xindex,xcolor:longint):string;//outputs entire color stream
begin
try;result:=low__setcolor3(xdata,xindex,xcolor,0);except;end;
end;
//## low__setcolor3 ##
function low__setcolor3(var xdata:string;xindex,xcolor:longint;xadjBrightness100:longint):string;//18sep2022 outputs entire color stream
var
   p,xdefcol,int1:longint;
   //## xval255 ##
   function xcolset(xindex,xcolor:longint):string;
   var
      v4:tint4;
      //## x255 ##
      function x255(x:byte):string;
      begin
      case x of
      0..9:  result:='00'+inttostr(x);// -> 009
      10..99:result:='0'+inttostr(x);//  -> 099
      else   result:=inttostr(x);//      -> 199
      end;//case
      end;
   begin
   //defaults
   result:='';
   //range
   v4.val:=xcolor;
   v4.a:=frcrange(xindex,0,255);
   //.adjBrightness - 18sep2022
   if (xadjBrightness100<>0) then
      begin
      v4.r:=low__coloradjBrightness(v4.r,xadjBrightness100);
      v4.g:=low__coloradjBrightness(v4.g,xadjBrightness100);
      v4.b:=low__coloradjBrightness(v4.b,xadjBrightness100);
      end;
   //get
   result:=x255(v4.a)+x255(v4.r)+x255(v4.g)+x255(v4.b);
   end;
begin
try
//defaults
result:='col2';//header
xcolor:=frcrange(xcolor,0,16777215);
//get
for p:=0 to 255 do if low__validcolor(p,xdefcol) then
   begin
   if (p=xindex)                        then result:=result+xcolset(p,xcolor)
   else if low__getcolor2(xdata,p,int1) then result:=result+xcolset(p,int1)
   else                                      result:=result+xcolset(p,xdefcol);
   end;//p
except;end;
end;
//## low__getcolors ##
function low__getcolors(xnormal,xtitle:pvirtualinfo;xmorecolors:pvirtualmorecolors):string;
   //## xadd ##
   procedure xadd(xindex,xcolor:longint);
   begin
   result:=low__setcolor2(result,xindex,xcolor);
   end;
begin
try
//defaults
result:='';
//get
//.standard colors
if (xnormal<>nil) then
   begin
   xadd(cnFrame,xnormal.frame);
   xadd(cnFrame2,xnormal.frame2);
   xadd(cnback1,xnormal.background);
   xadd(cnborder1,xnormal.border);
   xadd(cnhigh1,xnormal.highlight);
   xadd(cnhover1,xnormal.hover);
   xadd(cntext1,xnormal.font);
   xadd(cntexthigh1,xnormal.fonthighlight);
   xadd(cntextdis1,xnormal.disablefont);
   xadd(cndis1,xnormal.disable);
   xadd(cndisbr1,xnormal.disableborder);
   end;
//.title colors
if (xtitle<>nil) then
   begin
   xadd(cnFrame,xtitle.frame);
   xadd(cnFrame2,xtitle.frame2);
   xadd(cnback2,xtitle.background);
   xadd(cnborder2,xtitle.border);
   xadd(cnhigh2,xtitle.highlight);
   xadd(cnhover2,xtitle.hover);
   xadd(cntext2,xtitle.font);
   xadd(cntexthigh2,xtitle.fonthighlight);
   xadd(cntextdis2,xtitle.disablefont);
   xadd(cndis2,xtitle.disable);
   xadd(cndisbr2,xtitle.disableborder);
   end;
//.more colors
if (xmorecolors<>nil) then
   begin
   xadd(cnsFrame,xmorecolors.frame);
   xadd(cnsTitle,xmorecolors.title);
   xadd(cnsStandard,xmorecolors.standard);
   xadd(cnsAllinone,xmorecolors.allinone);
   xadd(cnsDark_light,xmorecolors.dark_light);
   xadd(cnsLight_dark,xmorecolors.light_dark);
   end;
except;end;
end;
//## low__setcolors ##
procedure low__setcolors(xdata:string;xnormal,xtitle:pvirtualinfo;xmorecolors:pvirtualmorecolors);
   //## xadd ##
   procedure xadd(xindex:longint;var xcolor:longint);
   begin
   low__getcolor2(xdata,xindex,xcolor);
   end;
begin
try
//get
//.standard colors
if (xnormal<>nil) then
   begin
   xadd(cnFrame,xnormal.frame);
   xadd(cnFrame2,xnormal.frame2);
   xadd(cnback1,xnormal.background);
   xadd(cnborder1,xnormal.border);
   xadd(cnhigh1,xnormal.highlight);
   xadd(cnhover1,xnormal.hover);
   xadd(cntext1,xnormal.font);
   xadd(cntexthigh1,xnormal.fonthighlight);
   xadd(cntextdis1,xnormal.disablefont);
   xadd(cndis1,xnormal.disable);
   xadd(cndisbr1,xnormal.disableborder);
   end;
//.title colors
if (xtitle<>nil) then
   begin
   xadd(cnFrame,xtitle.frame);
   xadd(cnFrame2,xtitle.frame2);
   xadd(cnback2,xtitle.background);
   xadd(cnborder2,xtitle.border);
   xadd(cnhigh2,xtitle.highlight);
   xadd(cnhover2,xtitle.hover);
   xadd(cntext2,xtitle.font);
   xadd(cntexthigh2,xtitle.fonthighlight);
   xadd(cntextdis2,xtitle.disablefont);
   xadd(cndis2,xtitle.disable);
   xadd(cndisbr2,xtitle.disableborder);
   end;
//.more colors
if (xmorecolors<>nil) then
   begin
   xadd(cnsframe,xmorecolors.frame);
   xadd(cnstitle,xmorecolors.title);
   xadd(cnsstandard,xmorecolors.standard);
   xadd(cnsallinone,xmorecolors.allinone);
   xadd(cnsdark_light,xmorecolors.dark_light);
   xadd(cnslight_dark,xmorecolors.light_dark);
   end;
except;end;
end;
//## low__setcolorsbyname ##
function low__setcolorsbyname(xname:string;xnormal,xtitle:pvirtualinfo;xmorecolors:pvirtualmorecolors):boolean;
label
   redo;
var
   dcount,xadjBrightness100,int1:longint;
   n,xdata:string;
   xdefonce,xchecknameonly:boolean;
   //## x255 ##
   function x255(x:byte):string;//argb -> don't adjust "a" this is a color index number - 18sep2022
   begin
   //inc
   inc(dcount);
   case dcount of
   1:;
   2..4:x:=low__coloradjBrightness(x,xadjBrightness100);
   end;
   if (dcount>=4) then dcount:=0;
   //get
   case x of
   0..9:  xdata:=xdata+'00'+inttostr(x);// -> 009
   10..99:xdata:=xdata+'0'+inttostr(x);//  -> 099
   else   xdata:=xdata+inttostr(x);//      -> 199
   end;//case
   end;
   //## aset ##
   procedure aset(x:array of byte;x2:string);
   var
      a:tstr8;
      p:longint;
   begin
   try
   result:=true;
   dcount:=0;
   a:=nil;
   if not xchecknameonly then
      begin
      a:=bnew;
      if (x2<>'') then a.sadd(x2) else a.aadd(x);
      if (a.len>=1) then
         begin
         for p:=0 to (a.len-1) do if (p<=3) then xdata:=xdata+char(a.pbytes[p]) else x255(a.pbytes[p]);
         end;
      end;
   except;end;
   try;bfree(a);except;end;
   end;
   //## fset ##
   procedure fset(x:string);
   var
      a:tstr8;
      n,e:string;
   begin
   try
   a:=nil;
   n:=low__platfolder('schemes')+x+'.'+cnFileEXT;
   case xchecknameonly of
   true:result:=low__fileexists(n);
   false:begin
      a:=bnew;
      if low__fromfile(low__platfolder('schemes')+x+'.'+cnFileEXT,a,e) then
         begin
         xdata:=a.text;
         result:=true;
         end;
      end;//begin
   end;//case
   except;end;
   try;bfree(a);except;end;
   end;
   //## xadd ##
   procedure xadd(xindex:longint;var xcolor:longint);
   begin
   low__getcolor2(xdata,xindex,xcolor);
   end;
   //## m ##
   function m(xname:string):boolean;
   begin
   result:=low__comparetext(xname,n);
   end;
begin
try
//defaults
result:=false;
xdefonce:=true;
xdata:='';
xchecknameonly:=(xnormal=nil) and (xtitle=nil) and (xmorecolors=nil);
xadjBrightness100:=0;
dcount:=0;
//init
redo:
n:=low__lowercase(xname);

//get
//.nil
if (n='') then
   begin
   //nil
   end
//.internal
else if (strcopy1(n,1,1)='?') then
   begin
   //.if padder
   if (n='?') then
      begin
      //nil
      end
   //.custom
   else if low__comparetext(strcopy1(n,1,7),'?custom') then
      begin
      int1:=strint(strcopy1(n,8,length(n)));
      if (int1>=0) and (int1<cnCustomLimit) then
         begin
         result:=true;
         if (not xchecknameonly) and zzok(syssettings,1016) then xdata:=syssettings.value[n];
         end;
      end
   //.paste and use - 27mar2022
   else if (n='?paste_and_use') then
      begin
      result:=true;
      if (not xchecknameonly) and zzok(syssettings,1016) then xdata:=syssettings.value[n];
      end
   //.static - built-in colors - 09may2021
   else if (n='?default')    then
      begin
      if (cols__defaultname<>'') and xdefonce then
         begin
         xdefonce:=false;
         xname:=cols__defaultname;
         goto redo;
         end
      else if (sizeof(cols__default)>=2) then aset(cols__default,'')
      else                                    aset(cols_black,'')//15mar2022 - was: glowing_grey)//10mar2021
      end
   //.newer built-in colors - 22jul2021
   else aset([0],low__findbuiltincolor(n,false,xadjBrightness100));//brightness MUST be handled by "aset()"
   end
//.file
else fset(xname);//retain name case

//set
if not xchecknameonly then low__setcolors(xdata,xnormal,xtitle,xmorecolors);
except;end;
end;
//## low__coloradjBrightness ##
function low__coloradjBrightness(x:byte;xadjBrightness100:longint):byte;
var
   v:longint;
begin
try
//defaults
result:=x;
//range
xadjBrightness100:=frcrange(xadjBrightness100,-100,100);
//filter
if (xadjBrightness100<>0) then
   begin
   //get
   if (x<1) then x:=1;//lift the value so we can esculate
   v:=round(x+(x*(xadjBrightness100/100)));
   //set
   if (v<0) then v:=0 else if (v>255) then v:=255;
   result:=byte(v);
   end;
except;end;
end;
//## low__findbuiltincolor ##
function low__findbuiltincolor(n:string;xexpand:boolean;var xadjBrightness100:longint):string;
var
   dcount:longint;
   //## x255 ##
   function x255(x:byte):string;//argb -> don't adjust "a" this is a color index number - 18sep2022
   begin
   //inc
   inc(dcount);
   case dcount of
   1:;
   2..4:x:=low__coloradjBrightness(x,xadjBrightness100);
   end;
   if (dcount>=4) then dcount:=0;
   //get
   case x of
   0..9:  result:='00'+inttostr(x);// -> 009
   10..99:result:='0'+inttostr(x);//  -> 099
   else   result:=inttostr(x);//      -> 199
   end;//case
   end;
   //## _aset ##
   procedure _aset(x:array of byte);
   var
      a:tstr8;
      p:longint;
   begin
   try
   dcount:=0;
   a:=nil;
   a:=bnew;
   a.aadd(x);
   if xexpand then
      begin
      if (a.len>=1) then
         begin
         for p:=0 to (a.len-1) do if (p<=3) then result:=result+char(a.pbytes[p]) else result:=result+x255(a.pbytes[p]);
         end;
      end
   else result:=a.text;
   except;end;
   try;bfree(a);except;end;
   end;
   //## aset ##
   procedure aset(x:array of byte);
   begin
   xadjBrightness100:=0;
   _aset(x);
   end;
   //## aset2 ##
   procedure aset2(x:array of byte;xbrightness:longint);
   begin
   xadjBrightness100:=xbrightness;
   _aset(x);
   end;
   //## m ##
   function m(xname:string):boolean;
   begin
   result:=low__comparetext(xname,n);
   end;
begin
try
//init
result:='';
xadjBrightness100:=0;
dcount:=0;
//get
if      m('?Army')              then aset(cols_Army)
else if m('?Army 2')            then aset2(cols_Army,10)
else if m('?Burnt Yellow')      then aset2(cols_BurntYellow,-20)
else if m('?Burnt Yellow 2')    then aset(cols_BurntYellow)//11oct2022
else if m('?Burnt Yellow 3')    then aset2(cols_BurntYellow,20)
else if m('?Burnt Red')         then aset2(cols_BurntRed,-20)
else if m('?Burnt Red 2')       then aset(cols_BurntRed)//11oct2022
else if m('?Burnt Red 3')       then aset2(cols_BurntRed,20)
else if m('?Burnt Purple')      then aset2(cols_BurntPurple,-20)
else if m('?Burnt Purple 2')    then aset(cols_BurntPurple)//11oct2022
else if m('?Burnt Purple 3')    then aset2(cols_BurntPurple,20)
else if m('?Burnt Orange')      then aset2(cols_BurntOrange,-20)
else if m('?Burnt Orange 2')    then aset(cols_BurntOrange)//11oct2022
else if m('?Burnt Orange 3')    then aset2(cols_BurntOrange,20)
else if m('?Eerie')             then aset2(cols_Eerie,-20)
else if m('?Eerie 2')           then aset(cols_Eerie)//11oct2022
else if m('?Eerie 3')           then aset2(cols_Eerie,20)
else if m('?Soft Green')        then aset2(cols_SoftGreen,-10)
else if m('?Soft Green 2')      then aset2(cols_SoftGreen,-5)
else if m('?Soft Green 3')      then aset(cols_SoftGreen)
else if m('?Soft Green 4')      then aset2(cols_SoftGreen,10)
else if m('?Aqua Marine')       then aset(cols_Aqua_Marine)
else if m('?Aqua Marine 2')     then aset2(cols_Aqua_Marine,10)
else if m('?Aqua Marine 3')     then aset2(cols_Aqua_Marine,20)
else if m('?Marine')            then aset(cols_Marine)
else if m('?Marine 2')          then aset2(cols_Marine,10)
else if m('?Marine 3')          then aset2(cols_Marine,20)
else if m('?Marine 4')          then aset2(cols_Marine,30)
else if m('?Lilac')             then aset(cols_Lilac)
else if m('?Lilac 2')           then aset2(cols_Lilac,10)
else if m('?Lilac 3')           then aset2(cols_Lilac,20)
else if m('?Gold')              then aset(cols_Gold)
else if m('?Gold 2')            then aset2(cols_Gold,10)
else if m('?Gold 3')            then aset2(cols_Gold,20)
else if m('?Gold 4')            then aset2(cols_Gold,30)
else if m('?Silver Gold')       then aset(cols_Silver_Gold)
else if m('?Silver Gold 2')     then aset2(cols_Silver_Gold,10)
else if m('?Grey')              then aset(cols_Grey)
else if m('?Grey 2')            then aset2(cols_Grey,10)
else if m('?grey 3')            then aset(cols_grey2)
else if m('?grey 4')            then aset2(cols_grey2,10)
else if m('?grey 5')            then aset2(cols_grey2,20)
else if m('?grey 6')            then aset2(cols_grey2,30)
else if m('?Soft Blue')         then aset(cols_Soft_Blue)
else if m('?Soft Blue 2')       then aset2(cols_Soft_Blue,10)
else if m('?Soft Blue 3')       then aset2(cols_Soft_Blue,20)
else if m('?Soft Blue 4')       then aset2(cols_Soft_Blue,30)
else if m('?Soft Blue 5')       then aset(cols_Soft_Blue2)//better background for controls contrast - 14nov2022
else if m('?Emerald')           then aset(cols_Emerald)
else if m('?Emerald 2')         then aset2(cols_Emerald,10)
else if m('?Emerald 3')         then aset2(cols_Emerald,20)
else if m('?Washed Crimson')    then aset(cols_Washed_Crimson)
else if m('?Washed Crimson 2')  then aset2(cols_Washed_Crimson,10)
else if m('?Washed Crimson 3')  then aset2(cols_Washed_Crimson,20)
else if m('?Dusty Pink')        then aset(cols_Dusty_Pink)
else if m('?Dusty Pink 2')      then aset2(cols_Dusty_Pink,10)
else if m('?Dusty Pink 3')      then aset2(cols_Dusty_Pink,20)
else if m('?Golden Sands')      then aset(cols_Golden_Sands)
else if m('?Golden Sands 2')    then aset2(cols_Golden_Sands,10)
else if m('?Golden Sands 3')    then aset2(cols_Golden_Sands,20)
else if m('?Fern')              then aset(cols_Fern)
else if m('?Fern 2')            then aset2(cols_Fern,10)
else if m('?Tangerine')         then aset(cols_Tangerine)
else if m('?Tangerine 2')       then aset2(cols_Tangerine,10)
else if m('?Tangerine 3')       then aset2(cols_Tangerine,20)
//.new built-in colors - 09may2021
else if m('?Barely Beige')       then aset(cols_Barely_Beige)
else if m('?Barely Beige 2')     then aset2(cols_Barely_Beige,10)
else if m('?Moon Blue')          then aset(cols_Moon_Blue)
else if m('?Moon Blue 2')        then aset2(cols_Moon_Blue,10)
else if m('?Moon Blue 3')        then aset2(cols_Moon_Blue,20)
else if m('?Moon Blue 4')        then aset2(cols_Moon_Blue,30)
else if m('?Moon Blue 5')        then aset2(cols_Moon_Blue,40)
else if m('?Howdy Brown')        then aset(cols_Howdy_Brown)
else if m('?Howdy Brown 2')      then aset2(cols_Howdy_Brown,20)
else if m('?Howdy Brown 3')      then aset2(cols_Howdy_Brown,30)
else if m('?Chirpy Charcoal')    then aset(cols_Chirpy_Charcoal)
else if m('?Chirpy Charcoal 2')  then aset2(cols_Chirpy_Charcoal,30)
else if m('?Dark Red Tint')      then aset(cols_DarkRedTint)//02may2022
else if m('?Dark Blue Tint')     then aset(cols_DarkBlueTint)//02may2022
else if m('?Dark Green Tint')    then aset(cols_DarkGreenTint)//02may2022
else if m('?Dark Yellow Tint')   then aset(cols_DarkYellowTint)//02may2022
else if m('?Dark Aqua Tint')     then aset(cols_DarkAquaTint)//02may2022
else if m('?Dreamy Cream')       then aset(cols_Dreamy_Cream)
else if m('?Dreamy Cream 2')     then aset2(cols_Dreamy_Cream,10)
else if m('?Dreamy Cream 3')     then aset2(cols_Dreamy_Cream,20)
else if m('?Gentle Ginger')      then aset(cols_Gentle_Ginger)
else if m('?Gentle Ginger 2')    then aset2(cols_Gentle_Ginger,10)
else if m('?Gentle Ginger 3')    then aset2(cols_Gentle_Ginger,20)
else if m('?Gentle Ginger 4')    then aset2(cols_Gentle_Ginger,30)
else if m('?Grumpy Green')       then aset(cols_Grumpy_Green)
else if m('?Grumpy Green 2')     then aset2(cols_Grumpy_Green,20)
else if m('?Grumpy Green 3')     then aset2(cols_Grumpy_Green,40)
else if m('?Grumpy Green 4')     then aset2(cols_Grumpy_Green,50)
else if m('?Glowing Grey')       then aset(cols_Glowing_Grey)
else if m('?Glowing Grey 2')     then aset2(cols_Glowing_Grey,10)
else if m('?Glowing Grey 3')     then aset2(cols_Glowing_Grey,20)
else if m('?Glowing Grey 4')     then aset2(cols_Glowing_Grey,30)
else if m('?Jovial Mauve')       then aset2(cols_Jovial_Mauve,-10)
else if m('?Jovial Mauve 2')     then aset(cols_Jovial_Mauve)
else if m('?Jovial Mauve 3')     then aset2(cols_Jovial_Mauve,10)
else if m('?Luscious Lilac')     then aset(cols_Luscious_Lilac)
else if m('?Luscious Lilac 2')   then aset2(cols_Luscious_Lilac,10)
else if m('?Luscious Lilac 3')   then aset2(cols_Luscious_Lilac,20)
else if m('?Luscious Lilac 4')   then aset2(cols_Luscious_Lilac,30)
else if m('?Slinky Pink')        then aset2(cols_Slinky_Pink,-10)
else if m('?Slinky Pink 2')      then aset(cols_Slinky_Pink)
else if m('?Slinky Pink 3')      then aset2(cols_Slinky_Pink,10)
else if m('?Rosebud Pink')       then aset(cols_Rosebud_Pink)
else if m('?Rosebud Pink 2')     then aset2(cols_Rosebud_Pink,10)
else if m('?Silky Sand')         then aset2(cols_Silky_Sand,-10)
else if m('?Silky Sand 2')       then aset(cols_Silky_Sand)
else if m('?Silky Sand 3')       then aset2(cols_Silky_Sand,10)
else if m('?Silky Sand 4')       then aset2(cols_Silky_Sand,20)
else if m('?Really Red')         then aset2(cols_Really_Red,-10)
else if m('?Really Red 2')       then aset(cols_Really_Red)
else if m('?Really Red 3')       then aset2(cols_Really_Red,20)
else if m('?Robust Red')         then aset(cols_Robust_Red)
else if m('?Robust Red 2')       then aset2(cols_Robust_Red,10)
else if m('?Robust Red 3')       then aset2(cols_Robust_Red,20)
else if m('?Red')                then aset(cols_Red)
else if m('?Red 2')              then aset2(cols_Red,10)
else if m('?Red 3')              then aset2(cols_Red,20)
else if m('?Red 4')              then aset(cols_Red2)
else if m('?Red 5')              then aset2(cols_Red2,10)
else if m('?Red 6')              then aset2(cols_Red2,20)
else if m('?Radiant Yellow')     then aset2(cols_Radiant_Yellow,-10)
else if m('?Radiant Yellow 2')   then aset(cols_Radiant_Yellow)
else if m('?Peach')              then aset2(cols_Peach,-5)
else if m('?Peach 2')             then aset(cols_Peach)
else if m('?Peach 3')            then aset2(cols_Peach,10)
else if m('?Tangy Tangerine')    then aset(cols_Tangy_Tangerine)
else if m('?Tangy Tangerine 2')  then aset2(cols_Tangy_Tangerine,20)
else if m('?Tangy Tangerine 3')  then aset2(cols_Tangy_Tangerine,45)
else if m('?Wild White')         then aset(cols_Wild_White)
else if m('?Wild Thing')         then aset(cols_Wild_Thing)//31may2021
else if m('?Wild Thing 2')       then aset2(cols_Wild_Thing,10)//31may2021
else if m('?Wild Thing 3')       then aset2(cols_Wild_Thing,20)//31may2021
else if m('?Wild Thing 4')       then aset2(cols_Wild_Thing,40)//31may2021
else if m('?Black')              then aset(cols_Black)//26aug2021
else if m('?Black 2')            then aset2(cols_Black,20)//26aug2021
else if m('?White')              then aset(cols_White)//26aug2021
else if m('?White 2')            then aset2(cols_White,10)//26aug2021
else if m('?Wild Mix')           then aset(cols_Wild_Mix)//26aug2021
else if m('?Wild Mix 2')         then aset2(cols_Wild_Mix,10)//26aug2021
else if m('?Wild Mix 3')         then aset2(cols_Wild_Mix,20)//26aug2021
else if m('?Wild Mix 4')         then aset2(cols_Wild_Mix,30)//26aug2021
else if m('?blue')               then aset(cols_blue)//26aug2021
else if m('?blue 2')             then aset2(cols_blue,10)//26aug2021
else if m('?blue 3')             then aset2(cols_blue,20)//26aug2021
else if m('?blue 4')             then aset2(cols_blue,30)//26aug2021
else if m('?blue 5')             then aset2(cols_blue,40)//26aug2021
else if m('?blue 6')             then aset2(cols_blue,50)//26aug2021

else if m('?royal blue')         then aset(cols_royal_blue)//26aug2021
else if m('?royal blue 2')       then aset2(cols_royal_blue,20)//26aug2021
else if m('?royal blue 3')       then aset2(cols_royal_blue,30)//26aug2021
else if m('?royal blue 4')       then aset2(cols_royal_blue,40)//26aug2021
else if m('?royal blue 5')       then aset2(cols_royal_blue,50)//26aug2021

else if m('?pink')               then aset(cols_pink)//09mar2021
else if m('?pink 2')             then aset2(cols_pink,10)//09mar2021

else if m('?satin pink')         then aset2(cols_satinpink,-10)//15mar2021
else if m('?satin pink 2')       then aset(cols_satinpink)//15mar2021
else if m('?satin pink 3')       then aset2(cols_satinpink,10)//15mar2021
else if m('?satin pink 4')       then aset2(cols_satinpink,20)//15mar2021
//.purple
else if m('?purple')             then aset(cols_purple)//07jun2022
else if m('?purple 2')           then aset2(cols_purple,20)//07jun2022
else if m('?purple 3')           then aset2(cols_purple,30)//07jun2022
else if m('?purple 4')           then aset2(cols_purple,40)//07jun2022

else if m('?purple 5')           then aset(cols_purple2)//07jun2022
else if m('?purple 6')           then aset2(cols_purple2,10)//07jun2022
else if m('?purple 7')           then aset2(cols_purple2,20)//07jun2022

else if m('?purple 8')           then aset(cols_purple3)//07jun2022
else if m('?purple 9')           then aset2(cols_purple3,20)//07jun2022
//.brown - 12jun2022
else if m('?brown')              then aset(cols_brown)
else if m('?brown 2')            then aset(cols_brown2)
else if m('?brown 3')            then aset(cols_brown3)
else if m('?brown 4')            then aset(cols_brown4)
else if m('?brown 5')            then aset(cols_brown5)
else if m('?brown 6')            then aset(cols_brown6)//21jun2022
else if m('?brown 7')            then aset2(cols_brown6,10)//21jun2022
else if m('?brown 8')            then aset2(cols_brown6,20)//21jun2022
else if m('?brown 9')            then aset2(cols_brown6,30)//21jun2022

else
   begin
   if (sizeof(cols__default)>=2) then aset(cols__default) else aset(cols_black);
   end;
except;end;
end;
//## sysstatus0 ##
function sysstatus0(xindex:longint;xvalue:string):boolean;//07oct2022
var
   xref64:comp;
begin
try;xref64:=ms64;result:=sysstatus(xref64,xindex,xvalue);except;end;
end;
//## sysstatus ##
function sysstatus(var xref64:comp;xindex:longint;xvalue:string):boolean;//04oct2022
begin
try;result:=sysstatus2(xref64,xindex,xvalue,'',-1);except;end;
end;
//## sysstatus2 ##
function sysstatus2(var xref64:comp;xindex:longint;xvalue,xnewtitle:string;xnewpert:double):boolean;//07oct2022
begin//Note: returns TRUE when stopped
try
result:=false;
if (xindex>=0) and (sysprogram<>nil) and (ms64>=xref64) then
   begin
   if (xnewtitle<>'') or (xnewpert>=0) then
      begin
      //init
      if (xnewtitle='') then xnewtitle:=sysprogram.sys.xstatustitle;
      if (xnewpert<0) then xnewpert:=sysprogram.sys.xstatuspert;
      //get
      sysprogram.sys.xstatus(xnewpert,xnewtitle);
      end;
   result:=sysstatus_settext(xindex,xvalue);
   sysstatus_paintnow;
   xref64:=ms64+sysstatus_painttime;
   end;
except;end;
end;
//## sysstatus_settext ##
function sysstatus_settext(xindex:longint;xvalue:string):boolean;//07oct2022
begin//Note: returns TRUE when stopped
try
result:=false;
if (xindex>=0) and (sysprogram<>nil) then
   begin
   sysprogram.sys.xstatustext[xindex]:=xvalue;
   result:=sysstatus_stopped;
   end;
except;end;
end;
//## sysstatus_setpert ##
function sysstatus_setpert(xpert:double):boolean;//07oct2022
begin//Note: returns TRUE when stopped
try
result:=false;
if (sysprogram<>nil) then
   begin
   sysprogram.sys.xstatuspert:=xpert;
   result:=sysstatus_stopped;
   end;
except;end;
end;
//## sysstatus_paintnow ##
function sysstatus_paintnow:boolean;//07oct2022
begin//Note: returns TRUE when stopped
try
result:=false;
if (sysprogram<>nil) then
   begin
   sysprogram.sys.xstatuspaintnow;
   result:=sysstatus_stopped;
   end;
except;end;
end;
//## sysstatus_stopped ##
function sysstatus_stopped:boolean;//07oct2022
begin
try;result:=(sysprogram<>nil) and sysprogram.sys.xstatustopped;except;end;
end;
//## low__ver ##
function low__ver:longint;//low__gossver, low__sysver etc//low__ver
begin
try;result:=40032446;except;end;
end;
//## low__verstr ##
function low__verstr:string;//low__sysver etc//low__ver
begin
try
result:=inttostr(low__ver);
result:=strcopy1(result,1,1)+'.'+strcopy1(result,2,2)+'.'+strcopy1(result,4,length(result));
except;end;
end;
//## low__centerform ##
procedure low__centerform(x:tcustomform);//26apr2021
var
   a:trect;
   dx,dy:longint;
begin
try
//check
if zznil(x,2002) then exit;
//get
a:=misworkarea;
dx:=a.left+((a.right-a.left)-x.width) div 2;
dy:=a.top+((a.bottom-a.top)-x.height) div 2;
x.setbounds(dx,dy,x.width,x.height);
except;end;
end;
//## low__newmsgwindow ##
function low__newmsgwindow(xclassname:string;xowner:hwnd;xproc:twndmethod):hwnd;
var
   a:twndclass;
begin
try
//defaults
result:=0;
//range
if (xclassname='') then xclassname:='hcom';
//make class
with a do
begin
style           :=0;
lpfnWndProc     :=@defwindowproc;
cbClsExtra      :=0;
cbWndExtra      :=0;
hInstance       :=0;
hIcon           :=0;
hCursor         :=0;
hbrBackground   :=0;
lpszMenuName    :=nil;
lpszClassName   :=pchar(xclassname);//20may2021
end;
//register class
registerclassa(a);
//make window
result:=createwindow(pchar(xclassname),'',0,0,0,0,0,xowner,0,hinstance,nil);
//connect to "xproc" -> standard Windows "twndmethod" procedure - 21may2021
if assigned(xproc) then setwindowlong(result,GWL_WNDPROC,longint(makeobjectinstance(xproc)));
except;end;
end;
//## low__freewindow ##
procedure low__freewindow(var x:hwnd);
begin
try
if (x<>0) then
   begin
   destroywindow(x);
   x:=0;
   end;
except;end;
end;
//## low__wmerasebkgnd ##
procedure low__wmerasebkgnd(xform:tobject;var message:twmerasebkgnd);
begin
try
//check
if (xform=nil) or (not (xform is tform)) then exit;
//get
if not isiconic((xform as tform).handle) then message.result:=1
else
   begin
   message.msg:=wm_iconerasebkgnd;
   (xform as tform).defaulthandler(message);
   end;
except;end;
end;
//## wmmousewheel ##
procedure low__wmmousewheel(xsystem:tbasicsystem;var message:tmessage);
var//Tested and correct on XP HOME on 05-FEB-2006
   a:tint4;
   xval:longint;
begin
try
//handled
message.result:=0;
low__resetwheeltime;//03apr2021
//get
if zzok(xsystem,1017) and (not xsystem.destroying) then
   begin
   a.val:=message.wparam;
   xval:=round(smallint(a.wrds[1])/120)*viwheelspeed;
   if (xval<>0) then xsystem.aadd('w',0,xval,0);
   end;
except;end;
end;
//## low__programname ##
function low__programname:string;
begin
try
result:=programname;
scheck(result,programname_check);
except;end;
end;
//## createstringlist ##
function createstringlist:tstringlist;
begin
try
satinc(satStringlist,1);
result:=tstringlist.create;
zzadd(result);
except;end;
end;
//## createbitmap ##
function createbitmap:tbitmap;
begin
try
satinc(satBitmap,1);
result:=tbitmap.create;
zzadd(result);
except;end;
end;
//## createfilestream ##
function createfilestream(x:string;xmode:word):tfilestream;//27sep2022
begin
try
satinc(satFilestream,1);
result:=nil;//fixed - 27sep2022
result:=tfilestream.create(x,xmode);
zzadd(result);
except;end;
end;
//platform support -------------------------------------------------------------
//## low__plat ##
function low__plat(xcmd,xprgname:string;xrunaction:boolean):string;
const
   platfoldername='Blaiz Enterprises';
   xvintageok=false;//NO - Gossamer is strictly new - 19aug2020
   //Website now "http://www.BlaizEnterprises.com" with double encryption of ecap and cestr - 08nov2019, 24oct2019
   //Both "xsoftware" and "xvintage" are now "*.BlaizEnterprises.com" as of 15may2021
   //Decode using: "cdstr -> ecap" from BlaizTools
   xportal:array[0..91] of byte=(42,0,0,0,159,214,17,48,48,177,74,58,89,15,121,35,234,93,197,240,107,83,233,137,48,71,183,36,133,78,215,105,29,62,118,253,104,84,41,172,197,222,248,231,188,38,210,195,44,2,197,33,214,122,180,37,15,226,210,220,162,5,35,133,198,36,127,102,9,5,151,85,212,73,197,49,55,165,196,166,179,125,142,158,24,52,173,51,181,41,206,255);
   xvintage:array[0..99] of byte=(46,0,0,0,159,214,17,48,48,177,74,58,89,15,121,35,234,93,197,240,107,83,233,137,48,71,183,36,133,78,215,104,29,62,118,253,104,84,41,193,197,222,248,230,179,38,210,9,75,2,197,28,218,122,180,234,215,226,210,3,149,5,35,122,198,36,127,57,25,5,151,87,208,73,243,35,234,165,196,23,238,125,142,156,168,52,173,57,202,151,197,66,56,164,254,156,137,219,193,255);
//was:   xsoftware:array[0..101] of byte=(47,0,0,0,159,214,17,48,48,177,74,58,89,15,121,35,234,93,197,240,107,83,233,137,48,71,183,36,133,78,215,101,29,62,118,253,104,84,41,176,197,222,248,217,171,38,210,9,97,2,197,22,231,122,180,33,195,226,210,217,160,5,35,114,198,36,127,110,15,5,151,81,223,73,62,41,181,165,196,21,247,125,142,115,166,52,173,43,15,151,197,68,44,164,254,170,170,243,220,66,210,255);
   xsoftware:array[0..91] of byte=(42,0,0,0,159,214,17,48,48,177,74,58,89,15,121,35,234,93,197,240,107,83,233,137,48,71,183,36,133,78,215,105,29,62,118,253,104,84,41,172,197,222,248,231,188,38,210,195,44,2,197,33,214,122,180,37,15,226,210,220,162,5,35,133,198,36,127,102,9,5,151,85,212,73,197,49,55,165,196,166,179,125,142,158,24,52,173,51,181,41,206,255);
   xfacebook:array[0..111] of byte=(52,0,0,0,159,214,17,48,48,177,74,58,89,15,121,35,234,93,197,240,107,83,233,137,48,71,183,36,133,78,215,33,29,62,118,54,115,84,41,178,197,222,248,163,170,38,210,247,24,2,197,27,214,122,180,31,250,226,210,249,163,5,35,128,198,36,127,34,15,5,151,82,216,73,243,49,251,165,196,17,230,125,142,145,173,196,173,43,10,151,197,52,47,52,254,177,169,62,172,46,146,75,21,87,12,164,126,104,117,254,159,255);
   xtwitter:array[0..99] of byte=(46,0,0,0,159,214,17,48,48,177,74,58,89,15,121,35,234,93,197,240,107,83,233,137,48,71,183,36,133,78,215,33,29,62,118,54,115,84,41,118,197,222,248,238,188,38,210,254,94,2,197,41,218,122,180,46,195,226,210,250,163,5,35,126,198,36,127,86,11,5,151,68,212,73,243,46,240,165,196,19,249,125,142,154,160,52,173,54,14,151,197,55,60,164,254,169,70,209,159,255);
   xinstagram:array[0..113] of byte=(53,0,0,0,159,214,17,48,48,177,74,58,89,15,121,35,234,93,197,240,107,83,233,137,48,71,183,36,133,78,215,33,29,62,118,54,115,84,41,168,197,222,248,225,188,38,210,12,24,2,197,30,227,122,180,47,9,226,210,248,155,5,35,131,198,36,127,97,7,5,151,70,218,73,243,49,245,165,196,7,241,125,142,92,160,196,173,64,1,151,197,1,45,52,254,160,171,62,172,61,198,75,21,96,26,164,126,90,136,224,99,115,213,255);
   xbyBEcom:array[0..75] of byte=(34,0,0,0,159,214,17,48,48,177,74,58,94,15,121,35,234,93,197,240,107,83,233,91,48,71,183,30,133,78,215,108,29,62,118,47,154,84,41,117,113,222,248,255,10,38,210,9,79,73,127,39,229,122,125,46,254,226,210,179,87,5,35,132,0,151,197,153,80,5,36,157,6,129,184,255);
var
   xprgnameORG,str1,v,v2,xval:string;
   p:longint;
   //## xnospaces ##
   function xnospaces(x:string):string;//02may2022
   var
      p:longint;
   begin
   try
   result:=x;
   for p:=1 to length(result) do if (strcopy1(result,p,1)=#32) or (strcopy1(result,p,1)=#160) or (strcopy1(result,p,1)=#9) then result[p-1+stroffset]:=#32;
   low__remchar(result,#32);
   except;end;
   end;
   //## xvisit ##
   function xvisit(xval:array of byte;xmore:string):string;
   var
      a:tstr8;
   begin
   try
   //defaults
   result:='';
   //init
   a:=nil;
   a:=bnew;
   //get
   a.aadd(xval);
   if low__cdmix(a) then
      begin
      result:=a.text+xmore;
      if xrunaction and (result<>'') then runlow(result,'');
      end;
   except;end;
   try;bfree(a);except;end;
   end;
begin
try
//defaults
result:='';
//init
xcmd:=low__lowercase(xcmd);
xval:='';  
xprgnameORG:=xprgname;
if (xprgname='') then
   begin
   xprgname:=programwebname;
   scheck(xprgname,programwebname_check);//30aug2020
   end;
//.split
if (xcmd<>'') then
   begin
   for p:=1 to length(xcmd) do if (strcopy1(xcmd,p,1)='.') then
      begin
      xval:=strcopy1(xcmd,p+1,length(xcmd));
      xcmd:=strcopy1(xcmd,1,p-1);
      break;
      end;//p
   end;

//get
if      (xcmd='newinstance') then
   begin
   icheck(programnewinstance,programnewinstance_check);
   result:=low__exename;
   if xrunaction then
      begin
      siSaveallsettings;
      runLOW(result,'');
      end;
   end
//.folder
else if (xcmd='folder') then
   begin
   result:=asfolder(asfolder(low__extractfilepath(low__exename))+platfoldername);//this folder and up we own
   //filter
   if (xprgname<>'') then
      begin
      xprgname:=safefilename(xprgname,true);
      result:=asfolder(result+xprgname);
      end;
   //get
   if xrunaction and (not directoryexists(result)) then forcedirectories(result);
   end
//.folderbe
else if (xcmd='folderbe') then
   begin
   result:=asfolder(asfolder(low__extractfilepath(low__exename))+platfoldername);//this folder and up we own
   if xrunaction and (not directoryexists(result)) then forcedirectories(result);
   end
else if (xcmd='root') then result:=asfolder(low__extractfilepath(low__exename))
else if (xcmd='showroot') then
   begin
   result:=asfolder(low__extractfilepath(low__exename));
   runlow(result,'');
   end
else if (xcmd='showhelp') then low__showhelp(not vihelp_show)
//.visit
//xxxxxxxxxxxelse if (xcmd='splash') then result:=low__cdstr(xportal)//leave the "ecap()" encryption in place -> splash screen expects the url to be encrypted with ecap - 07mar2020
else if (xcmd='portal') then result:=xvisit(xportal,'')
else if (xcmd='software') then result:=xvisit(xsoftware,'')
else if (xcmd='vintage') then result:=xvisit(xvintage,'')
//was: else if (xcmd='nprogram') then result:=xvisit(xsoftware,low__insstr('/'+low__lowercase(safename(xnospaces(xprgname))+'.html'),xprgname<>''))//new program
//was: else if (xcmd='nprogramzip') then result:=xvisit(xsoftware,low__insstr('/'+low__lowercase(safename(xnospaces(xprgname))+'.zip'),xprgname<>''))//new program - 15may2021
else if (xcmd='nprogram') or (xcmd='program') then result:=xvisit(xsoftware,low__insstr('/'+low__lowercase(safename(xnospaces(xprgname))+'.html'),xprgname<>''))//new program
else if (xcmd='nprogramzip') or (xcmd='programzip') then result:=xvisit(xsoftware,low__insstr('/'+low__lowercase(safename(xnospaces(xprgname))+'.zip'),xprgname<>''))//new program - 15may2021
else if (xcmd='vprogram') then result:=xvisit(xvintage,low__insstr('/'+low__lowercase(safename(xnospaces(xprgname))+'.html'),xprgname<>''))//vintage program
else if (xcmd='vprogramzip') then result:=xvisit(xvintage,low__insstr('/'+low__lowercase(safename(xnospaces(xprgname))+'.zip'),xprgname<>''))//vintage program - 15may2021
else if (xcmd='instagram') then result:=xvisit(xinstagram,'')
else if (xcmd='facebook') then result:=xvisit(xfacebook,'')
else if (xcmd='twitter') then result:=xvisit(xtwitter,'')
//.start menu
else if (xcmd='startmenu') then
   begin
   result:=winprograms+xprgname+low__insstr(' (Vintage)',xvintageok)+#32+bstr(low__cdmixb(bcopyarray(xbyBEcom)))+'.lnk';//unique link name on startmenu - 10apr2019, 30mar2019, 02FEB2011
   //.create
   if      (xval='') or (xval='create') then
      begin
      if xrunaction and (not low__fileexists(result)) then low__createlink(result,low__exename,'','');
      end
   //.del
   else if (xval='del') then
      begin
      if xrunaction then low__remfile(result);
      end
   //.exists
   else if (xval='exists') then result:=bnc(low__fileexists(result))
   //.toggle
   else if (xval='toggle') then
      begin
      case low__fileexists(result) of
      true:low__plat(xcmd+'.del',xprgname,xrunaction);//delete existing
      false:low__plat(xcmd,xprgname,xrunaction);//create new
      end;//case
      end
   //.error
   else showerror('Unknown directive "'+xcmd+'.'+xval+'" [006]');
   end
//.desktop
else if (xcmd='desktop') then
   begin
   result:=windesktop+xprgname+low__insstr(' (Vintage)',xvintageok)+#32+bstr(low__cdmixb(bcopyarray(xbyBEcom)))+'.lnk';//unique link name on startmenu - 10apr2019, 30mar2019, 02FEB2011
   //.create
   if      (xval='') or (xval='create') then
      begin
      //init
      if viwine then v:=remlastext(result)+'.desktop' else v:='';
      //get
      if xrunaction and ( (not low__fileexists(result)) and (not low__fileexists(v)) ) then
         begin
         low__createlink(result,low__exename,'','');
         //Note: Wine writes the ".lnk" and makes it's own ".desktop" files -> only the ".desktop" works as a link so we should delete the ".lnk" as it just wastes desktop space - 05feb2022
         if viwine and low__fileexists(result) and (v<>'') then
            begin
            //slight delay on a Windowed Ubuntu v20 - so try 20 times 100ms apart - 05feb2022
            for p:=1 to 20 do
            begin
            if low__fileexists(v) then
               begin
               low__remfile(result);
               break;
               end;
            sleep(100);
            end;//p
            end;
         end;
      end
   //.del
   else if (xval='del') then
      begin
      if xrunaction then
         begin
         low__remfile(result);
         //Note: Wine generates a duplicate file ending with ".desktop" - 05feb2022
         if viwine then low__remfile(remlastext(result)+'.desktop');
         end;
      end
   //.exists
   else if (xval='exists') then result:=bnc(low__fileexists(result))
   //.toggle
   else if (xval='toggle') then
      begin
      case low__fileexists(result) of
      true:low__plat(xcmd+'.del',xprgname,xrunaction);//delete existing
      false:low__plat(xcmd,xprgname,xrunaction);//create new
      end;//case
      end
   //.error
   else showerror('Unknown directive "'+xcmd+'.'+xval+'" [006]');
   end
else showerror('Unknown directive "'+xcmd+'" [007]');
except;end;
end;
//## low__platroot ##
function low__platroot:string;
begin
try;result:=low__plat('root','',true);except;end;
end;
//## low__platfolder ##
function low__platfolder(xname:string):string;//06oct2020
begin
try
case (xname<>'') of
true:result:=low__plat('folder',xname,true);
false:result:=low__plat('folderbe','',true);
end;
except;end;
end;
//## low__plattemp ##
function low__plattemp:string;
begin
try;result:=low__platfolder('temp');except;end;
end;
//## low__platDLLname ##
function low__platDLLname(xname:string):string;//26sep2021
begin
try;result:=low__platfolder('settings')+low__lowercase(xname)+low__insstr('-',xname<>'')+low__ownname+'.dll';except;end;
end;
//## low__platsyssettings ##
function low__platsyssettings:string;
begin
try;result:=low__platfolder('settings')+'sys-'+low__ownname+'.ini';except;end;
end;
//## low__platprgsettings ##
function low__platprgsettings:string;
begin
try;result:=low__platfolder('settings')+'prg-'+low__ownname+'.ini';except;end;
end;
//## low__platonce ##
function low__platonce:string;
begin
try;result:=low__platfolder('settings')+low__ownname+'.one';except;end;
end;
//## low__platactive ##
function low__platactive:string;
begin
try;result:=low__platfolder('settings')+low__ownname+'.act';except;end;
end;
//## low__platimages ##
function low__platimages:string;
begin
try;result:=low__platfolder('images');except;end;
end;
//## low__platsysext ##
function low__platsysext(xext:string):string;//29aug2021
begin
try
xext:=low__lowercase(xext);
result:=low__platfolder('settings')+'sys-'+low__ownname+low__insstr('.',xext<>'')+xext;
except;end;
end;
//## low__platprgext ##
function low__platprgext(xext:string):string;//29aug2021
begin
try
xext:=low__lowercase(xext);
result:=low__platfolder('settings')+'prg-'+low__ownname+low__insstr('.',xext<>'')+xext;
except;end;
end;
//## need_chimes ##
procedure need_chimes;//02mar2022
begin
try;{$ifdef chimes} {$else}showerror('CHIMES support required');{$endif}except;end;
end;
//## need_mm ##
procedure need_mm;
begin
try;{$ifdef mm} {$else}showerror('MM support required');{$endif}except;end;
end;
//## need_jpeg ##
procedure need_jpeg;
begin
try;{$ifdef jpeg} {$else}showerror('JPEG support required');{$endif}except;end;
end;
//## need_gif ##
procedure need_gif;
begin
try;{$ifdef gif} {$else}showerror('GIF support required');{$endif}except;end;
end;
//## need_ico ##
procedure need_ico;
begin
try;{$ifdef ico} {$else}showerror('ICO support required');{$endif}except;end;
end;
//## have_ico ##
function have_ico:boolean;//22may2022
begin
try;{$ifdef ico}result:=true;{$else}result:=false;{$endif}except;end;
end;
//## need_tbt ##
procedure need_tbt;
begin
try;{$ifdef tbt} {$else}showerror('TBT support required');{$endif}except;end;
end;
//## need_man ##
procedure need_man;//09feb2022
begin
try;{$ifdef man} {$else}showerror('MAN support required');{$endif}except;end;
end;
//## need_mfile ##
procedure need_mfile;//09feb2022
begin
try;{$ifdef mfile} {$else}showerror('MFILE support required');{$endif}except;end;
end;


//timing support ---------------------------------------------------------------
//## ms64 ##
function ms64:comp;//64bit millisecond system timer, 01-SEP-2006
var//64bit system timer, replaces "gettickcount" with range of 49.7 days,
   //now with new range of 29,247 years.
   //Note: must be called atleast once every 49.7 days, or it will loose track so
   //      system timer should call this routine regularly.
   i4:tint4;
   tmp:comp;
begin
try
{$ifdef D3}
//defaults
result:=0;
//process
//.get
i4.val:=gettickcount;
//i4.val:=timeGettime;//high resolution timer - 28sep2021
//INTEGER -> CURRENCY (0..4billion)
//#1
result:=i4.bytes[0];
//#2
tmp:=i4.bytes[1];
result:=result+(tmp*256);
//#3
tmp:=i4.bytes[2];
result:=result+(tmp*256*256);
//#4
tmp:=i4.bytes[3];
result:=result+(tmp*256*256*256);
//#5
if (not ms64init) then
   begin
{//debug code only
   if programtesting then
      begin
      ms64OFFSET:=maxint;
      ms64OFFSET:=ms64OFFSET*4;
      end
   else ms64OFFSET:=0;
{}
   ms64OFFSET:=0;
   ms64LAST:=result;
   ms64init:=true;
   end;//end of if
//# thread safe - allow a large difference margin (10 minutes) so close calling
//# threads won't corrupt (increment falsely) the offset var.
if ((result+600000)<ms64LAST) then ms64OFFSET:=ms64OFFSET+ms64LAST;
//lastv
ms64LAST:=result;
//#6
result:=result+ms64OFFSET;
{$endif}
{$ifdef D10}
result:=DateTimeToMilliseconds(now);
{$endif}
except;end;
end;
//## ms64FAST ##
function ms64FAST:comp;//64bit millisecond system timer, 01-SEP-2006
var//64bit system timer, replaces "gettickcount" with range of 49.7 days,
   //now with new range of 29,247 years.
   //Note: must be called atleast once every 49.7 days, or it will loose track so
   //      system timer should call this routine regularly.
   i4:tint4;
   tmp:comp;
begin
try
{$ifdef D3}
//defaults
result:=0;
//process
//.get
//i4.val:=gettickcount;
i4.val:=timeGettime;//high resolution timer - 28sep2021
//INTEGER -> CURRENCY (0..4billion)
//#1
result:=i4.bytes[0];
//#2
tmp:=i4.bytes[1];
result:=result+(tmp*256);
//#3
tmp:=i4.bytes[2];
result:=result+(tmp*256*256);
//#4
tmp:=i4.bytes[3];
result:=result+(tmp*256*256*256);
//#5
if (not ms64init) then
   begin
{//debug code only
   if programtesting then
      begin
      ms64OFFSET:=maxint;
      ms64OFFSET:=ms64OFFSET*4;
      end
   else ms64OFFSET:=0;
{}
   ms64OFFSET:=0;
   ms64LAST:=result;
   ms64init:=true;
   end;//end of if
//# thread safe - allow a large difference margin (10 minutes) so close calling
//# threads won't corrupt (increment falsely) the offset var.
if ((result+600000)<ms64LAST) then ms64OFFSET:=ms64OFFSET+ms64LAST;
//lastv
ms64LAST:=result;
//#6
result:=result+ms64OFFSET;
{$endif}
{$ifdef D10}
result:=DateTimeToMilliseconds(now);
{$endif}
except;end;
end;
//## ms64str ##
function ms64str:string;//06NOV2010
begin
try;result:=floattostr(ms64);except;end;
end;
//## msr64 ##
function msr64:comp;//relative 64bit millisecond system timer - 20feb2021
begin
try
//was: result:=trunc((ms64-msr64__ref)*(msr64__speed/100));
result:=low__div64(low__mult64(ms64-msr64__ref,msr64__speed),100);
if (result<0) then result:=0;
except;end;
end;
//## msr64str ##
function msr64str:string;//20feb2021
begin
try;result:=floattostr(msr64);except;end;
end;
//## low__setmsr64 ##
procedure low__setmsr64(xnewtime64:comp;xnewspeed:longint);
begin//note: newspeed=10..1000, Note: comp doesn't support fractions (e.g. 1.1 or 0.1 such as speed of 10/100)
try
if (xnewtime64<0) then xnewtime64:=0;
msr64__speed:=frcrange(xnewspeed,10,1000);
//was: msr64__ref:=-(((xnewtime64*100)/msr64__speed)-ms64);
msr64__ref:=-(low__div64(low__mult64(xnewtime64,100),msr64__speed)-ms64);
except;end;
end;
//## nowmin ##
function nowmin:longint;//03mar2022
var
   h,min,sec,ms:word;
begin
try
result:=0;
low__decodetime2(now,h,min,sec,ms);//h=0..23, min=0..59
h:=frcrange(h,0,23);
min:=frcrange(min,0,59);
result:=frcrange((h*60)+min,0,1439);
except;end;
end;
//## low__t ##
function low__t(x:boolean):longint;
begin
try;if x then result:=tepOn else result:=tepOff;except;end;
end;
//## low__instouch ##
function low__instouch(xval,xtouchval:longint):longint;//06may2020
begin
try;result:=low__instouch2(xval,xtouchval,true);except;end;
end;
//## low__instouch2 ##
function low__instouch2(xval,xtouchval:longint;xallowtouch:boolean):longint;//06may2020
begin
try;result:=xval;if xallowtouch and vitouch then result:=frcmin(xval,xtouchval);except;end;
end;
//## low__randomstr ##
function low__randomstr(x:tstr8;xlen:longint):boolean;//27apr2021
var
   p:longint;
begin
try
//defaults
result:=false;
//get
if block(x) then
   begin
   x.setlen(xlen);
   if (x.len>=1) then
      begin
      for p:=0 to (x.len-1) do x.pbytes[p]:=byte(random(256));
      end;
   end;
//successful
result:=true;
except;end;
try;bunlockautofree(x);except;end;
end;

//-- Clipboard Support ---------------------------------------------------------
//## low__copymulti ##
function low__copymulti(xformat:array of word;xdata:array of tstr8):boolean;
var
   xcount,p:longint;
   xmustclose:boolean;
   //## xadd ##
   function xadd:boolean;
   var
      data:thandle;
      dataptr:pointer;
      xsize:longint;
   begin
   try
   //defaults
   result:=false;
   //check
   if (xdata[p]=nil) then exit;
   //init
   xsize:=xdata[p].count;
   //get
   data:=globalalloc(GMEM_MOVEABLE,xsize);
   try
   dataptr:=globallock(data);
    try
    move(xdata[p].core^,dataptr^,xsize);//OK - 26fep2022
    setclipboarddata(xformat[p],data);
    result:=true;
    finally
    globalunlock(data);
    end;
   except;globalfree(data);end;
   except;end;
   end;
begin
try
//defaults
result:=false;
xmustclose:=false;
//init
xcount:=1+smallest(high(xformat),high(xdata));
//lock
for p:=0 to high(xdata) do block(xdata[p]);
//open
clipboard.open;
xmustclose:=true;
clipboard.clear;//clear the clipboard
//get
for p:=0 to (xcount-1) do if (xformat[p]>=1) and (xdata[p]<>nil) then
   begin
   result:=xadd;
   if not result then break;
   end;
except;end;
try
if xmustclose then clipboard.close;
//unlock
for p:=0 to high(xdata) do bunlockautofree(xdata[p]);
except;end;
end;
//## low__copywordcore ##
function low__copywordcore(xall:boolean;var x:twordcore):boolean;
label
   skipend;
var
   a:tstr8;
   p:longint;
   xmustclose:boolean;
   str1,str2,e:string;
   //## xadd ##
   function xadd(xformat:word):boolean;
   var
      data:thandle;
      dataptr:pointer;
      xsize:longint;
   begin
   try
   //defaults
   result:=false;
   //check
   if (xformat<=0) or (a=nil) then exit;
   //init
   xsize:=a.count;
   //get
   data:=globalalloc(GMEM_MOVEABLE,xsize);
   try
   dataptr:=globallock(data);
    try
    move(a.core^,dataptr^,xsize);//OK - 26fep2022
    setclipboarddata(xformat,data);
    result:=true;
    finally
    globalunlock(data);
    end;
   except;globalfree(data);end;
   except;end;
   end;
begin
try
//defaults
result:=false;
xmustclose:=false;
a:=nil;
//init
a:=bnew;
str1:=low__aorbstr('sel','all',xall);
//open
clipboard.open;
xmustclose:=true;
clipboard.clear;//clear the clipboard
//bwp
a.clear;
str2:='';
if not low__wordcore4(x,'ioget',bcopystr1('bwp '+str1,1,maxint),a,str2,e) then goto skipend;
if not xadd(cf_bwp) then goto skipend;
//txt -> Important: CF_TEXT expects a null terminated string - 26sep2022
a.clear;
str2:='';
if not low__wordcore4(x,'ioget',bcopystr1('txt '+str1,1,maxint),a,str2,e) then goto skipend;
a.aadd([0]);//null terminated string
if not xadd(cf_text) then goto skipend;
//successful
result:=true;
skipend:
except;end;
try
bfree(a);
if xmustclose then clipboard.close;
except;end;
end;
//## low__pastewordcore ##
function low__pasteformat(xformat:word;xout:tstr8):boolean;
label
   skipend;
var
   xmustclose:boolean;
   data:thandle;
   dataptr:pointer;
   xsize:longint;
begin
try
//defaults
result:=false;
xmustclose:=false;
//check
if not block(xout) then exit;
//init
xout.clear;
if not clipboard.hasformat(xformat) then goto skipend;
//open
clipboard.open;
xmustclose:=true;
//get
data:=getclipboarddata(xformat);
try
if (data<>0) then
   begin
   try
   dataptr:=globallock(data);
   xsize:=globalsize(data);
   xout.setlen(xsize);
   move(dataptr^,xout.core^,xsize);
   //successful
   result:=true;
   except;end;
   //unlock
   globalunlock(data);
   end;
except;end;
skipend:
except;end;
try
bunlockautofree(xout);
if xmustclose then clipboard.close;
except;end;
end;
//## low__cancopytxt ##
function low__cancopytxt:boolean;//20mar2021
begin
try;result:=true;except;end;
end;
//## low__copytxt ##
function low__copytxt(xdata:tstr8):boolean;
begin
try
result:=false;
if block(xdata) then
   begin
   clipboard.astext:=zzstr(xdata,80).text;
   result:=true;
   end;
except;end;
try;bunlockautofree(xdata);except;end;
end;
//## low__copytxt2 ##
function low__copytxt2(var xdata:string):boolean;
var
   a:tstr8;
begin
try
result:=false;
a:=nil;
a:=bnew;
a.text:=xdata;
result:=low__copytxt(a);
except;end;
try;bfree(a);except;end;
end;
//## low__copytxt2b ##
function low__copytxt2b(xdata:string):boolean;
begin
try;result:=low__copytxt2(xdata);except;end;
end;
//## low__canpastetxt ##
function low__canpastetxt:boolean;//16mar2021
begin
try;result:=clipboard.hasformat(cf_text);except;end;
end;
//## low__pastetxt ##
function low__pastetxt(xdata:tstr8):boolean;//16mar2021
begin
try
result:=false;
if block(xdata) and low__canpastetxt then
   begin
   xdata.text:=clipboard.astext;
   result:=true;
   end;
except;end;
try
if (not result) and zzok(xdata,1020) then xdata.clear;
bunlockautofree(xdata);
except;end;
end;
//## low__pastetxt2 ##
function low__pastetxt2(var xdata:string):boolean;//16mar2021
begin
try
result:=false;
xdata:='';
if low__canpastetxt then
   begin
   xdata:=clipboard.astext;
   result:=true;
   end;
except;end;
end;
//## low__pastetxt2b ##
function low__pastetxt2b:string;//25jul2021
begin
try;low__pastetxt2(result);except;end;
end;
//## low__canpasteimg ##
function low__canpasteimg:boolean;//07apr2021
begin
try;result:=low__canpasteimg2(nil);except;end;
end;
//## low__canpasteimg2 ##
function low__canpasteimg2(xfromimg:tobject):boolean;//12apr2021
var
   xbits,xw,xh:longint;
begin
try
result:=false;
if zzok(xfromimg,1021) then result:=misok82432(xfromimg,xbits,xw,xh)
else                        result:=clipboard.hasformat(cf_bitmap);
except;end;
end;
//## low__pasteimg ##
function low__pasteimg(d:tbasicimage):boolean;//07apr2021
begin
try;result:=low__pasteimg3(d,nil,false,0,0);except;end;
end;
//## low__pasteimg2 ##
function low__pasteimg2(d:tbasicimage;xfromimg:tobject;xfit:boolean):boolean;//12apr2021
begin
try;result:=low__pasteimg3(d,xfromimg,xfit,0,0);except;end;
end;
//## low__pasteimg3 ##
function low__pasteimg3(d:tbasicimage;xfromimg:tobject;xfit:boolean;xfitmaxW,xfitmaxH:longint):boolean;//14apr2021, 12apr2021
label
   skipend;
var
   a:tobject;
   aw,ah,xbits,xw,xh,ddw,ddh:longint;
begin
try
//defaults
result:=false;
a:=nil;
aw:=0;
ah:=0;
ddw:=1;
ddh:=1;
//check
if zznil(d,2004) or (not low__canpasteimg2(xfromimg)) then exit;
//range
xfitmaxW:=frcmin(xfitmaxW,0);
xfitmaxH:=frcmin(xfitmaxH,0);
//get
//.xfromimg -> a
if zzok(xfromimg,1022) then
   begin
   if not misok82432(xfromimg,xbits,xw,xh) then goto skipend;
   a:=misimg32(xw,xh);
   if (xw<>misw(a)) or (xh<>mish(a)) then goto skipend;
   if mishasai(xfromimg) and (not misaicopy(xfromimg,a)) then goto skipend;
   if not miscopyareaxx(rect(0,0,maxint,maxint),0,0,xw,xh,rect(0,0,xw-1,xh-1),a,xfromimg,255,0,clnone,0) then goto skipend;//fixed - 14apr2021
   end
//.clipoard -> a
else
   begin
   a:=misbmp32(1,1);
   (a as tbmp).assign(clipboard);//fixed via "xinfo" - 18jun2021
   end;
aw:=misw(a);
ah:=mish(a);
ddw:=aw;
ddh:=ah;
//.size
if zzok(xfromimg,1023) and xfit then
   begin
   //.stretch fit
   if (xfitmaxW=0) and (xfitmaxH=0) then
      begin
      ddw:=frcmin(misw(d),1);
      ddh:=frcmin(mish(d),1);
      end
   //.scale fit
   else if (xfitmaxW>=1) and (xfitmaxH>=1) then
      begin
      low__scaledown(xfitmaxW,xfitmaxH,aw,ah,ddw,ddh);
      end
   //.fixed width and variable height
   else if (xfitmaxW>=1) and (xfitmaxH=0) then
      begin
      ddw:=xfitmaxW;
      ddh:=frcmin(round((xfitmaxW/frcmin(aw,1))*ah),1);
      end
   //.fixed height and variable width
   else if (xfitmaxH>=1) and (xfitmaxW=0) then
      begin
      ddh:=xfitmaxH;
      ddw:=frcmin(round((xfitmaxH/frcmin(ah,1))*aw),1);
      end;
   end;
//set
if (ddw<=0) or (ddh<=0) then goto skipend;
if ((ddw<>misw(d)) or (ddh<>mish(d))) and (not d.sizeto(ddw,ddh)) then goto skipend;
if not miscopyareaxx(rect(0,0,maxint,maxint),0,0,ddw,ddh,rect(0,0,aw-1,ah-1),d,a,255,0,clnone,0) then goto skipend;
//Note: Any change in cellwidth/cellheight has to be modified
if mishasai(a) and mishasai(d) and (not misaicopy(a,d)) then goto skipend;
//successful
result:=true;
skipend:
except;end;
try;freeobj(@a);except;end;
end;
//## low__cancopyimg ##
function low__cancopyimg:boolean;//12apr2021
begin
try;result:=true;except;end;
end;
//## low__copyimg ##
function low__copyimg(d:tobject;xoptions:currency):boolean;//12apr2021
begin
try;result:=low__copyimg2(d,0,0,xoptions,false,false,clnone,-1,false);except;end;
end;
//## low__copyimg2 ##
function low__copyimg2(d:tobject;ddw,ddh:longint;xoptions:currency;xmirror,xflip:boolean;xtransparentcolor,xfeather:longint;xtransframe:boolean):boolean;//18jun2021, 07jun2021, 02jun2021
label//To copy a 32bit image as is use "feather=-1" - 18jun2021
   skipend;
var
   a:tbmp;
   xalpha:tbasicimage;
   xouttranscol,xtc,dbits,dw,dh:longint;
   e:string;
begin
try
//defaults
result:=false;
a:=nil;
xalpha:=nil;
//check
if (not low__cancopyimg) or (not misok82432(d,dbits,dw,dh)) then exit;
//init
if (ddw>=1) then dw:=ddw;
if (ddh>=1) then dh:=ddh;
xtc:=clnone;
if (xtransparentcolor<>clnone) then xtc:=mistranscol(d,xtransparentcolor,true);
//get
a:=misbmp32(1,1);
if not missize(a,dw,dh) then goto skipend;
if not misaicopy(d,a) then goto skipend;
//.lock
a.lock;
//.cls -> Note: CLS and DRAW.TRANS required to CUT the image out properly so ALPHA maker and function correctly - 07jun2021
if (xtc<>clnone) then miscls(a,xtc);
//.draw
if not miscopyareaxx(rect(0,0,maxint,maxint),0,0,a.width*low__aorb(1,-1,xmirror),a.height*low__aorb(1,-1,xflip),misarea(d),a,d,255,low__aorb(0,1,xtc<>clnone),xtc,xoptions) then goto skipend;
//.magic feather -> xtransframe -> draw 1px frame at outer edge of image using "transparentcolor" so feather can penetrate from the edge even if the image has NOT been
//                                 cropped to do so -> fixes the "STAR" problem with the tips of a croppped image touching it's outer edge there is nothing for the
//                                 feather system to work in from with

//.alpha - supports feather and transparent color - 07jun2021
if (misb(a)=32) then
   begin
   //.make alpha
   xalpha:=misimg8(misw(a),mish(a));
   if not mask__feather2(a,xalpha,xfeather,xtc,xtransframe,xouttranscol) then goto skipend;
   //.write alpha
   if not mask__copy(a,xalpha) then goto skipend;
   end;

//.unlock
a.unlock;
//.copy
clipboard.assign(a.core);
//successful
result:=true;
skipend:
except;end;
try
freeobj(@a);
freeobj(@xalpha);
except;end;
end;
//## low__copyimgto ##
function low__copyimgto(s,d:tbasicimage;xoptions:currency):boolean;//18jun2021
var
   int1:longint;
begin
try;result:=low__copyimgto2(s,d,0,0,xoptions,false,false,clnone,-1,false,int1);except;end;
end;
//## low__copyimgto2 ##
function low__copyimgto2(s,d:tbasicimage;ddw,ddh:longint;xoptions:currency;xmirror,xflip:boolean;xtransparentcolor,xfeather:longint;xtransframe:boolean;var dtranscol:longint):boolean;//07jun2021, 02jun2021
label
   skipend;
var
   xalpha:tbasicimage;
   int1,xtc,dbits,sbits,dw,dh,sw,sh:longint;
   e:string;
begin
try
//defaults
result:=false;
dtranscol:=clnone;
xalpha:=nil;
//check
if not misok82432(s,sbits,sw,sh) then exit;
if not misok82432(d,dbits,dw,dh) then exit;
//init
if (ddw>=1) then dw:=ddw;
if (ddh>=1) then dh:=ddh;
xtc:=clnone;
if (xtransparentcolor<>clnone) then xtc:=mistranscol(s,xtransparentcolor,true);
dtranscol:=xtc;
//get
if not missize(d,dw,dh) then goto skipend;
if not misaicopy(d,s) then goto skipend;
//.cls -> Note: CLS and DRAW.TRANS required to CUT the image out properly so ALPHA maker and function correctly - 07jun2021
if (xtc<>clnone) then miscls(d,xtc);
//.draw
if not miscopyareaxx(rect(0,0,maxint,maxint),0,0,d.width*low__aorb(1,-1,xmirror),d.height*low__aorb(1,-1,xflip),misarea(s),d,s,255,low__aorb(0,1,xtc<>clnone),xtc,xoptions) then goto skipend;
//.alpha - supports feather and transparent color - 07jun2021
if (misb(d)=32) then
   begin
   //.make alpha
   xalpha:=misimg8(misw(d),mish(d));
   if not mask__feather2(d,xalpha,xfeather,xtc,xtransframe,int1) then goto skipend;
   //.write alpha
   if not mask__copy(d,xalpha) then goto skipend;
   end;
//successful
result:=true;
skipend:
except;end;
try;freeobj(@xalpha);except;end;
end;


//error messages ---------------------------------------------------------------
//## gec__taskfailed ##
function gec__taskfailed(var e:string):boolean;//pass-thru support
begin
try;result:=true;e:=gecTaskfailed;except;end;
end;

//tep handling -----------------------------------------------------------------
//## tep__tick ##
function tep__tick(x:boolean):longint;
begin
try;if x then result:=tepTick20 else result:=tepUntick20;except;end;
end;
//## tep__tick2 ##
function tep__tick2(x:boolean):longint;
begin
try;if x then result:=tepTicktwo20 else result:=tepUnticktwo20;except;end;
end;
//## tep__tick3 ##
function tep__tick3(x:boolean):longint;
begin
try;if x then result:=tepTickthree20 else result:=tepUntickthree20;except;end;
end;
//## tep__yes ##
function tep__yes(x:boolean):longint;
begin
try;if x then result:=tepYes20 else result:=tepYesBLANK20;except;end;
end;


//-- "mm" multimedia support ---------------------------------------------------
{$ifdef mm}
//## mm_init ##
procedure mm_init;
label
   skipend;
var
   p:longint;
begin
try
//check
if (mmsys_mode=2) then exit//already inited
else if (mmsys_mode<>0) then exit;//not free -> error
//get
mmsys_mode:=1;//initing
try
//.midi
for p:=0 to high(mmsys_mid_deviceok) do//13may2021
begin
mmsys_mid_deviceok[p]:=false;
mmsys_mid_devicename[p]:='';
end;//p
//.wave
for p:=0 to high(mmsys_wav_deviceok) do//05mar2022
begin
mmsys_wav_deviceok[p]:=false;
mmsys_wav_devicename[p]:='';
end;//p
except;end;

//was: fasttimer__start;//07oct2021

//done
mmsys_mode:=2;//inited
except;end;
end;
//## mm_shut ##
procedure mm_shut;
begin
try
//check
if (mmsys_mode>=3) then exit//already shuting or shut
else if (mmsys_mode<>2) then exit;//not inited -> error

//get
mmsys_mode:=3;//shuting
try
//.internal MIDI shutdown
freeobj(@mmsys_midi);
//.internal CHIMES shutdown
freeobj(@mmsys_chimes);
//.internal WAVE shutdown
freeobj(@mmsys_wave);//17jul2021
//.internal MCI shutdown
freeobj(@mmsys_mm);
except;end;

//done
mmsys_mode:=4;//shut
except;end;
end;
//## mm_ok ##
function mm_ok:boolean;
begin
try;result:=true;except;end;
end;
//## mm_inited ##
function mm_inited:boolean;
begin
try;result:=(mmsys_mode=2);except;end;
end;
//## mm_playmanagement_init ##
function mm_playmanagement_init(var xmuststop,xmustplay,xplaying:boolean;var xmustpertpos:double;var xmustpos,xlastpos:longint;var xlastfilename:string):boolean;
begin
try
result:=true;//pass-thru
xmuststop:=false;
xmustplay:=false;
xplaying:=false;
xmustpertpos:=-1;//off
xmustpos:=-1;//off
xlastpos:=0;
xlastfilename:='';
except;end;
end;
//## mm_playmanagement ##
function mm_playmanagement(xstyle:string;xmode,xintroms:longint;var xmuststop,xmustplay,xplaying,xhostupdate:boolean;var xmustpertpos:double;var xmustpos,xlastpos:longint;var xlastfilename:string;xnav:tbasicnav;xplaylist:tbasicmenu;xplaylistmask:string;xjump:tbasicjump):boolean;
label
   skipend;
var
   xcanplayfile,xselectidle:boolean;
   dstyle,xpos,xlen:longint;
   //## xcanplay ##
   function xcanplay:boolean;
   begin
   if (dstyle=1) then result:=mid_canplaymidi else result:=mm_canplay;
   end;
   //## m_len ##
   function m_len:longint;
   begin
   if (dstyle=1) then result:=mid_len else result:=mm_len;
   end;
   //## m_canpertpos ##
   function m_canpertpos:boolean;//06mar2022
   begin
   if (dstyle=1) then result:=mid_canpertpos else result:=mm_canpertpos;
   end;
   //## m_pos ##
   function m_pos:longint;
   begin
   if (dstyle=1) then result:=mid_pos else result:=mm_pos;
   end;
   //## m_setpos ##
   procedure m_setpos(x:longint);
   begin
   if (dstyle=1) then mid_setpos(x) else mm_setpos(x);
   end;
   //## m_setpertpos ##
   procedure m_setpertpos(x:double);
   begin
   if (dstyle=1) then mid_setpertpos(x) else mm_setpertpos(x);
   end;
   //## m_seeking ##
   function m_seeking:boolean;
   begin
   if (dstyle=1) then result:=mid_seeking else result:=mm_seeking;
   end;
   //## m_playing ##
   function m_playing:boolean;
   begin
   if (dstyle=1) then result:=mid_playing else result:=mm_playing;
   end;
   //## m_playfile ##
   function m_playfile(x:string):boolean;
   begin
   if (dstyle=1) then result:=mid_playfile(x) else result:=mm_playfile(x);
   end;
   //## m_stop ##
   procedure m_stop;
   begin
   if (dstyle=1) then mid_stop else mm_stop;
   end;
   //## xnavvalue ##
   function xnavvalue:string;
   begin
   result:='';
   if (xnav<>nil) then result:=xnav.value else if (xplaylist<>nil) then result:=xplaylist.xgetval2(xplaylist.itemindex);
   end;
   //## xidletime ##
   function xidletime:comp;
   begin
   result:=0;
   if (xnav<>nil) then result:=xnav.idletime else if (xplaylist<>nil) then result:=xplaylist.idletime;
   end;
   //## xnavlist ##
   function xnavlist:tbasicmenu;
   begin
   result:=nil;
   if (xnav<>nil) then result:=xnav.xlist else if (xplaylist<>nil) then result:=xplaylist;
   end;
   //## xnavmask ##
   function xnavmask:string;
   begin
   result:='';
   if (xnav<>nil) then result:=xnav.omasklist else if (xplaylist<>nil) then result:=xplaylistmask;
   end;
begin
try
//defaults
result:=true;//pass-thru
xhostupdate:=false;

//required
if (xnav=nil) and (xplaylist=nil) then exit;

//style
xstyle:=low__lowercase(xstyle);
if (xstyle='mid') then dstyle:=1 //mid
else                   dstyle:=0;//mm

//check
if (not xcanplay) or m_seeking then exit;

//range
xintroms:=frcmin(xintroms,0);
//init

xlen:=frcrange(m_len,0,low__aorb(maxint,xintroms,xintroms>0));
xpos:=frcrange(m_pos,0,xlen);
xmode:=frcrange(xmode,0,mmMax);//playback mode (once, repeat all, random etc)
xcanplayfile:=low__matchmaskb(xnavvalue,xnavmask);
xselectidle:=(xidletime>=2000) and (not xmustplay);//list idleness detector - 21feb2022

//file - manual list
if xplaying and (not low__comparetext(xlastfilename,xnavvalue)) then xmustplay:=true;

//stop - takes priority over play - 21feb2022
if xmuststop then
   begin
   xlastpos:=m_pos;
   xplaying:=false;
   xmustplay:=false;
   xmuststop:=false;
   xmustpos:=-1;//off
   xmustpertpos:=-1;//off
   if m_playing then m_stop;
   goto skipend;
   end;

//play
if xmustplay then
   begin
   if (not xplaying) and (xmustpos<0) and (xmustpertpos<0) then xmustpos:=xlastpos;
   xplaying:=true;
   xmustplay:=false;
   xmuststop:=false;
   if m_playing then m_stop;
   if low__setstr(xlastfilename,xnavvalue) then
      begin
      if not m_canpertpos then xmustpertpos:=-1;//reset if system DOES NOT support pert pos - 06mar2022
      xmustpos:=-1;
      end;
   m_playfile(xlastfilename);
   if (xmustpertpos>=0) then m_setpertpos(xmustpertpos) else m_setpos(xmustpos);
   if (xjump<>nil) then xjump.setparams(m_pos,m_len);//update immediately - 20feb2022
   xmustpos:=-1;//off
   xmustpertpos:=-1;//off
   xhostupdate:=true;//now playing -> host should update any information panels etc - 22feb2022
   goto skipend;
   end;

//pos
if (xmustpos>=0) or (xmustpertpos>=0) then
   begin
   case xplaying of
   true:begin
      if (xmustpertpos>=0) then m_setpertpos(xmustpertpos) else m_setpos(xmustpos);
      xmustpertpos:=-1;
      xmustpos:=-1;
      end;
   false:xmustplay:=true;
   end;
   goto skipend;
   end;

//repeat
if xplaying and (m_pos>=xlen) then
   begin
   //get
   case xmode of
   mmOnce:begin
      xmuststop:=true;
      goto skipend;
      end;
   mmRepeatOne:begin
      xmustpos:=0;
      goto skipend;
      end;
   mmRepeatAll:;//do below
   mmAllOnce  :;//do below
   mmRandom:begin
      if xselectidle then
         begin
         xnavlist.itemindex:=random(xnavlist.count);
         xmustplay:=true;
         end;
      end;
   else goto skipend;
   end;//case
   //set
   if xselectidle then
      begin
      if (xnavlist.itemindex>=(xnavlist.count-1)) then
         begin
         case xmode of
         mmRepeatAll:begin
            xnavlist.itemindex:=0;
            xmustplay:=true;
            end;
         mmAllOnce:xmuststop:=true;
         end;//case
         end
      else
         begin
         xnavlist.itemindex:=xnavlist.itemindex+1;
         xmustplay:=true;
         end;
      end;
   goto skipend;
   end;

skipend:
//jump sync
if (xjump<>nil) then xjump.setparams(m_pos,m_len);//update immediately - 20feb2022
except;end;
end;


//.wave support ----------------------------------------------------------------
//## wav_ok ##
function wav_ok:boolean;
begin
try;result:=true;except;end;
end;
//## wav_vol ##
function wav_vol:longint;
var
   a:tint4;
   int1,v:longint;
   woc:twaveoutcaps;
   ok:boolean;
begin
try
//defaults
result:=0;
ok:=false;
v:=maxword;
a.val:=0;
//check
if not mm_inited then exit;

//wave
if (waveoutgetdevcaps(wave_mapper,@woc,sizeof(woc))=MMSYSERR_NOERROR) and ((woc.dwSupport and WAVECAPS_VOLUME)=WAVECAPS_VOLUME) then
   begin
   ok:=true;
   waveOutGetVolume(wave_mapper,@int1);
   a.val:=int1;
   if ((woc.dwSupport and WAVECAPS_LRVOLUME)=WAVECAPS_LRVOLUME) then
      begin//stereo
      if (a.wrds[0]<v) then v:=a.wrds[0];//left
      if (a.wrds[1]<v) then v:=a.wrds[1];//right
      end
   else
      begin//mono -> one ch has volume other is zero
      v:=a.wrds[0]+a.wrds[1];
      end;
   end;

//set
if ok then result:=frcrange(round((100*v)/maxword),0,100);//0..100%
except;end;
end;
//## wav_setvol ##
function wav_setvol(x:longint):boolean;
var
   a:tint4;
   woc:twaveoutcaps;
begin
try
result:=mm_inited;
//check
if not result then exit;

//range
a.wrds[0]:=frcrange(frcrange(x,0,100)*round(maxword/100),0,maxword);//left
a.wrds[1]:=a.wrds[0];//right

//wave - required since we READ the volume from wave - 23mar2022
if (waveoutgetdevcaps(wave_mapper,@woc,sizeof(woc))=MMSYSERR_NOERROR) and ((woc.dwSupport and WAVECAPS_VOLUME)=WAVECAPS_VOLUME) then waveOutSetVolume(wave_mapper,a.val);
except;end;
end;
//## wav_devicelist ##
procedure wav_devicelist;
var
   moc:twaveoutcaps;
   v,c,p:longint;
   //## xnamestr ##
   function xnamestr:string;//13may2021
   var
      p:longint;
      str1:string;
   begin
   try
   //defaults
   result:='';
   //get
   setlength(str1,sizeof(moc.szPname));
   if (str1<>'') then
      begin
      for p:=1 to length(str1) do
      begin
      v:=frcrange(ord(moc.szPname[p-1]),0,255);
      if (v=0) then
         begin
         setlength(str1,p-1);
         break;
         end
      else str1[p-1+stroffset]:=char(byte(v));
      end;//p
      //set
      result:=str1;
      end;
   except;end;
   end;
begin
try
if (mmsys_wav_devicetime=0) or (ms64>=mmsys_wav_devicetime) then
   begin
   //reset
   mmsys_wav_devicetime:=ms64+10000;//check every max 10secs - 18apr2021
   //get -> Note: 0=wave-mapper, 1..N = Device #0..(N-1)
   c:=0;
   try
   for p:=0 to high(mmsys_wav_deviceok) do
   begin
   if (p<=0) then
      begin
      mmsys_wav_deviceok[p]:=true;
      mmsys_wav_devicename[p]:='Wave Mapper';
      end
   else
      begin
      mmsys_wav_deviceok[p]:=(waveoutgetdevcaps(p-1,@moc,sizeof(moc))=MMSYSERR_NOERROR);
      if mmsys_wav_deviceok[p] then mmsys_wav_devicename[p]:=xnamestr else mmsys_wav_devicename[p]:='';
      end;
   //.count
   if mmsys_wav_deviceok[p] then c:=p+1;
   end;//p
   except;end;
   //set
   mmsys_wav_devicecount:=c;
   end;
except;end;
end;
//## wav_deviceindex ##
function wav_deviceindex:longint;
begin//not operational yet
try;result:=0;except;end;
end;
//## wav_setdeviceindex ##
function wav_setdeviceindex(x:longint):boolean;
begin//Not operational yet
try;result:=false;except;end;
end;
//## wav_devicelimit ##
function wav_devicelimit:longint;
begin
try;result:=0;if mm_inited then result:=high(mmsys_wav_deviceok)+1;except;end;
end;
//## wav_devicecount ##
function wav_devicecount:longint;//exclude wave mapper
begin
try
result:=0;
if mm_inited then
   begin
   wav_devicelist;
   result:=mmsys_wav_devicecount;
   end;
except;end;
end;
//## wav_deviceok ##
function wav_deviceok(xindex:longint):boolean;
begin
try
result:=false;
if mm_inited then wav_devicelist;result:=(xindex>=0) and (xindex<=high(mmsys_wav_deviceok)) and mmsys_wav_deviceok[xindex];
except;end;
end;
//## wav_devicename ##
function wav_devicename(xindex:longint;xdefval:string):string;
begin
try
result:='';
if mm_inited then
   begin
   wav_devicelist;
   if (xindex>=0) and (xindex<=high(mmsys_wav_deviceok)) then result:=mmsys_wav_devicename[xindex];
   result:=low__udv(result,xdefval);
   end;
except;end;
end;
//## wav_flush44 ##
function wav_flush44:boolean;
begin
try;result:=mm_inited;if result then mm_wave.pflush;;except;end;
end;
//## wav_push44 ##
function wav_push44(x:tstr8):boolean;
begin
try
result:=mm_inited;
if result then
   begin
   mm_wave.format:='44100 16 1';//xxxxxxxxxxxx
   result:=mm_wave.push(x);
   end;
except;end;
end;
//## wav_len44 ##
function wav_len44:longint;
begin
try;result:=0;if mm_inited then result:=mm_wave.pushlen;except;end;
end;

//.midi support ----------------------------------------------------------------
//## mid_ok ##
function mid_ok:boolean;
begin
try;result:=true;except;end;
end;
//## mid_devicelist ##
procedure mid_devicelist;
var
   moc:tmidioutcaps;
   v,c,p:longint;
   //## xnamestr ##
   function xnamestr:string;//13may2021
   var
      p:longint;
      str1:string;
   begin
   try
   //defaults
   result:='';
   //get
   setlength(str1,sizeof(moc.szPname));
   if (str1<>'') then
      begin
      for p:=1 to length(str1) do
      begin
      v:=frcrange(ord(moc.szPname[p-1]),0,255);
      if (v=0) then
         begin
         setlength(str1,p-1);
         break;
         end
      else str1[p-1+stroffset]:=char(byte(v));
      end;//p
      //set
      result:=str1;
      end;
   except;end;
   end;
begin
try
if (mmsys_mid_devicetime=0) or (ms64>=mmsys_mid_devicetime) then
   begin
   //reset
   mmsys_mid_devicetime:=ms64+10000;//check every max 10secs - 18apr2021
   //get -> Note: 0=midi-mapper, 1..N = Device #0..(N-1)
   c:=0;
   try
   for p:=0 to high(mmsys_mid_deviceok) do
   begin
   if (p<=0) then
      begin
      mmsys_mid_deviceok[p]:=true;
      mmsys_mid_devicename[p]:='Midi Mapper';
      end
   else
      begin
      mmsys_mid_deviceok[p]:=(midioutgetdevcaps(p-1,@moc,sizeof(moc))=MMSYSERR_NOERROR);
      if mmsys_mid_deviceok[p] then mmsys_mid_devicename[p]:=xnamestr else mmsys_mid_devicename[p]:='';
      end;
   //.count
   if mmsys_mid_deviceok[p] then c:=p+1;
   end;//p
   except;end;
   //set
   mmsys_mid_devicecount:=c;
   end;
except;end;
end;
//## mid_canstop ##
function mid_canstop:boolean;
begin
try;result:=mm_inited and mm_midi.canstop;except;end;
end;
//## mid_stop ##
procedure mid_stop;
begin
try;if mm_inited then mm_midi.stop;except;end;
end;
//## mid_canplay ##
function mid_canplay:boolean;
begin
try;result:=mm_inited and mm_midi.canplay;except;end;
end;
//## mid_play ##
procedure mid_play;
begin
try;if mm_inited then mm_midi.play;except;end;
end;
//## mid_canplaymidi ##
function mid_canplaymidi:boolean;
begin
try;result:=mm_inited and mm_midi.canplaymidi;except;end;
end;
//## mid_playmidi ##
function mid_playmidi(xmiddata:tstr8):boolean;
begin
try;result:=false;if mm_inited then result:=mm_midi.playdata(xmiddata) else bautofree(xmiddata);except;end;
end;
//## mid_playfile ##
function mid_playfile(xfilename:string):boolean;
begin
try;result:=mm_inited and mm_midi.playfile(xfilename);except;end;
end;
//## mid_speed ##
function mid_speed:longint;
begin
try;result:=0;if mm_inited then result:=mm_midi.speed;except;end;
end;
//## mid_speed2 ##
function mid_speed2:longint;
begin
try;result:=0;if mm_inited then result:=mm_midi.speed2;except;end;
end;
//## mid_setspeed ##
function mid_setspeed(x:longint):boolean;
begin
try;result:=mm_inited;if result then mm_midi.speed:=x;except;end;
end;
//## mid_setspeed2 ##
function mid_setspeed2(x:longint):boolean;
begin
try;result:=mm_inited;if result then mm_midi.speed2:=x;except;end;
end;
//## mid_style ##
function mid_style:longint;
begin
try;result:=0;if mm_inited then result:=mm_midi.style;except;end;
end;
//## mid_setstyle ##
function mid_setstyle(x:longint):boolean;
begin
try;result:=mm_inited;if result then mm_midi.style:=x;except;end;
end;
//## mid_deviceindex ##
function mid_deviceindex:longint;
begin
try;result:=0;if mm_inited then result:=mm_midi.deviceindex;except;end;
end;
//## mid_setdeviceindex ##
function mid_setdeviceindex(x:longint):boolean;
begin
try;result:=mm_inited;if result then mm_midi.deviceindex:=x;except;end;
end;
//## mid_devicelimit ##
function mid_devicelimit:longint;
begin
try;result:=0;if mm_inited then result:=high(mmsys_mid_deviceok)+1;except;end;
end;
//## mid_devicecount ##
function mid_devicecount:longint;//exclude midi mapper
begin
try
result:=0;
if mm_inited then
   begin
   mid_devicelist;
   result:=mmsys_mid_devicecount;
   end;
except;end;
end;
//## mid_deviceok ##
function mid_deviceok(xindex:longint):boolean;
begin
try
result:=false;
if mm_inited then mid_devicelist;result:=(xindex>=0) and (xindex<=high(mmsys_mid_deviceok)) and mmsys_mid_deviceok[xindex];
except;end;
end;
//## mid_devicename ##
function mid_devicename(xindex:longint;xdefval:string):string;
begin
try
result:='';
if mm_inited then
   begin
   mid_devicelist;
   if (xindex>=0) and (xindex<=high(mmsys_mid_deviceok)) then result:=mmsys_mid_devicename[xindex];
   result:=low__udv(result,xdefval);
   end;
except;end;
end;
//## mid_seeking ##
function mid_seeking:boolean;
begin
try;result:=mm_inited and mm_midi.seeking;except;end;
end;
//## mid_vol ##
function mid_vol:longint;
var//Note: Returns the lowest volume value from WAVE only, as under Win10 MIDI_MAPPER levels aren't adjusted by Volume Mixer whereas WAVE_MAPPER are - 30mar2021
   int1,v:longint;
   a:tint4;
   woc:twaveoutcaps;
   moc:tmidioutcaps;
   ok:boolean;
begin
try
//defaults
result:=0;
ok:=false;
v:=maxword;
a.val:=0;
//check
if not mm_inited then exit;

//wave
if (waveoutgetdevcaps(wave_mapper,@woc,sizeof(woc))=MMSYSERR_NOERROR) and ((woc.dwSupport and WAVECAPS_VOLUME)=WAVECAPS_VOLUME) then
   begin
   ok:=true;
   waveOutGetVolume(wave_mapper,@int1);
   a.val:=int1;
   if ((woc.dwSupport and WAVECAPS_LRVOLUME)=WAVECAPS_LRVOLUME) then
      begin//stereo
      if (a.wrds[0]<v) then v:=a.wrds[0];//left
      if (a.wrds[1]<v) then v:=a.wrds[1];//right
      end
   else
      begin//mono -> one ch has volume other is zero
      v:=a.wrds[0]+a.wrds[1];
      end;
   end;

//midi
//Note: Can't use MIDI volume levels as a guide to system volume level as Win10 doesn't set them via Volume Mixer when the slider is shifted (midi can use multi-output cards) - 31mar2021
//      Do not use as of yet.
{
if (midioutgetdevcaps(midi_mapper,@moc,sizeof(moc))=MMSYSERR_NOERROR) and ((moc.dwSupport and MIDICAPS_VOLUME)=MIDICAPS_VOLUME) then
   begin
   ok:=true;
   midiOutGetVolume(midi_mapper,@int1);
   a.val:=int1;
   if ((woc.dwSupport and MIDICAPS_LRVOLUME)=MIDICAPS_LRVOLUME) then
      begin//stereo
      if (a.wrds[0]<v) then v:=a.wrds[0];//left
      if (a.wrds[1]<v) then v:=a.wrds[1];//right
      end
   else
      begin//mono -> one ch has volume other is zero
      v:=a.wrds[0]+a.wrds[1];
      end;
   end;
{}

//set
if ok then result:=frcrange(round((100*v)/maxword),0,100);//0..100%

//extended range -> uses feedback to work WITH Microsoft Windows Volume Mixer and other Midi Drivers - 23mar2022
case viwine of
true:result:=mmsys_mid_basevol;//linux -> no separate midi/wave volume handler -> so we do it all - 23mar2022
//was: false:if (result>=100) then result:=100+frcrange(mmsys_mid_basevol-100,0,100) else mmsys_mid_basevol:=100;//windows
false:if (result>=100) then result:=100+frcrange(mmsys_mid_basevol-100,0,100) else mmsys_mid_basevol:=result;//windows
end;//case
except;end;
end;
//## mid_vol1 ##
function mid_vol1:longint;//modifies volume of notes
begin
try;result:=100;if mm_inited then result:=mm_midi.vol;except;end;
end;
//## mid_vol2 ##
function mid_vol2:longint;//modifies volume of notes
begin
try;result:=100;if mm_inited then result:=mm_midi.vol2;except;end;
end;
//## mid_setvol ##
function mid_setvol(x:longint):boolean;
var
   a:tint4;
   woc:twaveoutcaps;
   moc:tmidioutcaps;
   v,int1:longint;
begin
try
result:=mm_inited;
//check
if not result then exit;
//range
case viwine of
true :mmsys_mid_basevol:=frcrange(x,  0,200);//linux
//false:mmsys_mid_basevol:=frcrange(x,100,200);//windows
false:mmsys_mid_basevol:=frcrange(x,  0,200);//linux
end;

a.wrds[0]:=frcrange(frcrange(x,0,100)*round(maxword/100),0,maxword);//left
a.wrds[1]:=a.wrds[0];//right

//wave - required since we READ the volume from wave - 23mar2022
if (waveoutgetdevcaps(wave_mapper,@woc,sizeof(woc))=MMSYSERR_NOERROR) and ((woc.dwSupport and WAVECAPS_VOLUME)=WAVECAPS_VOLUME) then waveOutSetVolume(wave_mapper,a.val);

//midi
int1:=mid_deviceindex-1;
if (midioutgetdevcaps(int1,@moc,sizeof(moc))=MMSYSERR_NOERROR) and ((moc.dwSupport and MIDICAPS_VOLUME)=MIDICAPS_VOLUME) then midiOutSetVolume(int1,a.val);
except;end;
end;
//## mid_setvol1 ##
function mid_setvol1(x:longint):boolean;//modifies volume of notes
begin
try;result:=mm_inited;if result then mm_midi.vol:=x;except;end;
end;
//## mid_setvol2 ##
function mid_setvol2(x:longint):boolean;//modifies volume of notes
begin
try;result:=mm_inited;if result then mm_midi.vol2:=x;except;end;
end;
//## mid_canpertpos ##
function mid_canpertpos:boolean;//true=system supports percentage positioning, else not - 06mar2022
begin
result:=true;
end;
//## mid_pos ##
function mid_pos:longint;
begin
try;result:=0;if mm_inited then result:=mm_midi.pos;except;end;
end;
//## mid_pertpos ##
function mid_pertpos:double;
begin
try;result:=0;if mm_inited then result:=low__makepertD0(mm_midi.pos,mm_midi.len);except;end;
end;
//## mid_setpos ##
function mid_setpos(x:longint):boolean;
begin
try;result:=mm_inited;if result then mm_midi.pos:=x;except;end;
end;
//## mid_setpertpos ##
function mid_setpertpos(x:double):boolean;
begin
try;result:=mm_inited;if result then mm_midi.pertpos:=x;except;end;
end;
//## mid_len ##
function mid_len:longint;
begin
try;result:=0;if mm_inited then result:=mm_midi.len;except;end;
end;
//## mid_lyriccount ##
function mid_lyriccount:longint;
begin
try;result:=0;if mm_inited then result:=mm_midi.lcount;except;end;
end;
//## mid_pos ##
function mid_lyric(xpos:longint;xshowsep:boolean):string;
begin
try;result:='';if mm_inited then result:=mm_midi.lfind(xpos,xshowsep);except;end;
end;
//## mid_format ##
function mid_format:longint;
begin
try;result:=0;if mm_inited then result:=mm_midi.format;except;end;
end;
//## mid_tracks ##
function mid_tracks:longint;
begin
try;result:=0;if mm_inited then result:=mm_midi.tracks;except;end;
end;
//## mid_msgs ##
function mid_msgs:longint;//total number of messages in midi
begin
try;result:=0;if mm_inited then result:=mm_midi.msgs;except;end;
end;
//## mid_msgssent ##
function mid_msgssent:longint;//number of message sent to midi hardware
begin
try;result:=0;if mm_inited then result:=mm_midi.msgssent;except;end;
end;
//## mid_lag ##
function mid_lag:longint;
begin
try;result:=0;if mm_inited then result:=restrict32(mm_midi.lag);except;end;
end;
//## mid_bytes ##
function mid_bytes:longint;//memory in use in bytes
begin
try;result:=0;if mm_inited then result:=mm_midi.bytes;except;end;
end;
//## mid_midbytes ##
function mid_midbytes:longint;//size of midi in bytes
begin
try;result:=0;if mm_inited then result:=mm_midi.midbytes;except;end;
end;
//## mid_phandle ##
function mid_phandle:longint;//handle of midi device
begin
try;result:=0;if mm_inited then result:=mm_midi.handle;except;end;
end;
//## mid_deviceactive ##
function mid_deviceactive:boolean;//have access to midi device - 15apr2021
begin
try;result:=mm_inited and (mm_midi.handle<>0);except;end;
end;
//## mid_usingtimer ##
function mid_usingtimer:boolean;
begin
try;result:=mm_inited and mm_midi.usingtimer;except;end;
end;
//## mid_playing ##
function mid_playing:boolean;
begin
try;result:=mm_inited and mm_midi.playing;except;end;
end;
//## mid_keepopen ##
function mid_keepopen:boolean;
begin
try;result:=mm_inited and mm_midi.keepopen;except;end;
end;
//## mid_setkeepopen ##
function mid_setkeepopen(x:boolean):boolean;
begin
try;result:=mm_inited;if result then mm_midi.keepopen:=x;except;end;
end;
//## mid_loop ##
function mid_loop:boolean;
begin
try;result:=mm_inited and mm_midi.loop;except;end;
end;
//## mid_setloop ##
function mid_setloop(x:boolean):boolean;
begin
try;result:=mm_inited;if result then mm_midi.loop:=x;except;end;
end;

//.chimes support --------------------------------------------------------------
//## chm_ok ##
function chm_ok:boolean;
begin
try;result:=true;except;end;
end;
//## chm_count ##
function chm_count:longint;
begin
try;result:=0;if mm_inited then result:=mm_chimes.count;except;end;
end;
//## chm_numberfrom1 ##
function chm_numberfrom1:longint;
begin
try;result:=0;if mm_inited then result:=mm_chimes.numberfrom1;except;end;
end;
//## chm_numberfrom2 ##
function chm_numberfrom2:longint;
begin
try;result:=0;if mm_inited then result:=mm_chimes.numberfrom2;except;end;
end;
//## chm_numberfrom3 ##
function chm_numberfrom3:longint;
begin
try;result:=0;if mm_inited then result:=mm_chimes.numberfrom3;except;end;
end;
//## chm_name ##
function chm_name(xindex:longint):string;
var
   xintro,xdong,xdong2:tstr8;
   int1,int2:longint;
begin
try;result:='';if mm_inited then chm_info(xindex,result,int1,int2,xintro,xdong,xdong2);except;end;
end;
//## chm_canintro ##
function chm_canintro(xindex:longint):boolean;
var
   xname:string;
   xintro,xdong,xdong2:tstr8;
   int1,int2:longint;
begin
try;result:=false;if mm_inited then result:=chm_info(xindex,xname,int1,int2,xintro,xdong,xdong2) and (xintro<>nil) and (xintro.len>=2);except;end;
end;
//## chm_candong ##
function chm_candong(xindex:longint):boolean;
var
   xname:string;
   xintro,xdong,xdong2:tstr8;
   int1,int2:longint;
begin
try;result:=false;if mm_inited then result:=chm_info(xindex,xname,int1,int2,xintro,xdong,xdong2) and (xdong<>nil) and (xdong.len>=2);except;end;
end;
//## chm_candong2 ##
function chm_candong2(xindex:longint):boolean;
var
   xname:string;
   xintro,xdong,xdong2:tstr8;
   int1,int2:longint;
begin
try;result:=false;if mm_inited then result:=chm_info(xindex,xname,int1,int2,xintro,xdong,xdong2) and (xdong2<>nil) and (xdong2.len>=2);except;end;
end;
//## chm_canstop ##
function chm_canstop:boolean;
begin
try;result:=false;if mm_inited then result:=mm_chimes.canstop;except;end;
end;
//## chm_stop ##
procedure chm_stop;
begin
try;if mm_inited then mm_chimes.stop;except;end;
end;
//## chm_mustplayname ##
function chm_mustplayname(xname:string;xmins:longint):boolean;
begin
try;result:=false;if mm_inited then result:=mm_chimes.mustplayname(xname,xmins);except;end;
end;
//## chm_mustplayindex ##
function chm_mustplayindex(xindex,xmins:longint):boolean;
begin
try;result:=false;if mm_inited then result:=mm_chimes.mustplayindex(xindex,xmins);except;end;
end;
//## chm_canplay ##
function chm_canplay:boolean;
begin
try;result:=false;if mm_inited then result:=mm_chimes.canplay;except;end;
end;
//## chm_playname ##
procedure chm_playname(xname:string;xmins:longint;x0,x15,x30,x45,xtest:boolean);
begin
try;if mm_inited then mm_chimes.playname(xname,xmins,x0,x15,x30,x45,xtest);except;end;
end;
//## chm_playname2 ##
procedure chm_playname2(xname:string);
begin
try;if mm_inited then mm_chimes.playname2(xname);except;end;
end;
//## chm_playname3 ##
procedure chm_playname3(xname:string;xmins:longint;n0,n15,n30,n45,b0,s0,s15,s30,s45,xtest:boolean);
begin
try;if mm_inited then mm_chimes.playname3(xname,xmins,n0,n15,n30,n45,b0,s0,s15,s30,s45,xtest);except;end;
end;
//## chm_playindex ##
procedure chm_playindex(xindex,xmins:longint;x0,x15,x30,x45,xtest:boolean);
begin
try;if mm_inited then mm_chimes.playindex(xindex,xmins,x0,x15,x30,x45,xtest);except;end;
end;
//## chm_playindex2 ##
procedure chm_playindex2(xindex:longint);
begin
try;if mm_inited then mm_chimes.playindex2(xindex);except;end;
end;
//## chm_chimingpert ##
function chm_chimingpert:double;
begin
try;result:=0;if mm_inited then result:=mm_chimes.chimingpert;except;end;
end;
//## chm_chiming ##
function chm_chiming:boolean;
begin
try;result:=false;if mm_inited then result:=mm_chimes.chiming;except;end;
end;
//## chm_playing ##
function chm_playing:boolean;
begin
try;result:=chm_chiming;except;end;
end;
//## chm_testing ##
function chm_testing:boolean;
begin
try;result:=false;if mm_inited then result:=mm_chimes.testing;except;end;
end;
//## chm_buzzercount ##
function chm_buzzercount:longint;
begin
try;result:=0;if mm_inited then result:=mm_chimes.buzzercount;except;end;
end;
//## chm_buzzer ##
function chm_buzzer:longint;
begin
try;result:=0;if mm_inited then result:=mm_chimes.buzzer;except;end;
end;
//## chm_setbuzzer ##
procedure chm_setbuzzer(x:longint);
begin
try;if mm_inited then mm_chimes.buzzer:=x;except;end;
end;
//## chm_buzzerlabel ##
function chm_buzzerlabel(x:longint):string;
begin
try;if mm_inited then result:=mm_chimes.findbuzzerlabel(x) else result:=inttostr(x);except;end;
end;
//## chm_vol ##
function chm_vol:longint;//chimes volume, not buzzer
begin
try;result:=0;if mm_inited then result:=mm_chimes.vol;except;end;
end;
//## chm_setvol ##
procedure chm_setvol(x:longint);//chimes volume, not buzzer
begin
try;if mm_inited then mm_chimes.vol:=x;except;end;
end;
//## chm_info ##
function chm_info(xindex:longint;var xname:string;var xstyle,xtep:longint;var xintro,xdong,xdong2:tstr8):boolean;
begin
try
//defaults
result  :=false;
xname   :='';
xintro  :=nil;
xdong   :=nil;
xdong2  :=nil;
//get
if mm_inited then result:=mm_chimes.info(xindex,xname,xstyle,xtep,xintro,xdong,xdong2);
except;end;
end;
//## chm_findname ##
function chm_findname(xname:string;var xindex:longint):boolean;
begin
try
//defaults
result:=false;
xindex:=0;
//get
if mm_inited then result:=mm_chimes.findname(xname,xindex);
except;end;
end;
//## chm_safename ##
function chm_safename(xname,xdefname:string):string;//15nov2022
label
   once,redo;
var//Note: a name can also be a title which is NOT a chime so chimes always have a style char and the ":" char preceeding their name -> e.g. "m:Westminster" - 15nov2022
   xonce:boolean;
   xstyle,xtep,xindex:longint;
   a,b,c:tstr8;
begin
try
result:=xname;
xonce:=true;
once:
chm_findname(result,xindex);
redo:
chm_info(xindex,result,xstyle,xtep,a,b,c);
if (strcopy1(result,2,1)<>':') then
   begin
   if xonce then
      begin
      xonce:=false;
      if (xdefname<>'') then
         begin
         if (strcopy1(xdefname,2,1)=':') then result:=xdefname else result:='m:Westminster';
         goto once;
         end;
      end;
   inc(xindex);
   if (xindex<100) then goto redo;
   end;
except;end;
end;

//.mm support ------------------------------------------------------------------
//## mm_canstop ##
function mm_canstop:boolean;
begin
try;result:=mm_inited and (mm_mm.canstop or mm_playing);except;end;
end;
//## mm_stop ##
procedure mm_stop;
begin
try
if mm_inited then
   begin
   mmsys_mm_lastpos:=mm_pos;
   mm_mm.stop;
   end;
except;end;
end;
//## mm_canplay ##
function mm_canplay:boolean;
begin
try;result:=mm_inited and (not mm_mm.playbusy);except;end;
end;
//## mm_play ##
function mm_play:boolean;
begin
try
result:=false;
if mm_inited and mm_canplay then
   begin
   result:=mm_playfile(mmsys_mm_lastfilename);
   mm_setpos(mmsys_mm_lastpos);
   end;
except;end;
end;
//## mm_playfile ##
function mm_playfile(xfilename:string):boolean;
var
   e:string;
begin
try
result:=mm_inited and mm_mm.play(xfilename,e);
case result of
true:begin
   mmsys_mm_lastfilename:=xfilename;
   mmsys_mm_lastsize:=low__filesize(xfilename);
   mmsys_mm_lastlen:=mm_mm.len;
   mmsys_mm_lastpos:=mm_mm.position;
   end;
false:begin
   mmsys_mm_lastfilename:='';
   mmsys_mm_lastsize:=0;
   mmsys_mm_lastlen:=0;
   mmsys_mm_lastpos:=0;
   end;
end;//case
except;end;
end;
//## mm_bytes ##
function mm_bytes:longint;
begin
try;result:=mmsys_mm_lastsize;except;end;
end;
//## mm_seeking ##
function mm_seeking:boolean;
begin
try;result:=mm_inited and (mm_mm.playbusy or mm_mm.positionbusy);except;end;
end;
//## mm_canpertpos ##
function mm_canpertpos:boolean;//true=system supports percentage positioning, else not - 06mar2022
begin
result:=true;
end;
//## mm_pos ##
function mm_pos:longint;
begin
try
result:=0;
if mm_inited then
   begin
   case mm_playing and (not mm_seeking) of
   true:result:=mm_mm.position;
   false:result:=frcrange(mmsys_mm_lastpos,0,mm_len);//maintain position value even when playback has stopped - 20feb2022
   end;//case
   end;
except;end;
end;
//## mm_setpos ##
function mm_setpos(x:longint):boolean;
begin
try
result:=mm_inited;
if result then
   begin
   mm_mm.position:=frcmin(x,0);
   mmsys_mm_lastpos:=frcmin(x,0);
   end;
except;end;
end;
//## mm_setpertpos ##
function mm_setpertpos(x:double):boolean;//06mar2022
var
   v:longint;
begin
try
result:=mm_inited;
if result then
   begin
   if (x<0) then x:=0 else if (x>100) then x:=100;
   v:=frcrange(round(mm_mm.len*x) div 100,0,frcmin(mm_mm.len-1,0));
   mm_mm.position:=frcmin(v,0);
   mmsys_mm_lastpos:=frcmin(v,0);
   end;
except;end;
end;
//## mm_len ##
function mm_len:longint;
begin
try;result:=0;if mm_inited then result:=mmsys_mm_lastlen;except;end;//maintain length value even when playback has stopped - 20feb2022
end;
//## mm_deviceactive ##
function mm_deviceactive:boolean;//have access to midi device - 15apr2021
begin
try;result:=mm_inited and (mm_mm.handle<>0) and (mm_mm.state>=msHold);except;end;
end;
//## mm_playing ##
function mm_playing:boolean;
begin
try;result:=mm_inited and mm_mm.playing;except;end;
end;
//## mm_loop ##
function mm_loop:boolean;
begin
try;result:=mm_inited and mm_mm.oloop;except;end;
end;
//## mm_setloop ##
function mm_setloop(x:boolean):boolean;
begin
try;result:=mm_inited;if result then mm_mm.oloop:=x;except;end;
end;
//## mm_autostop ##
function mm_autostop:boolean;
begin
try;result:=mm_inited and mm_mm.oautostop;except;end;
end;
//## mm_setautostop ##
function mm_setautostop(x:boolean):boolean;
begin
try;result:=mm_inited;if result then mm_mm.oautostop:=x;except;end;
end;
//## mm_mode ##
function mm_mode:tmmodes;
begin
try;result:=mmNotReady;if mm_inited then result:=mm_mm.mode;except;end;
end;
//## mm_state ##
function mm_state:byte;
begin
try;result:=msFree;if mm_inited then result:=mm_mm.state;except;end;
end;

{$else}

//## mm_init ##
procedure mm_init;
begin
end;
//## mm_shut ##
procedure mm_shut;
begin
end;
//## mm_ok ##
function mm_ok:boolean;
begin
result:=false;
end;
//## mm_inited ##
function mm_inited:boolean;
begin
result:=false;
end;
//## mm_playmanagement_init ##
function mm_playmanagement_init(var xmuststop,xmustplay,xplaying:boolean;var xmustpertpos:double;var xmustpos,xlastpos:longint;var xlastfilename:string):boolean;
begin
try
result:=true;//pass-thru
xmuststop:=false;
xmustplay:=false;
xplaying:=false;
xmustpertpos:=-1;//off
xmustpos:=-1;//off
xlastpos:=0;
xlastfilename:='';
except;end;
end;
//## mm_playmanagement ##
function mm_playmanagement(xstyle:string;xmode,xintroms:longint;var xmuststop,xmustplay,xplaying,xhostupdate:boolean;var xmustpertpos:double;var xmustpos,xlastpos:longint;var xlastfilename:string;xnav:tbasicnav;xplaylist:tbasicmenu;xplaylistmask:string;xjump:tbasicjump):boolean;
begin
result:=false;
end;

//.wave support ----------------------------------------------------------------
//## wav_ok ##
function wav_ok:boolean;
begin
result:=false;
end;
//## wav_vol ##
function wav_vol:longint;
begin
result:=100;
end;
//## wav_setvol ##
function wav_setvol(x:longint):boolean;
begin
result:=false;
end;
//## wav_devicelist ##
procedure wav_devicelist;
begin

end;
//## wav_deviceindex ##
function wav_deviceindex:longint;
begin//not operational yet
try;result:=0;except;end;
end;
//## wav_setdeviceindex ##
function wav_setdeviceindex(x:longint):boolean;
begin//Not operational yet
try;result:=false;except;end;
end;
//## wav_devicelimit ##
function wav_devicelimit:longint;
begin
result:=0;
end;
//## wav_devicecount ##
function wav_devicecount:longint;//exclude midi mapper
begin
result:=0;
end;
//## wav_deviceok ##
function wav_deviceok(xindex:longint):boolean;
begin
result:=false;
end;
//## wav_devicename ##
function wav_devicename(xindex:longint;xdefval:string):string;
begin
result:=xdefval;
end;
//## wav_flush44 ##
function wav_flush44:boolean;
begin
result:=false;
end;
//## wav_push44 ##
function wav_push44(x:tstr8):boolean;
begin
try;result:=false;bautofree(x);except;end;
end;
//## wav_len44 ##
function wav_len44:longint;
begin
result:=0;
end;

//.midi support ----------------------------------------------------------------
//## mid_ok ##
function mid_ok:boolean;
begin
result:=false;
end;
//## mid_devicelist ##
procedure mid_devicelist;
begin

end;
//## mid_canstop ##
function mid_canstop:boolean;
begin
result:=false;
end;
//## mid_stop ##
procedure mid_stop;
begin
end;
//## mid_canplay ##
function mid_canplay:boolean;
begin
result:=false;
end;
//## mid_play ##
procedure mid_play;
begin
end;
//## mid_canplaymidi ##
function mid_canplaymidi:boolean;
begin
result:=false;
end;
//## mid_playmidi ##
function mid_playmidi(xmiddata:tstr8):boolean;
begin
try;result:=false;bautofree(xmiddata);except;end;
end;
//## mid_playfile ##
function mid_playfile(xfilename:string):boolean;
begin
result:=false;
end;
//## mid_speed ##
function mid_speed:longint;
begin
result:=100;
end;
//## mid_speed2 ##
function mid_speed2:longint;
begin
result:=100;
end;
//## mid_setspeed ##
function mid_setspeed(x:longint):boolean;
begin
result:=false;
end;
//## mid_setspeed2 ##
function mid_setspeed2(x:longint):boolean;
begin
result:=false;
end;
//## mid_style ##
function mid_style:longint;
begin
result:=0;
end;
//## mid_setstyle ##
function mid_setstyle(x:longint):boolean;
begin
result:=false;
end;
//## mid_deviceindex ##
function mid_deviceindex:longint;
begin
result:=0;
end;
//## mid_setdeviceindex ##
function mid_setdeviceindex(x:longint):boolean;
begin
result:=false;
end;
//## mid_devicelimit ##
function mid_devicelimit:longint;
begin
result:=0;
end;
//## mid_devicecount ##
function mid_devicecount:longint;//exclude midi mapper
begin
result:=0;
end;
//## mid_deviceok ##
function mid_deviceok(xindex:longint):boolean;
begin
result:=false;
end;
//## mid_devicename ##
function mid_devicename(xindex:longint;xdefval:string):string;
begin
result:=xdefval;
end;
//## mid_seeking ##
function mid_seeking:boolean;
begin
result:=false;
end;
//## mid_vol ##
function mid_vol:longint;//system volume
begin
result:=100;
end;
//## mid_vol1 ##
function mid_vol1:longint;//modifies volume of notes
begin
result:=100;
end;
//## mid_vol2 ##
function mid_vol2:longint;//modifies volume of notes
begin
result:=100;
end;
//## mid_setvol ##
function mid_setvol(x:longint):boolean;
begin
result:=false;
end;
//## mid_setvol1 ##
function mid_setvol1(x:longint):boolean;//modifies volume of notes
begin
result:=false;
end;
//## mid_setvol2 ##
function mid_setvol2(x:longint):boolean;//modifies volume of notes
begin
result:=false;
end;
//## mid_canpertpos ##
function mid_canpertpos:boolean;//true=system supports percentage positioning, else not - 06mar2022
begin
result:=true;
end;
//## mid_pos ##
function mid_pos:longint;
begin
result:=0;
end;
//## mid_pertpos ##
function mid_pertpos:double;
begin
result:=0;
end;
//## mid_setpos ##
function mid_setpos(x:longint):boolean;
begin
result:=false;
end;
//## mid_setpertpos ##
function mid_setpertpos(x:double):boolean;
begin
result:=false;
end;
//## mid_len ##
function mid_len:longint;
begin
result:=0;
end;
//## mid_lyriccount ##
function mid_lyriccount:longint;
begin
result:=0;
end;
//## mid_pos ##
function mid_lyric(xpos:longint;xshowsep:boolean):string;
begin
result:='';
end;
//## mid_format ##
function mid_format:longint;
begin
result:=0;
end;
//## mid_tracks ##
function mid_tracks:longint;
begin
result:=0;
end;
//## mid_msgs ##
function mid_msgs:longint;//total number of messages in midi
begin
result:=0;
end;
//## mid_msgssent ##
function mid_msgssent:longint;//number of message sent to midi hardware
begin
result:=0;
end;
//## mid_lag ##
function mid_lag:longint;
begin
result:=0;
end;
//## mid_bytes ##
function mid_bytes:longint;//memory in use in bytes
begin
result:=0;
end;
//## mid_midbytes ##
function mid_midbytes:longint;//size of midi in bytes
begin
result:=0;
end;
//## mid_phandle ##
function mid_phandle:longint;//handle of midi device
begin
result:=0;
end;
//## mid_deviceactive ##
function mid_deviceactive:boolean;//have access to midi device - 15apr2021
begin
result:=false;
end;
//## mid_usingtimer ##
function mid_usingtimer:boolean;
begin
result:=false;
end;
//## mid_playing ##
function mid_playing:boolean;
begin
result:=false;
end;
//## mid_keepopen ##
function mid_keepopen:boolean;
begin
result:=false;
end;
//## mid_setkeepopen ##
function mid_setkeepopen(x:boolean):boolean;
begin
result:=false;
end;
//## mid_loop ##
function mid_loop:boolean;
begin
result:=false;
end;
//## mid_setloop ##
function mid_setloop(x:boolean):boolean;
begin
result:=false;
end;

//.chimes support --------------------------------------------------------------
//## chm_ok ##
function chm_ok:boolean;
begin
result:=true;
end;
//## chm_count ##
function chm_count:longint;
begin
result:=0;
end;
//## chm_numberfrom1 ##
function chm_numberfrom1:longint;
begin
result:=0;
end;
//## chm_numberfrom2 ##
function chm_numberfrom2:longint;
begin
result:=0;
end;
//## chm_numberfrom3 ##
function chm_numberfrom3:longint;
begin
result:=0;
end;
//## chm_name ##
function chm_name(xindex:longint):string;
begin
result:='';
end;
//## chm_canintro ##
function chm_canintro(xindex:longint):boolean;
begin
result:=true;
end;
//## chm_candong ##
function chm_candong(xindex:longint):boolean;
begin
result:=true;
end;
//## chm_candong2 ##
function chm_candong2(xindex:longint):boolean;
begin
result:=true;
end;
//## chm_canstop ##
function chm_canstop:boolean;
begin
result:=false;
end;
//## chm_stop ##
procedure chm_stop;
begin

end;
//## chm_mustplayname ##
function chm_mustplayname(xname:string;xmins:longint):boolean;
begin
result:=false;
end;
//## chm_mustplayindex ##
function chm_mustplayindex(xindex,xmins:longint):boolean;
begin
result:=false;
end;
//## chm_canplay ##
function chm_canplay:boolean;
begin
result:=false;
end;
//## chm_playname ##
procedure chm_playname(xname:string;xmins:longint;x0,x15,x30,x45,xtest:boolean);
begin

end;
//## chm_playname2 ##
procedure chm_playname2(xname:string);
begin

end;
//## chm_playname3 ##
procedure chm_playname3(xname:string;xmins:longint;n0,n15,n30,n45,b0,s0,s15,s30,s45,xtest:boolean);
begin

end;
//## chm_playindex ##
procedure chm_playindex(xindex,xmins:longint;x0,x15,x30,x45,xtest:boolean);
begin

end;
//## chm_playindex2 ##
procedure chm_playindex2(xindex:longint);
begin

end;
//## chm_chimingpert ##
function chm_chimingpert:double;
begin
result:=0;
end;
//## chm_chiming ##
function chm_chiming:boolean;
begin
result:=false;
end;
//## chm_playing ##
function chm_playing:boolean;
begin
result:=false;
end;
//## chm_testing ##
function chm_testing:boolean;
begin
result:=false;
end;
//## chm_buzzercount ##
function chm_buzzercount:longint;
begin
result:=0;
end;
//## chm_buzzer ##
function chm_buzzer:longint;
begin
result:=0;//off
end;
//## chm_setbuzzer ##
procedure chm_setbuzzer(x:longint);
begin

end;
//## chm_buzzerlabel ##
function chm_buzzerlabel(x:longint):string;
begin
try;result:=inttostr(p);except;end;
end;
//## chm_vol ##
function chm_vol:longint;//chimes volume, not buzzer
begin
result:=0;
end;
//## chm_setvol ##
procedure chm_setvol(x:longint);//chimes volume, not buzzer
begin

end;
//## chm_info ##
function chm_info(xindex:longint;var xname:string;var xstyle,xtep:longint;var xintro,xdong,xdong2:tstr8):boolean;
begin
result  :=false;
xname   :='';
xintro  :=nil;
xdong   :=nil;
xdong2  :=nil;
end;
//## chm_findname ##
function chm_findname(xname:string;var xindex:longint):boolean;
begin
result:=false;
xindex:=0;
end;
//## chm_safename ##
function chm_safename(xname,xdefname:string):string;//15nov2022
begin
result:=xname;
end;

//.mm support ------------------------------------------------------------------
//## mm_canstop ##
function mm_canstop:boolean;
begin
result:=false;
end;
//## mm_stop ##
procedure mm_stop;
begin
end;
//## mm_canplay ##
function mm_canplay:boolean;
begin
result:=false;
end;
//## mm_play ##
function mm_play:boolean;
begin
result:=false;
end;
//## mm_playfile ##
function mm_playfile(xfilename:string):boolean;
begin
result:=false;
end;
//## mm_bytes ##
function mm_bytes:longint;
begin
result:=0;
end;
//## mm_seeking ##
function mm_seeking:boolean;
begin
result:=false;
end;
//## mm_canpertpos ##
function mm_canpertpos:boolean;//true=system supports percentage positioning, else not - 06mar2022
begin
result:=true;
end;
//## mm_pos ##
function mm_pos:longint;
begin
result:=0;
end;
//## mm_setpos ##
function mm_setpos(x:longint):boolean;
begin
result:=false;
end;
//## mm_setpertpos ##
function mm_setpertpos(x:double):boolean;//06mar2022
begin
result:=false;
end;
//## mm_len ##
function mm_len:longint;
begin
result:=0;
end;
//## mm_deviceactive ##
function mm_deviceactive:boolean;//have access to midi device - 15apr2021
begin
result:=false;
end;
//## mm_playing ##
function mm_playing:boolean;
begin
result:=false;
end;
//## mm_loop ##
function mm_loop:boolean;
begin
result:=false;
end;
//## mm_setloop ##
function mm_setloop(x:boolean):boolean;
begin
result:=false;
end;
//## mm_autostop ##
function mm_autostop:boolean;
begin
result:=false;
end;
//## mm_setautostop ##
function mm_setautostop(x:boolean):boolean;
begin
result:=false;
end;
//## mm_mode ##
function mm_mode:tmmodes;
begin
result:=mmNotReady;
end;
//## mm_state ##
function mm_state:byte;
begin
result:=msFree;
end;
{$endif}
//end of "mm" multimedia support -----------------------------------------------


//history support --------------------------------------------------------------
//## his__found ##
function his__found(xname:string):boolean;
var
   int1:longint;
begin
try;result:=his__find(xname,int1);except;end;
end;
//## his__find ##
function his__find(xname:string;var xindex:longint):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
xindex:=0;
//check
if (xname='') then exit;
//fast find
if (syshis_last>=0) and (syshis_last<=high(syshis_nam)) and low__comparetext(xname,syshis_nam[syshis_last]) then
   begin
   xindex:=syshis_last;
   if (xindex>=0) and (xindex<=high(syshis_nam)) and (syshis_nam[xindex]<>'') then//27apr2021
      begin
      result:=true;
      exit;
      end;
   end;
//find
for p:=0 to high(syshis_nam) do
begin
if (syshis_nam[p]<>'') and low__comparetext(xname,syshis_nam[p]) then
   begin
   xindex:=p;
   syshis_last:=p;//fast find
   result:=true;
   break;
   end;
end;//p
except;end;
end;
//## his__clear ##
function his__clear(xname:string):boolean;
var
   p,int1:longint;
begin
try
result:=true;
if his__find(xname,int1) then
   begin
   for p:=0 to high(syshis_val[int1]) do
   begin
   syshis_val[int1][p]:='';
   syshis_ref1[int1][p]:=0;
   syshis_ref2[int1][p]:=0;
   end;//p
   syshis_nam[int1]:='';
   end;
except;end;
end;
//## his__canprev ##
function his__canprev(xname:string):boolean;
var
   str1:string;
begin
try;result:=his__prev(xname,str1,false);except;end;
end;
//## his__prev ##
function his__prev(xname:string;var xoutval:string;xmove:boolean):boolean;
var
   v1,v2:longint;
begin
try;result:=his__prev2(xname,xoutval,v1,v2,xmove);except;end;
end;
//## his__prev2 ##
function his__prev2(xname:string;var xoutval:string;var v1,v2:longint;xmove:boolean):boolean;
var
   p,int1:longint;
begin
try
//defaults
result:=false;
xoutval:='';
v1:=0;
v2:=0;
//get
if his__find(xname,int1) then
   begin
   for p:=0 to high(syshis_val[int1]) do
   begin
   if (syshis_val[int1][p]='') then break
   else if (strcopy1x(syshis_val[int1][p],1,1)='A') then
      begin
      if (p>=1) and (syshis_val[int1][p-1]<>'') then
         begin
         if xmove then
            begin
            syshis_val[int1][p]:='N'+strcopy1x(syshis_val[int1][p],2,length(syshis_val[int1][p]));//mark normal
            syshis_val[int1][p-1]:='A'+strcopy1x(syshis_val[int1][p-1],2,length(syshis_val[int1][p-1]));//mark active
            end;
         xoutval:=strcopy1x(syshis_val[int1][p-1],2,length(syshis_val[int1][p-1]));//return active value
         v1:=syshis_ref1[int1][p-1];
         v2:=syshis_ref2[int1][p-1];
         result:=true;
         end;
      break;
      end;
   end;//p
   end;
except;end;
end;
//## his__cannext ##
function his__cannext(xname:string):boolean;
var
   str1:string;
begin
try;result:=his__next(xname,str1,false);except;end;
end;
//## his__next ##
function his__next(xname:string;var xoutval:string;xmove:boolean):boolean;
var
   v1,v2:longint;
begin
try;result:=his__next2(xname,xoutval,v1,v2,xmove);except;end;
end;
//## his__next2 ##
function his__next2(xname:string;var xoutval:string;var v1,v2:longint;xmove:boolean):boolean;
var
   p,int1:longint;
begin
try
//defaults
result:=false;
xoutval:='';
v1:=0;
v2:=0;
//get
if his__find(xname,int1) then
   begin
   for p:=0 to high(syshis_val[int1]) do
   begin
   if (syshis_val[int1][p]='') then break
   else if (strcopy1x(syshis_val[int1][p],1,1)='A') then
      begin
      if (p<high(syshis_val[int1])) and (syshis_val[int1][p+1]<>'') then
         begin
         if xmove then
            begin
            syshis_val[int1][p]:='N'+strcopy1x(syshis_val[int1][p],2,length(syshis_val[int1][p]));//mark normal
            syshis_val[int1][p+1]:='A'+strcopy1x(syshis_val[int1][p+1],2,length(syshis_val[int1][p+1]));//mark active
            end;
         xoutval:=strcopy1x(syshis_val[int1][p+1],2,length(syshis_val[int1][p+1]));//return active value
         v1:=syshis_ref1[int1][p+1];
         v2:=syshis_ref2[int1][p+1];
         result:=true;
         end;
      break;
      end;
   end;//p
   end;
except;end;
end;
//## his__active ##
function his__active(xname:string;var xoutval:string):boolean;
var
   v1,v2:longint;
begin
try;result:=his__active2(xname,xoutval,v1,v2);except;end;
end;
//## his__active2 ##
function his__active2(xname:string;var xoutval:string;var v1,v2:longint):boolean;
var
   p,int1:longint;
begin
try
//defaults
result:=false;
xoutval:='';
v1:=0;
v2:=0;
//get
if his__find(xname,int1) then
   begin
   for p:=0 to high(syshis_val[int1]) do
   begin
   if (syshis_val[int1][p]='') then break
   else if (strcopy1x(syshis_val[int1][p],1,1)='A') then
      begin
      xoutval:=strcopy1x(syshis_val[int1][p],2,length(syshis_val[int1][p]));//return active value
      v1:=syshis_ref1[int1][p];
      v2:=syshis_ref2[int1][p];
      result:=true;
      break;
      end;
   end;//p
   end;
except;end;
end;
//## his__setactiveref ##
function his__setactiveref(xname:string;v1,v2:longint):boolean;//sets ref of active item
var
   p,int1:longint;
begin
try
result:=false;
if his__find(xname,int1) then
   begin
   for p:=0 to high(syshis_val[int1]) do
   begin
   if (syshis_val[int1][p]='') then break
   else if (strcopy1x(syshis_val[int1][p],1,1)='A') then
      begin
      syshis_ref1[int1][p]:=v1;
      syshis_ref2[int1][p]:=v2;
      result:=true;
      break;
      end;
   end;//p
   end;
except;end;
end;
//## his__add ##
function his__add(xname,xval:string):boolean;
begin
try;result:=his__add2(xname,xval,0,0,false);except;end;
end;
//## his__add2 ##
function his__add2(xname,xval:string;v1,v2:longint;xstorev12:boolean):boolean;
label
   skipend;
var
   p,int1,int2:longint;
begin
try
//defaults
result:=false;
int1:=-1;

//check
if (xname='') then exit;

//find existing OR create new
if his__find(xname,int2) then int1:=int2
else
   begin//new
   for p:=0 to high(syshis_nam) do if (syshis_nam[p]='') then
      begin
      int1:=p;
      syshis_nam[p]:=xname;
      //init -> clear all values if any still present
      for int2:=0 to high(syshis_val[int1]) do
      begin
      syshis_val[int1][int2]:='';
      syshis_ref1[int1][int2]:=0;
      syshis_ref2[int1][int2]:=0;
      end;//int2
      break;
      end;//p
   end;

//check
if (int1<=-1) then exit;

//add
for p:=0 to high(syshis_val[int1]) do
begin
if (syshis_val[int1][p]='') then
   begin
   syshis_val[int1][p]:='A'+xval;
   if xstorev12 then
      begin
      syshis_ref1[int1][p]:=v1;
      syshis_ref2[int1][p]:=v2;
      end;
   result:=true;
   break;
   end
else if (strcopy1x(syshis_val[int1][p],1,1)='A') then
   begin
   //check -> already active
   if low__comparetext(syshis_val[int1][p],'A'+xval) then
      begin
      if xstorev12 then
         begin
         syshis_ref1[int1][p]:=v1;
         syshis_ref2[int1][p]:=v2;
         end;
      result:=true;
      goto skipend;
      end;
   //mark normal
   syshis_val[int1][p]:='N'+strcopy1x(syshis_val[int1][p],2,length(syshis_val[int1][p]));//mark normal
   //add - have room
   if (p<high(syshis_val[int1])) then
      begin
      syshis_val[int1][p+1]:='A'+xval;
      if xstorev12 then
         begin
         syshis_ref1[int1][p+1]:=v1;
         syshis_ref2[int1][p+1]:=v2;
         end;
      //.wipe out any forward facing items
      if ((p+2)<=high(syshis_val[int1])) then
         begin
         for int2:=p+2 to high(syshis_val[int1]) do
         begin
         syshis_val[int1][int2]:='';
         syshis_ref1[int1][int2]:=0;
         syshis_ref2[int1][int2]:=0;
         end;//int2
         end;
      result:=true;
      end
   //add - make room
   else
      begin
      //shift up one
      for int2:=1 to high(syshis_val[int1]) do
      begin
      syshis_val[int1][int2-1]:=syshis_val[int1][int2];
      syshis_ref1[int1][int2-1]:=syshis_ref1[int1][int2];
      syshis_ref2[int1][int2-1]:=syshis_ref2[int1][int2];
      end;//p
      //set
      syshis_val[int1][p]:='A'+xval;
      syshis_ref1[int1][p]:=low__insint(v1,xstorev12);
      syshis_ref2[int1][p]:=low__insint(v2,xstorev12);
      result:=true;
      end;
   //stop
   break;
   end;
end;//p

skipend:
except;end;
end;
//-- system disk support -------------------------------------------------------
//## dk_init ##
procedure dk_init(xnewlabel:string);
begin
sysdisk_inuse:=true;
if (xnewlabel<>'') then sysdisk_label:=xnewlabel;
end;
//## dk_findfirst ##
function dk_findnext(var xpos:longint;xfolder:string;xfolders,xfiles:boolean;var xoutname,xoutnameonly:string;var xoutfolder,xoutfile:boolean;var xoutdate:tdatetime;var xoutsize:longint;var xoutreadonly:boolean):boolean;
label//Supports single level of folders only -> all we need right now - 04apr2021
   skipend;
var
   dpos,xfolderlen,p,int1,int2:longint;
   str1:string;
   xisfile:boolean;
begin
try
//defaults
result:=false;
xoutname:='';
xoutnameonly:='';
xoutfolder:=false;
xoutfile:=false;
xoutdate:=now;
xoutsize:=0;
xoutreadonly:=false;

//range
if (xpos<0) then xpos:=0;
dpos:=xpos;

//check
if dk_havescope(xfolder) then xfolder:=asfolder(xfolder) else goto skipend;

//init
xfolderlen:=length(xfolder);

//find
for p:=0 to high(sysdisk_name) do
begin
dpos:=p+1;//inc
if (p>=xpos) then
   begin
   if (sysdisk_name[p]<>'') then
      begin
      str1:=low__extractfilepath(sysdisk_name[p]);
      if (str1<>'') then
         begin
         //init
         xisfile:=low__isfile(sysdisk_name[p]);
         //get
         if (xfolders and (not xisfile) and low__comparetext(strcopy1(str1,1,xfolderlen),xfolder) and (length(str1)>xfolderlen)) or (xfiles and xisfile and low__comparetext(str1,xfolder)) then
            begin
            //get
            xoutname:=sysdisk_name[p];
            xoutnameonly:='';
            case xisfile of
            true:begin//as a file
               if (xoutname<>'') then
                  begin
                  for int1:=length(xoutname) downto 1 do if (strcopy1(xoutname,int1,1)='\') or (strcopy1(xoutname,int1,1)='/') then
                     begin
                     xoutnameonly:=strcopy1(xoutname,int1+1,length(xoutname));
                     break;
                     end;
                  end;
               end;
            false:begin//as a folder
               if (xoutname<>'') then
                  begin
                  int2:=0;
                  for int1:=length(xoutname) downto 1 do if (strcopy1(xoutname,int1,1)='\') or (strcopy1(xoutname,int1,1)='/') then
                     begin
                     inc(int2);
                     if (int2>=2) then
                        begin
                        xoutnameonly:=strcopy1(xoutname,int1+1,length(xoutname)-int1-1);//no slashes
                        break;
                        end;
                     end;
                  end;
               end;
            end;//case
            xoutfolder:=not xisfile;
            xoutfile:=xisfile;
            xoutdate:=sysdisk_date[p];
            xoutreadonly:=sysdisk_readonly[p];
            if xisfile and zzok(sysdisk_data[p],1024) then xoutsize:=sysdisk_data[p].len;
            //successful
            result:=true;
            //stop
            break;
            end;
         end;
      end;
   end;
end;//p

skipend:
except;end;
try;if (dpos>xpos) then xpos:=dpos;except;end;
end;
//## dk_havescope ##
function dk_havescope(xname:string):boolean;
begin
try;result:=sysdisk_inuse and (xname<>'') and (strcopy1(xname,1,1)=sysdisk_char);except;end;
end;
//## dk_makefolder ##
function dk_makefolder(xname:string;var e:string):boolean;
label
   skipend;
var
   xindex,int1,p:longint;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
//check
if dk_havescope(xname) then xname:=asfolder(xname) else goto skipend;
//check - allow ONE folder level only e.g. "!:\Images\" -> or two slashes
int1:=0;
for p:=1 to length(xname) do if (strcopy1(xname,p,1)='\') or (strcopy1(xname,p,1)='/') then inc(int1);
if (int1>2) then goto skipend;
//get
if not dk_find(xname,true,xindex) then goto skipend;
//successful
result:=true;
skipend:
except;end;
end;
//## dk_folderexists ##
function dk_folderexists(xname:string):boolean;
var
   int1:longint;
begin
try;result:=dk_havescope(xname) and dk_find(asfolder(xname),false,int1);except;end;
end;
//## dk_fileexists ##
function dk_fileexists(xname:string):boolean;
var
   int1:longint;
begin
try;result:=dk_havescope(xname) and dk_find(xname,false,int1);except;end;
end;
//## dk_find ##
function dk_find(xname:string;xcreatenew:boolean;var xindex:longint):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
xindex:=0;
//check
if (not sysdisk_inuse) or (xname='') then exit;
//find existing;
for p:=0 to high(sysdisk_name) do if (sysdisk_name[p]<>'') and low__comparetext(sysdisk_name[p],xname) then
   begin
   xindex:=p;
   result:=true;
   break;
   end;
//create new
if (not result) and xcreatenew then
   begin
   for p:=0 to high(sysdisk_name) do if (sysdisk_name[p]='') then
      begin
      result:=true;
      xindex:=p;
      sysdisk_name[p]:=xname;
      if zznil(sysdisk_data[p],2005) then sysdisk_data[p]:=bnew;//create data handler - 03apr2021
      sysdisk_readonly[p]:=false;
      break;
      end;//p
   end;
except;end;
end;
//## dk_remfile ##
function dk_remfile(xname:string):boolean;
label
   skipend;
var
   xindex:longint;
begin
try
//defaults
result:=false;
//check
if not sysdisk_inuse then goto skipend;
//find
if dk_find(xname,false,xindex) then
   begin
   //check
   if sysdisk_readonly[xindex] then goto skipend;
   //delete
   if zzok(sysdisk_data[xindex],1025) then sysdisk_data[xindex].clear;
   sysdisk_name[xindex]:='';
   end;
//successful
result:=true;
skipend:
except;end;
end;
//## dk_tofile ##
function dk_tofile(xname:string;xdata:tstr8;var e:string):boolean;//30sep2021
label
   skipend;
var
   xindex:longint;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
//lock
zzstr(xdata,83);
if not block(xdata) then goto skipend;
//check
if not sysdisk_inuse then goto skipend;
//find
if not dk_find(xname,true,xindex) then goto skipend;
//check
if sysdisk_readonly[xindex] then
   begin
   e:=gecReadonly;
   goto skipend;
   end;
//write
if zzok(sysdisk_data[xindex],1026) then
   begin
   sysdisk_data[xindex].clear;
   if low__comparetext(anyformatb(xdata),'zip') and (not low__decompress(xdata,e)) then goto skipend;
   sysdisk_data[xindex].add(xdata);
   end;
//.date
sysdisk_date[xindex]:=now;
//successful
result:=true;
skipend:
except;end;
try;bunlockautofree(xdata);except;end;
end;
//## dk_tofile2 ##
function dk_tofile2(xname:string;xdata:array of byte;var e:string):boolean;//14apr2021
var
   a:tstr8;
begin
try
result:=false;
a:=nil;
a:=bnew;
a.aadd(xdata);
result:=dk_tofile(xname,a,e);
except;end;
try;bfree(a);except;end;
end;
//## dk_fromfile ##
function dk_fromfile(xname:string;xdata:tstr8;var e:string):boolean;
label
   skipend;
var
   xindex:longint;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
//lock
zzstr(xdata,84);
if not block(xdata) then goto skipend;
//init
xdata.clear;
//check
if not sysdisk_inuse then goto skipend;
//find
if not dk_find(xname,false,xindex) then
   begin
   e:=gecFilenotfound;
   goto skipend;
   end;
//check
if sysdisk_readonly[xindex] then
   begin
   e:=gecReadonly;
   goto skipend;
   end;
//read
if zzok(sysdisk_data[xindex],1027) then xdata.add(sysdisk_data[xindex]);
//successful
result:=true;
skipend:
except;end;
try;bunlockautofree(xdata);except;end;
end;
//## low__stdencrypt ##
function low__stdencrypt(x,ekey:tstr8;mode1:longint):boolean;//updated 19aug2020
label
   skipend;
var
   lt,el,e,p2,p:longint;
   elist,xlist:pdlbyte;
begin
try
//defaults
result:=false;
//check
if zznil(x,2006) or zznil(ekey,2007) then goto skipend;
if (x.len<=0) then
   begin
   result:=true;
   goto skipend;
   end;
//init
lt:=x.len;
el:=ekey.len;
e:=0;
elist:=ekey.pbytes;
xlist:=x.pbytes;
//get
case mode1 of
0:begin//encrypt str - binary
   for p:=1 to lt do
   begin
   e:=e+1;
   if (e>el) then e:=1;
   p2:=elist[e-1]+xlist[p-1];
   if (p2>255) then p2:=p2-256;
   xlist[p-1]:=p2;
   end;//p
   end;
1:begin//decrypt str - binary
   for p:=1 to lt do
   begin
   e:=e+1;
   if (e>el) then e:=1;
   p2:=xlist[p-1]-elist[e-1];
   if (p2<0) then p2:=p2+256;
   xlist[p-1]:=p2;
   end;//p
   end;
2:begin//encrypt plainttext to plaintext str char range "13-255"
   for p:=1 to lt do
   begin
   e:=e+1;
   if (e>el) then e:=1;
   p2:=elist[e-1]+xlist[p-1];
   if (p2>255) then p2:=p2-242;
   xlist[p-1]:=p2;
   end;//p
   end;
3:begin//decrypt plainttext str
   for p:=1 to lt do
   begin
   e:=e+1;
   if (e>el) then e:=1;
   p2:=xlist[p-1]-elist[e-1];
   if (p2<14) then p2:=p2+242;
   xlist[p-1]:=p2;
   end;//p
   end;
end;//case
//successful
result:=true;
skipend:
except;end;
try
bautofree(x);
bautofree(ekey);
except;end;
end;
//## low__glseEDK ##
function low__glseEDK:tstr8;
const
   //was: glseEDK='2-13-09afdklJ*[q-02490-9123poasdr90q34[9q2u3-[9234[9u0w3689yq28901iojIOJHPIae;riqu58pq5uq9531asdo';
   xmap:array[0..96] of byte=(50,45,49,51,45,48,57,97,102,100,107,108,74,42,91,113,45,48,50,52,57,48,45,57,49,50,51,112,111,97,115,100,114,57,48,113,51,52,91,57,113,50,117,51,45,91,57,50,51,52,91,57,117,48,119,51,54,56,57,121,113,50,56,57,48,49,105,111,106,73,79,74,72,80,73,97,101,59,114,105,113,117,53,56,112,113,53,117,113,57,53,51,49,97,115,100,111);
begin
try;result:=bnew_autofree;result.aadd(xmap);except;end;
end;
//## low__ecapk ##
function low__ecapk:tstr8;
const//Note: Generate a short random key for "ecap" system - updaed 19aug2020
   //was:map='asdfklj4imzxhmewro982489alkt9[1239-12,as[023aeoi43q[9';//should be OK in D10
   xmap:array[0..52] of byte=(97,115,100,102,107,108,106,52,105,109,122,120,104,109,101,119,114,111,57,56,50,52,56,57,97,108,107,116,57,91,49,50,51,57,45,49,50,44,97,115,91,48,50,51,97,101,111,105,52,51,113,91,57);
var
   xlen,p:longint;
   xlist:pdlbyte;
begin
try
//defaults
result:=bnew_autofree;
//init
xlen:=10+random(41);{10-50}
result.setlen(xlen);
xlist:=result.pbytes;
//get
if (result.len>=1) then
   begin
   for p:=1 to result.len do xlist[p-1]:=xmap[random(50)];
   end;
except;end;
end;
//## low__ecap ##
function low__ecap(x:tstr8;e:boolean):boolean;
begin
try;result:=low__ecapbin(x,e,false);except;end;
end;
//## low__ecapbin ##
function low__ecapbin(x:tstr8;e,bin:boolean):boolean;
label
   skipend;
var
   klen:longint;
   k:tstr8;
   ee,dd:byte;
begin{Encrypt/Decrypt Caption - Valid input range 14-255}
try
//defaults
result:=false;
k:=nil;
//check
if zznil(x,2008) then exit;
//lock
block(x);
if (x.len<=0) then
   begin
   result:=true;
   goto skipend;
   end;
//decide - ascii/binary
case bin of
true:begin
   ee:=glseEncrypt;
   dd:=glseDecrypt;
   end;
false:begin
   ee:=glseTextEncrypt;
   dd:=glseTextDecrypt;
   end;
end;//case
//get
case e of
true:begin//encrypt
    //generate random key
    k:=low__ecapk;
    block(k);//hold onto this value
    klen:=k.len;
    //encrypt
    if not low__stdencrypt(x,k,ee) then goto skipend;
    //header - kLlength(1),Key(10-50),eData(0..X)}
    if not low__stdencrypt(k,low__glseEDK,dd) then goto skipend;
    //.insert length + key before encrypted data
    x.ains([14+klen],0);
    x.ins(k,1);
    //.filter
    //was: if not bin then General.SwapStrs(Z,#39,#39+#39);
    end;
false:begin//decrypt
     //filter
     //was: if not bin then General.SwapStrs(X,#39+#39,#39);
     //kLength
     klen:=x.pbytes[0]-14;
     //init
     k:=bcopy1(x,2,klen);
     block(k);//hold onto this value
     bdel1(x,1,1+klen);//leave just the encrypted data
     //decrypt
     if not low__stdencrypt(k,low__glseEDK,ee) then goto skipend;
     if not low__stdencrypt(x,k,dd) then goto skipend;
     end;//end of begin
end;//case
//successful
result:=true;
skipend:
except;end;
try
bunlockautofree(k);//27apr2021
bunlockautofree(x);
except;end;
end;
//## low__xysort ##
function low__xysort(xstyle:longint;xdata,x:tstr8):boolean;
begin
try;result:=low__xysort2([xstyle],xdata,x);except;end;
end;
//## low__xysort2 ##
function low__xysort2(xstyle:array of byte;xdata,x:tstr8):boolean;
label//Note: xdata=is actually the encryption key
   skipend,redo2,redo;
var
   sindex,int1,s,v,i2,i,p2,p,xdatalen,xreflen,xlen:longint;
   b:byte;
   xref:tstr8;
begin
try
//defaults
result:=false;
xref:=nil;
//check
if zznil(xdata,2011) or zznil(x,2012) then goto skipend;
//init
sindex:=low(xstyle);
xlen:=x.len;
//.xdata -> encryption key
//was: if (xdata='') then xdata:=copy(#9#251#34#22#10#29#175#174#103#28#62#91#61#01#78,3,99);
if (xdata.len=0) then xdata.aadd1([9,251,34,22,10,29,175,174,103,28,62,91,61,1,78],3,99);
xdatalen:=xdata.len;
//.xref
xref:=bnew;
//loop
redo2:
//xref
s:=xstyle[sindex];
xref.clear;
case s of
0,100,200:xref.aadd([2,1,4,7,3,12,8,6,9,23,11,12,18,4,27,18,24,42,17,22,31]);
1,101,201:xref.aadd([9,3,2,1,5,13,22,10,8,8,3,2,17,40]);
2,102,202:xref.aadd([11,8,5,2,4,3,2,7,22,1,18,33,12,14,55]);
3,103,203:xref.aadd([3,3,4,5,16,7,3,1,3,6,5,8,17,9,11,24,23,14,15,17]);
4,104,204:xref.aadd([27,9,99,12,2,2,3,1,3,3,55,13,47,117,213,101,98,19,10,6]);
5,105,205:xref.aadd([3,4,5,120,77,13,33,7,5,10,9,4,3,37,50,21,79,100]);
else      xref.aadd([8,2,5,7,1,5,2,9,5,18,44,29,13,14,37,22,1,4,2,6,7,2,11]);
end;

{//was:
0,100,200:xref:=#2#1#4#7#3#12#8#6#9#23#11#12#18#4#27#18#24#42#17#22#31;
1,101,201:xref:=#9#3#2#1#5#13#22#10#8#8#3#2#17#40;
2,102,202:xref:=#11#8#5#2#4#3#2#7#22#1#18#33#12#14#55;
3,103,203:xref:=#3#3#4#5#16#7#3#1#3#6#5#8#17#9#11#24#23#14#15#17;
4,104,204:xref:=#27#9#99#12#2#2#3#1#3#3#55#13#47#117#213#101#98#19#10#6;
5,105,205:xref:=#3#4#5#120#77#13#33#7#5#10#9#4#3#37#50#21#79#100;
else xref:=#8#2#5#7#1#5#2#9#5#18#44#29#13#14#37#22#1#4#2#6#7#2#11;
{}//end

xreflen:=xref.len;
//.decrypt
if (s>=200) then
   begin
   //get
   p2:=1;
   for p:=1 to xlen do
   begin
   int1:=x.pbytes[p-1]-xdata.pbytes[p2-1];
   if (int1<0) then int1:=int1+256;
   x.pbytes[p-1]:=byte(int1);
   inc(p2);
   if (p2>xdatalen) then p2:=1;
   end;//p
   end;//s
//.clear
p:=1;
i:=1;
i2:=1;
redo:
//.swap width
if (i>xreflen) then
   begin
   case i2 of
   0,1:i:=2;
   2:i:=4;
   3:i:=7;
   4:i:=3;
   5:i:=9;
   6:i:=13;
   else i:=3;
   end;
   inc(i2);
   if (i2>=7) then i2:=0;
   if (i>xreflen) then i:=1;
   end;
v:=xref.pbytes[i-1];
inc(i);
p2:=p+v;
//.do swap
if (p2<=xlen) then
   begin
   b:=x.pbytes[p-1];
   x.pbytes[p-1]:=x.pbytes[p2-1];
   x.pbytes[p2-1]:=b;
   p:=p2;
   end;
//inc
inc(p);
if (p<=xlen) then goto redo;

//.encrypt
if (s>=100) and (s<200) then
   begin
   //get
   p2:=1;
   for p:=1 to xlen do
   begin
   int1:=x.pbytes[p-1]+xdata.pbytes[p2-1];
   if (int1>=256) then int1:=int1-256;
   x.pbytes[p-1]:=byte(int1);
   inc(p2);
   if (p2>xdatalen) then p2:=1;
   end;//p
   end;//s

//xstyle inc
if (sindex<high(xstyle)) then
   begin
   inc(sindex);
   goto redo2;
   end;

//successful
result:=true;
skipend:
except;end;
try
bautofree(xdata);
bautofree(x);
bfree(xref);
except;end;
end;
//## low__lestrb ##
function low__lestrb(x:tstr8):tstr8;//lite-encoder
begin
try
result:=bnew;
result.add(x);
low__lestr(result);
except;end;
try;result.oautofree:=true;except;end;
end;
//## low__lestr ##
function low__lestr(x:tstr8):boolean;//lite-encoder
label
   skipend;
var
   p:longint;
begin
try
//defaults
result:=false;
//check
if (not block(x)) or (x.len<=0) then goto skipend;
//get
low__xysort(104,bcopystr1('kljasd()*3aeasff',1,maxint),x);    //A                     //90
//successful
result:=true;
skipend:
except;end;
try;bunlockautofree(x);except;end;
end;
//## low__ldstrb ##
function low__ldstrb(x:tstr8):tstr8;//lite-decoder
begin
try
result:=bnew;
result.add(x);
low__ldstr(result);
except;end;
try;result.oautofree:=true;except;end;
end;
//## low__ldstr ##
function low__ldstr(x:tstr8):boolean;//lite-decoder
label
   skipend;
var
   p:longint;
begin
try
//defaults
result:=false;
//check
if (not block(x)) or (x.len<=0) then goto skipend;
//get
low__xysort(204,bcopystr1('kljasd()*3aeasff',1,maxint),x);
//successful
result:=true;
skipend:
except;end;
try;bunlockautofree(x);except;end;
end;
//## low__cestrb ##
function low__cestrb(x:tstr8):tstr8;//lite-decoder
begin
try
result:=bnew;
result.add(x);
low__cestr(result);
except;end;
try;result.oautofree:=true;except;end;
end;
//## low__cestr ##
function low__cestr(x:tstr8):boolean;//critical-encoder
label
   skipend;
var//Note: Now super fast for large daata-blocks 1MB+ - 12nov2019
   v32,v,xlen,dp,p:longint;
   v1,v2:tstr8;
   a1,a2:byte;
   bol1:boolean;
begin
try
//defaults
result:=false;
v1:=nil;
v2:=nil;
//check
if (not block(x)) or (x.len<=0) then goto skipend;
//get
xlen:=x.len;
v32:=low__crc32seedable(x,8234723);
//.v1 - 09nov2019
v1:=bnew;
v1.setlen(xlen);
for p:=1 to xlen do v1.pbytes[p-1]:=byte(random(255));
//.v2
v2:=bnew;
v2.setlen(xlen);
for p:=1 to xlen do
begin
v:=x.pbytes[p-1]-v1.pbytes[p-1];
if (v<0) then inc(v,256);
v2.pbytes[p-1]:=byte(v);
end;//p
//.sort
low__xysort(1,bcopyarray([51,52,53,57,56,55,97,102]),v1);
low__xysort(0,bcopyarray([57,56,50,51,78,66,106,107,65,83,68,70,108,107,106]),v1);
low__xysort(3,bcopyarray([48,57,52,51,53,97,57,100,103]),v2);
low__xysort(5,bcopyarray([35,35,97,100,115,102,111,105,117,41,40,95,41,49]),v2);
x.setlen(xlen*2);
dp:=1;
for p:=1 to xlen do
begin
//.isodd
case (p<>((p div 2)*2)) of
true:begin
   x.pbytes[dp+0-1]:=v2.pbytes[p-1];
   x.pbytes[dp+1-1]:=v1.pbytes[p-1];
   end;
false:begin
   x.pbytes[dp+0-1]:=v1.pbytes[p-1];
   x.pbytes[dp+1-1]:=v2.pbytes[p-1];
   end;
end;
//.inc
inc(dp,2);
end;//p

//.finalise
x.insint4(xlen,0);
x.addint4(v32);
//was: result:=from32bit(xlen)+result+from32bit(v32);

//successful
result:=true;
skipend:
except;end;
try
bfree(v1);
bfree(v2);
bunlockautofree(x);
except;end;
end;
//## low__cdstrb ##
function low__cdstrb(x:tstr8):tstr8;//lite-decoder
begin
try
result:=bnew;
result.add(x);
low__cdstr(result);
except;end;
try;result.oautofree:=true;except;end;
end;
//## low__cdstr ##
function low__cdstr(x:tstr8):boolean;//critical-decoder BUT doesn't shutdown! - 09nov2019, 08mar2018
begin
try;result:=low__cdstr2(x,false,true);except;end;
end;
//## low__cdstr2 ##
function low__cdstr2(x:tstr8;xshow,xclose:boolean):boolean;//critical-decoder BUT doesn't shutdown! - 09nov2019, 08mar2018
label
   skipend;
const
   emsg:array[0..69] of byte=(218,205,222,194,223,132,109,155,156,162,211,159,129,195,216,213,210,222,203,206,147,205,155,73,147,161,196,171,194,227,210,203,223,209,150,129,215,209,149,139,145,152,197,133,208,229,134,206,204,223,138,194,225,201,141,138,158,83,211,213,198,224,202,203,223,227,211,129,219,146);
var
   dlen,vlen,a1,a2,a3,sp,int1,v32,v,xlen,p:longint;
   v1,v2:tstr8;
begin
try
//defaults
result:=false;
v1:=nil;
v2:=nil;
//check
if not block(x) then goto skipend;
//.error check #1
if (x.len<8) then
   begin
   if xclose then
      begin
      showerror8(low__ldstrb(bcopyarray(emsg)));
      sihalt;
      end;
   if xshow then showerror('Decode error #1');
   exit;
   end;
//init
dlen:=x.int4[0];
v32:=x.int4[x.len-1-3];
bdel1(x,1,4);
bdel1(x,x.len-3,4);
xlen:=x.len;
//.error check #2
if (dlen<=0) then
   begin
   if xclose then
      begin
      showerror8(low__ldstrb(bcopyarray(emsg)));
      sihalt;
      end;
   if xshow then showerror('Decode error #2');
   exit;
   end;
//get
vlen:=xlen div 2;
v1:=bnew;
v2:=bnew;
v1.setlen(vlen);
v2.setlen(vlen);
sp:=1;
for p:=1 to vlen do
begin
//.isodd
case (p<>((p div 2)*2)) of
true:begin
   v2.pbytes[p-1]:=x.pbytes[sp+0-1];
   v1.pbytes[p-1]:=x.pbytes[sp+1-1];
   end;
false:begin
   v1.pbytes[p-1]:=x.pbytes[sp+0-1];
   v2.pbytes[p-1]:=x.pbytes[sp+1-1];
   end;
end;//case
//.inc
inc(sp,2);
if ((sp+1)>xlen) then break;
end;//p

//.sort
low__xysort(0,bcopyarray([57,56,50,51,78,66,106,107,65,83,68,70,108,107,106]),v1);//fixed incorrect v1/v2 assignment order - 09nov2019
low__xysort(1,bcopyarray([51,52,53,57,56,55,97,102]),v1);
low__xysort(5,bcopyarray([35,35,97,100,115,102,111,105,117,41,40,95,41,49]),v2);
low__xysort(3,bcopyarray([48,57,52,51,53,97,57,100,103]),v2);

//.result
x.setlen(vlen);
for p:=1 to vlen do
begin
v:=v2.pbytes[p-1]+v1.pbytes[p-1];
if (v>255) then dec(v,256);
x.pbytes[p-1]:=byte(v);
end;//p

//.v32 check
int1:=low__crc32seedable(x,8234723);

//.error check #3
if (int1<>v32) then
   begin
   if xclose then
      begin
      showerror8(low__ldstrb(bcopyarray(emsg)));
      sihalt;
      end;
   if xshow then showerror('Decode error #3');
   exit;
   end;
//.error check #4
if (x.len<=0) then
   begin
   if xclose then
      begin
      showerror8(low__ldstrb(bcopyarray(emsg)));
      sihalt;
      end;
   if xshow then showerror('Decode error #4');
   exit;
   end;
//successful
result:=true;
skipend:
except;end;
try
bfree(v1);
bfree(v2);
bunlockautofree(x);
except;end;
end;
//## low__cemixb ##
function low__cemixb(x:tstr8):tstr8;//27apr2021
begin
try
result:=bnew;
result.add(x);
low__cemix(result);
except;end;
try;result.oautofree:=true;except;end;
end;
//## low__cemixc ##
function low__cemixc(x:string;xasarray:boolean):string;//critical-encoder dual layer - 22mar2021
var
   a:tstr8;
begin
try
result:='';
a:=nil;
a:=bnew;
a.text:=x;
low__cemix(a);
if xasarray then result:=a.textarray else result:=a.text;
except;end;
try;bfree(a);except;end;
end;
//## low__cemix ##
function low__cemix(x:tstr8):boolean;//critical-encoder dual layer
var
   bol1,bol2:boolean;
begin
try
result:=false;
block(x);
zzstr(x,98);
bol1:=low__ecapbin(x,true,true);
bol2:=low__cestr(x);
result:=bol1 and bol2;
except;end;
try;bunlockautofree(x);except;end;
end;
//## low__cdmixb ##
function low__cdmixb(x:tstr8):tstr8;//27apr2021
begin
try
result:=bnew;
result.add(x);
low__cdmix(result);
except;end;
try;result.oautofree:=true;except;end;
end;
//## low__cdmix ##
function low__cdmix(x:tstr8):boolean;//critical-decoder dual layer
var
   bol1,bol2:boolean;
begin
try
result:=false;
block(x);
zzstr(x,99);
bol1:=low__cdstr(x);
bol2:=low__ecapbin(x,false,true);
result:=bol1 and bol2;
except;end;
try;bunlockautofree(x);except;end;
end;
//## amakecheck ##
function amakecheck(x:array of byte):longint;
var
   a:tstr8;
begin
try
a:=bnew_autofree;
a.aadd(x);
result:=xmakecheck(a);
except;end;
end;
//## smakecheck ##
function smakecheck(x:string):longint;
var
   a:tstr8;
begin
try
a:=bnew_autofree;
a.text:=x;
result:=xmakecheck(a);
except;end;
end;
//## imakecheck ##
function imakecheck(x:longint):longint;
var
   a:tstr8;
begin
try
a:=bnew_autofree;
a.text:=inttostr(x);
result:=xmakecheck(a);
except;end;
end;
//## xmakecheck ##
function xmakecheck(x:tstr8):longint;
label
   skipend;
var
   v,p:longint;
   z:tint4;
begin
try
//defaults
result:=0;
//check
if zznil(x,2031) or (x.len<1) then goto skipend;
//get
for p:=1 to x.len do
begin
v:=x.pbytes[p-1];
case v of
0     :dec(result,197);
1..2  :inc(result,44);
3..16 :dec(result,500);
17..24:inc(result,91);
25..32:dec(result,25);
33..54:inc(result,66);
55..68:inc(result,2);
69..73:dec(result,1);
74..88:inc(result,5);
89..100:inc(result,33);
101..109:inc(result,50);
110..114:dec(result,21);
115..122:inc(result,13);
123..140:inc(result,17);
141..158:inc(result,73);
159..169:dec(result,12);
170..182:inc(result,19);
183..202:dec(result,6);
203..215:inc(result,90);
216..227:inc(result,114);
228..239:dec(result,87);
240..254:inc(result,31);
255:dec(result,3);
end;//case
end;//p
skipend:
//add length
inc(result,x.len);
inc(result,x.len div 3);
//add default ID offset
inc(result,59324);
//roll some of the values
z.val:=result;
z.bytes[0]:=255-z.bytes[0];
z.bytes[2]:=255-z.bytes[2];
result:=z.val;
except;end;
try;bautofree(x);except;end;
end;
//## acheck ##
procedure acheck(x:array of byte;xuserval:longint);
var
   a:tstr8;
begin
try
if (xuserval=-133) then exit;//disable checker
a:=bnew_autofree;
a.aadd(x);
xcheck(a,xuserval);
except;end;
end;
//## scheck ##
function scheck(x:string;xuserval:longint):boolean;
var
   a:tstr8;
begin
try
result:=false;
a:=bnew_autofree;
a.text:=x;
if xcheck(a,xuserval) then result:=true;
except;end;
end;
//## icheck ##
procedure icheck(x,xuserval:longint);
var
   a:tstr8;
begin
try
a:=bnew_autofree;
a.text:=inttostr(x);
xcheck(a,xuserval);
except;end;
end;
//## xcheck ##
function xcheck(x:tstr8;xuserval:longint):boolean;
var
   a:tstr8;
   xval:longint;
begin
try
//defaults
result:=false;
//get
if (not block(x)) or (x.len<1) then
   begin
   xuserval:=0;
   xval:=-1;
   end
else xval:=xmakecheck(x);
//show fatal error
if (xval<>xuserval) then
   begin
   //Note: Message below is same for other content checkers BUT this one is
   //      encrypted via "low__cemix()" and thus cannot be patterned matched
   //      by code Hackers to detect security check points easily - 30aug2020
   //'Fatal Error: Program is incomplete, damaged or has been tampered with.'
   a:=bnew;
   a.aadd([81,0,0,0,159,214,17,48,48,177,74,58,70,15,121,35,234,93,197,240,107,83,233,122,48,71,183,2,133,78,215,100,29,62,118,47,89,84,41,180,197,222,248,221,180,38,210,7,36,2,197,213,197,122,180,46,4,226,210,254,166,5,35,114,220,36,127,174,151,5,151,86,139,73,243,44,251,165,196,8,244,125,197,19,167,52,173,50,1,151,197,64,33,196,254,103,89,62,172,46,140,75,21,79,92,164,252,92,184,224,130,8,226,146,243,181,59,174,86,51,160,1,179,226,251,126,142,208,214,71,50,173,20,36,232,5,206,199,150,48,190,220,175,242,146,73,23,193,191,191,160,184,242,223,245,71,169,40,138,72,152,41,44,112,113,69,46,39,244,255]);
   low__cdmix(a);
   showerror8(a);
   sihalt;
   end
else result:=true;
except;end;
try;bunlockautofree(x);except;end;//28jan2021
end;

//protect support --------------------------------------------------------------
//## protect_text ##
function protect_text(xcode:longint;xtext:string):string;
begin
try
result:='';
if scheck(xtext,xcode) then result:=xtext;
except;end;
end;
//## xcodecheck ##
procedure xcodecheck;//11oct2022
label
   redo,skipone,skipdone,skipend;
var
   z1,z2:tint4;
   i1,i2,aid,bid,ap,bp,a1,a2,a3,b1,b2,b3,v,p:longint;
   x:tstr8;
   aonce,bonce:boolean;
   e:string;
begin
try
//defaults
x:=nil;
ap:=0;
bp:=0;
aid:=0;
bid:=0;
//check
if (programcheck_mode=(-91234351-5)) then exit;//use -91234356 to disable security check - 11oct2022
//check
if (programcheck_mode<>(234876+21)) then goto skipdone;//must use "234897" for a security check - 11oct2022
//init
x:=bnew;
if not low__fromfile(low__exename,x,e) then goto skipend;//fail to load file -> skip security check - 11oct2022
//.a
aonce:=true;
a1:=programcode_checkid[0];
a2:=programcode_checkid[1];
a3:=programcode_checkid[2];
//.b
bonce:=true;
b1:=programcode_checkid2[0];
b2:=programcode_checkid2[1];
b3:=programcode_checkid2[2];
//get
p:=1;
redo:
v:=x.pbytes[p-1];
//.skip over security checkid
if aonce and (v=a1) and (x.bytes[p]=a2) and (x.bytes[p+1]=a3) and x.asame4(p-1,low(programcode_checkid),high(programcode_checkid)-5,programcode_checkid,true) then//exclude the very last four chars at least - 11oct2022
   begin
   aonce:=false;
   ap:=p+sizeof(programcode_checkid)-5;
   inc(p,sizeof(programcode_checkid));
   goto skipone;
   end;
//.skip over security checkid2
if bonce and (v=b1) and (x.bytes[p]=b2) and (x.bytes[p+1]=b3) and x.asame4(p-1,low(programcode_checkid2),high(programcode_checkid2)-5,programcode_checkid2,true) then//exclude the very last four chars at least - 11oct2022
   begin
   bonce:=false;
   bp:=p+sizeof(programcode_checkid2)-5;
   inc(p,sizeof(programcode_checkid2));
   goto skipone;
   end;

//.calc b
case v of
0     :dec(bid,17);
1..2  :inc(bid,14);
3..15 :dec(bid,350);
16..24:inc(bid,19);
25..32:dec(bid,3);
33..54:inc(bid,73);
55..68:inc(bid,3);
69..73:dec(bid,2);
74..95:dec(bid,6);
96..100:inc(bid,24);
101..110:inc(bid,52);
111..140:inc(bid,15);
141..158:inc(bid,112);
159..169:dec(bid,11);
170..182:inc(bid,234);
183..192:dec(bid,7);
193..215:inc(bid,83);
216..227:inc(bid,127);
228..232:dec(bid,52);
233..254:inc(bid,101);
255:dec(bid,10);
end;//case

//.calc a
case v of
0     :dec(aid,197);
1..2  :inc(aid,44);
3..15 :dec(aid,500);
16..24:inc(aid,91);
25..32:dec(aid,25);
33..54:inc(aid,66);
55..68:inc(aid,2);
69..73:dec(aid,1);
74..95:inc(aid,5);
96..100:inc(aid,33);
101..110:inc(aid,50);
111..140:inc(aid,17);
141..158:inc(aid,73);
159..169:dec(aid,12);
170..182:inc(aid,19);
183..192:dec(aid,6);
193..215:inc(aid,90);
216..227:inc(aid,114);
228..232:dec(aid,87);
233..254:inc(aid,31);
255:dec(aid,3);
end;//case

//.loop
inc(p);
skipone:
if (p<=x.len) then goto redo;

//add length
//.a
inc(aid,x.len);
inc(aid,98712);
//.b
inc(bid,x.len div 3);
inc(aid,187231);

//show fatal error
skipdone:
i1:=high(programcode_checkid)-3;
i2:=high(programcode_checkid2)-3;
z1.val:=aid;
z2.val:=bid;

{//debug only:
showbasic(
inttostr(aid)+'<<A>>'+rcode+
'a: '+inttostr(z1.bytes[0])+'='+inttostr(programcode_checkid[i1])+rcode+
'b: '+inttostr(z1.bytes[1])+'='+inttostr(programcode_checkid[i1+1])+rcode+
'c: '+inttostr(z1.bytes[2])+'='+inttostr(programcode_checkid[i1+2])+rcode+
'd: '+inttostr(z1.bytes[3])+'='+inttostr(programcode_checkid[i1+3])+rcode+
inttostr(bid)+'<<B>>'+rcode+
'a: '+inttostr(z2.bytes[0])+'='+inttostr(programcode_checkid2[i2])+rcode+
'b: '+inttostr(z2.bytes[1])+'='+inttostr(programcode_checkid2[i2+1])+rcode+
'c: '+inttostr(z2.bytes[2])+'='+inttostr(programcode_checkid2[i2+2])+rcode+
'd: '+inttostr(z2.bytes[3])+'='+inttostr(programcode_checkid2[i2+3])+rcode+
'');
{}//yyy

if (z1.bytes[0]<>programcode_checkid[i1])  or (z1.bytes[1]<>programcode_checkid[i1+1])  or (z1.bytes[2]<>programcode_checkid[i1+2])  or (z1.bytes[3]<>programcode_checkid[i1+3]) or
   (z2.bytes[0]<>programcode_checkid2[i2]) or (z2.bytes[1]<>programcode_checkid2[i2+1]) or (z2.bytes[2]<>programcode_checkid2[i2+2]) or (z2.bytes[3]<>programcode_checkid2[i2+3]) then
   begin
   //Note: Message below is same for other content checkers BUT this one is
   //      encrypted via "low__cemix()" and thus cannot be patterned matched
   //      by code Hackers to detect security check points easily - 30aug2020
   //'Fatal Error: Program is incomplete, damaged or has been tampered with.'
   if (x=nil) then x:=bnew else x.clear;
   x.aadd([81,0,0,0,159,214,17,48,48,177,74,58,70,15,121,35,234,93,197,240,107,83,233,122,48,71,183,2,133,78,215,100,29,62,118,47,89,84,41,180,197,222,248,221,180,38,210,7,36,2,197,213,197,122,180,46,4,226,210,254,166,5,35,114,220,36,127,174,151,5,151,86,139,73,243,44,251,165,196,8,244,125,197,19,167,52,173,50,1,151,197,64,33,196,254,103,89,62,172,46,140,75,21,79,92,164,252,92,184,224,130,8,226,146,243,181,59,174,86,51,160,1,179,226,251,126,142,208,214,71,50,173,20,36,232,5,206,199,150,48,190,220,175,242,146,73,23,193,191,191,160,184,242,223,245,71,169,40,138,72,152,41,44,112,113,69,46,39,244,255]);
   low__cdmix(x);
   showerror8(x);
   siClose;//11oct2022
   end;
skipend:
except;end;
try;bfree(x);except;end;//28jan2021
end;
{//!!!! Exclude this code from release versions of programs !!!!!!/
//## low__makecodecheck ##
procedure low__makecodecheck(xfilename:string);
label
   redo,skipone,skipdone,skipend;
var
   i4:tint4;
   aid,bid,ap,bp,a1,a2,a3,b1,b2,b3,v,p:longint;
   x:tstr8;
   aonce,bonce:boolean;
   e:string;
begin
try
//defaults
x:=nil;
ap:=0;
bp:=0;
aid:=0;
bid:=0;
//init
x:=bnew;
if not low__fromfile(xfilename,x,e) then goto skipend;//fail to load file -> skip security check - 11oct2022
//.a
aonce:=true;
a1:=programcode_checkid[0];
a2:=programcode_checkid[1];
a3:=programcode_checkid[2];
//.b
bonce:=true;
b1:=programcode_checkid2[0];
b2:=programcode_checkid2[1];
b3:=programcode_checkid2[2];
//get
p:=1;
redo:
v:=x.pbytes[p-1];
//.skip over security checkid
if aonce and (v=a1) and (x.bytes[p]=a2) and (x.bytes[p+1]=a3) and x.asame4(p-1,low(programcode_checkid),high(programcode_checkid)-5,programcode_checkid,true) then//exclude the very last four chars at least - 11oct2022
   begin
   aonce:=false;
   ap:=p+sizeof(programcode_checkid)-5;
   inc(p,sizeof(programcode_checkid));
   goto skipone;
   end;
//.skip over security checkid2
if bonce and (v=b1) and (x.bytes[p]=b2) and (x.bytes[p+1]=b3) and x.asame4(p-1,low(programcode_checkid2),high(programcode_checkid2)-5,programcode_checkid2,true) then//exclude the very last four chars at least - 11oct2022
   begin
   bonce:=false;
   bp:=p+sizeof(programcode_checkid2)-5;
   inc(p,sizeof(programcode_checkid2));
   goto skipone;
   end;

//.calc b
case v of
0     :dec(bid,17);
1..2  :inc(bid,14);
3..15 :dec(bid,350);
16..24:inc(bid,19);
25..32:dec(bid,3);
33..54:inc(bid,73);
55..68:inc(bid,3);
69..73:dec(bid,2);
74..95:dec(bid,6);
96..100:inc(bid,24);
101..110:inc(bid,52);
111..140:inc(bid,15);
141..158:inc(bid,112);
159..169:dec(bid,11);
170..182:inc(bid,234);
183..192:dec(bid,7);
193..215:inc(bid,83);
216..227:inc(bid,127);
228..232:dec(bid,52);
233..254:inc(bid,101);
255:dec(bid,10);
end;//case

//.calc a
case v of
0     :dec(aid,197);
1..2  :inc(aid,44);
3..15 :dec(aid,500);
16..24:inc(aid,91);
25..32:dec(aid,25);
33..54:inc(aid,66);
55..68:inc(aid,2);
69..73:dec(aid,1);
74..95:inc(aid,5);
96..100:inc(aid,33);
101..110:inc(aid,50);
111..140:inc(aid,17);
141..158:inc(aid,73);
159..169:dec(aid,12);
170..182:inc(aid,19);
183..192:dec(aid,6);
193..215:inc(aid,90);
216..227:inc(aid,114);
228..232:dec(aid,87);
233..254:inc(aid,31);
255:dec(aid,3);
end;//case

//.loop
inc(p);
skipone:
if (p<=x.len) then goto redo;

//add length
//.a
inc(aid,x.len);
inc(aid,98712);
//.b
inc(bid,x.len div 3);
inc(aid,187231);

//store
//.a
i4.val:=aid;
x.pbytes[ap+0]:=i4.bytes[0];
x.pbytes[ap+1]:=i4.bytes[1];
x.pbytes[ap+2]:=i4.bytes[2];
x.pbytes[ap+3]:=i4.bytes[3];
//.b
i4.val:=bid;
x.pbytes[bp+0]:=i4.bytes[0];
x.pbytes[bp+1]:=i4.bytes[1];
x.pbytes[bp+2]:=i4.bytes[2];
x.pbytes[bp+3]:=i4.bytes[3];

//save
if      (ap=0) then showbasic('Bad number A')
else if (bp=0) then showbasic('Bad number B')
else if not low__tofile(xfilename,x,e) then showbasic('Save failed: '+e);
skipend:
except;end;
try;bfree(x);except;end;//28jan2021
end;
{}//!!!!
//## low__showhelp ##
procedure low__showhelp(dshow:boolean);
var
   a:tbasicprg2;
   dx,dy,dw,dh:longint;
begin
try
{//was:
//create
dw:=700;
dh:=600;
if zznil(programhelpviewer,2040) then
   begin
   //range
   if (dw<=0) then dw:=700;
   if (dh<=0) then dh:=700;
   //get
   programhelpviewer:=thelpviewer.create;
   programhelpviewer.setsize(dw,dh);
   end;
//show
programhelpviewer.center;
programhelpviewer.show;
{}

//now:
if (system_program<>nil) and (system_program is tbasicprg2) then
   begin
   //init
   a:=(system_program as tbasicprg2);
   //get
   case dshow of
   true:begin
      if not a.rootwin.xhavemainhelp then a.rootwin.xmainhelp;
      a.rootwin.rightvisible:=dshow;
      end;
   false:if a.rootwin.xhavemainhelp then a.rootwin.rightvisible:=dshow;
   end;//case
  //.set style here
  a.rootwin.rightmax:=vihelp_max;
   //store
   if (dshow<>vihelp_show) and visyssettingsloaded then
      begin
      syssettings.b['help.show']:=dshow;
      visyncandsave;
      end;
   end;
except;end;
end;
//## low__createlink ##
procedure low__createlink(df,sf,dswitches,iconfilename:string);//10apr2019, 14NOV2010
var//Note: df=> filename to save link as, sf=filename we are linking to
   //ShlObj, ActiveX, ComObj
  iobject:iunknown;
  islink:ishelllink;
  ipfile:ipersistfile;
begin
try
//defaults
iobject:=nil;
//init
iobject:=createcomobject(CLSID_ShellLink);
islink:=iobject as ishelllink;
ipfile:=iobject as ipersistfile;
//clean
low__remfile(df);
//link
with islink do
begin
setarguments(pchar(dswitches));
setpath(pchar(sf));
setworkingdirectory(pchar(low__extractfilepath(sf)));
if (iconfilename<>'') then seticonlocation(pchar(iconfilename),0);//14NOV2010
end;
//.link.save
ipfile.save(pwchar(widestring(df)),false);
except;end;
//On 01mar2021 @2am the below line of code starting causing fatal error -> need to lookup if it actually is required or if there is a "correct" method for getting rid of this object instance - 01mar2021
//needs fixing!!!!!!!!!!!!!!!!: try;freeobj(@iobject);except;end;
//Note: "iunknown" is a special instance that is automatically destroyed by the compiler - 27apr2021
end;
//## runLOW ##
procedure runLOW(fDOC,fPARMS:string);//stress tested on Win98/WinXP - 27NOV2011, 06JAN2011
begin
try;shellexecute(longint(0),nil,PChar(fDoc),PChar(fPARMS),nil,1);except;end;
end;
//## low__vol ##
function low__vol(var xfilename:string):boolean;//check once only - 10OCT2010
label
   skipdone;
var
   z:string;
begin
try
//defaults
result:=false;
xfilename:='';
//get
if (sys_sndvol32='') then
   begin
   //Vista
   //.1
   z:=winsystem+'SNDVOL.EXE';
   if low__fileexists(z) then goto skipdone;
   //.2
   z:=winroot+'SNDVOL.EXE';
   if low__fileexists(z) then goto skipdone;
   //XP
   z:=winsystem+'SNDVOL32.EXE';
   if low__fileexists(z) then goto skipdone;
   //Win98
   z:=winroot+'SNDVOL32.EXE';
   if low__fileexists(z) then goto skipdone;
   //set
   skipdone:
   if not low__fileexists(z) then z:='?';//mark as not found - 10mar2021
   sys_sndvol32:=z;
   end;
//set
if (sys_sndvol32<>'') and (sys_sndvol32<>'?') then
   begin
   xfilename:=sys_sndvol32;
   result:=true;
   end;
except;end;
end;
//## low__canshowvol ##
function low__canshowvol:boolean;
var
   str1:string;
begin
try;result:=low__vol(str1);except;end;
end;
//## low__showvol ##
procedure low__showvol;
var
   str1:string;
begin
try;if low__vol(str1) then runlow(str1,'');except;end;
end;
//## stableobj ##
function stableobj(x:tobject):boolean;//07mar2021
begin
try
result:=false;
if zznil(x,2050)             then exit
else if (x is tbasicsystem)  then result:=(x as tbasicsystem).stable
else if (x is tbasiccontrol) then result:=(x as tbasiccontrol).stable;
except;end;
end;
//## freeobj ##
function freeobj(x:pobject):boolean;//02feb2021, 05DEC2011, 14JAN2011, 15OCT2004
{//was:
   //## xbasicthreadstop ##
   procedure xbasicthreadstop;
   label
      redo;
   var
      aref:comp;
      a:tbasicthreadstop;
      p:longint;
   begin
   try
   //defaults
   a:=(x^ as tbasicthreadstop);
   if zznil(a,2051) then exit;
   //muststop
   if a.stopping then
      begin
      x^:=nil;//nil only -> since another copy is already shuting this object down - 20feb2021
      exit;
      end;
   //signal thread to stop
   aref:=ms64+60000;//60sec timeout
   a.muststop;
   //timer is caught in a VCL event -> don't wait - 10may2021
   if a.vcl_waiting then
      begin
      x^:=nil;//nil only -> since another copy is already shuting this object down - 20feb2021
      a.mustfree;
      exit;
      end;
   //wait for thread to finish
   redo:
   if (not a.stopped) and (aref>=ms64) then
      begin
      app__processallmessages;
      sleep(20);
      goto redo;
      end;
   //successful
   x^.free;
   x^:=nil;
   except;end;
   end;
{}//yyyyyyyyyyyyyyy
begin//Note: as a function this proc supports inline processing -> e.g. if a and b and freeobj() and d then -> which uses LESS code - 05may2020
try
result:=true;
//check
if (x=nil) or zznil(x^,3001)  then exit;
//hide
try;if (x^ is tcommonform)    then (x^ as tcommonform).visible:=false;except;end;
//counters
if      (x^ is tstringlist)   then satinc(satStringlist,-1)
else if (x^ is tbitmap)       then satinc(satBitmap,-1)
else if (x^ is tfilestream)   then satinc(satFilestream,-1)

{$ifdef jpeg}
else if (x^ is tjpegimage)    then satinc(satJpegimage,-1)//01may2021
{$endif}
//hide
else if (x^ is twincontrol) then
   begin
   with (x^ as twincontrol) do
   begin
   visible:=false;
   parent:=nil;
   end;
   end;

//-- shutdown handlers ---------------------------------------------------------
//tthread based
//was: if (x^ is tbasictimer)  then xbasictimer
//was: if (x^ is tbasicthreadstop) then xbasicthreadstop//21may2021
//general purpose shutdown handler
//else
   begin
   x^.free;
   zzdel(x^);//Note: Must immediately follow the object's "free" proc - 04may2021
   x^:=nil;
   end;
except;end;
end;
//## leakhunt ##
procedure leakhunt(x:longint;xlabel:string);
var//Note: xlabel is optional and updates when not "nil" - 28jan2021
   p:longint;
   //## xsetlabel ##
   procedure xsetlabel;
   begin
   if (sysleak_label[x]='') and (xlabel='') then sysleak_label[x]:='Leak count = '//must use a default label first time
   else if (xlabel<>'')                     then sysleak_label[x]:=xlabel;
   end;
   //## xinc ##
   procedure xinc;
   begin
   if (sysleak_counter[x]<1000000) then inc(sysleak_counter[x]) else sysleak_counter[x]:=0;//inc or reset from beginning - 28jan2021
   sysleak_show:=true;
   end;
begin//Note: Used to quickly narrow any system leaks by comparing "satinc" from HERE to THERE and store on screen in position "p" using label "xlabel" - 28jan2021
try
//check
if not system_debug then exit;
//range
x:=frcrange(x,-high(sysleak_start),high(sysleak_start));
//get
if (x>=1)       then
   begin
   for p:=(satEndof_overview+1) to satmax do if (satlabel(p)<>'') then sysleak_start[x][p]:=sysstats_active[p];
   xsetlabel;
   xinc;
   end
else if (x<=-1) then
   begin
   x:=-x;
   for p:=(satEndof_overview+1) to satmax do if (satlabel(p)<>'') then sysleak_stop[x][p]:=sysstats_active[p]-sysleak_start[x][p];//store the difference
   xsetlabel;
   xinc;
   end
else if (x=0) then
   begin
   sysleak_label[x]:='!!! Index of "0" not valid !!!  Use range 1..N or -1..-N';
   xinc;
   end;
except;end;
end;
//## leakinfo ##
function leakinfo(x:longint;var xdata:string):boolean;
var
   str1:string;
   p,xstart,xstop:longint;
begin
try
//defaults
result:=false;
xdata:='';
//check
if not system_debug then exit;
//range
x:=frcrange(x,-high(sysleak_start),high(sysleak_start));
if (x<0) then x:=-x;
//get
if (sysleak_label[x]<>'') then
   begin
   //init
   result:=true;
   str1:='';
   xstart:=0;
   xstop:=0;
   xdata:=sysleak_label[x];
   //get
   if (x=0) then
      begin
      //nil
      end
   else
      begin
      for p:=0 to satmax do
      begin
      inc(xstart,sysleak_start[x][p]);
      inc(xstop,sysleak_stop[x][p]);
      if (sysleak_stop[x][p]<>0) then
         begin
         if (length(str1)<=100) then
            begin
            str1:=str1+'['+satlabel(p)+'/'+low__thousands64(sysleak_stop[x][p])+']';
            if (length(str1)>=100) then str1:=str1+'...';
            end;
         end;
      end;//p
      end;

   //finish
   xdata:=str1;
   //xdata:=low__64(system_debug_val1)+'<< GUI: ' +low__aorbstr('normal','fast',system_debugFAST)+'  procload: '+low__64(systimer_procload)+'/'+low__64(systimer_procloadPeak)+'  objs: '+low__64(systrack_objcount)+'  ptrs: '+low__64(systrack_ptrcount)+' ptr.bytes: '+low__64(systrack_ptrbytes)+'  total: '+low__64(sysstats_total)+' <-- '+inttostr(x)+')====> '+low__insstr('+',xstop>=1)+low__thousands64(xstop)+' / '+low__thousands64(xstart+xstop)+' <==== '+sysleak_label[x]+' ====> '+str1+' <==ID'+low__thousands64(sysleak_counter[x])+#32;
   end;
except;end;
end;
//## low__sysadd ##
procedure low__sysadd(x:tobject);
var
   p:longint;
begin
try
if (x<>nil) then
   begin
   //check for existing
   for p:=0 to high(syslist) do if (x=syslist[p]) then exit;
   //add
   for p:=0 to high(syslist) do if (nil=syslist[p]) then
      begin
      syslist[p]:=x;
      break;
      end;//p
   end;
except;end;
end;
//## low__sysdel ##
procedure low__sysdel(x:tobject);
var
   p:longint;
begin
try
if (x<>nil) then
   begin
   //find
   for p:=0 to high(syslist) do if (x=syslist[p]) then
      begin
      syslist[p]:=nil;
      break;
      end;//p
   end;
except;end;
end;
//## low__closecount ##
function low__closecount:longint;
var
   p:longint;
begin
try
//defaults
result:=sysclose_count;
//get
for p:=0 to high(syslist) do if zzok(syslist[p],1030) and (syslist[p] is tbasicsystem) then inc(result,(syslist[p] as tbasicsystem).closelocked);
except;end;
end;
//## low__closelock ##
procedure low__closelock;
begin
try;inc(sysclose_count,1);except;end;
end;
//## low__closeunlock ##
procedure low__closeunlock;
begin
try;sysclose_count:=frcmin(sysclose_count-1,0);except;end;
end;
//## satinc ##
procedure satinc(xindex,xcreate:longint);
const
   xmaxlimit=maxint-100;
   xminlimit=-xmaxlimit;
begin
try
//range
if      (xcreate>10)   then xcreate:=10
else if (xcreate<-10) then xcreate:=-10;
//inc
if (xindex>=0) and (xindex<=high(sysstats_active)) then
   begin
   case xcreate of
   1..maxint:begin//create
      if (xindex>satEndof_overview) then inc(sysstats_total,xcreate);//23apr2021
      if (sysstats_active[xindex]<=xmaxlimit)  then inc(sysstats_active[xindex],xcreate) else sysstats_active[xindex]:=0;
      if (sysstats_destroy[xindex]<=xmaxlimit) then inc(sysstats_create[xindex],xcreate) else sysstats_create[xindex]:=0;//persistant
      end;
   minint..-1:begin//destroy
      if (xindex>satEndof_overview) then inc(sysstats_total,xcreate);//23apr2021
      if (sysstats_active[xindex]>=xminlimit)  then inc(sysstats_active[xindex],xcreate) else sysstats_active[xindex]:=0;
      if (sysstats_destroy[xindex]>=xminlimit) then inc(sysstats_destroy[xindex],-xcreate) else sysstats_destroy[xindex]:=0;//persistant
      end;
   end;//case
   end;
except;end;
end;
//## satval ##
function satval(xindex:longint):longint;
begin
try;result:=0;if (xindex>=0) and (xindex<=high(sysstats_active)) then result:=sysstats_active[xindex];except;end;
end;
//## satstr ##
function satstr(xindex:longint):string;
begin
try;result:=inttostr(satval(xindex));except;end;
end;
//## satlabel ##
function satlabel(x:longint):string;
   //## r ##
   procedure r(x:string);
   begin
   result:=x;
   end;
begin
try
case x of
//.overview
satPartpaint        :r('partpaint');
satFullpaint        :r('fullpaint');
satDragstart        :r('drag.start');
satDragcapture      :r('drag.capture');
satDragpaint        :r('drag.paint');
satSizestart        :r('size.start');
satSizecapture      :r('size.capture');
satSizepaint        :r('size.paint');
satMaskcapture      :r('maskcapture');
satErrors           :r('errors');
//.core
satBasicprg         :r('basicprg');
satObjectex         :r('objectex');
satStr8             :r('str8');
satMask8            :r('mask8');
satBmp              :r('bmp');
satBitmap           :r('bitmap');
satBasicimage       :r('image');
satMidi             :r('midi');
satMidiopen         :r('midi open');
satMidiblocks       :r('midi blocks');
satBWP              :r('BWP');
satDynlist          :r('dynlist');
satDynbyte          :r('dynbyte');
satDynint           :r('dynint');
satDynstr           :r('dynstr');
satFrame            :r('frame');
satThread           :r('thread');
satTimer            :r('timer');
satVars8            :r('vars8');
satJpegimage        :r('jpegimage');
satFilestream       :r('filestream');
satPstring          :r('pstring');//05may2021
satWave             :r('wave');
satWaveopen         :r('wave open');
satAny              :r('any');
//.gui
satSystem           :r('system');
satControl          :r('control');
satTitle            :r('title');
satEdit             :r('edit');
satHead             :r('head');
satTick             :r('tick');
satToolbar          :r('toolbar');
satScroll           :r('scroll');
satNav              :r('nav');
satSplash           :r('splash');
satHelp             :r('help');
satColmatrix        :r('colmatrix');
satColor            :r('color');
satInfo             :r('info');
satMenu             :r('menu');
satCols             :r('columns');
satSetcolor         :r('setcolor');
else                 r('');//nil
end;//case
except;end;
end;
//## satsum ##
function satsum:string;
const
   xsep=' ';
   xpadder='             ';//13c
   xpadder2='--------------------------------------------------------';
var
   a:tstr8;
   i,p:longint;
   //## xpad ##
   function xpad(x:string):string;
   var
      int1,int2:longint;
   begin
   int1:=length(xpadder);
   int2:=frcmax(length(x),int1);
   result:=strcopy1(x,1,int2)+strcopy1(xpadder,1,int1-int2);
   end;
   //## xpadnum ##
   function xpadnum(x:string):string;
   var
      int1,int2:longint;
   begin
   int1:=4;
   int2:=frcmax(length(x),int1);
   result:=strcopy1(x,1,int2)+strcopy1(xpadder,1,int1-int2);
   end;
   //## xnum ##
   function xnum(x:comp):string;
   begin
   if (x=0)      then result:=xpad('-')
   else if (x<0) then result:=xpad('!'+low__thousands64(x))
   else               result:=xpad(low__thousands64(x));
   end;
   //## xaddsat ##
   procedure xaddsat(xindex,xnumber:longint);
   var
      str1,str2:string;
   begin
   //header
   if (xindex<0) then
      begin
      a.sadd(xpadnum('#')+xsep+xpad(ntranslate('Name'))+xsep+xpad(ntranslate('Total'))+xsep+ntranslate('Rate')+rcode);
      exit;
      end;
   //statistic
   str1:='';
   str2:='';
   if (sysstats_ratec[xindex]<>0) or (sysstats_rated[xindex]<>0) then
      begin
      if (sysstats_rated[xindex]<>0) then str1:='-'+low__thousands64(sysstats_rated[xindex])+'/s';
      if (sysstats_ratec[xindex]<>0) then str2:='+'+low__thousands64(sysstats_ratec[xindex])+'/s';
      end;
   a.sadd(xpadnum(inttostr(xnumber)+'. ')+xsep+xpad(satlabel(xindex))+xsep+xnum(sysstats_active[xindex])+xsep+str1+low__insstr('  ',(str1<>'') and (str2<>''))+str2+rcode);
   end;
   //## xsechead ##
   procedure xsechead(xtitle:string);
   begin
   a.sadd('-- '+xtitle+' --'+rcode);
   end;
begin
try
//defaults
result:='';
a:=nil;
//init
a:=bnew;

//overview -------------------------------------------------------------------------
xsechead('Overview');
xaddsat(-1,0);
i:=0;
for p:=0 to satEndof_overview do
begin
if (satlabel(p)<>'') then
   begin
   inc(i);
   xaddsat(p,i);
   end;
end;//p
a.sadd(rcode);

//core -------------------------------------------------------------------------
xsechead('Core');
xaddsat(-1,0);
i:=0;
for p:=(satEndof_overview+1) to satEndof_core do
begin
if (satlabel(p)<>'') then
   begin
   inc(i);
   xaddsat(p,i);
   end;
end;//p
a.sadd(rcode);

//gui --------------------------------------------------------------------------
xsechead('GUI');
xaddsat(-1,0);
i:=0;
for p:=(satEndof_core+1) to satEndof_gui do
begin
if (satlabel(p)<>'') then
   begin
   inc(i);
   xaddsat(p,i);
   end;
end;//p

//set
result:=a.text;
except;end;
try;bfree(a);except;end;
end;
//## ppadd ##
procedure ppadd(x:pointer);
var
   p:longint;
begin
try
if system_debug and (x<>nil) then
   begin
   //find existing
   for p:=0 to high(systrack_ptr) do if (x=systrack_ptr[p]) then exit;
   //add new
   for p:=0 to high(systrack_ptr) do if (nil=systrack_ptr[p]) then
      begin
      systrack_ptr[p]:=x;
      inc(systrack_ptrcount);
      break;
      end;//p
   end;
except;end;
end;
//## ppdel ##
procedure ppdel(x:pointer);
var
   p:longint;
begin
try
if system_debug and (x<>nil) then
   begin
   //find existing
   for p:=0 to high(systrack_ptr) do if (x=systrack_ptr[p]) then
      begin
      systrack_ptr[p]:=nil;
      dec(systrack_ptrcount);
      break;
      end;//p
   end;
except;end;
end;
//## ppok ##
function ppok(x:pointer;xid:longint):boolean;
begin
result:=(x<>nil);
if result then ppcheck(x,xid);
end;
//## ppnil ##
function ppnil(x:pointer;xid:longint):boolean;
begin
result:=(x=nil);
if not result then ppcheck(x,xid);
end;
//## ppcheck ##
procedure ppcheck(x:pointer;xid:longint);
label
   skipend;
var
   p:longint;
   bol1:boolean;
   sclass2:string;
begin
if system_debug then
   begin
   if (x=nil) then pperr('is nil','fatal',x,xid)
   else if (x<>nil) then
      begin
      //find
      bol1:=false;
      for p:=0 to high(systrack_ptr) do if (x=systrack_ptr[p]) then
         begin
         bol1:=true;
         break;
         end;//p
      //get
      if not bol1 then pperr('does not exist','fatal',x,xid);
      end;
   end;
skipend:
end;
//## pperr ##
procedure pperr(xreason,xlevel:string;x:pointer;xid:longint);
begin
try
showerror(
'-- Pointer Error --'+rcode+
rcode+
'Explanation: Pointer being referenced '+xreason+'.'+rcode+
rcode+
'* Severity: '+xlevel+rcode+
'* Pointer: '+low__64(longint(x))+rcode+
'* Ref ID: '+low__64(xid)+rcode+
'');
except;end;
end;
//## zzobjerr ##
procedure zzobjerr(xreason,xlevel,sclass2:string;xsatlabel,xid:longint);
var
   sclass:string;
begin
try
//get
if (xsatlabel<0) then sclass:='Unknown'
else
   begin
   sclass:=satlabel(xsatlabel);
   if (sclass='') then sclass:='Class has no sat label';
   end;
//set
showerror(
'-- Object Error --'+rcode+
rcode+
'Explanation: Object being referenced '+xreason+'.'+rcode+
rcode+
'* Severity: '+xlevel+rcode+
'* Class 1: '+sclass+rcode+
'* Class 2: '+low__udv(sclass2,'-')+rcode+
'* Ref ID: '+low__64(xid)+rcode+
'');
except;end;
end;
//## zzadd ##
procedure zzadd(x:tobject);
var
   p:longint;
begin
try
if system_debug and (x<>nil) then
   begin
   //find existing
   for p:=0 to high(systrack_obj) do if (x=systrack_obj[p]) then exit;
   //add new
   for p:=0 to high(systrack_obj) do if (nil=systrack_obj[p]) then
      begin
      systrack_obj[p]:=x;
      inc(systrack_objcount);
      break;
      end;//p
   end;
except;end;
end;
//## zzdel ##
procedure zzdel(x:tobject);
var
   p:longint;
begin
try
if system_debug and (x<>nil) then
   begin
   //find existing
   for p:=0 to high(systrack_obj) do if (x=systrack_obj[p]) then
      begin
      systrack_obj[p]:=nil;
      dec(systrack_objcount);
      break;
      end;//p
   end;
except;end;
end;
//## zzok ##
function zzok(x:tobject;xid:longint):boolean;
begin
result:=(x<>nil);
if result then zzobj2(x,-1,xid);
end;
//## zzok2 ##
function zzok2(x:tobject):boolean;
begin
result:=(x<>nil);
end;
//## zznil ##
function zznil(x:tobject;xid:longint):boolean;
begin
result:=(x=nil);
if not result then zzobj2(x,-1,xid);
end;
//## zznil2 ##
function zznil2(x:tobject):boolean;//12feb202
begin
result:=(x=nil);
end;
//## zzimg ##
function zzimg(x:tobject):boolean;//12feb2202
begin
result:=(x<>nil) and (x is tbasicimage);
end;
//## asimg ##
function asimg(x:tobject):tbasicimage;//12feb2202
begin
result:=nil;
if (x<>nil) and (x is tbasicimage) then result:=x as tbasicimage;
end;
//## zzany ##
function zzany(x:tobject):boolean;//13feb2202
begin
result:=(x<>nil) and (x is tany);
end;
//## asany ##
function asany(x:tobject):tany;//13feb2202
begin
result:=nil;
if (x<>nil) and (x is tany) then result:=x as tany;
end;
//## zzobj ##
function zzobj(x:tobject;xid:longint):tobject;
begin
result:=zzobj2(x,-1,xid);
end;
//## zzobj2 ##
function zzobj2(x:tobject;xsatlabel,xid:longint):tobject;
label
   skipend;
var
   p:longint;
   bol1:boolean;
   sclass2:string;
begin
result:=x;
if system_debug then
   begin
   if (x=nil) then zzobjerr('is nil','fatal','',xsatlabel,xid)
   else if (x<>nil) then
      begin
      //exceptions
      if (x=clipboard) then goto skipend;//07jun2021
      //find
      bol1:=false;
      for p:=0 to high(systrack_obj) do if (x=systrack_obj[p]) then
         begin
         bol1:=true;
         break;
         end;//p
      //class2
      sclass2:='-';
      try;sclass2:=x.classname;except;sclass2:='-';end;
      //get
      if not bol1 then zzobjerr('does not exist','fatal',sclass2,xsatlabel,xid);
      end;
   end;
skipend:
end;
//## zzvars ##
function zzvars(x:tvars8;xid:longint):tvars8;
begin
result:=x;
if system_debug then zzobj2(x,satVars8,xid);
end;
//## zzstr ##
function zzstr(x:tstr8;xid:longint):tstr8;
begin
result:=x;
if system_debug then zzobj2(x,satStr8,xid);
end;
{$ifdef jpeg}
//## zzjpg ##
function zzjpg(x:tjpegimage;xid:longint):tjpegimage;
begin
result:=x;
if system_debug then zzobj2(x,satJpegimage,xid);
end;
{$endif}

//## sifindframe ##
function sifindframe(xname:string):string;//07jun2022
label
   redo;
var
   xtrycount,p:longint;
   xonce:boolean;
begin
try
//defaults
result:='';
xonce:=true;
xtrycount:=0;
//find
redo:
for p:=0 to (system_framecount-1) do if low__comparetext(xname,system_framename[p]) then
   begin
   result:=system_framecode[p];
   break;
   end;
//check
if (result='') then
   begin
   //default frame can be a frame.name "@<name>" or frame.code "....."
   if (frame__default<>'') then
      begin
      if (strcopy1(frame__default,1,1)='@') then//as frame.name
         begin
         xonce:=false;
         xname:=strcopy1(frame__default,2,length(frame__default));
         //.emergency fallback - fixed - 07jun2022
         inc(xtrycount);
         if (xtrycount<=2) then goto redo;
         end
      else result:=frame__default;//as frame.code
      end;
   //fallback default
   if (result='') then result:='100,ss,dd';//modern
   end;
except;end;
end;
//## siframes ##
procedure siframes;//11oct2022
   //## xadd ##
   procedure xadd(xname,xcode:string);
   begin
   try
   //check
   if (xname='') or (xcode='') or (system_framecount>high(system_framename)) then exit;
   //get
   system_framename[system_framecount]:=xname;
   system_framecode[system_framecount]:=xcode;
   inc(system_framecount);
   except;end;
   end;
begin
try
//check
if (system_framecount>=1) then exit;
//get
xadd('Antique'        ,'m24|20,s,d|10,d,ds20|30,ds20,ds70|30,ds70,ds50|100,ds50,s');
xadd('Antique 2'      ,'m30|30,s,ds10|10,ds10,ds20|20,ds20,ds70|20,ds70,ds50|10,ds50,d|100,d,s');
xadd('Antique 3'      ,'m30|20,s,d|10,d,ds20|20,ds20,ds70|20,ds70,ds50|10,ds50,s|100,s,s');
xadd('Traditional'    ,'m16|80,ss,dd|100,dd,ss');
xadd('Traditional 2'  ,'m16|70,ss,dd|100,dd,ss');
xadd('Traditional 3'  ,'m16|50,ss,dd|10,dd,ss|35,ss,ss|100,dd,dd');
xadd('Traditional 4'  ,'m26|85,s,d|8,d,s|100,s,s');
xadd('Traditional 5'  ,'m26|70,s,d|8,d,s|100,s,s');
xadd('Flat'           ,'m32|20,ss,dd|8,dd,ss|65,ss,ss|100,dd,dd');
xadd('Flat 2'         ,'m22|10,ss,dd|4,dd,ss|82,ss,ss|100,dd,dd');
xadd('Flat 3'         ,'m22|95,ss,sd10|100,dd,dd');
xadd('Flat 4'         ,'m22|95,ss,sd30|100,dd,dd');
xadd('Flat 5'         ,'m22|95,sd30,ss|100,dd,dd');
xadd('Flat 6'         ,'m16|50,s,d|30,d,d|100,d,s');
xadd('Flat 7'         ,'m16|20,s,d|50,d,d|100,d,s');
xadd('Flat 8'         ,'m24|20,s,d|70,d,d|100,d,s');
xadd('Modern'         ,'m5|100,sb60,d');
xadd('Modern 2'       ,'m5|100,s,d');
xadd('Classic'        ,'m40|10,sb60,dd|20,dd,sb60|30,sb80,sb80|5,dd,sb60|5,dd,sb60|100,dd,sb60');
xadd('Classic 2'      ,'m40|10,sb60,dd|20,dd,ss60|30,ss80,ss80|5,dd,sb60|5,dd,sb60|100,dd,ss');
xadd('Classic 3'      ,'m40|10,sw60,dd|20,dd,ss60|30,ss80,ss80|8,dd,sd60|8,dd,sd60|100,dd,ss');
xadd('Lines'          ,'m22|10,ss,dd|5,dd,ss|30,ss,ss|5,dd,dd|30,ss,ss|5,dd,dd|30,ss,ss|100,dd,dd');
xadd('Lines 2'        ,'m22|10,ss,dd|5,dd,ss|20,ss,ss|5,dd,dd|20,ss,ss|5,dd,dd|20,ss,ss|5,dd,dd|20,ss,ss|100,dd,dd');
xadd('Double'         ,'m10|50,ss,dd50|12,dd50,db50|100,db50,dd');
xadd('Double 2'       ,'m24|30,ss,dd50|8,dd50,db50|20,db50,db70|100,db70,dd');
xadd('Double 3'       ,'m24|30,ss,dd50|8,dd50,sd50|20,sd50,sd70|100,sd70,dd');
xadd('Double 4'       ,'m24|30,ss,dd|8,dd,sd50|50,sd50,sd70|100,sd70,dd');
xadd('Double 5'       ,'m27|40,s,d|8,d,s|30,s,s|8,s,d|100,d,s');
xadd('Double 6'       ,'m16|20,s,d|20,d,s60|30,s60,s60|20,s60,d|100,d,s');
xadd('Stacked'        ,'m20|30,s,d|8,d,s|30,s,d|8,d,s|30,s,d|100,d,sd50');
xadd('Stacked 2'      ,'m20|20,s,d|8,d,s|20,s,d|8,d,s|20,s,d|8,d,s|20,s,d|100,d,sd50');
xadd('Stacked 3'      ,'m20|15,s,d|8,d,s|15,s,d|8,d,s|15,s,d|8,d,s|15,s,d|8,d,s|15,s,d|100,d,sd50');
xadd('Stacked 4'      ,'m20|10,s,d|7,d,s|10,s,d|7,d,s|10,s,d|7,d,s|10,s,d|7,d,s|10,s,d|7,d,s|10,s,d|100,d,sd50');
xadd('Stacked 5'      ,'m20|10,s,d|6,d,s|10,s,d|7,d,s|10,s,d|7,d,s|10,s,d|7,d,s|10,s,d|7,d,s|10,s,d|7,d,s|10,s,d|100,d,sd50');
xadd('Fuzz'           ,'m10|50,dd,ss50|15,ss50,sb50|100,sb50,sw50');
xadd('Fuzz 2'         ,'m20|50,dd,ss50|15,ss50,sw50|100,sw50,sb50');
xadd('Fuzz 3'         ,'m20|50,dd,ss50|15,ss50,sw50|100,sw50,sw50');
xadd('Old World'      ,'m14|50,ss,dd|100,dd,ss');
xadd('Modern Insert'  ,'m40|20,sb62,dd|56,d,sb62|17,sb55,sb55|8,sb55,dd|100,d,d');
xadd('Gallery'        ,'m22|10,ss60,dd|10,dd,sb60|67,ss80,ss80|8,sb80,dd|100,dd,sb100');
xadd('Gallery 2'      ,'m22|10,ss60,dd|10,dd,sb60|67,ss80,sb80|8,sb80,dd|100,dd,sb100');
xadd('Gallery 3'      ,'m22|10,ss60,dd|10,dd,sb60|67,sb70,ss70|8,ss70,dd|100,dd,sb100');
except;end;
end;
//## siInit ##
procedure siInit;//low level version - 12sep2021, 10mar2020
var
   v,p2,p:longint;
   cmp1:comp;
   str1,str2,x,e:string;
   xdatetime:tdatetime;
   //## xerrLR ##
   function xerrLR:boolean;//triggered when "Complete boolean eval=ticked" - 01jul2021
   begin
   try;result:=true;showerror('Processing failure [lr001]');sihalt;except;end;
   end;
begin
try
//check
if siInited then exit else siInited:=true;

//-- Special Settings file for a Windows Store App (our info) -------------------------------------------------------------------------------------------
//1. Make sure "Blaiz Enterprises" is left blank
//2. Ensure the file "Blaiz Enterprises\settings\sys-<programname>.app" exists -> swings program into Store APP mode (hiding/disabling certain options)
//3. If Store App is *** PAID ** then place a number of 1 in the above file to trigger "system_paid=true" or "0" for free to use - 30mar2022
// OR
// If the program is a FREE Desktop Application, then make sure the file in "2." above does not exist
//-------------------------------------------------------------------------------------------------------------------------------------------------------


//xxxxxxxxxxxxxxxxxxxxx clipboard.astext:=inttostr(amakecheck(programhelp));//xxxxxxxxxxxxxxxxxxxxxxxxxx

//xxxxxxxxxxxxxxxxxxxxx clipboard.astext:=inttostr(amakecheck(programbanner));
//xxxxxxxxxxxxxxxxxxxxxx clipboard.astext:=inttostr(amakecheck(programsplash));
//xxxxxxxxxxxxxxxxxxxxx clipboard.astext:=inttostr(amakecheck(programbanner2));

//xxxxxxxxxxxxxxxxxxxxx clipboard.astext:=inttostr(amakecheck(program_icon20h));
//xxxxxxxxxxxxxxxxxxxxx clipboard.astext:=inttostr(amakecheck(program_icon32h));
//xxxxxxxxxxxxxxxxxxxxx clipboard.astext:=inttostr(amakecheck(program_icon32hB));
//xxxxxxxxxxxxxxxxxxxxx clipboard.astext:=inttostr(amakecheck(program_icon32hC));
//xxxxxxxxxxxxxxxxxxxxx clipboard.astext:=inttostr(amakecheck(program_icon32hD));
//xxxxxxxxxxxxxxxxxxxxx clipboard.astext:=low__cemixc('Windows Store App',true);
//xxxxxxxxxxxxxxxxxxxxx clipboard.astext:=low__cemixc('Gossamer (4th Generation)',true);
//xxxxxxxxxxxxxxxxxxxxx clipboard.astext:=low__cemixc('4th Generation (Gossamer)',true);
//xxxxxxxxxxxxxxxxxxxxx clipboard.astext:=low__cemixc('Standard',true);

//xxxxxxxxxxxxxxxxxxxxx clipboard.astext:=low__cemixc('Plus Multi-Panel',true);

//.needed support - 31may2022, 24may2022
need_ico;
need_gif;


//.start the randomiser sub-system - 12sep2021
randomize;

//check processing via compiler is set to LEFT-to-RIGHT processing only - some procs will raise error or fail if this is NOT the mode - 01jul2021
if true or xerrLR then
   begin
   //nil
   end;

//debug init
system_debugPaintcount:=0;
system_debugPainttime:=ms64;

//system tracking -> do before anything else so tracking is accurate - 01may2021
for p:=0 to high(systrack_obj) do systrack_obj[p]:=nil;

//system_debug_pointerlist__SLOW
for p:=0 to high(systrack_ptr) do systrack_ptr[p]:=nil;

//system id -> unique for each running copy of program - 19feb2022
system_instanceid:=application.handle;

//system_plus0-N - 27jun2022
for p:=0 to programplusmax do
begin
system_plus0[p]:=nil;
system_plus1[p]:=nil;
system_plus2[p]:=nil;
system_plus3[p]:=nil;
system_plus4[p]:=nil;
system_plus5[p]:=nil;
system_plus6[p]:=nil;
system_plus7[p]:=nil;
system_plus8[p]:=nil;
system_plus9[p]:=nil;
end;//p

//frames
siframes;

//system disk support - 03apr2021
xdatetime:=now;
for p:=0 to high(sysdisk_name) do
begin
sysdisk_name[p]:='';
sysdisk_data[p]:=nil;
sysdisk_date[p]:=xdatetime;
sysdisk_readonly[p]:=false;
end;//p

//system timer - 19feb2021
cmp1:=ms64;
for p:=0 to high(systimer_event) do
begin
systimer_owner[p]  :=nil;
systimer_event[p]  :=nil;
systimer_busy[p]   :=false;
systimer_delay[p]  :=0;//off
systimer_ref64[p]  :=cmp1;
end;//p

//syshis_nam - 21mar2021
for p:=0 to high(syshis_nam) do syshis_nam[p]:='';

//system threads init - 16oct2021
systhread__initall;

//critical checkers
scheck(programname,programname_check);
scheck(programwebname,programwebname_check);
scheck(programversion,programversion_check);
icheck(programnewinstance,programnewinstance_check);
scheck(programslogan,programslogan_check);//08mar2021
acheck(program_icon20h,program_icon20h_check);//26sep2022
acheck(program_icon32h,program_icon32h_check);//12jun2021
acheck(program_icon32hB,program_icon32hB_check);//30apr2022
acheck(program_icon32hC,program_icon32hC_check);//30apr2022
acheck(program_icon32hD,program_icon32hD_check);//30apr2022
acheck(programsplash,programsplash_check);
acheck(programbanner,programbanner_check);//28may2021
acheck(programbanner2,programbanner2_check);//31may2021
if not system_debug then acheck(programhelp,programhelp_check);

//.program code checker - use code "-1745" to disable - 27sep2022, 28aug2021
xcodecheck;

//init system vars
//.idle trackers - 03apr2021
syskeytime:=ms64;//keyboard key press/stroke up or down
sysclicktime:=ms64;//mouse click
sysmovetime:=ms64;//mouse move
sysmovetime_global:=ms64;//global mouse move
sysdowntime:=ms64;//moue down
syswheeltime:=ms64;//mouse wheel

//WINE Support - 02feb2022 -----------------------------------------------------
system_winepresent:=low__driveexists('z:\');

//Windows Store App and PAID status - 03may2022 --------------------------------
{$ifdef storeapp}
 system_storeapp:=true;
 system_paid:=(programpaid_store>=1);//is the Store app PAID or FREE
{$else}
 str1:=low__platfolder('settings')+'sys-'+low__ownname+'.app';
 system_storeapp:=low__fileexists(str1);
 //.paid status
 case system_storeapp of//paid=1..N = 30mar2022
 true :system_paid:=(programpaid_store>=1) or (strint(low__fromfilestrb(str1,str2))>=1);//is the Windows Store App PAID or FREE
 false:system_paid:=(programpaid>=1);//is the Desktop Application PAID or FREE
 end;//case
{$endif}

//system settings handlers -----------------------------------------------------
syssettings:=vnew2(953);
prgsettings:=vnew2(954);

//special clipboard formats ----------------------------------------------------
try
cf_bwd:=registerclipboardformat('Blaiz Writer Document');
cf_bwp:=registerclipboardformat('Blaiz Word Processor Document');
except;end;

//system stats -----------------------------------------------------------------
//.resource level tracking
for p:=0 to high(sysstats_active) do
begin
sysstats_active[p]   :=0;
sysstats_create[p]   :=0;
sysstats_destroy[p]  :=0;
sysstats_ratec[p]    :=0;
sysstats_rated[p]    :=0;
end;//p

//.leak tracking
sysleak_show:=false;
for p:=0 to high(sysleak_start) do
begin
for p2:=0 to high(sysleak_start[0]) do//range error fixed - 20apr2021
begin
sysleak_start[p][p2]:=0;
sysleak_stop[p][p2] :=0;
end;//p2
sysleak_label[p]    :='';
sysleak_counter[p]  :=0;
end;//p


//OS Code ----------------------------------------------------------------------
{$ifdef D3}
syscode:=osW32;
stroffset:=1;//D3
{$endif}

{$ifdef w64}
syscode:=osW64;
stroffset:=1;//D3
{$endif}

{$ifdef D10}
syscode:=osA32;
x:='abc';
stroffset:=low(x);//D10
{$endif}

{$ifdef a64}
syscode:=osA64;
x:='abc';
stroffset:=low(x);//D10
{$endif}


//debug support ----------------------------------------------------------------
for p:=0 to high(debug_form) do
begin
debug_form[p]:=nil;
debug_info[p]:='';
end;//p


//string support ---------------------------------------------------------------
//translated strings
tsBytes:=ntranslate('bytes');
tsB:=low__uppercase(translate('b'));//single byte - 24feb2016
tsKB:=low__uppercase(translate('kb'));
tsMB:=low__uppercase(translate('mb'));
tsGB:=low__uppercase(translate('gb'));



//sysarrays --------------------------------------------------------------------
//.system menu
for p:=0 to high(sysmenu_name) do
begin
sysmenu_name[p]:='';
sysmenu_pos[p]:=0;
sysmenu_hover[p]:=-1;
sysmenu_selstart[p]:=0;
sysmenu_selcount[p]:=0;
sysmenu_ref64[p]:=0;
end;//p

try
//.int32
for p:=0 to high(p4INT32) do p4INT32[p]:=p*p*p*p;
//.cur256
for p:=0 to high(p4CUR256) do
begin
p4CUR256[p]:=p*p;
p4CUR256[p]:=p4CUR256[p]*p4CUR256[p];
end;//p
//.ref65025_div_255 - 06apr2017
for p:=0 to high(ref65025_div_255) do ref65025_div_255[p]:=p div 255;
//.fb255
for p:=low(fb255) to high(fb255) do
begin
v:=p;
if (v<0) then v:=0 else if (v>255) then v:=255;
fb255[p]:=byte(v);
end;//p
//.fbwrap255
for p:=low(fbwrap255) to high(fbwrap255) do
begin
v:=p;
 repeat
 if (v>255) then dec(v,255)
 else if (v<0) then inc(v,255)
 until (v>=0) and (v<=255);
fbwrap255[p]:=byte(v);
end;//p

except;end;


//temp support -----------------------------------------------------------------
//.temp buffer support
systmppos:=0;
for p:=0 to high(systmpstyle) do
begin
systmpstyle[p]:=0;//free
systmpid[p]:='';
systmptime[p]:=0;
systmpbmp[p]:=nil;
end;//p
//.temp int buffer support
sysintpos:=0;
for p:=0 to high(sysintstyle) do
begin
sysintstyle[p]:=0;//free
sysintid[p]:='';
sysinttime[p]:=0;
sysintobj[p]:=nil;
end;//p
//.temp byte buffer support
sysbytepos:=0;
for p:=0 to high(sysbytestyle) do
begin
sysbytestyle[p]:=0;//free
sysbyteid[p]:='';
sysbytetime[p]:=0;
sysbyteobj[p]:=nil;
end;//p


//system font slots ------------------------------------------------------------
for p:=0 to high(sysfont_dref) do
begin
sysfont_data[p]        :=bnew;
sysfont_dref[p]        :=bnew;
sysfont_time[p]        :=0;
sysfont_avew[p]        :=0;
sysfont_minw[p]        :=0;
sysfont_maxw[p]        :=0;
end;//p


//system -----------------------------------------------------------------------
//root font
low__font2('root','',0,false);

//initial language
//xxxxxxxxxxxsetlang('','');


{
//yyyyyyyyy
//This is not requied yet -> as portable doesn't do anything by default even
  on 1st run
//setup program for first time
if not low__fileexists(low__platonce) then
   begin
   //.mark as done
   a:=bnew2(41);
   a.text:='done';
   low__tofile(low__platonce,a,e);
   end;
{}//yyyyyyyyyyyyyyyy

//load mm system ---------------------------------------------------------------
mm_init;//29mar2021


//system fast vars - 06apr2021
low__reloadfastvars;

//system settings
siLoadsyssettings;
siLoadprgsettings;


//system sync ------------------------------------------------------------------
viSync;


//system links -----------------------------------------------------------------
program__init;//primarily for testing purposes generally

except;end;
end;
//## siCloseprompt ##
procedure siCloseprompt(x:tbasicsystem);
begin
try
//check
if siclosing or sicloseprompting or (x=nil) then exit;
sicloseprompting:=true;
//prompt
case (not x.mustcloseprompt) or x.popquery2(ntranslate('Close program?'),'','Close Program',false) of
true:siclose;//no need to reset because we are now closing down - 26aug2021
false:sicloseprompting:=false;//cancelled -> reset and allow for another attempt
end;
except;end;
end;
//## siClose ##
procedure siClose;
begin
try
//check
if siclosing then exit;

//close
siclosing:=true;//goes via "system.__ontimer->siclosing->sihalt" to prevent in "__ontimer()" font referencing during shutdown which can cause fatal access error - 14may2020
except;end;
end;
//## siHalt ##
procedure siHalt;
var
   int1,p:longint;
   xref64:comp;
begin
try
//check
if sihalted then exit else sihalted:=true;

//Assumed to be safe to shutdown at this point, since "siClosing" will trigger ALL instances of "tbasicsystem" and the like to cancel menus etc OR wait till dialogs are done
//        before calling this proc "siHalt;" - 03apr2021

//main timer -> disable main timer so no new procs are fired etc - 03apr2021
systimer_enabled:=false;

//disconnect vital events
visyncevent:=nil;
//was: fasttimer__stop;//07oct2021

//system helpers ---------------------------------------------------------------
program__close;
//was: if zzok(programhelpviewer,1040) then freeobj(@programhelpviewer);


//system hubs ------------------------------------------------------------------
mm_shut;//29mar2021
drop_shut;//26jul2021

//system threads stopall - 16oct2021 -------------------------------------------
systhread__stopall(true);


//temp support -----------------------------------------------------------------
//.temp buffer support
for p:=0 to high(systmpstyle) do
begin
systmpstyle[p]:=2;//locked
freeobj(@systmpbmp[p]);
end;//p
//.temp int support
for p:=0 to high(sysintstyle) do
begin
sysintstyle[p]:=2;//locked
freeobj(@sysintobj[p]);
end;//p
//.temp byte support
for p:=0 to high(sysbytestyle) do
begin
sysbytestyle[p]:=2;//locked
freeobj(@sysbyteobj[p]);
end;//p


//debug support ----------------------------------------------------------------
for p:=0 to high(debug_form) do freeobj(@debug_form[p]);


//system font slots ------------------------------------------------------------
for p:=0 to high(sysfont_dref) do
begin
freeobj(@sysfont_data[p]);
freeobj(@sysfont_dref[p]);
end;


//system settings handlers -----------------------------------------------------
siSavesyssettings;
siSaveprgsettings;


//system disk support ----------------------------------------------------------
for p:=0 to high(sysdisk_name) do
begin
sysdisk_name[p]:='';
bfree(sysdisk_data[p]);
sysdisk_readonly[p]:=false;
end;//p


//system dynamic tep support ---------------------------------------------------
bfree(syslist_tep20);


//system settings handlers #2 --------------------------------------------------
freeobj(@syssettings);
freeobj(@prgsettings);
freeobj(@viframecode);//23feb2022

//wait a short moment for ALL threads to shutdown - 26may2021
xref64:=ms64+20000;
while true do
begin
if (ms64>=xref64) or (sysstats_active[satThread]<=0) then break;
sleep(50);
app__processallmessages;
end;//loop

except;end;
try
//terminate
app__running:=false;
except;end;
end;
//## siLoadsyssettings ##
function siLoadsyssettings:boolean;
var
   a:tstr8;
   e:string;
begin
try
result:=false;
a:=nil;
a:=bnew;
result:=low__fromfile(low__platsyssettings,a,e);
if zzok(syssettings,1041) then
   begin
   siLoadsyssettingsfrom(a);
   visyssettingsloaded:=true;
   end;
except;end;
try;bfree(a);except;end;
end;
//## siLoadprgsettings ##
function siLoadprgsettings:boolean;
var
   a:tstr8;
   e:string;
begin
try
result:=false;
a:=nil;
a:=bnew;
result:=low__fromfile(low__platprgsettings,a,e);
if zzok(prgsettings,1042) then
   begin
   zzvars(prgsettings,110);
   prgsettings.data:=a;
   zzstr(a,111);
   viprgsettingsloaded:=true;
   vimustloadid:=true;
   vimustsync:=true;
   end;
except;end;
try;bfree(a);except;end;
end;
//## siLoadsyssettingsfrom ##
procedure siLoadsyssettingsfrom(x:tstr8);
begin
try
//init
block(x);//allow x to be nil
//get
if zzok(syssettings,1044) then
   begin
   //get
   syssettings.data:=x;
   siFiltersettings(syssettings);
   zzvars(syssettings,116);
   //done
   vimustloadid:=true;
   vimustsync:=true;
   end;
except;end;
try;bunlockautofree(x);except;end;
end;
//## siLoadprgsettingsfrom ##
procedure siLoadprgsettingsfrom(x:tstr8);
begin
try
//init
block(x);//allow x to be nil
//get
if zzok(prgsettings,1045) then
   begin
   zzvars(prgsettings,117);
   prgsettings.data:=x;
   vimustloadid:=true;
   vimustsync:=true;
   end;
except;end;
try;bunlockautofree(x);except;end;
end;
//## siSavesyssettings ##
function siSavesyssettings:boolean;
var
   e:string;
begin
try;result:=zzok(syssettings,1046) and zzok(syssettings,1047) and low__tofile(low__platsyssettings,syssettings.data,e);except;end;
end;
//## siSaveprgsettings ##
function siSaveprgsettings:boolean;
var
   e:string;
begin
try;result:=zzok(prgsettings,1048) and zzok(prgsettings,1049) and low__tofile(low__platprgsettings,prgsettings.data,e);except;end;
end;
//## siSaveallsettings ##
procedure siSaveallsettings;//23mar2022
begin
try
//.save program based settings so new instance has the up-to-date information to run - 05mar2022
if (system_program<>nil) and (system_program is tbasicprg1) then (system_program as tbasicprg1).xsavesettings else siSaveprgsettings;
//.save system based settings
siSavesyssettings;
except;end;
end;
//## siFontname2_deffont ##
function siFontname2_deffont:string;//12jun2022
begin
try;result:=low__udv(programinit_fontname2_deffont,'Courier New');except;end;
end;
//## siFiltersettings ##
function siFiltersettings(x:tvars8):boolean;
var
   a:tvars8;
   xwinemode,int1,p:longint;
   str1,str2,str3:string;
   xmustdefaults,xwine,bol1:boolean;
   //## bset ##
   procedure bset(xname:string;xdef,xval:boolean);
   begin
   //def
   if not a.found(xname) then
      begin
      a.b[xname]:=xdef;
      result:=true;
      end
   //val in range
   else if (a.b[xname]<>xval) then
      begin
      a.b[xname]:=xval;
      result:=true;
      end;
   //sync
   x.value[xname]:=a.value[xname];
   end;
   //## iset ##
   procedure iset(xname:string;xmin,xmax,xdef,xval:longint);
   begin
   xdef:=frcrange(xdef,xmin,xmax);
   xval:=frcrange(xval,xmin,xmax);
   //def
   if not a.found(xname) then
      begin
      a.i[xname]:=xdef;
      result:=true;
      end
   //val in range
   else if (a.i[xname]<>xval) then
      begin
      a.i[xname]:=xval;
      result:=true;
      end;
   //sync
   x.i[xname]:=a.i[xname];
   end;
   //## sset ##
   procedure sset(xname,xdef,xval:string);
   begin
   //def
   if not a.found(xname) then
      begin
      a.s[xname]:=xdef;
      result:=true;
      end
   //val in range
   else if (a.s[xname]<>xval) then
      begin
      a.s[xname]:=xval;
      result:=true;
      end;
   //sync
   x.s[xname]:=a.s[xname];
   end;
begin
try
//defaults
result:=false;
a:=nil;
//check
if zznil(x,2060) then exit;
//init
a:=vnew2(955);
a.data:=zzvars(x,133).data;
x.clear;
//xmustdefaults
xmustdefaults:=not a.found('winemode');
//color
str1:=a.value['colorname'];
if not low__setcolorsbyname(str1,nil,nil,nil) then str1:='?Default';
sset('colorname',str1,str1);

//fontname
sset('fontname'   ,'Arial',low__udv(a.value['fontname']   ,'Arial'));
//fontname.c
sset('fontname.c' ,'Arial',low__udv(a.value['fontname.c'] ,'Arial'));
//fontname2
sset('fontname2'  ,siFontname2_deffont,low__udv(a.value['fontname2']  ,siFontname2_deffont));//12jun2022
//fontname2.c
sset('fontname2.c',siFontname2_deffont,low__udv(a.value['fontname2.c'],siFontname2_deffont));//12jun2022

//bordersize -> do before anything else as it affects the MAX FONT ZOOM permitted - 07jun2021
iset('bordersize',0,72,32,a.i['bordersize']);
vibordersize__temp:=frcmin(x.i['bordersize'],0);//07jun2021
//fontsize
iset('fontsize',6,72,10,a.i['fontsize']);//05sep2020
iset('fontsize2',6,72,frcrange(programinit_fontname2_defsize,6,72),a.i['fontsize2']);//12jun2022, 26feb2022, 05feb2022

//zoom
iset('zoom',0,low__syszoomlimit,0,a.i['zoom']);//15apr2021, 14mar2021
//framename
sset('framename','default',a.value['framename']);//23feb2022
if (viframecode=nil) then viframecode:=bnew;
//other
bset('startlink',false,a.b['startlink']);//def=OFF - 24aug2020
bset('desktoplink',false,a.b['desktoplink']);//def=OFF
bset('touch',false,a.b['touch']);
bset('headlarge',true,a.b['headlarge']);//01mar2022
bset('headcenter',false,a.b['headcenter']);//11oct2022
bset('autoscroll',true,a.b['autoscroll']);//28sep2022
bset('doubleclicks',true,a.b['doubleclicks']);//08oct2020
bset('round',true,a.b['round']);
bset('minimalscroll',false,a.b['minimalscroll']);//08feb2022
bset('dragfast',false,a.b['dragfast']);
bset('softclose',true,a.b['softclose']);
bset('framemax',programinit_framemax,a.b['framemax']);//04mar2022, 14mar2021
bset('ecomode',false,a.b['ecomode']);//09may2021
bset('32bit',true,a.b['32bit']);//09may2021
//was: bset('lockposition',false,a.b['lockposition']);//27feb2022
iset('winemode',0,2,0,a.i['winemode']);//0=auto, 1=enable, 2=disable - 02feb2022
bset('realtimehelp',true,a.b['realtimehelp']);
bset('ontop',false,a.b['ontop']);
iset('mididevice',0,99,0,a.i['mididevice']);//05mar2022
iset('wavedevice',0,99,0,a.i['wavedevice']);//05mar2022
bset('help.bw',programhelp_helpbw,a.b['help.bw']);//24jul2021
bset('help.show',programhelp_helpshow,a.b['help.show']);//24jul2021
bset('help.max',false,a.b['help.max']);//18dec2021, 24jul2021
iset('opensave.sort',0,nlMax,nlName,a.i['opensave.sort']);//25mar2021
bset('opensave.preview',true,a.b['opensave.preview']);//22may2022
iset('nav.sort',0,nlMax,nlName,a.i['nav.sort']);//25mar2021
bset('coloriseimages',false,a.b['coloriseimages']);//10mar2021
bset('enhanced',true,a.b['enhanced']);
bset('specialcolors',true,a.b['specialcolors']);
iset('sparkle',0,20,sparkle__default,a.i['sparkle']);//15mar2022
//was: iset('bordersize',0,72,32,a.i['bordersize']); -> now handled 1st up above - 07jun2021
iset('scrollsize',5,72,20,a.i['scrollsize']);//20px - 29mar2021
iset('fontfeather',0,4,1,a.i['fontfeather']);//0=none, 1=low, 2=medium, 3=high, 4=ultra
iset('fontfeatherf',0,3,0,a.i['fontfeatherf']);//0=none, 1=low, 2=medium, 3=high
bset('shaderound',true,a.b['shaderound']);//0=flat, 1=round
bset('shadeglow',programinit_shadeglow,a.b['shadeglow']);//12jun2022
bset('safearea',true,a.b['safearea']);
bset('splash',true,a.b['splash']);
for p:=0 to (cnCustomLimit-1) do
begin
str1:=a.s['?custom'+inttostr(p)];
str1:=low__setcolor2(str1,-1,0);
x.s['?custom'+inttostr(p)]:=str1;
end;//p
//.paste and use
str1:=a.s['?paste_and_use'];
x.s['?paste_and_use']:=low__setcolor2(str1,-1,0);
//.Wine specific defaults - 13feb2022
if xmustdefaults then
   begin
   //init
   xwinemode :=frcrange(a.i['winemode'],0,2);//0=automatic, 1=enable, 2=disable - 02feb2022
   xwine     :=(xwinemode=1) or ((xwinemode=0) and system_winepresent);
   //get
   if xwine then
      begin
      iset('fontfeather',0,4,1,0);//0=none, 1=low, 2=medium, 3=high, 4=ultra
      iset('fontfeatherf',0,3,0,2);//0=none, 1=dark, 2=moderate, 3=light
      end;
   end;
except;end;
try;freeobj(@a);except;end;
end;
//## viSyncandsave ##
procedure viSyncandsave;
begin
try
//check
if not visyssettingsloaded then exit;
//get
viSync;
siSavesyssettings;//save -> only need to save system settings here - 05oct2020
except;end;
end;
//## viSync ##
procedure viSync;
label
   skipscheme;
var
   s:tvars8;
   xnormal,xtitle:tvirtualinfo;
   int1,xdragtrigger:longint;
   n,v,str1,xcolorname,sfontname,sfontname2,xfontname,xfontname2:string;
   xtouch,xmustloadid,xmustpaint:boolean;
   sw,sh,xzoom,xfontsize,xfontsize2,a,b,p:longint;
   xzoom__root,xfontsize__root,xfontsize__root2,xscrollsize__root:longint;//root versions -> these are the values BEFORE any zoom is applied - 14mar2021
   tmps:single;
   //## xcolorchecks ##
   procedure xcolorchecks(var x:tvirtualinfo);
   begin
   with x do
   begin
   //new, less restrictive color checkers - 27mar2021
   highlight       :=low__ecv(highlight,background,10);
   font            :=low__ecv(font,background,30);
   fonthighlight   :=low__ecv(fonthighlight,highlight,10);
//was: - these were too restrictive and were causing some colors not to appear when the user would otherwise expect them too - 17mar2021
//   highlight       :=low__ecv(highlight,background,20);
//   font            :=low__ecv(font,background,30);
//   fonthighlight   :=low__ecv(fonthighlight,highlight,30);
//   disableborder   :=low__ecv(disableborder,disable,20);
//   disablefont     :=low__ecv(disablefont,disable,30);
   end;
   end;
   //## xrunframe ##
   function xrunframe:longint;//returns minsize for frame
   var
      s,d:longint;
   begin
   low__framecols(vititle.background,vititle.frame,vititle.frame2,result,s,d);
   vititle.framefindcol:=s;
   vititle.framefindcol2:=d;
   vinormal.framefindcol:=s;
   vinormal.framefindcol2:=d;
   end;
begin
try
//defaults
s:=nil;
xmustpaint:=false;
xmustloadid:=vimustloadid;
vimustloadid:=false;

//lock
if visyncing then exit else visyncing:=true;

//init
s:=vnew2(956);
sw:=misscreenw;
sh:=misscreenh;
if zzok(syssettings,1050) then s.data:=zzvars(syssettings,140).data;
siFiltersettings(s);//is this really necessary here//??????????????????????????
zzvars(s,141);//re-check

//get

//.wine -> not supported for Store Apps - 30mar2022
if not system_storeapp then
   begin
   viwinemode :=frcrange(s.i['winemode'],0,2);//0=automatic, 1=enable, 2=disable - 02feb2022
   viwine     :=(viwinemode=1) or ((viwinemode=0) and system_winepresent);
   end;

vifeatherf            :=frcrange(s.i['fontfeatherf'],low__aorb(0,1,viwine),3);//wine mode -> don't allow to be turned off under Wine - 13feb2022
xcolorname            :=s.value['colorname'];//case sensitive to allow for filenames with both lower and upper case characters - 09mar2021

//.fontname
str1                  :=low__udv(s.value['fontname'],'Arial');
vifontnameraw         :=str1;
if (strcopy1(str1,1,1)='*') then str1:=low__udv(s.value['fontname.c'],'Arial');
sfontname             :=str1;

//.fontname2
str1                  :=low__udv(s.value['fontname2'],siFontname2_deffont);
vifontnameraw2        :=str1;
if (strcopy1(str1,1,1)='*') then str1:=low__udv(s.value['fontname2.c'],siFontname2_deffont);
sfontname2            :=str1;

//.default
low__findfontname2('$fontname',sfontname,sfontname2,xfontname);//convert dynamic font names "Default" and "Default 2" into real font names - 0feb2022
low__findfontname2('$fontname2',sfontname,sfontname2,xfontname2);//convert dynamic font names "Default" and "Default 2" into real font names - 0feb2022
xtouch                :=s.b['touch'];

//.user controlled settings -> which go on to generate the final values for "vizoom" and "vifontsize/vifontsize2" system values - 26feb2022, 14mar2021
xzoom__root           :=frcrange(s.i['zoom'],0,low__syszoomlimit);//15apr2021, 14mar2021
xfontsize__root       :=frcrange(s.i['fontsize'],6,72);
xfontsize__root2      :=frcrange(s.i['fontsize2'],6,72);//26feb2022
//.xzoom
if (xzoom__root<=0) then
   begin
   case misscreenresin248K of
   2:xzoom:=1;//1x
   4:xzoom:=2;//2x
   8:xzoom:=4;//4x
   else xzoom:=1;//1x
   end;//case
   end
else xzoom:=frcrange(xzoom__root,1,4);
//.xfontsize
xfontsize             :=frcmin(xfontsize__root*xzoom,6);
xfontsize2            :=frcmin(xfontsize__root2*xzoom,6);
//.normal
xnormal.fontname      :=xfontname;
xnormal.fn            :=low__font2('fn',xfontname,xfontsize,false);
xnormal.fnH           :=low__fontmaxh(xnormal.fn);
xnormal.fb            :=low__font2('fb',xfontname,xfontsize,true);
xnormal.fbH           :=low__fontmaxh(xnormal.fb);

//.title
xtitle.fontname       :=xfontname;
xtitle.fn             :=xnormal.fn;
xtitle.fnH            :=xnormal.fnH;
xtitle.fb             :=xnormal.fb;
xtitle.fbH            :=xnormal.fbH;

//colorname --------------------------------------------------------------------
//init
low__setcolorsbyname(xcolorname,@xnormal,@xtitle,@vimorecolors);

//-- Set -----------------------------------------------------------------------
//.drag
vidragtrigger      :=20*xzoom;
vidragtriggerfine  :=1*xzoom;

//.fontheight
int1:=0;
int1:=largest(int1,xnormal.fnH);
int1:=largest(int1,xnormal.fbH);
if (xtitle.fn<>xnormal.fn) then int1:=largest(int1,xtitle.fnH);
if (xtitle.fb<>xnormal.fb) then int1:=largest(int1,xtitle.fbH);
vifontheight:=int1;
//.titleheight(s)
vititleheight:=int1;//xxxxxxxxxxxfrcmin(int1,low__insint(touchsmall,xtouch));
vititleheight2:=round(int1*1.5);//frcmin(round(int1*1.5),low__insint(touchnormal,xtouch));
//width ratio
low__fontavew(0);
int1:=low__font0('Arial',8*xzoom);
b:=frcmin(low__fontavew(int1),1);//system standard -> "Arial/8"
a:=1;
a:=largest(a,low__fontavew(xnormal.fn));
a:=largest(a,low__fontavew(xnormal.fb));
if (xtitle.fn<>xnormal.fn) then a:=largest(a,low__fontavew(xtitle.fn));
if (xtitle.fb<>xnormal.fb) then a:=largest(a,low__fontavew(xtitle.fb));
//.font width ratio
tmps:=(a/nozero(1200018,b));
if (tmps<=0) then tmps:=1;
vifontwidthratio:=tmps;
//.tab ratio
if (tmps<0.5) then tmps:=0.5
else if (tmps>2.3) then tmps:=2.3;
vitabratio:=nozero_sig(1200019,tmps);

//.color checks
xcolorchecks(xnormal);
xcolorchecks(xtitle);

//set
vicopy(xnormal,vinormal);
vicopy(xtitle,vititle);
vizoom                :=xzoom;//14mar2021
vizoom__root          :=xzoom__root;//14mar2021
vitouch               :=xtouch;
vidoubleclicks        :=s.b['doubleclicks'];
viround               :=s.b['round'];
viminimal__scrollbar  :=s.b['minimalscroll'];//08feb2022
vidragfast            :=false;//locked off - s.b['dragfast'];
visoftclose           :=s.b['softclose'];
viframemax            :=s.b['framemax'];//04mar2022, 14mar2021
viecomode             :=s.b['ecomode'];//09may2021
vi32bit               :=s.b['32bit'];//09may2021
//was: viLockposition        :=s.b['lockposition'];//27feb2022
viheadlarge           :=s.b['headlarge'];//01mar2022
viheadcenter          :=s.b['headcenter'];//11oct2022
viautoscroll          :=s.b['autoscroll'];//28sep2022
//.feather
vifeather             :=frcrange(s.i['fontfeather'],0,4);
visafearea            :=s.b['safearea'];
visplash              :=s.b['splash'];//29aug2020
vishaderound          :=s.b['shaderound'];
vishadeglow           :=s.b['shadeglow'];//12jun2022
vishadestyle          :=low__aorbstr('g50','g-50',vishaderound);//19aug2020
vihelp                :=s.b['realtimehelp'];
vienhanced            :=s.b['enhanced'];
vispecialcolors       :=s.b['specialcolors'];
//.sparkle list - 27feb2022
visparkle             :=frcrange(s.i['sparkle'],0,20);
low__sparklefill(visparkle);
//.bordersize
vibordersize__root    :=frcrange(s.i['bordersize'],0,72);
vibordersize          :=vibordersize__root*vizoom;
//.frame
if low__setstr(viframename,s.value['framename']) then
   begin
   low__iroll(viframeid,1);//detect different frame so that CUSTOM colored windows can update their pathc colors - 24feb2022
   viframecode.text:=sifindframe(viframename);
   end;
viFrameminsize:=xrunframe;
//.other
viscrollsize__root    :=frcrange(s.i['scrollsize'],5,100);
viscrollsize          :=viscrollsize__root*vizoom;
vicolorname           :=xcolorname;
vifontname            :=sfontname;//02feb2022
vifontname2           :=sfontname2;
vifontsize__root      :=xfontsize__root;//14mar2021
vifontsize__root2     :=xfontsize__root2;
vifontsize            :=xfontsize;
vifontsize2           :=xfontsize2;
vistartlink           :=s.b['startlink'];
videsktoplink         :=s.b['desktoplink'];
viontop               :=s.b['ontop'];
vicoloriseimages      :=s.b['coloriseimages'];
vihelp_bw             :=s.b['help.bw'];
vihelp_show           :=s.b['help.show'];
vihelp_max            :=s.b['help.max'];
vilinevsp             :=1*xzoom;
vilineheight          :=frcmin(vifontheight+1,low__aorb(0,low__touchsmall,xtouch))+(2*vilinevsp);
//.mididevice - 07mar2022
int1                  :=frcrange(s.i['mididevice'],0,99);
if (int1<>vimididevice) then
   begin
   vimididevice:=int1;
   if (int1<>mid_deviceindex) then mid_setdeviceindex(int1);
   end;
vimidideviceNEW:=int1;//update any "nmididevice" control
//.wavedevice - 07mar2022
int1                  :=frcrange(s.i['wavedevice'],0,99);
if (int1<>viwavedevice) then
   begin
   viwavedevice:=int1;
   if (int1<>wav_deviceindex) then wav_setdeviceindex(int1);
   end;
viwavedeviceNEW:=int1;//update any "nwavedevice" control

//sync ontop -> Note: As of 19mar2021 while window is MAXIMISED changing ontop settings looses the window's "NORMAL" rect - 19mar2021
case viontop of
true:if (application.mainform<>nil) and (application.mainform.formstyle<>fsstayontop) then application.mainform.formstyle:=fsstayontop;
false:if (application.mainform<>nil) and (application.mainform.formstyle<>fsnormal) then application.mainform.formstyle:=fsnormal;
end;

//sync system links -> Note: not supported for Store Apps - 30mar2022
if not system_storeapp then
   begin
   low__plat('startmenu.'+low__aorbstr('del','create',vistartlink),'',true);
   low__plat('desktop.'+low__aorbstr('del','create',videsktoplink),'',true);
   end;

//sync mainhelp
low__showhelp(vihelp_show);//24jul2021

//sync cursor - 29aug2021
low__loadcursor;

//inc
low__iroll(vidataid,1);
if xmustloadid then low__iroll(viloadid,1);
skipscheme:
except;end;
try;freeobj(@s);except;end;
try
low__iroll(visyncid,1);//13feb2022
//sync with a host
if assigned(visyncevent) then visyncevent(nil);
//stop
visyncing:=false;
except;end;
end;
//## vicopy ##
procedure vicopy(var s,d:tvirtualinfo);
begin
try
//core values
d.fn               :=s.fn;
d.fnH              :=s.fnH;
d.fb               :=s.fb;
d.fbH              :=s.fbH;
d.frame            :=s.frame;
d.frame2           :=s.frame2;
d.border           :=s.border;
d.background       :=s.background;
d.highlight        :=s.highlight;
d.hover            :=s.hover;
d.disable          :=s.disable;
d.disableborder    :=s.disableborder;
d.disablefont      :=s.disablefont;
d.font             :=s.font;
d.fonthighlight    :=s.fonthighlight;
d.fontname         :=s.fontname;
except;end;
end;
//-- System Object Checkers Support --------------------------------------------
//## sbwpok ##
function sbwpok(x:tobject):boolean;
begin
try;result:=zzok(x,1060) and (x is tbasicbwp);except;end;
end;
//## sbwp ##
function sbwp(x:tobject):tbasicbwp;
begin
try
zzok(x,7350);
result:=(x as tbasicbwp);
except;end;
end;
//-- MIS Support ---------------------------------------------------------------
//## misset_brushcolor ##
function misset_brushcolor(x:tobject;xval:longint):boolean;
begin
try
//defaults
result:=false;
//check
if zznil(x,2061) then exit;
//get
//.bmp
if (x is tbmp) and (x as tbmp).cancanvas then
   begin
{$ifdef D3}
   (x as tbmp).canvas.brush.color:=xval;
{$endif}
{$ifdef D10}
   (x as tbmp).canvas.fill.color:=xval;
{$endif}
   result:=true;
   end
//.bitmap
else if (x is tbitmap) then
   begin
{$ifdef D3}
   (x as tbitmap).canvas.brush.color:=xval;
{$endif}
{$ifdef D10}
   (x as tbitmap).canvas.fill.color:=xval;
{$endif}
   result:=true;
   end;
except;end;
end;
//## misset_brushclear ##
function misset_brushclear(x:tobject;xval:boolean):boolean;
begin
try
//defaults
result:=false;
//check
if zznil(x,2061) then exit;
//get
//.bmp
if (x is tbmp) and (x as tbmp).cancanvas then
   begin
{$ifdef D3}
   case xval of
   true:(x as tbmp).canvas.brush.style:=bsclear;
   false:(x as tbmp).canvas.brush.style:=bssolid;
   end;//case
{$endif}
{$ifdef D10}
   case xval of
   true:(x as tbmp).canvas.fill.kind:=tbrushkind.none;
   false:(x as tbmp).canvas.fill.kind:=tbrushkind.solid;
   end;//case
{$endif}
   result:=true;
   end
//.bitmap
else if (x is tbitmap) then
   begin
{$ifdef D3}
   case xval of
   true:(x as tbitmap).canvas.brush.style:=bsclear;
   false:(x as tbitmap).canvas.brush.style:=bssolid;
   end;//case
{$endif}
{$ifdef D10}
   case xval of
   true:(x as tbitmap).canvas.fill.kind:=tbrushkind.none;
   false:(x as tbitmap).canvas.fill.kind:=tbrushkind.solid;
   end;//case
{$endif}
   result:=true;
   end;
except;end;
end;
//## misset_fontcolor ##
function misset_fontcolor(x:tobject;xval:longint):boolean;
begin
try
//defaults
result:=false;
//check
if zznil(x,2062) then exit;
//get
//.bmp
if (x is tbmp) and (x as tbmp).cancanvas and ((x as tbmp).sharp=0) then
   begin
{$ifdef D3}
   (x as tbmp).canvas.font.color:=xval;
{$endif}
//xxxxxxxxxxxxxxxxxxx//???????????????????//D10: No support for this yet!!!!
   result:=true;
   end
//.bitmap
else if (x is tbitmap) then
   begin
{$ifdef D3}
   (x as tbitmap).canvas.font.color:=xval;
{$endif}
//xxxxxxxxxxxxxxxxxxx//???????????????????//D10: No support for this yet!!!!
   result:=true;
   end;
except;end;
end;
//## misset_fontname ##
function misset_fontname(x:tobject;xval:string):boolean;
begin
try
//defaults
result:=false;
//check
if zznil(x,2064) then exit;
//get
//.bmp
if (x is tbmp) and (x as tbmp).cancanvas and ((x as tbmp).sharp=0) then
   begin
{$ifdef D3}
   (x as tbmp).canvas.font.name:=xval;
{$endif}
{$ifdef D10}
   (x as tbmp).canvas.font.family:=xval;
{$endif}
   result:=true;
   end
//.bitmap
else if (x is tbitmap) then
   begin
{$ifdef D3}
   (x as tbitmap).canvas.font.name:=xval;
{$endif}
{$ifdef D10}
   (x as tbitmap).canvas.font.family:=xval;
{$endif}
   result:=true;
   end;
except;end;
end;
//## misset_fontsize ##
function misset_fontsize(x:tobject;xval:longint):boolean;
begin
try
//defaults
result:=false;
//check
if zznil(x,2065) then exit;
//range
xval:=frcmin(xval,5);
//get
//.bmp
if (x is tbmp) and (x as tbmp).cancanvas and ((x as tbmp).sharp=0) then
   begin
   (x as tbmp).canvas.font.size:=xval;
   result:=true;
   end
//.bitmap
else if (x is tbitmap) then
   begin
   (x as tbitmap).canvas.font.size:=xval;
   result:=true;
   end;
except;end;
end;
//## misset_fontheight ##
function misset_fontheight(x:tobject;xval:longint):boolean;
begin
try
//defaults
result:=false;
//check
if zznil(x,2066) then exit;
//get
//.bmp
if (x is tbmp) and (x as tbmp).cancanvas and ((x as tbmp).sharp=0) then
   begin
{$ifdef D3}
   (x as tbmp).canvas.font.height:=xval;
{$endif}
{$ifdef D10}
   (x as tbmp).canvas.font.size:=-xval;
{$endif}
//xxxxxxxxxxxxx//?????????????????//D10: Not sure if this works
   result:=true;
   end
//.bitmap
else if (x is tbitmap) then
   begin
{$ifdef D3}
   (x as tbitmap).canvas.font.height:=xval;
{$endif}
{$ifdef D10}
   (x as tbitmap).canvas.font.size:=-xval;
{$endif}
//xxxxxxxxxxxxx//?????????????????//D10: Not sure if this works
   result:=true;
   end;
except;end;
end;
//## misset_fontstyle ##
function misset_fontstyle(x:tobject;xbold,xitalic,xunderline,xstrikeout:boolean):boolean;
var
   a:tfontstyles;
begin
try
//defaults
result:=false;
//check
if zznil(x,2067) then exit;
//get
a:=[];
{$ifdef D3}
if xbold       then a:=a+[fsbold];
if xitalic     then a:=a+[fsitalic];
if xunderline  then a:=a+[fsunderline];
if xstrikeout  then a:=a+[fsstrikeout];
{$endif}
{$ifdef D10}
if xbold       then a:=a+[tfontstyle.fsbold];
if xitalic     then a:=a+[tfontstyle.fsitalic];
if xunderline  then a:=a+[tfontstyle.fsunderline];
if xstrikeout  then a:=a+[tfontstyle.fsstrikeout];
{$endif}

//set
//.bmp
if (x is tbmp) and (x as tbmp).cancanvas and ((x as tbmp).sharp=0) then
   begin
   (x as tbmp).canvas.font.style:=a;
   result:=true;
   end
//.bitmap
else if (x is tbitmap) then
   begin
   (x as tbitmap).canvas.font.style:=a;
   result:=true;
   end;
except;end;
end;
//## misset_textextent ##
function misset_textextent(x:tobject;xval:string):tpoint;
{$ifdef D3}
var
   a:tsize;
{$endif}
begin
try
//defaults
result.x:=0;
result.y:=0;
//check
if zznil(x,2068) then exit;
//get
//.bmp
if (x is tbmp) and (x as tbmp).cancanvas then
   begin
{$ifdef D3}
   a:=(x as tbmp).canvas.textextent(xval);
   result.x:=a.cx;
   result.y:=a.cy;
{$endif}
{$ifdef D10}
   result.x:=round((x as tbmp).canvas.textwidth(xval));
   result.y:=round((x as tbmp).canvas.textheight(xval));
{$endif}
   end
//.bitmap
else if (x is tbitmap) then
   begin
{$ifdef D3}
   a:=(x as tbitmap).canvas.textextent(xval);
   result.x:=a.cx;
   result.y:=a.cy;
{$endif}
{$ifdef D10}
   result.x:=round((x as tbitmap).canvas.textwidth(xval));
   result.y:=round((x as tbitmap).canvas.textheight(xval));
{$endif}
   end;
except;end;
end;
//## misset_textwidth ##
function misset_textwidth(x:tobject;xval:string):longint;
begin
try
//defaults
result:=0;
//check
if zznil(x,2069) then exit;
//get
//.bmp
if (x is tbmp) and (x as tbmp).cancanvas then
   begin
{$ifdef D3}
   result:=(x as tbmp).canvas.textwidth(xval);
{$endif}
{$ifdef D10}
   result:=round((x as tbmp).canvas.textwidth(xval));
{$endif}
   end
//.bitmap
else if (x is tbitmap) then
   begin
{$ifdef D3}
   result:=(x as tbitmap).canvas.textwidth(xval);
{$endif}
{$ifdef D10}
   result:=round((x as tbitmap).canvas.textwidth(xval));
{$endif}
   end;
except;end;
end;
//## misset_textheight ##
function misset_textheight(x:tobject;xval:string):longint;
begin
try
//defaults
result:=0;
//check
if zznil(x,2070) then exit;
//get
//.bmp
if (x is tbmp) and (x as tbmp).cancanvas then
   begin
{$ifdef D3}
   result:=(x as tbmp).canvas.textheight(xval);
{$endif}
{$ifdef D10}
   result:=round((x as tbmp).canvas.textheight(xval));
{$endif}
   end
//.bitmap
else if (x is tbitmap) then
   begin
{$ifdef D3}
   result:=(x as tbitmap).canvas.textheight(xval);
{$endif}
{$ifdef D10}
   result:=round((x as tbitmap).canvas.textheight(xval));
{$endif}
   end;
except;end;
end;
//## mis_textrect ##
function mis_textrect(x:tobject;xarea:trect;dx,dy:longint;xval:string):boolean;
{$ifdef D10}
var
   da,ta:trectf;
   dc:talphacolor;
{$endif}
begin
try
//defaults
result:=false;
//check
if zznil(x,2071) then exit;
//get
//.bmp
if (x is tbmp) and (x as tbmp).cancanvas then
   begin
{$ifdef D3}
   (x as tbmp).canvas.textrect(xarea,dx,dy,xval);
{$endif}
{$ifdef D10}
   da.left:=xarea.left;
   da.right:=xarea.right;
   da.top:=xarea.top;
   da.bottom:=xarea.bottom;
   //cls
   (x as tbmp).canvas.clearrect(da,dc);
   //text
   ta.left:=dx;
   if (ta.left<xarea.left) then ta.left:=xarea.left;
   ta.right:=xarea.right;
   ta.top:=dy;
   if (ta.top<xarea.top) then ta.top:=xarea.top;
   ta.bottom:=xarea.bottom;
   (x as tbmp).canvas.filltext(ta,xval,false,255,[],ttextalign.leading);
{$endif}
   result:=true;
   end
//.bitmap
else if (x is tbitmap) then
   begin
{$ifdef D3}
   (x as tbitmap).canvas.textrect(xarea,dx,dy,xval);
{$endif}
{$ifdef D10}
   da.left:=xarea.left;
   da.right:=xarea.right;
   da.top:=xarea.top;
   da.bottom:=xarea.bottom;
   //cls
   (x as tbitmap).canvas.clearrect(da,dc);
   //text
   ta.left:=dx;
   if (ta.left<xarea.left) then ta.left:=xarea.left;
   ta.right:=xarea.right;
   ta.top:=dy;
   if (ta.top<xarea.top) then ta.top:=xarea.top;
   ta.bottom:=xarea.bottom;
   (x as tbitmap).canvas.filltext(ta,xval,false,255,[],ttextalign.leading);
{$endif}
   result:=true;
   end;
except;end;
end;
//## misv ##
function misv(s:tobject):boolean;//valid
begin
try;result:=zzok(s,1061) and ( (s is tbmp) or (s is tbasicimage) or (s is tbitmap));except;end;
end;
//## misb ##
function misb(s:tobject):longint;//bits 0..N
begin
try
//defaults
result:=0;
//get
if zznil(s,2072) then exit
//.bmp
else if (s is tbmp) then result:=(s as tbmp).bits
//.image
else if (s is tbasicimage) then result:=(s as tbasicimage).bits
//.bitmap
else if (s is tbitmap) then
   begin
{$ifdef D3}
   if      (s as tbitmap).monochrome             then result:=1//26may2019
   else if ((s as tbitmap).pixelformat=pf1bit)   then result:=1
   else if ((s as tbitmap).pixelformat=pf4bit)   then result:=4
   else if ((s as tbitmap).pixelformat=pf8bit)   then result:=8
   else if ((s as tbitmap).pixelformat=pf15bit)  then result:=15
   else if ((s as tbitmap).pixelformat=pf16bit)  then result:=16
   else if ((s as tbitmap).pixelformat=pf24bit)  then result:=24
   else if ((s as tbitmap).pixelformat=pf32bit)  then result:=32;
{$endif}
{$ifdef D10}
   result:=32;
{$endif}
   end;
except;end;
end;
//## missetb ##
procedure missetb(s:tobject;sbits:longint);
begin
try
sbits:=frcmin(sbits,1);
if not misv(s) then exit
else if (s is tbasicimage) then (s as tbasicimage).setparams(sbits,misw(s),mish(s))
else if (s is tbmp) then (s as tbmp).bits:=sbits
else if (s is tbitmap) then
   begin
{$ifdef D3}
   case sbits of
   1:if ((s as tbitmap).pixelformat<>pf1bit) then (s as tbitmap).pixelformat:=pf1bit;
   4:if ((s as tbitmap).pixelformat<>pf4bit) then (s as tbitmap).pixelformat:=pf4bit;
   8:if ((s as tbitmap).pixelformat<>pf8bit) then (s as tbitmap).pixelformat:=pf8bit;
   15:if ((s as tbitmap).pixelformat<>pf15bit) then (s as tbitmap).pixelformat:=pf15bit;
   16:if ((s as tbitmap).pixelformat<>pf16bit) then (s as tbitmap).pixelformat:=pf16bit;
   24:if ((s as tbitmap).pixelformat<>pf24bit) then (s as tbitmap).pixelformat:=pf24bit;
   32:if ((s as tbitmap).pixelformat<>pf32bit) then (s as tbitmap).pixelformat:=pf32bit;
   end;//case
{$endif}
{$ifdef D10}
   //can't change pixelformat under D10 - fixed at 32bit - 21aug2020
{$endif}
   end;
except;end;
end;
//## missetb2 ##
function missetb2(s:tobject;sbits:longint):boolean;//12feb2022
begin
try
result:=false;
missetb(s,sbits);
result:=(misb(s)<>sbits);
except;end;
end;
//## misf ##
function misf(s:tobject):longint;//color format
begin
try
//defaults
result:=cfNone;
//get
if zznil(s,2074) then exit
//.basicimage
else if (s is tbasicimage) then
   begin
   case (s as tbasicimage).bits of
   8: result:=cfRGB8;
   15:result:=cfRGB15;
   16:result:=cfRGB16;
   24:result:=cfRGB24;
   32:result:=cfRGBA32;
   end;
   end
//.bmp
else if (s is tbmp) then
   begin
{$ifdef D3}
   case (s as tbmp).bits of
   8: result:=cfRGB8;
   15:result:=cfRGB15;
   16:result:=cfRGB16;
   24:result:=cfRGB24;
   32:result:=cfRGBA32;
   end;
{$endif}
{$ifdef D10}
   case (s as tbmp).core.pixelformat of
   tpixelformat.RGB:result:=cfRGB24;
   tpixelformat.BGR:result:=cfBGR24;
   tpixelformat.RGBA:result:=cfRGBA32;
   tpixelformat.BGRA:result:=cfBGRA32;
   end;
{$endif}
   end
//.bitmap
else if (s is tbitmap) then
   begin
{$ifdef D3}
   case (s as tbitmap).pixelformat of
   pf8bit: result:=cfRGB8;
   pf15bit:result:=cfRGB15;
   pf16bit:result:=cfRGB16;
   pf24bit:result:=cfRGB24;
   pf32bit:result:=cfRGBA32;
   end;
{$endif}
{$ifdef D10}
   case (s as tbitmap).pixelformat of
   tpixelformat.RGB:result:=cfRGB24;
   tpixelformat.BGR:result:=cfBGR24;
   tpixelformat.RGBA:result:=cfRGBA32;
   tpixelformat.BGRA:result:=cfBGRA32;
   end;
{$endif}
   end;
except;end;
end;
//## misw ##
function misw(s:tobject):longint;
begin
try
result:=0;
if zznil(s,2075)           then exit
else if (s is tbmp)        then result:=(s as tbmp).width
else if (s is tbasicimage) then result:=(s as tbasicimage).width
else if (s is tbitmap)     then result:=(s as tbitmap).width;
except;end;
end;
//## mish ##
function mish(s:tobject):longint;
begin
try
result:=0;
if zznil(s,2076)           then exit
else if (s is tbmp)        then result:=(s as tbmp).height
else if (s is tbasicimage) then result:=(s as tbasicimage).height
else if (s is tbitmap)     then result:=(s as tbitmap).height;
except;end;
end;
//## mishasai ##
function mishasai(s:tobject):boolean;
begin
try
result:=false;
if zznil(s,2077)           then exit
else if (s is tbmp)        then result:=true
else if (s is tbasicimage) then result:=true
else if (s is tbitmap)     then result:=false;
except;end;
end;
//## misonecell ##
function misonecell(s:tobject):boolean;//26apr2022
label
   skipend;
var
   a:tbasicimage;
   ca:trect;
begin
try
//defaults
result:=true;
a:=nil;
//check
if not mishasai(s) then exit;
if (misai(s).count<=1) then exit;
//get
result:=false;
if not miscell(s,0,ca) then goto skipend;
a:=misimg(misb(s),ca.right-ca.left+1,ca.bottom-ca.top+1);
if not miscopyarea32(0,0,misw(a),mish(a),ca,a,s) then goto skipend;//can copy ALL 32bits of color
if not missize(s,misw(a),mish(a)) then goto skipend;
if not miscopyarea32(0,0,misw(a),mish(a),ca,s,a) then goto skipend;//can copy ALL 32bits of color
misai(s).count:=1;
//successful
result:=true;
skipend:
except;end;
try;freeobj(@a);except;end;
end;
//## miscells ##
function miscells(s:tobject;var sbits,sw,sh,scellcount,scellw,scellh,sdelay:longint;var shasai:boolean;var stransparent:boolean):boolean;//27jul2021
var
   xbits,xw,xh:longint;
   xhasai:boolean;
begin
try
//defaults
result:=false;
sbits:=0;
sw:=1;
sh:=1;
scellcount:=1;
scellw:=1;
scellh:=1;
sdelay:=500;//500 ms
shasai:=false;
stransparent:=false;
//check
if not misokex(s,xbits,xw,xh,xhasai) then exit;
//get
sbits:=xbits;
sw:=frcmin(xw,1);
sh:=frcmin(xh,1);
if xhasai then
   begin
   scellcount:=frcmin(misai(s).count,1);
   stransparent:=misai(s).transparent;
   sdelay:=frcmin(misai(s).delay,1);
   end;
shasai:=xhasai;
scellw:=frcmin(trunc(sw/scellcount),1);
scellh:=sh;
//successful
result:=true;
except;end;
end;
//## miscellsFPS10 ##
function miscellsFPS10(s:tobject;var sbits,sw,sh,scellcount,scellw,scellh,sfps10:longint;var shasai:boolean;var stransparent:boolean):boolean;//27jul2021
var
   xms:longint;
begin
try
result:=miscells(s,sbits,sw,sh,scellcount,scellw,scellh,xms,shasai,stransparent);
sfps10:=frcmin(trunc(10000/xms),1);//x10=>100=10.0 fps
except;end;
end;
//## miscell ##
function miscell(s:tobject;sindex:longint;var scellarea:trect):boolean;
var
   sms,sbits,sw,sh,scellcount,scellw,scellh:longint;
   shasai:boolean;
   stransparent:boolean;
begin
try
//defaults
result:=false;
scellarea:=nilarea;
//get
if miscells(s,sbits,sw,sh,scellcount,scellw,scellh,sms,shasai,stransparent) then
   begin
   //range
   sindex:=frcrange(sindex,0,scellcount-1);
   //get
   scellarea.left:=sindex*scellw;
   scellarea.right:=scellarea.left+scellw-1;
   scellarea.top:=0;
   scellarea.bottom:=scellh-1;
   result:=true;
   end;
except;end;
end;
//## miscell2 ##
function miscell2(s:tobject;sindex:longint):trect;
begin
try;miscell(s,sindex,result);except;end;
end;
//## miscellarea ##
function miscellarea(s:tobject;sindex:longint):trect;
begin
try;miscell(s,sindex,result);except;end;
end;
//## misaiclear2 ##
function misaiclear2(s:tobject):boolean;
begin
try;result:=(s<>nil) and misaiclear(misai(s)^);except;end;
end;
//## misaiclear ##
function misaiclear(var x:tanimationinformation):boolean;
begin
try
//defaults
result:=false;
//get
with x do
begin
binary:=true;
format:='';
subformat:='';
info:='';//22APR2012
filename:='';
map16:='';//Warning: won't work under D10 - 21aug2020
transparent:=false;
syscolors:=false;
flip:=false;
mirror:=false;
delay:=0;
itemindex:=0;
count:=1;
bpp:=24;
//cursor - 20JAN2012
hotspotX:=0;
hotspotY:=0;
hotspotMANUAL:=false;//use system generated AUTOMATIC hotspot - 03jan2019
//special
owrite32bpp:=false;//22JAN2012
//final
readb64:=false;
readb128:=false;
writeb64:=false;
writeb128:=false;
//internal
iosplit:=0;//none
cellwidth:=0;
cellheight:=0;
use32:=false;
end;
//successful
result:=true;
except;end;
end;
//## msiai ##
function misai(s:tobject):panimationinformation;
begin
try
result:=@system_default_ai;//always return a pointer to a valid structure
if zznil(s,2078) then misaiclear(system_default_ai)
else if (s is tbasicimage) then result:=@(s as tbasicimage).ai
else if (s is tbmp) then result:=@(s as tbmp).ai
else misaiclear(system_default_ai);
except;end;
end;
//## low__aicopy ##
function low__aicopy(var s,d:tanimationinformation):boolean;
begin
try
//defaults
result           :=false;
//get
d.format         :=s.format;
d.subformat      :=s.subformat;
d.filename       :=s.filename;
d.map16          :=s.map16;
d.transparent    :=s.transparent;
d.syscolors      :=s.syscolors;//13apr2021
d.flip           :=s.flip;
d.mirror         :=s.mirror;
d.delay          :=s.delay;
d.itemindex      :=s.itemindex;
d.count          :=s.count;
d.bpp            :=s.bpp;
d.owrite32bpp    :=s.owrite32bpp;
d.binary         :=s.binary;
d.readB64        :=s.readB64;
d.readB128       :=s.readB128;
d.readB128       :=s.readB128;
d.writeB64       :=s.writeB64;
d.writeB128      :=s.writeB128;
d.iosplit        :=s.iosplit;
d.cellwidth      :=s.cellwidth;
d.cellheight     :=s.cellheight;
d.use32          :=s.use32;//22may2022
//.special - 10jul2019
d.hotspotMANUAL  :=s.hotspotMANUAL;
d.hotspotX       :=s.hotspotX;
d.hotspotY       :=s.hotspotY;
//successful
result           :=true;
except;end;
end;
//## misaicopy ##
function misaicopy(s,d:tobject):boolean;
begin
try
result:=false;
if mishasai(d) then
   begin
   if mishasai(s) then result:=low__aicopy(misai(s)^,misai(d)^) else result:=misaiclear(misai(d)^);
   end;
except;end;
end;
//## miscopy ##
function miscopy(s,d:tobject):boolean;//12feb2022
label
   skipend;
var
   //s
   sbits,sw,sh,scellcount,scellw,scellh,sdelay:longint;
   shasai:boolean;
   stransparent:boolean;
   //d
   dbits,dw,dh,dcellcount,dcellw,dcellh,ddelay:longint;
   dhasai:boolean;
   dtransparent:boolean;
begin
try
//defaults
result:=false;
//get
//.invalid
if zznil2(s) or zznil2(d) then goto skipend
//.fast
else if zzimg(s) and zzimg(d) then result:=asimg(d).copyfrom(asimg(s))//09may2022
//.moderate
else
   begin
   //.info
   if not miscells(s,sbits,sw,sh,scellcount,scellw,scellh,sdelay,shasai,stransparent) then goto skipend;
   if not miscells(d,dbits,dw,dh,dcellcount,dcellw,dcellh,ddelay,dhasai,dtransparent) then goto skipend;
   //.size
   if (sw<>dw) or (sh<>dh) and (not missize(d,sw,sh)) then goto skipend;
   //.bits
   if (sbits<>dbits) and (not missetb2(d,sbits)) then goto skipend;
   //.pixels -> full 32bit RGBA support - 15feb2022
   if not miscopyarea32(0,0,sw,sh,misarea(s),d,s) then goto skipend;
   //.ai
   if shasai and dhasai and (not misaicopy(s,d)) then goto skipend;
   end;
//successful
result:=true;
skipend:
except;end;
end;
//## misokex ##
function misokex(s:tobject;var sbits,sw,sh:longint;var shasai:boolean):boolean;
begin
try
//defaults
result:=false;
sbits:=0;
sw:=0;
sh:=0;
shasai:=false;
//check
if programdisablegraphics then exit;//special debug mode - 10jun2019
//get
if zznil(s,2079) then exit
else if (s is tbmp) then
   begin
   sw     :=(s as tbmp).width;
   sh     :=(s as tbmp).height;
   sbits  :=(s as tbmp).bits;
   shasai :=true;
   end
else if (s is tbasicimage) then
   begin
   sw     :=(s as tbasicimage).width;
   sh     :=(s as tbasicimage).height;
   sbits  :=(s as tbasicimage).bits;
   shasai :=true;
   end
else if (s is tbitmap) then
   begin
   sw:=(s as tbitmap).width;
   sh:=(s as tbitmap).height;
   if      (s as tbitmap).monochrome            then sbits:=1
   else if ((s as tbitmap).pixelformat=pf1bit)  then sbits:=1
   else if ((s as tbitmap).pixelformat=pf4bit)  then sbits:=4
   else if ((s as tbitmap).pixelformat=pf8bit)  then sbits:=8
   else if ((s as tbitmap).pixelformat=pf15bit) then sbits:=15
   else if ((s as tbitmap).pixelformat=pf16bit) then sbits:=16
   else if ((s as tbitmap).pixelformat=pf24bit) then sbits:=24
   else if ((s as tbitmap).pixelformat=pf32bit) then sbits:=32;
   end;
//set
result:=(sw>=1) and (sh>=1) and (sbits>=1);
except;end;
end;
//## misok ##
function misok(s:tobject;var sbits,sw,sh:longint):boolean;
var
   shasai:boolean;
begin
try;result:=misokex(s,sbits,sw,sh,shasai);except;end;
end;
//## misokk ##
function misokk(s:tobject):boolean;
var
   shasai:boolean;
   sbits,sw,sh:longint;
begin
try;result:=misokex(s,sbits,sw,sh,shasai);except;end;
end;
//## misokai ##
function misokai(s:tobject;var sbits,sw,sh:longint):boolean;
var
   shasai:boolean;
begin
try;result:=misokex(s,sbits,sw,sh,shasai) and shasai;except;end;
end;
//## misokaii ##
function misokaii(s:tobject):boolean;
var
   shasai:boolean;
   sbits,sw,sh:longint;
begin
try;result:=misokex(s,sbits,sw,sh,shasai) and shasai;except;end;
end;
//## misok8 ##
function misok8(s:tobject;var sw,sh:longint):boolean;
var
   sbits:longint;
   shasai:boolean;
begin
try;result:=misokex(s,sbits,sw,sh,shasai) and (sbits=8);except;end;
end;
//## misokai8 ##
function misokai8(s:tobject;var sw,sh:longint):boolean;
var
   sbits:longint;
   shasai:boolean;
begin
try;result:=misokex(s,sbits,sw,sh,shasai) and (sbits=8) and shasai;except;end;
end;
//## misok24 ##
function misok24(s:tobject;var sw,sh:longint):boolean;
var
   sbits:longint;
   shasai:boolean;
begin
try;result:=misokex(s,sbits,sw,sh,shasai) and (sbits=24);except;end;
end;
//## misokk24 ##
function misokk24(s:tobject):boolean;
var
   sbits,sw,sh:longint;
   shasai:boolean;
begin
try;result:=misokex(s,sbits,sw,sh,shasai) and (sbits=24);except;end;
end;
//## misok24 ##
function misokai24(s:tobject;var sw,sh:longint):boolean;
var
   sbits:longint;
   shasai:boolean;
begin
try;result:=misokex(s,sbits,sw,sh,shasai) and (sbits=24) and shasai;except;end;
end;
//## misok824 ##
function misok824(s:tobject;var sbits,sw,sh:longint):boolean;
var
   shasai:boolean;
begin
try;result:=misokex(s,sbits,sw,sh,shasai) and ((sbits=8) or (sbits=24));except;end;
end;
//## misok82432 ##
function misok82432(s:tobject;var sbits,sw,sh:longint):boolean;
var
   shasai:boolean;
begin
try;result:=misokex(s,sbits,sw,sh,shasai) and ((sbits=8) or (sbits=24) or (sbits=32));except;end;
end;
//## misokk824 ##
function misokk824(s:tobject):boolean;
var
   shasai:boolean;
   sbits,sw,sh:longint;
begin
try;result:=misokex(s,sbits,sw,sh,shasai) and ((sbits=8) or (sbits=24));except;end;
end;
//## misokk82432 ##
function misokk82432(s:tobject):boolean;
var
   shasai:boolean;
   sbits,sw,sh:longint;
begin
try;result:=misokex(s,sbits,sw,sh,shasai) and ((sbits=8) or (sbits=24) or (sbits=32));except;end;
end;
//## misokai824 ##
function misokai824(s:tobject;var sbits,sw,sh:longint):boolean;
var
   shasai:boolean;
begin
try;result:=misokex(s,sbits,sw,sh,shasai) and ((sbits=8) or (sbits=24)) and shasai;except;end;
end;
//## mismustlock ##
function mismustlock(s:tobject):boolean;
begin
try
result:=false;
if     zznil(s,2080) then exit
else if (s is tbmp)  then result:=not (s as tbmp).locked;
except;end;
end;
//## mislock ##
function mislock(s:tobject):boolean;
begin
try
result:=false;
if     zznil(s,2081) then exit
else if (s is tbmp)  then
   begin
   if not (s as tbmp).locked then
      begin
      (s as tbmp).lock;
      result:=(s as tbmp).locked;
      end;
   end;
except;end;
end;
//## misunlock ##
function misunlock(s:tobject):boolean;
begin
try
result:=false;
if     zznil(s,2082) then exit
else if (s is tbmp)  then
   begin
   if (s as tbmp).locked then
      begin
      (s as tbmp).unlock;
      result:=not (s as tbmp).locked;
      end;
   end;
except;end;
end;
//## mislocked ##
function mislocked(s:tobject):boolean;//27jan2021
begin
try
result:=false;
if     zznil(s,2083) then exit
else if (s is tbmp)  then result:=(s as tbmp).locked;
except;end;
end;
//## misinfo ##
function misinfo(s:tobject;var sbits,sw,sh:longint;var shasai:boolean):boolean;
begin
try
result:=false;
sbits:=0;
sw:=0;
sh:=0;
shasai:=false;
if zznil(s,2085) then exit;
sbits:=misb(s);
sw:=misw(s);
sh:=mish(s);
shasai:=mishasai(s);
result:=(sw>=1) and (sh>=1) and (sbits>=1);
except;end;
end;
//## misinfo2432 ##
function misinfo2432(s:tobject;var sbits,sw,sh:longint;var shasai:boolean):boolean;
begin
try;result:=misinfo(s,sbits,sw,sh,shasai) and ((sbits=24) or (sbits=32));except;end;
end;
//## misinfo82432 ##
function misinfo82432(s:tobject;var sbits,sw,sh:longint;var shasai:boolean):boolean;
begin
try;result:=misinfo(s,sbits,sw,sh,shasai) and ((sbits=8) or (sbits=24) or (sbits=32));except;end;
end;
//## misinfo8162432 ##
function misinfo8162432(s:tobject;var sbits,sw,sh:longint;var shasai:boolean):boolean;
begin
try;result:=misinfo(s,sbits,sw,sh,shasai) and ((sbits=8) or (sbits=16) or (sbits=24) or (sbits=32));except;end;
end;
//## misinfo824 ##
function misinfo824(s:tobject;var sbits,sw,sh:longint;var shasai:boolean):boolean;
begin
try;result:=misinfo(s,sbits,sw,sh,shasai) and ((sbits=8) or (sbits=24));except;end;
end;
//## misrows8 ##
function misrows8(s:tobject;var xout:pcolorrows8):boolean;
begin
try
//defaults
result:=false;
xout:=nil;
//get
if zznil(s,2086) then exit
else if (s is tbmp) then
   begin
   if (s as tbmp).canrows then xout:=(s as tbmp).prows8;
   end
else if (s is tbasicimage) then xout:=(s as tbasicimage).prows8;
//set
result:=(xout<>nil);
except;end;
end;
//## misrows16 ##
function misrows16(s:tobject;var xout:pcolorrows16):boolean;
begin
try
//defaults
result:=false;
xout:=nil;
//get
if zznil(s,2087) then exit
else if (s is tbmp) then
   begin
   if (s as tbmp).canrows then xout:=(s as tbmp).prows16;
   end
else if (s is tbasicimage) then xout:=(s as tbasicimage).prows16;
//set
result:=(xout<>nil);
except;end;
end;
//## misrows24 ##
function misrows24(s:tobject;var xout:pcolorrows24):boolean;
begin
try
//defaults
result:=false;
xout:=nil;
//get
if zznil(s,2088) then exit
else if (s is tbmp) then
   begin
   if (s as tbmp).canrows then xout:=(s as tbmp).prows24;
   end
else if (s is tbasicimage) then xout:=(s as tbasicimage).prows24;
//set
result:=(xout<>nil);
except;end;
end;
//## misrows32 ##
function misrows32(s:tobject;var xout:pcolorrows32):boolean;
begin
try
//defaults
result:=false;
xout:=nil;
//get
if zznil(s,2089) then exit
else if (s is tbmp) then
   begin
   if (s as tbmp).canrows then xout:=(s as tbmp).prows32;
   end
else if (s is tbasicimage) then xout:=(s as tbasicimage).prows32;
//set
result:=(xout<>nil);
except;end;
end;
//## misrows82432 ##
function misrows82432(s:tobject;var xout8:pcolorrows8;var xout24:pcolorrows24;var xout32:pcolorrows32):boolean;//26jan2021
begin
try
//defaults
result:=false;
xout8:=nil;
xout24:=nil;
xout32:=nil;
//get
if zznil(s,2090) then exit
else if (s is tbmp) then
   begin
   if (s as tbmp).canrows then
      begin
      xout8 :=(s as tbmp).prows8;
      xout24:=(s as tbmp).prows24;
      xout32:=(s as tbmp).prows32;
      end
   else exit;
   end
else if (s is tbasicimage) then
   begin
   xout8 :=(s as tbasicimage).prows8;
   xout24:=(s as tbasicimage).prows24;
   xout32:=(s as tbasicimage).prows32;
   end;
//set
result:=(xout8<>nil) and (xout24<>nil) and (xout32<>nil);
except;end;
end;
//## mispixel8VAL ##
function mispixel8VAL(s:tobject;sy,sx:longint):byte;
begin
result:=mispixel8(s,sy,sx);
end;
//## mispixel8 ##
function mispixel8(s:tobject;sy,sx:longint):tcolor8;
var
   sr8 :pcolorrow8;
   sr24:pcolorrow24;
   sr32:pcolorrow32;
   sc24:tcolor24;
   sc32:tcolor32;
   sbits,sw,sh:longint;
begin
try
//defaults
result:=0;
//get
if misok82432(s,sbits,sw,sh) and (sx>=0) and (sx<sw) and (sy>=0) and (sy<sh) and misscan82432(s,sy,sr8,sr24,sr32) then
   begin
   //.8
   if      (sbits=8)  then result:=sr8[sx]
   //.24
   else if (sbits=24) then
      begin
      sc24:=sr24[sx];
      result:=sc24.r;
      if (sc24.g>result) then result:=sc24.g;
      if (sc24.b>result) then result:=sc24.b;
      end
   //.32
   else if (sbits=32) then
      begin
      sc32:=sr32[sx];
      result:=sc32.r;
      if (sc32.g>result) then result:=sc32.g;
      if (sc32.b>result) then result:=sc32.b;
      end;
   end;
except;end;
end;
//## mispixel24VAL ##
function mispixel24VAL(s:tobject;sy,sx:longint):longint;
begin
result:=low__rgbint(mispixel24(s,sy,sx));
end;
//## mispixel24 ##
function mispixel24(s:tobject;sy,sx:longint):tcolor24;
var
   sr8 :pcolorrow8;
   sr24:pcolorrow24;
   sr32:pcolorrow32;
   sc32:tcolor32;
   sbits,sw,sh:longint;
begin
try
//defaults
result.r:=0;
result.g:=0;
result.b:=0;
//get
if misok82432(s,sbits,sw,sh) and (sx>=0) and (sx<sw) and (sy>=0) and (sy<sh) and misscan82432(s,sy,sr8,sr24,sr32) then
   begin
   //.8
   if      (sbits=8)  then
      begin
      result.r:=sr8[sx];
      result.g:=result.r;
      result.b:=result.r;
      end
   //.24
   else if (sbits=24) then result:=sr24[sx]
   //.32
   else if (sbits=32) then
      begin
      sc32:=sr32[sx];
      result.r:=sc32.r;
      result.g:=sc32.g;
      result.b:=sc32.b;
      end;
   end;
except;end;
end;
//## mispixel32VAL ##
function mispixel32VAL(s:tobject;sy,sx:longint):longint;
begin
result:=low__rgbaint(mispixel32(s,sy,sx));
end;
//## mispixel32 ##
function mispixel32(s:tobject;sy,sx:longint):tcolor32;
var
   sr8 :pcolorrow8;
   sr24:pcolorrow24;
   sr32:pcolorrow32;
   sc24:tcolor24;
   sbits,sw,sh:longint;
begin
try
//defaults
result.r:=0;
result.g:=0;
result.b:=0;
result.a:=0;
//get
if misok82432(s,sbits,sw,sh) and (sx>=0) and (sx<sw) and (sy>=0) and (sy<sh) and misscan82432(s,sy,sr8,sr24,sr32) then
   begin
   //.8
   if      (sbits=8)  then
      begin
      result.r:=sr8[sx];
      result.g:=result.r;
      result.b:=result.r;
      result.a:=255;
      end
   //.24
   else if (sbits=24) then
      begin
      sc24:=sr24[sx];
      result.r:=sc24.r;
      result.g:=sc24.g;
      result.b:=sc24.b;
      result.a:=255;
      end
   //.32
   else if (sbits=32) then result:=sr32[sx];
   end;
except;end;
end;
//## missetpixel32VAL ##
function missetpixel32VAL(s:tobject;sy,sx,xval:longint):boolean;
begin
result:=missetpixel32(s,sy,sx,low__intrgba32(xval));
end;
//## missetpixel32 ##
function missetpixel32(s:tobject;sy,sx:longint;xval:tcolor32):boolean;
var
   sr8 :pcolorrow8;
   sr24:pcolorrow24;
   sr32:pcolorrow32;
   sc24:tcolor24;
   sbits,sw,sh:longint;
begin
try
//defaults
result:=false;
//get
if misok82432(s,sbits,sw,sh) and (sx>=0) and (sx<sw) and (sy>=0) and (sy<sh) and misscan82432(s,sy,sr8,sr24,sr32) then
   begin
   //.8
   if      (sbits=8)  then
      begin
      sc24.r:=xval.r;
      sc24.g:=xval.g;
      sc24.b:=xval.b;
      sr8[sx]:=low__greyscale2(sc24);
      end
   //.24
   else if (sbits=24) then
      begin
      sc24.r:=xval.r;
      sc24.g:=xval.g;
      sc24.b:=xval.b;
      sr24[sx]:=sc24;
      end
   //.32
   else if (sbits=32) then sr32[sx]:=xval;
   end;
//successful
result:=true;
except;end;
end;
//## misscan82432 ##
function misscan82432(s:tobject;sy:longint;var sr8:pcolorrow8;var sr24:pcolorrow24;var sr32:pcolorrow32):boolean;//26jan2021
var
   sw,sh:longint;
begin
try
//defaults
result:=false;
sr8:=nil;
sr24:=nil;
sr32:=nil;
//check
if zznil(s,2091) then exit;
//init
sw:=misw(s);
sh:=mish(s);
if (sw<=0) or (sh<=0) then exit;
//range
if (sy<0) then sy:=0 else if (sy>=sh) then sy:=sh-1;

//fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

//get
if (s is tbasicimage) then
   begin
   sr8 :=(s as tbasicimage).prows8[sy];
   sr24:=(s as tbasicimage).prows24[sy];
   sr32:=(s as tbasicimage).prows32[sy];
   end
else if (s is tbmp) then
   begin
   if (s as tbmp).canrows then
      begin
      sr8 :=(s as tbmp).prows8[sy];
      sr24:=(s as tbmp).prows24[sy];
      sr32:=(s as tbmp).prows32[sy];
      end
   else exit;
   end
else if (s is tbitmap) then//Warning: Use with care -> not really supported for mobile phone technology - 26jan2021
   begin
   sr8 :=(s as tbitmap).scanline[sy];
   sr24:=(s as tbitmap).scanline[sy];
   sr32:=(s as tbitmap).scanline[sy];
   end
else exit;
//successful
result:=(sr8<>nil) and (sr24<>nil) and (sr32<>nil);
except;end;
end;
//## misscan8 ##
function misscan8(s:tobject;sy:longint;var sr8:pcolorrow8):boolean;//26jan2021
var
   sw,sh:longint;
begin
try
//defaults
result:=false;
sr8:=nil;
//check
if zznil(s,2092) then exit;
//init
sw:=misw(s);
sh:=mish(s);
if (sw<=0) or (sh<=0) then exit;
//range
if (sy<0) then sy:=0 else if (sy>=sh) then sy:=sh-1;

//fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

//get
if (s is tbasicimage) then
   begin
   sr8 :=(s as tbasicimage).prows8[sy];
   end
else if (s is tbmp) then
   begin
   if (s as tbmp).canrows then
      begin
      sr8 :=(s as tbmp).prows8[sy];
      end
   else exit;
   end
else if (s is tbitmap) then//Warning: Use with care -> not really supported dfor mobile phone technology - 26jan2021
   begin
   sr8 :=(s as tbitmap).scanline[sy];
   end
else exit;
//successful
result:=(sr8<>nil);
except;end;
end;
//## misscan24 ##
function misscan24(s:tobject;sy:longint;var sr24:pcolorrow24):boolean;//26jan2021
var
   sw,sh:longint;
begin
try
//defaults
result:=false;
sr24:=nil;
//check
if zznil(s,2093) then exit;
//init
sw:=misw(s);
sh:=mish(s);
if (sw<=0) or (sh<=0) then exit;
//range
if (sy<0) then sy:=0 else if (sy>=sh) then sy:=sh-1;

//fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

//get
if (s is tbasicimage) then
   begin
   sr24:=(s as tbasicimage).prows24[sy];
   end
else if (s is tbmp) then
   begin
   if (s as tbmp).canrows then
      begin
      sr24:=(s as tbmp).prows24[sy];
      end
   else exit;
   end
else if (s is tbitmap) then//Warning: Use with care -> not really supported dfor mobile phone technology - 26jan2021
   begin
   sr24:=(s as tbitmap).scanline[sy];
   end
else exit;
//successful
result:=(sr24<>nil);
except;end;
end;
//## misscan32 ##
function misscan32(s:tobject;sy:longint;var sr32:pcolorrow32):boolean;//26jan2021
var
   sw,sh:longint;
begin
try
//defaults
result:=false;
sr32:=nil;
//check
if zznil(s,2099) then exit;
//init
sw:=misw(s);
sh:=mish(s);
if (sw<=0) or (sh<=0) then exit;
//range
if (sy<0) then sy:=0 else if (sy>=sh) then sy:=sh-1;

//fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

//get
if (s is tbasicimage) then
   begin
   sr32:=(s as tbasicimage).prows32[sy];
   end
else if (s is tbmp) then
   begin
   if (s as tbmp).canrows then
      begin
      sr32:=(s as tbmp).prows32[sy];
      end
   else exit;
   end
else if (s is tbitmap) then//Warning: Use with care -> not really supported dfor mobile phone technology - 26jan2021
   begin
   sr32:=(s as tbitmap).scanline[sy];
   end
else exit;
//successful
result:=(sr32<>nil);
except;end;
end;
//## misscan2432 ##
function misscan2432(s:tobject;sy:longint;var sr24:pcolorrow24;var sr32:pcolorrow32):boolean;//26jan2021
var
   sw,sh:longint;
begin
try
//defaults
result:=false;
sr24:=nil;
sr32:=nil;
//check
if zznil(s,2100) then exit;
//init
sw:=misw(s);
sh:=mish(s);
if (sw<=0) or (sh<=0) then exit;
//range
if (sy<0) then sy:=0 else if (sy>=sh) then sy:=sh-1;

//fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

//get
if (s is tbasicimage) then
   begin
   sr24:=(s as tbasicimage).prows24[sy];
   sr32:=(s as tbasicimage).prows32[sy];
   end
else if (s is tbmp) then
   begin
   if (s as tbmp).canrows then
      begin
      sr24:=(s as tbmp).prows24[sy];
      sr32:=(s as tbmp).prows32[sy];
      end
   else exit;
   end
else if (s is tbitmap) then//Warning: Use with care -> not really supported dfor mobile phone technology - 26jan2021
   begin
   sr24:=(s as tbitmap).scanline[sy];
   sr32:=(s as tbitmap).scanline[sy];
   end
else exit;
//successful
result:=(sr24<>nil) and (sr32<>nil);
except;end;
end;
//## misscan824 ##
function misscan824(s:tobject;sy:longint;var sr8:pcolorrow8;var sr24:pcolorrow24):boolean;//26jan2021
var
   sw,sh:longint;
begin
try
//defaults
result:=false;
sr8:=nil;
sr24:=nil;
//check
if zznil(s,2101) then exit;
//init
sw:=misw(s);
sh:=mish(s);
if (sw<=0) or (sh<=0) then exit;
//range
if (sy<0) then sy:=0 else if (sy>=sh) then sy:=sh-1;

//fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

//get
if (s is tbasicimage) then
   begin
   sr8 :=(s as tbasicimage).prows8[sy];
   sr24:=(s as tbasicimage).prows24[sy];
   end
else if (s is tbmp) then
   begin
   if (s as tbmp).canrows then
      begin
      sr8 :=(s as tbmp).prows8[sy];
      sr24:=(s as tbmp).prows24[sy];
      end
   else exit;
   end
else if (s is tbitmap) then//Warning: Use with care -> not really supported dfor mobile phone technology - 26jan2021
   begin
   sr8 :=(s as tbitmap).scanline[sy];
   sr24:=(s as tbitmap).scanline[sy];
   end
else exit;
//successful
result:=(sr8<>nil) and (sr24<>nil);
except;end;
end;
//## misscan832 ##
function misscan832(s:tobject;sy:longint;var sr8:pcolorrow8;var sr32:pcolorrow32):boolean;//14feb2022
var
   sw,sh:longint;
begin
try
//defaults
result:=false;
sr8:=nil;
sr32:=nil;
//check
if zznil(s,2101) then exit;
//init
sw:=misw(s);
sh:=mish(s);
if (sw<=0) or (sh<=0) then exit;
//range
if (sy<0) then sy:=0 else if (sy>=sh) then sy:=sh-1;

//fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

//get
if (s is tbasicimage) then
   begin
   sr8 :=(s as tbasicimage).prows8[sy];
   sr32:=(s as tbasicimage).prows32[sy];
   end
else if (s is tbmp) then
   begin
   if (s as tbmp).canrows then
      begin
      sr8 :=(s as tbmp).prows8[sy];
      sr32:=(s as tbmp).prows32[sy];
      end
   else exit;
   end
else if (s is tbitmap) then//Warning: Use with care -> not really supported dfor mobile phone technology - 26jan2021
   begin
   sr8 :=(s as tbitmap).scanline[sy];
   sr32:=(s as tbitmap).scanline[sy];
   end
else exit;
//successful
result:=(sr8<>nil) and (sr32<>nil);
except;end;
end;
//## misbitmap ##
function misbitmap(dbits,dw,dh:longint):tbitmap;
begin//Note: Flow now goes -> ask for bits -> get what we can get -> must check what bits we actually got under Android etc - 03may2020
try
result:=nil;
dw:=frcmin(dw,1);
dh:=frcmin(dh,1);
result:=createbitmap;
missetb(result,dbits);
missize(result,dw,dh);
except;end;
end;
//## misbitmap32 ##
function misbitmap32(dw,dh:longint):tbitmap;
begin
try;result:=misbitmap(32,dw,dh);except;end;
end;
{$ifdef jpeg}
//## misjpg ##
function misjpg:tjpegimage;//01may2021
begin
try
result:=nil;
result:=tjpegimage.create;
zzadd(result);
satinc(satJpegimage,1);
except;end;
end;
{$endif}
//## misbmp ##
function misbmp(dbits,dw,dh:longint):tbmp;
begin//Note: Flow now goes -> ask for bits -> get what we can get -> must check what bits we actually got under Android etc - 03may2020
try
result:=nil;
dw:=frcmin(dw,1);
dh:=frcmin(dh,1);
result:=tbmp.create;
result.setparams(dbits,dw,dh);
except;end;
end;
//## misbmp32 ##
function misbmp32(dw,dh:longint):tbmp;
begin
try;result:=misbmp(32,dw,dh);except;end;
end;
//## misbmp24 ##
function misbmp24(dw,dh:longint):tbmp;
begin
try;result:=misbmp(24,dw,dh);except;end;
end;
//## misimg ##
function misimg(dbits,dw,dh:longint):tbasicimage;
begin
try
result:=nil;
result:=tbasicimage.create;
result.setparams(dbits,frcmin(dw,1),frcmin(dh,1));
except;end;
end;
//## misimg8 ##
function misimg8(dw,dh:longint):tbasicimage;//26jan2021
begin
try;result:=misimg(8,dw,dh);except;end;
end;
//## misimg24 ##
function misimg24(dw,dh:longint):tbasicimage;
begin
try;result:=misimg(24,dw,dh);except;end;
end;
//## misimg32 ##
function misimg32(dw,dh:longint):tbasicimage;
begin
try;result:=misimg(32,dw,dh);except;end;
end;
//## misatleast ##
function misatleast(s:tobject;dw,dh:longint):boolean;//26jul2021
label
   skipend;
begin
try
//defaults
result:=false;
//check
if zznil(s,101) then exit;
//get
if (dw<=0) or (dh<=0) then
   begin
   result:=true;
   exit;
   end;
if (misw(s)<dw) or (mish(s)<dh) then
   begin
   if not missize(s,dw+100,dh+100) then goto skipend;
   end;
//successful
result:=true;
skipend:
except;end;
end;
//## missize ##
function missize(s:tobject;dw,dh:longint):boolean;
begin
try;result:=missize2(s,dw,dh,false);except;end;
end;
//## missize2 ##
function missize2(s:tobject;dw,dh:longint;xoverridelock:boolean):boolean;
label
   skipend;
var
   xmustrelock:boolean;
begin
try
//defaults
result:=false;
xmustrelock:=false;
//check
if zznil(s,2102) then exit;
//range
dw:=frcmin(dw,1);
dh:=frcmin(dh,1);
//.bmp
if (s is tbmp) then
   begin
   if (dw<>(s as tbmp).width) or (dh<>(s as tbmp).height) then
      begin
      //init
      xmustrelock:=mislocked(s);
      if xmustrelock then misunlock(s);
      //check
      if not (s as tbmp).cansetparams then goto skipend;
      //shrink
      (s as tbmp).setparams((s as tbmp).bits,1,1);
      //enlarge
      result:=(s as tbmp).setparams((s as tbmp).bits,dw,dh);
      end
   else result:=true;
   end
//.image
else if (s is tbasicimage) then result:=(s as tbasicimage).sizeto(dw,dh)
//.bitmap
else if (s is tbitmap) then
   begin
   if (dw<>(s as tbitmap).width) or (dh<>(s as tbitmap).height) then
      begin
      //shrink
      (s as tbitmap).height:=1;
      (s as tbitmap).width:=1;
      //enlarge
      (s as tbitmap).width:=dw;
      (s as tbitmap).height:=dh;
      end;
   //successful
   result:=true;
   end;
skipend:
except;end;
try;if xmustrelock then mislock(s);except;end;
end;
//## miscountcolors ##
function miscountcolors(i:tobject):longint;//full color count - uses dynamic memory (2mb) - 15OCT2009
begin
try;result:=miscountcolors2(rect(0,0,maxint,maxint),i,nil);except;end;
end;
//## miscountcolors2 ##
function miscountcolors2(da_clip:trect;i,xsel:tobject):longint;//full color count - uses dynamic memory (2mb) - 19sep2018, 15OCT2009
label
   skipend;
const
   maxp=2097152;
type
   pcs=^tcs;
   tcs=array[0..maxp] of set of 0..7;
var//~580ms for a 1152x864 [24bit] with 362,724 colors
   //Dynamic memory used now instead of limited stack - 15OCT2009
   xselw,xselh,iw,ih,ibits,xselbits,p,ci,ip,rx,ry:longint;
   a32:pcolorrow32;
   a24,xselr24:pcolorrow24;
   a8,xselr8:pcolorrow8;
   b:tdynamicbyte;
   z32:tcolor32;
   z24:tcolor24;
   ics:pcs;
   c2:set of 0..7;
   xselok:boolean;
begin
try
//defaults
result:=0;
b:=nil;
//check
if not misok82432(i,ibits,iw,ih) then exit;
//init
b:=tdynamicbyte.create;
b.setparams(maxp+1,maxp+1,0);
ics:=b.core;
//.x range
da_clip.left:=frcrange(da_clip.left,0,iw-1);
da_clip.right:=frcrange(da_clip.right,0,iw-1);
low__orderint(da_clip.left,da_clip.right);
//.y range
da_clip.top:=frcrange(da_clip.top,0,ih-1);
da_clip.bottom:=frcrange(da_clip.bottom,0,ih-1);
low__orderint(da_clip.top,da_clip.bottom);
//.xselok
xselok:=misok824(xsel,xselbits,xselw,xselh) and (xselw>=iw) and (xselh>=ih);
//get
//.ry
for ry:=da_clip.top to da_clip.bottom do
begin
if not misscan82432(i,ry,a8,a24,a32) then goto skipend;
if xselok and (not misscan824(xsel,ry,xselr8,xselr24)) then goto skipend;
//.32
if (ibits=32) then
   begin
   for rx:=da_clip.left to da_clip.right do if (xselbits=0) or ((xselbits=8) and (xselr8[rx]>=1)) or ((xselbits=24) and (xselr24[rx].r>=1)) then
   begin
   //.get
   z32:=a32[rx];
   p:=z32.r+z32.g*256+z32.b*65536;//0..16,777,215 -> 0..2,097,152
   ip:=p div 8;
   ci:=p-ip*8;
   //.set
   if not (ci in ics[ip]) then include(ics[ip],ci);
   end;//rx
   end
//.24
else if (ibits=24) then
   begin
   for rx:=da_clip.left to da_clip.right do if (xselbits=0) or ((xselbits=8) and (xselr8[rx]>=1)) or ((xselbits=24) and (xselr24[rx].r>=1)) then
   begin
   //.get
   z24:=a24[rx];
   p:=z24.r+z24.g*256+z24.b*65536;//0..16,777,215 -> 0..2,097,152
   ip:=p div 8;
   ci:=p-ip*8;
   //.set
   if not (ci in ics[ip]) then include(ics[ip],ci);
   end;//rx
   end
//.8
else if (ibits=8) then
   begin
   for rx:=da_clip.left to da_clip.right do if (xselbits=0) or ((xselbits=8) and (xselr8[rx]>=1)) or ((xselbits=24) and (xselr24[rx].r>=1)) then
   begin
   //.get
   z24.r:=a8[rx];
   p:=z24.r+z24.r*256+z24.r*65536;//0..16,777,215 -> 0..2,097,152
   ip:=p div 8;
   ci:=p-ip*8;
   //.set
   if not (ci in ics[ip]) then include(ics[ip],ci);
   end;//rx
   end;
end;//ry

//return result
for rx:=0 to maxp do
begin
c2:=ics[rx];
if (byte(c2)>=1) then//25ms faster than "(c2<>[])"
   begin
   if (0 in c2) then result:=result+1;//faster than a loop
   if (1 in c2) then result:=result+1;
   if (2 in c2) then result:=result+1;
   if (3 in c2) then result:=result+1;
   if (4 in c2) then result:=result+1;
   if (5 in c2) then result:=result+1;
   if (6 in c2) then result:=result+1;
   if (7 in c2) then result:=result+1;
   end;//end of if
end;//end of loop
skipend:
except;end;
try;freeobj(@b);except;end;
end;
//## mismove82432 ##
function mismove82432(s:tobject;xmove,ymove:longint):boolean;//19jun2021
label
   skipend;
var
   a:tbasicimage;
   dr8,sr8:pcolorrow8;
   dr24,sr24:pcolorrow24;
   dr32,sr32:pcolorrow32;
   sc8:tcolor8;
   sc24:tcolor24;
   sc32:tcolor32;
   sbits,sw,sh,dx,dy,sx,sy:longint;
begin
try
//defaults
result:=false;
a:=nil;
//check
if not misok82432(s,sbits,sw,sh) then exit;
//init
xmove:=frcrange(-xmove,-sw,sw);
if (xmove<0) then xmove:=sw+xmove;
ymove:=frcrange(-ymove,-sh,sh);
if (ymove<0) then ymove:=sh+ymove;
//check
if ((xmove<=0) or (xmove>=sw)) and ((ymove<=0) or (ymove>=sh)) then
   begin
   result:=true;
   exit;
   end;
//take a copy
a:=misimg(sbits,sw,sh);
if not miscopyareaxx1(0,0,sw,sh,misarea(s),a,s) then goto skipend;
//get
sy:=ymove;
for dy:=0 to (sh-1) do
begin
sx:=xmove;
if not misscan82432(a,sy,sr8,sr24,sr32) then goto skipend;
if not misscan82432(s,dy,dr8,dr24,dr32) then goto skipend;
//.32
if (sbits=32) then
   begin
   for dx:=0 to (sw-1) do
   begin
   sc32:=sr32[sx];
   dr32[dx]:=sc32;
   //inc
   inc(sx);
   if (sx>=sw) then sx:=0;
   end;//dx
   end
//.24
else if (sbits=24) then
   begin
   for dx:=0 to (sw-1) do
   begin
   sc24:=sr24[sx];
   dr24[dx]:=sc24;
   //inc
   inc(sx);
   if (sx>=sw) then sx:=0;
   end;//dx
   end
else if (sbits=8) then
   begin
   for dx:=0 to (sw-1) do
   begin
   sc8:=sr8[sx];
   dr8[dx]:=sc8;
   //inc
   inc(sx);
   if (sx>=sw) then sx:=0;
   end;//dx
   end;
//inc
inc(sy);
if (sy>=sh) then sy:=0;
end;//p
//successful
result:=true;
skipend:
except;end;
try;freeobj(@a);except;end;
end;
//## mismatch82432 ##
function mismatch82432(s,d:tobject;xtol,xfailrate:longint):boolean;//10jul2021
begin
try;result:=mismatcharea82432(s,d,misarea(s),misarea(d),xtol,xfailrate);except;end;
end;
//## mismatcharea82432 ##
function mismatcharea82432(s,d:tobject;sa,da:trect;xtol,xfailrate:longint):boolean;//10jul2021
label
   skipend;
var
   sr32,dr32:pcolorrow32;
   sr24,dr24:pcolorrow24;
   sr8,dr8:pcolorrow8;
   sc32,dc32:tcolor32;
   sc24,dc24:tcolor24;
   sc8,dc8:tcolor8;
   xfailcount,dx,dy,sbits,sw,sh,dbits,dw,dh:longint;
begin
try
//check
result:=false;
if not misok82432(s,sbits,sw,sh) then exit;
if not misok82432(d,dbits,dw,dh) then exit;

//compare - fast
if (sbits<>dbits) then goto skipend;
//.xfailrate
xtol:=frcrange(xtol,0,50);
xfailrate:=frcmin(xfailrate,0);
//.range - sa
sa.left   :=frcrange(sa.left  ,0,sw-1);
sa.right  :=frcrange(sa.right ,0,sw-1);
sa.top    :=frcrange(sa.top   ,0,sh-1);
sa.bottom :=frcrange(sa.bottom,0,sh-1);
if (sa.right<sa.left) or (sa.bottom<sa.top) then goto skipend;
//.range - da
da.left   :=frcrange(da.left  ,0,dw-1);
da.right  :=frcrange(da.right ,0,dw-1);
da.top    :=frcrange(da.top   ,0,dh-1);
da.bottom :=frcrange(da.bottom,0,dh-1);
if (da.right<da.left) or (da.bottom<da.top) then goto skipend;
//.check
if ((sa.right-sa.left)<>(da.right-da.left)) then exit;
if ((sa.bottom-sa.top)<>(da.bottom-da.top)) then exit;

//compare - slow
for dy:=da.top to da.bottom do
begin
if not misscan82432(s,sa.top+(dy-da.top),sr8,sr24,sr32) then goto skipend;
if not misscan82432(d,dy,dr8,dr24,dr32) then goto skipend;
xfailcount:=0;
//.32
if (sbits=32) then
   begin
   for dx:=da.left to da.right do
   begin
   sc32:=sr32[sa.left+(dx-da.left)];
   dc32:=dr32[dx];
   if (sc32.r<>dc32.r) or (sc32.g<>dc32.g) or (sc32.b<>dc32.b) or (sc32.a<>dc32.a) then
      begin
      inc(xfailcount);
      if (xfailcount>=xfailrate) then goto skipend;
      end;
   end;//dx
   end
//.24
else if (sbits=24) then
   begin
   for dx:=da.left to da.right do
   begin
   sc24:=sr24[sa.left+(dx-da.left)];
   dc24:=dr24[dx];
//   if (sc24.r<>dc24.r) or (sc24.g<>dc24.g) or (sc24.b<>dc24.b) then
   if (sc24.r<(dc24.r-xtol)) or (sc24.r>(dc24.r+xtol)) or
      (sc24.g<(dc24.g-xtol)) or (sc24.g>(dc24.g+xtol)) or
      (sc24.b<(dc24.b-xtol)) or (sc24.b>(dc24.b+xtol)) then
      begin
      inc(xfailcount);
      if (xfailcount>=xfailrate) then goto skipend;
      end;
   end;//dx
   end
//.8
else if (sbits=8) then
   begin
   for dx:=da.left to da.right do
   begin
   sc8:=sr8[sa.left+(dx-da.left)];
   dc8:=dr8[dx];
   if (sc8<>dc8) then
      begin
      inc(xfailcount);
      if (xfailcount>=xfailrate) then goto skipend;
      end;
   end;//dx
   end;
end;//dy

//successful
result:=true;
skipend:
except;end;
end;
//## misclean ##
function misclean(s:tobject;scol,stol:longint):boolean;//19sep2022
label
   skipend;
var
   sr32:pcolorrow32;
   sr24:pcolorrow24;
   sr8:pcolorrow8;
   c32:tcolor32;
   s24,c24:tcolor24;
   c8:tcolor8;
   slum,sx,sy,sbits,sw,sh:longint;
   r1,r2,g1,g2,b1,b2,slum1,slum2:longint;
begin
try
//defaults
result:=false;
//check
if (scol=clnone) then
   begin
   result:=true;
   exit;
   end;
if not misok82432(s,sbits,sw,sh) then exit;
//range
s24:=low__intrgb(misfindtranscol82432(s,scol));
stol:=frcrange(stol,0,255);
r1:=s24.r-stol;
r2:=s24.r+stol;
g1:=s24.g-stol;
g2:=s24.g+stol;
b1:=s24.b-stol;
b2:=s24.b+stol;
slum:=low__greyscale2b(s24);
slum1:=slum-stol;
slum2:=slum+stol;

//get
for sy:=0 to (sh-1) do
begin
//.scan
if not misscan82432(s,sy,sr8,sr24,sr32) then goto skipend;

//.32
if (sbits=32) then
   begin
   for sx:=0 to (sw-1) do
   begin
   c32:=sr32[sx];
   if (c32.r>=r1) and (c32.r<=r2) and (c32.g>=g1) and (c32.g<=g2) and (c32.b>=b1) and (c32.b<=b2) then
      begin
      c32.r:=s24.r;
      c32.g:=s24.g;
      c32.b:=s24.b;
      sr32[sx]:=c32;
      end;
   end;//sx
   end
//.24
else if (sbits=24) then
   begin
   for sx:=0 to (sw-1) do
   begin
   c24:=sr24[sx];
   if (c24.r>=r1) and (c24.r<=r2) and (c24.g>=g1) and (c24.g<=g2) and (c24.b>=b1) and (c24.b<=b2) then sr24[sx]:=s24;
   end;//sx
   end
//.8
else if (sbits=8) then
   begin
   for sx:=0 to (sw-1) do
   begin
   c8:=sr8[sx];
   if (c8>=slum1) and (c8<=slum2) then sr8[sx]:=slum;
   end;//sx
   end;
end;//sy

//successful
result:=true;
skipend:
except;end;
end;
//## miscls ##
function miscls(s:tobject;xcolor:longint):boolean;
begin
try;result:=misclsarea2(s,rect(0,0,maxint,maxint),xcolor,xcolor);except;end;
end;
//## misclsarea ##
function misclsarea(s:tobject;sarea:trect;xcolor:longint):boolean;
begin
try;result:=misclsarea3(s,sarea,xcolor,xcolor,clnone,clnone);except;end;
end;
//## misclsarea2 ##
function misclsarea2(s:tobject;sarea:trect;xcolor,xcolor2:longint):boolean;
begin
try;result:=misclsarea3(s,sarea,xcolor,xcolor2,clnone,clnone);except;end;
end;
//## misclsarea3 ##
function misclsarea3(s:tobject;sarea:trect;xcolor,xcolor2,xalpha,xalpha2:longint):boolean;
label
   skipdone,skipend;
var
  sr8 :pcolorrow8;
  sr16:pcolorrow16;
  sr24:pcolorrow24;
  sr32:pcolorrow32;
  sc8 :tcolor8;
  sc16:tcolor16;
  sc24,sc,sc2:tcolor24;
  sc32:tcolor32;
  dx,dy,sbits,sw,sh:longint;
  xpert:extended;
  xcolorok,xalphaok,shasai:boolean;
  da:trect;
  xa:byte;
begin
try
//defaults
result:=false;
//check
if not misinfo8162432(s,sbits,sw,sh,shasai) then exit;
//range
if (sarea.right<sarea.left) or (sarea.bottom<sarea.top) or (sarea.bottom<0) or (sarea.top>=sh) or (sarea.right<0) or (sarea.left>=sw) then
   begin
   result:=true;
   exit;
   end;
da.left:=frcrange(sarea.left,0,sw-1);
da.right:=frcrange(sarea.right,0,sw-1);
da.top:=frcrange(sarea.top,0,sh-1);
da.bottom:=frcrange(sarea.bottom,0,sh-1);

//init
//.color
if (xcolor <>clnone) and (xcolor2=clnone) then xcolor2:=xcolor;
if (xcolor2<>clnone) and (xcolor =clnone) then xcolor:=xcolor2;
xcolorok:=(xcolor<>clnone) and (xcolor2<>clnone);
if xcolorok then
   begin
   sc:=low__intrgb(xcolor);
   sc2:=low__intrgb(xcolor2);
   end;
//.alpha
if (xalpha <>clnone) and (xalpha2=clnone) then xalpha2:=xalpha;
if (xalpha2<>clnone) and (xalpha =clnone) then xalpha:=xalpha2;
xalphaok:=(xalpha<>clnone) and (xalpha2<>clnone);
if xalphaok then
   begin
   xalpha:=frcrange(xalpha,0,255);
   xalpha2:=frcrange(xalpha2,0,255);
   end;
//check
if (not xcolorok) and (not xalphaok) then goto skipdone;
//get
for dy:=da.top to da.bottom do
begin
//.color gradient - optional
if xcolorok and (xcolor<>xcolor2) or (dy=da.top) then
   begin
   //.make color
   if (xcolor=xcolor2) then
      begin
      sc24.r:=sc.r;
      sc24.g:=sc.g;
      sc24.b:=sc.b;
      end
   else
      begin
      xpert:=(dy-da.top+1)/(da.bottom-da.top+1);
      sc24.r:=round( (sc.r*(1-xpert))+(sc2.r*xpert) );
      sc24.g:=round( (sc.g*(1-xpert))+(sc2.g*xpert) );
      sc24.b:=round( (sc.b*(1-xpert))+(sc2.b*xpert) );
      end;
   //.more bits
   case sbits of
   8:begin
      sc8:=sc24.r;
      if (sc24.g>sc8) then sc8:=sc24.g;
      if (sc24.b>sc8) then sc8:=sc24.b;
      end;
   16:sc16:=(sc24.r div 8) + (sc24.g div 8)*32 + (sc24.b div 8)*1024;
   32:begin
      sc32.r:=sc24.r;
      sc32.g:=sc24.g;
      sc32.b:=sc24.b;
      sc32.a:=255;//fully solid
      end;
   end;//case
   end;
//.alpha gradient - optional
//was: if xalphaok and (xalpha<>xalpha2) or (dy=da.top) then
if xalphaok and ((xalpha<>xalpha2) or (dy=da.top)) then//fixed error - 22apr2021
   begin
   //.make alpha
   if (xalpha=xalpha2) then
      begin
      xa:=xalpha;
      end
   else
      begin
      xpert:=(dy-da.top+1)/(da.bottom-da.top+1);
      xa:=byte(frcrange(round( (xalpha*(1-xpert))+(xalpha2*xpert) ),0,255));
      end;
   end;
//.scan
if not misscan2432(s,dy,sr24,sr32) then goto skipend;
//.pixels
case sbits of
8 :begin
   if not xcolorok then goto skipdone;
   sr8:=pointer(sr24);
   for dx:=da.left to da.right do sr8[dx]:=sc8;
   end;
16:begin
   if not xcolorok then goto skipdone;
   sr16:=pointer(sr24);
   for dx:=da.left to da.right do sr16[dx]:=sc16;
   end;
24:begin
   if not xcolorok then goto skipdone;
   for dx:=da.left to da.right do sr24[dx]:=sc24;
   end;
32:begin
   //.c + a
   if xcolorok and xalphaok then
      begin
      sc32.a:=xa;
      for dx:=da.left to da.right do sr32[dx]:=sc32;
      end
   //.c only
   else if xcolorok then
      begin
      for dx:=da.left to da.right do sr32[dx]:=sc32;
      end
   //.a only
   else if xalphaok then
      begin
      for dx:=da.left to da.right do sr32[dx].a:=xa;
      end;
   end;
end;//case
end;//dy
//successful
skipdone:
result:=true;
skipend:
except;end;
end;
//## misdrawcanvas ##
function misdrawcanvas(d:tcanvas;dx,dy:longint;s:tgraphic;scanvas:tcanvas):boolean;
begin
try
//defaults
result:=false;
//check
if (d=nil) or (s=nil) then exit;
//get
if sysfasttiminginuse and (scanvas<>nil) then
   begin
   miscopyarea(d,scanvas,rect(0,0,s.width-1,s.height-1));
   end
else d.draw(0,0,s);
except;end;
end;
//## miscopyarea ##
function miscopyarea(d,s:tcanvas;a:trect):boolean;
begin
try;result:=miscopyarea2(d,s,a,a);except;end;
end;
//## miscopyarea2 ##
function miscopyarea2(d,s:tcanvas;da,sa:trect):boolean;
label
   redo;
const
   ystep=200;
var
   dda:trect;
   ypos:longint;
   //## xpullarea ##
   function xpullarea(var a:trect):boolean;
   begin
   //defaults
   result:=false;
   //get
   if (ypos<=da.bottom) then
      begin
      a.left:=da.left;
      a.right:=da.right;
      a.top:=ypos;
      a.bottom:=frcmax(ypos+ystep,da.bottom);
      inc(ypos,ystep);
      if (a.bottom=da.bottom) then inc(ypos,1);//push past end of boudary to prevent another cycle
      result:=true;
      end;
   end;
begin
try
//defaults
result:=false;
//check
if (d=nil) or (s=nil) then exit;
if (da.right<da.left) or (da.bottom<da.top) or (sa.right<sa.left) or (sa.bottom<sa.top) then
   begin
   result:=true;
   exit;
   end;
//get
{$ifdef D3}
//.bit by bit for stable fasttimer - 07jul2021
if sysfasttiminginuse and low__areaequal(da,sa) then
   begin
   ypos:=da.top;
redo:
   if xpullarea(dda) then
      begin
      d.copyrect(rect(dda.left,dda.top,dda.right+1,dda.bottom+1),s,rect(dda.left,dda.top,dda.right+1,dda.bottom+1));
      app__fasttimer;//30sep2021
      goto redo;
      end;
   end
//.all at once
else d.copyrect(rect(da.left,da.top,da.right+1,da.bottom+1),s,rect(sa.left,sa.top,sa.right+1,sa.bottom+1));
result:=true;
{$endif}
{$ifdef D10}
//.bit by bit for stable fasttimer - 07jul2021
if sysfasttiminginuse and low__areaequal(da,sa) then
   begin
   ypos:=da.top;
redo:
   if xpullarea(dda) then
      begin
      d.copyrect(rect(dda.left,dda.top,dda.right+1,dda.bottom+1),s,rect(dda.left,dda.top,dda.right+1,dda.bottom+1));
      app__fasttimer;//30sep2021
      goto redo;
      end;
   end
//.all at once
else d.copyrect(rect(da.left,da.top,da.right+1,da.bottom+1),s,rect(sa.left,sa.top,sa.right+1,sa.bottom+1));
result:=true;
{$endif}
except;end;
end;
//## miscopypixels ##
function miscopypixels(var drows,srows:pcolorrows8;xbits,xw,xh:longint):boolean;
var//Assumed: common to both is xbits, xw and xh
   //Note: Ultra-rapid pixel copier -> upto 2x-4x faster - 18may2020
   sr8,dr8:pcolorrow8;
   sr96,dr96:pcolorrow96;
   srs8,drs8:pcolorrows8;
   srs96,drs96:pcolorrows96;
   c96:tcolor96;
   dx,dy,vrowsize,v1,v2,vpos:longint;
   b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10:boolean;
begin
try
//defaults
result:=false;
//check
if (srows=nil) or (drows=nil) or (xw<1) or (xh<1) then exit;
if (xbits<>8) and (xbits<>24) and (xbits<>32) then exit;
//init
//.8
srs8:=pointer(cardinal(srows));
drs8:=pointer(cardinal(drows));
//.96
srs96:=pointer(cardinal(srows));
drs96:=pointer(cardinal(drows));
//.v1 + v2
vrowsize:=(xbits div 8)*xw;
v1:=(vrowsize div sizeof(tcolor96));
v2:=vrowsize-(v1*sizeof(tcolor96));
vpos:=vrowsize-v2;
b0:=(v2>=1);
b1:=(v2>=2);
b2:=(v2>=3);
b3:=(v2>=4);
b4:=(v2>=5);
b5:=(v2>=6);
b6:=(v2>=7);
b7:=(v2>=8);
b8:=(v2>=9);
b9:=(v2>=10);
b10:=(v2>=11);
//get
for dy:=0 to (xh-1) do
begin
//.fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;
//.continue
sr8:=srs8[dy];
dr8:=drs8[dy];
sr96:=srs96[dy];
dr96:=drs96[dy];
//.v1 - large blocks
if (v1>=1) then
   begin
   for dx:=0 to (v1-1) do
   begin
   c96:=sr96[dx];
   dr96[dx]:=c96;
   end;//dx
   end;
//.v2 - small blocks
if b0 then dr8[vpos+0]:=tcolor8(sr8[vpos+0]);
if b1 then dr8[vpos+1]:=tcolor8(sr8[vpos+1]);
if b2 then dr8[vpos+2]:=tcolor8(sr8[vpos+2]);
if b3 then dr8[vpos+3]:=tcolor8(sr8[vpos+3]);
if b4 then dr8[vpos+4]:=tcolor8(sr8[vpos+4]);
if b5 then dr8[vpos+5]:=tcolor8(sr8[vpos+5]);
if b6 then dr8[vpos+6]:=tcolor8(sr8[vpos+6]);
if b7 then dr8[vpos+7]:=tcolor8(sr8[vpos+7]);
if b8 then dr8[vpos+8]:=tcolor8(sr8[vpos+8]);
if b9 then dr8[vpos+9]:=tcolor8(sr8[vpos+9]);
if b10 then dr8[vpos+10]:=tcolor8(sr8[vpos+10]);
end;//dy
//successful
result:=true;
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//gggggggggggggggggggggggggg
//## miscopyareaxx ##
function miscopyareaxx(da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s:tobject;xpower255,xtrans,xtc:longint;xoptions:currency):boolean;//05sep2017, 25jul2017
begin
try;result:=miscopyareaxx2(da_clip,ddx,ddy,ddw,ddh,sa,d,s,xpower255,xtrans,xtc,xoptions,0,0);except;end;
end;
//## miscopyareaxx1 ##
function miscopyareaxx1(ddx,ddy,ddw,ddh:currency;sa:trect;d,s:tobject):boolean;//01jun2019
begin
try;result:=miscopyareaxx5(rect(0,0,maxint,maxint),ddx,ddy,ddw,ddh,sa,d,s,nil,nil,nil,nil,255,0,clnone,0,0,0,nil,nil,nil,nil,nil,nil,nil);except;end;
end;
//## miscopyareaxx1A ##
function miscopyareaxx1A(ddx,ddy,ddw,ddh:currency;sa:trect;d,s:tobject;xusealpha:boolean):boolean;//support 32bit alpha channel - 27jan2021
begin
try;result:=miscopyareaxx8(rect(0,0,maxint,maxint),ddx,ddy,ddw,ddh,sa,d,s,nil,nil,nil,nil,nil,nil,0,0,false,255,0,clnone,0,0,0,nil,nil,nil,nil,nil,nil,nil,xusealpha);except;end;
end;
//## miscopyareaxx1B ##
function miscopyareaxx1B(ddx,ddy,ddw,ddh:currency;sa:trect;d,s:tobject;xpower255:longint;xusealpha:boolean):boolean;//support 32bit alpha channel - 27jan2021
begin
try;result:=miscopyareaxx8(rect(0,0,maxint,maxint),ddx,ddy,ddw,ddh,sa,d,s,nil,nil,nil,nil,nil,nil,0,0,false,xpower255,0,clnone,0,0,0,nil,nil,nil,nil,nil,nil,nil,xusealpha);except;end;
end;
//## miscopyareaxx2 ##
function miscopyareaxx2(da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s:tobject;xpower255,xtrans,xtc:longint;xoptions:currency;xscroll,yscroll:longint):boolean;//27sep2017, 26sep2017, 25sep2017, 25jul2017
begin
try;result:=miscopyareaxx3(da_clip,ddx,ddy,ddw,ddh,sa,d,s,nil,nil,xpower255,xtrans,xtc,xoptions,xscroll,yscroll);except;end;
end;
//## miscopyareaxx3 ##
function miscopyareaxx3(da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s,dm,sm:tobject;xpower255,xtrans,xtc:longint;xoptions:currency;xscroll,yscroll:longint):boolean;//27sep2017, 26sep2017, 25sep2017, 25jul2017
begin
try;result:=miscopyareaxx5(da_clip,ddx,ddy,ddw,ddh,sa,d,s,dm,nil,sm,nil,xpower255,xtrans,xtc,xoptions,xscroll,yscroll,nil,nil,nil,nil,nil,nil,nil);except;end;
end;
//## miscopyareaxx3b ##
function miscopyareaxx3b(da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s,dm,dm2,sm:tobject;xpower255,xtrans,xtc:longint;xoptions:currency;xscroll,yscroll:longint):boolean;//27sep2017, 26sep2017, 25sep2017, 25jul2017
begin
try;result:=miscopyareaxx5(da_clip,ddx,ddy,ddw,ddh,sa,d,s,dm,dm2,sm,nil,xpower255,xtrans,xtc,xoptions,xscroll,yscroll,nil,nil,nil,nil,nil,nil,nil);except;end;
end;
//## miscopyareaxx4 ##
function miscopyareaxx4(da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s,dm,sm:tobject;xpower255,xtrans,xtc:longint;xoptions:currency;xscroll,yscroll:longint;refOP,refRGB,refR,refG,refB,refX,refY:tstr8):boolean;//22aug2018, 27sep2017, 26sep2017, 25sep2017, 25jul2017
begin
try;result:=miscopyareaxx5(da_clip,ddx,ddy,ddw,ddh,sa,d,s,dm,nil,sm,nil,xpower255,xtrans,xtc,xoptions,xscroll,yscroll,refOP,refRGB,refR,refG,refB,refX,refY);except;end;
end;
//## miscopyareaxx5 ##
function miscopyareaxx5(da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s,dm,dm2,sm,sm2:tobject;xpower255,xtrans,xtc:longint;xoptions:currency;xscroll,yscroll:longint;refOP,refRGB,refR,refG,refB,refX,refY:tstr8):boolean;//15may2019, 22aug2018, 27sep2017, 26sep2017, 25sep2017, 25jul2017
begin
try;result:=miscopyareaxx6(da_clip,ddx,ddy,ddw,ddh,sa,d,s,dm,dm2,sm,sm2,nil,0,false,xpower255,xtrans,xtc,xoptions,xscroll,yscroll,refOP,refRGB,refR,refG,refB,refX,refY);except;end;
end;
//## miscopyareaxx6 ##
function miscopyareaxx6(da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s,dm,dm2,sm,sm2,sselshow:tobject;xselshowSTRIDE:longint;xselshowEVENINIT:boolean;xpower255,xtrans,xtc:longint;xoptions:currency;xscroll,yscroll:longint;refOP,refRGB,refR,refG,refB,refX,refY:tstr8):boolean;//32bit support - 25apr2020, 15may2019, 22aug2018, 27sep2017, 26sep2017, 25sep2017, 25jul2017
begin
try;result:=miscopyareaxx8(da_clip,ddx,ddy,ddw,ddh,sa,d,s,dm,dm2,sm,sm2,sselshow,nil,-1,xselshowSTRIDE,xselshowEVENINIT,xpower255,xtrans,xtc,xoptions,xscroll,yscroll,refOP,refRGB,refR,refG,refB,refX,refY,false);except;end;
end;
//## miscopyareaxx7 ##
function miscopyareaxx7(da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s,dm,dm2,sm,sm2,sselshow:tobject;dmask:tmask8;dmaskval:longint;xselshowSTRIDE:longint;xselshowEVENINIT:boolean;xpower255,xtrans,xtc:longint;xoptions:currency;xscroll,yscroll:longint;refOP,refRGB,refR,refG,refB,refX,refY:tstr8):boolean;//32bit alpha channel support - 26jan2021, 30aug2020, 25apr2020, 15may2019, 22aug2018, 27sep2017, 26sep2017, 25sep2017, 25jul2017
begin
try;result:=miscopyareaxx8(da_clip,ddx,ddy,ddw,ddh,sa,d,s,dm,dm2,sm,sm2,sselshow,dmask,dmaskval,xselshowSTRIDE,xselshowEVENINIT,xpower255,xtrans,xtc,xoptions,xscroll,yscroll,refOP,refRGB,refR,refG,refB,refX,refY,false);except;end;
end;
//## miscopyareaxx8 ##
function miscopyareaxx8(da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s,dm,dm2,sm,sm2,sselshow:tobject;dmask:tmask8;dmaskval:longint;xselshowSTRIDE:longint;xselshowEVENINIT:boolean;xpower255,xtrans,xtc:longint;xoptions:currency;xscroll,yscroll:longint;refOP,refRGB,refR,refG,refB,refX,refY:tstr8;xusealpha:boolean):boolean;//32bit alpha channel support - 29jan2021, 27jan2021, 30aug2020, 25apr2020, 15may2019, 22aug2018, 27sep2017, 26sep2017, 25sep2017, 25jul2017
begin
try;result:=miscopyareaxx9(clnone,clnone,da_clip,ddx,ddy,ddw,ddh,sa,d,s,dm,dm2,sm,sm2,sselshow,dmask,dmaskval,xselshowSTRIDE,xselshowEVENINIT,xpower255,xtrans,xtc,xoptions,xscroll,yscroll,refOP,refRGB,refR,refG,refB,refX,refY,xusealpha);except;end;
end;
//## misoptions #
function misoptions(xinvert,xgrey,xsepia,xnoise:boolean):currency;
var
   v8:tcur8;
begin
try
result:=0;
//get
v8.val:=0;
if xinvert then include(v8.bits,0);
if xgrey   then include(v8.bits,1);
if xsepia  then include(v8.bits,2);
if xnoise  then include(v8.bits,3);
//set
result:=v8.val;
except;end;
end;
//## miscopyareaxx9 ##
function miscopyareaxx9(xcolorise1,xcolorise2:longint;da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s,dm,dm2,sm,sm2,sselshow:tobject;dmask:tmask8;dmaskval:longint;xselshowSTRIDE:longint;xselshowEVENINIT:boolean;xpower255,xtrans,xtc:longint;xoptions:currency;xscroll,yscroll:longint;refOP,refRGB,refR,refG,refB,refX,refY:tstr8;xusealpha:boolean):boolean;//xinvert put last for better results - 05jun2021, "round()" instead of "trunc()" - 16mar2021, dsysinfo support - 10mar2021, 32bit alpha channel support - 29jan2021, 27jan2021, 30aug2020, 25apr2020, 15may2019, 22aug2018, 27sep2017, 26sep2017, 25sep2017, 25jul2017
begin
try;result:=miscopyareaxx10(xcolorise1,xcolorise2,da_clip,ddx,ddy,ddw,ddh,sa,d,s,dm,dm2,sm,sm2,sselshow,dmask,dmaskval,xselshowSTRIDE,xselshowEVENINIT,xpower255,xtrans,xtc,clnone,xoptions,xscroll,yscroll,refOP,refRGB,refR,refG,refB,refX,refY,xusealpha);except;end;
end;
//## miscopyareaxx10 ##
function miscopyareaxx10(xcolorise1,xcolorise2:longint;da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s,dm,dm2,sm,sm2,sselshow:tobject;dmask:tmask8;dmaskval:longint;xselshowSTRIDE:longint;xselshowEVENINIT:boolean;xpower255,xtrans,xtc,xwriteShadesofcolor:longint;xoptions:currency;xscroll,yscroll:longint;refOP,refRGB,refR,refG,refB,refX,refY:tstr8;xusealpha:boolean):boolean;//xinvert put last for better results - 05jun2021, "round()" instead of "trunc()" - 16mar2021, dsysinfo support - 10mar2021, 32bit alpha channel support - 29jan2021, 27jan2021, 30aug2020, 25apr2020, 15may2019, 22aug2018, 27sep2017, 26sep2017, 25sep2017, 25jul2017
label
   skipend,skiptrans;
var//Note: Speed optimised using x-pixel limiter "d1,d2", y-pixel limiter "d3,d4"
   //      and object caching "1x createtmp" and "2x createint" with a typical speed
   //      increase in PicWork of 45x, or a screen paint time originally of 3,485ms now 78ms
   //      with layer 2 image at 80,000px wide @ 1,000% zoom as of 06sep2017.
   //Note: s and d are required - 25jul2017
   //Note: da,sa are zero-based areas, e.g: da.left/right=0..[width-1],
   //Note: xpower255 range = 0..255 - 29may2019
   //Critical Note: must use "trunc" instead of "round" for correct rounding behaviour - 24SEP2011
   //Note: Range errors fixed on 26sep2017 -> now stable and reliable
   //Note: m =optional dest mask -> 24bit mask, but we use the red channel (0=transparent, 1=low..255=full) - 12nov2017
   //Note: m2 =optional 2nd dest mask -> 24bit mask, but we use the red channel (0=transparent, 1=low..255=full) - 14apr2019
   //Note: sm=optional source mask -> 24bit mask, but we use the red channel (0=transparent, 1=low..255=full) - 11jan2018
   //Note: Not in use yet --> sm2=optional 2nd source mask -> 24bit mask, but we use the red channel (0=transparent, 1=low..255=full) - 14apr2019
   //Note: Now supports 8,24 and 32 bits for "s" and "d" - 25apr2020
   //.locks
   dmustunlock,smustunlock,dmmustunlock,dm2mustunlock,smmustunlock,sm2mustunlock:boolean;
   a:tbasicimage;
   dr32,sr32,dr132,dr232,dr332,dr432:pcolorrow32;//25apr2020
   dr24,sr24,dmr24,dmr24b,smr24,sselshowr24,sselshowr24a,sselshowr24b,ar,ar1,ar2,dr1,dr2,dr3,dr4:pcolorrow24;
   mr8,dr8,sr8,dmr8,dmr8b,smr8,sselshowr8,sselshowr8a,sselshowr8b,dr18,dr28,dr38,dr48:pcolorrow8;
   aok1,aok2,dok1,dok2,dok3,dok4:boolean;
   xcwhite24,xcblack24,dc24,sc24:tcolor24;
   xcwhite32,xcblack32,dc32,sc32:tcolor32;
   mx,my:pdllongint;
   _mx,_my:tdynamicinteger;//mapper support
   xselstride,p,vr,vg,vb,vc,daW,daH,saW,saH:longint;
   v1,v2,v3,v4:longint;
   int1,d1,d2,d3,d4:longint;//x-pixel(d) and y-pixel(d) speed optimisers -> represent ACTUAL d.area needed to be processed - 05sep2017
   //.image values
   sw,sh,sbits:longint;
   smw,smh,smbits:longint;
   smw2,smh2,smbits2:longint;
   sselshoww,sselshowh,sselshowbits:longint;
   shasai,smhasai,smhasai2,sselshowhasai:boolean;
   dw,dh,dbits:longint;
   dmw,dmh,dmbits:longint;
   dmw2,dmh2,dmbits2:longint;
   dhasai,dmhasai,dmhasai2:boolean;
   //.other
   xalpha255,xpower2,dx,dy,sx,sy,sya,syb,sxa,sxb:longint;
   dx1,dx2,dy1,dy2:longint;
   xtranscol:tcolor24;
   bs:array[0..2] of boolean;
   xtranscolok,bol1,xfilters,xmirror,xflip,xinvert,xgrey,xsepia,xnoise:boolean;
   c8:tcur8;
   da:trect;
   str1:string;
   //ref pattern support - 24aug2018
   zmin,zmax,zoff,zcount:longint;
   reflistR,reflistG,reflistB,reflistRGB:pcolorrow8;
   reflistOP:pdllongint;
   refcoreR,refcoreG,refcoreB,refcoreRGB:tdynamicbyte;
   refcoreOP:tdynamicinteger;
   refuse:boolean;
   //colorise support - 27mar2021
   dcolorise1,dcolorise2:tcolor24;
   dcoloriseOK,dcoloriseInv:boolean;
   dcolorisev:longint;
   //write shades of color support - 15mar2022
   socOK:boolean;
   soc24:tcolor24;
   socLevel:longint;
   //## cint32 ##
   function cint32(x:currency):longint;
   begin//Note: Clip a 64bit integer to a 32bit integer range
   if (x>maxint) then x:=maxint
   else if (x<minint) then x:=minint;
   result:=trunc(x);
   end;
   //## xinc32 ##
   procedure xinc32(xr32:pcolorrow32;xoff:longint);
   begin
   xoff:=dx+xoff;
   if (xoff>=0) and (xoff<dw) then
      begin
      inc(vr,xr32[xoff].r);
      inc(vg,xr32[xoff].g);
      inc(vb,xr32[xoff].b);
      inc(vc);
      end;
   end;
   //## xinc24 ##
   procedure xinc24(xr:pcolorrow24;xoff:longint);
   begin
   xoff:=dx+xoff;
   if (xoff>=0) and (xoff<dw) then
      begin
      inc(vr,xr[xoff].r);
      inc(vg,xr[xoff].g);
      inc(vb,xr[xoff].b);
      inc(vc);
      end;
   end;
   //## xinc8 ##
   procedure xinc8(xr:pcolorrow8;xoff:longint);
   begin
   xoff:=dx+xoff;
   if (xoff>=0) and (xoff<dw) then
      begin
      inc(vr,xr[xoff]);
      inc(vg,xr[xoff]);
      inc(vb,xr[xoff]);
      inc(vc);
      end;
   end;
   //## d_sys24 ##
   procedure d_sys24;//10mar2021
   begin
   dcolorisev:=(sc24.r+sc24.g+sc24.b) div 3;
   if (dcolorisev<100) then dcolorisev:=100 else if (dcolorisev>230) then dcolorisev:=230;
   if dcoloriseInv then dcolorisev:=255-dcolorisev;//26mar2021
   sc24.r:=((dcolorise1.r*dcolorisev) + (dcolorise2.r*(255-dcolorisev))) div 255;
   sc24.g:=((dcolorise1.g*dcolorisev) + (dcolorise2.g*(255-dcolorisev))) div 255;
   sc24.b:=((dcolorise1.b*dcolorisev) + (dcolorise2.b*(255-dcolorisev))) div 255;
   end;
begin
try
//defaults
result:=false;//11SEP2011
_mx:=nil;
_my:=nil;
a:=nil;
reflistR:=nil;
reflistG:=nil;
reflistB:=nil;
reflistRGB:=nil;
reflistOP:=nil;
refcoreR:=nil;
refcoreG:=nil;
refcoreB:=nil;
refcoreRGB:=nil;
refcoreOP:=nil;
refuse:=false;
//.locks
dmustunlock     :=false;
smustunlock     :=false;
dmmustunlock    :=false;
dm2mustunlock   :=false;
smmustunlock    :=false;
sm2mustunlock   :=false;
//.xwriteShadesofcolor
socOK:=(xwriteShadesofcolor<>clnone);
socLevel:=255;//on by default - required for non-soc modes - 15mar2022
if socOK then soc24:=low__intrgb(xwriteShadesofcolor);

//.refs -> lock - 30aug2020
if (refOP<>nil)  then block(refOP);
if (refRGB<>nil) then block(refRGB);
if (refR<>nil)   then block(refR);
if (refG<>nil)   then block(refG);
if (refB<>nil)   then block(refB);
if (refX<>nil)   then block(refX);
if (refY<>nil)   then block(refY);

//check
if (sa.right<sa.left) or (sa.bottom<sa.top) then goto skipend;
if not misinfo82432(s,sbits,sw,sh,shasai) then goto skipend;
if not misinfo82432(d,dbits,dw,dh,dhasai) then goto skipend;
if zznil(dmask,2107) or (dmask.width<dw) or (dmask.height<dh) or (dmaskval<-1) then dmaskval:=-1;//off - 23may2020

//was: if (dmask<>nil) and (dmask.width>=2) and ((dmask.width<dw) or (dmask.height<dh)) then showbasic('err1>'+inttostr(dmask.width)+'='+inttostr(dw));//xxxxxxxxxxx
//-- init --
//.colors
xcwhite24.r:=255;  xcwhite24.g:=255;  xcwhite24.b:=255;
xcblack24.r:=0;    xcblack24.g:=0;    xcblack24.b:=0;
xcwhite32.r:=255;  xcwhite32.g:=255;  xcwhite32.b:=255;  xcwhite32.a:=255;
xcblack32.r:=0;    xcblack32.g:=0;    xcblack32.b:=0;    xcblack32.a:=255;

//.colorise -> convert color pixels into shades between "xcolorise1 .. xcolorise2" - 27mar2021
dcoloriseOK:=(xcolorise1<>clnone) and (xcolorise2<>clnone);
if dcoloriseOK then
   begin
   dcolorise1:=low__intrgb(xcolorise1);
   dcolorise2:=low__intrgb(xcolorise2);
   dcoloriseInv:=(low__brightness2b(low__rgbint(dcolorise1))<low__brightness2b(low__rgbint(dcolorise2)));
   end;
   
//allow only 8bit and 24bit mask handling:
//.dm & dm2
if (not misinfo824(dm,dmbits,dmw,dmh,dmhasai))      or (dmw<dw)  or (dmh<dh)  then dmbits:=0;//0=off
if (not misinfo824(dm2,dmbits2,dmw2,dmh2,dmhasai2)) or (dmw2<dw) or (dmh2<dh) then dmbits2:=0;//0=off
//.sm & sm2
if (not misinfo824(sm,smbits,smw,smh,smhasai))      or (smw<sw)  or (smh<sh)  then smbits:=0;//0=off
if (not misinfo824(sm2,smbits2,smw2,smh2,smhasai2)) or (smw2<sw) or (smh2<sh) then smbits2:=0;//0=off
//.sselshow
if (not misinfo824(sselshow,sselshowbits,sselshoww,sselshowh,sselshowhasai)) or (sselshoww<sw) or (sselshowh<sh) then sselshowbits:=0;//0=off
if (xselshowstride<1) then xselshowstride:=4;//use default value of 4 pixels when not specified - 08jul2019
xselstride:=2*xselshowstride;//2x for realtime calculations to work - 08jul2019
//.xpower
xpower255:=frcrange(xpower255,0,255);
xpower2:=xpower255;
xalpha255:=255;
//.ref pattern support - 24aug2018
if ref_use(refR) and (ref_count(refR)>=1) then
   begin
   if zznil(refcoreR,2110) then refcoreR:=tdynamicbyte.create;
   for int1:=255 downto 0 do refcoreR.value[int1]:=byte(ref_val0255(refR,int1));
   reflistR:=refcoreR.core;
   end;
if ref_use(refG) and (ref_count(refG)>=1) then
   begin
   if zznil(refcoreG,2111) then refcoreG:=tdynamicbyte.create;
   for int1:=255 downto 0 do refcoreG.value[int1]:=byte(ref_val0255(refG,int1));
   reflistG:=refcoreG.core;
   end;
if ref_use(refB) and (ref_count(refB)>=1) then
   begin
   if zznil(refcoreB,2112) then refcoreB:=tdynamicbyte.create;
   for int1:=255 downto 0 do refcoreB.value[int1]:=byte(ref_val0255(refB,int1));
   reflistB:=refcoreB.core;
   end;
if ref_use(refRGB) and (ref_count(refRGB)>=1) then
   begin
   if zznil(refcoreRGB,2113) then refcoreRGB:=tdynamicbyte.create;
   for int1:=255 downto 0 do refcoreRGB.value[int1]:=byte(ref_val0255(refRGB,int1));
   reflistRGB:=refcoreRGB.core;
   end;
if ref_use(refOP) and (ref_count(refOP)>=1) then
   begin
   if zznil(refcoreOP,2114) then refcoreOP:=tdynamicinteger.create;
   for int1:=255 downto 0 do refcoreOP.value[int1]:=round( (ref_val32(refOP,int1,int1,-255,255)/255)*xpower255 );
   reflistOP:=refcoreOP.core;
   end;
refuse:=(reflistR<>nil) or (reflistG<>nil) or (reflistB<>nil) or (reflistRGB<>nil) or (reflistOP<>nil);

//.xmirror
xmirror:=(ddw<0);if xmirror then ddw:=-ddw;
xflip  :=(ddh<0);if xflip   then ddh:=-ddh;
da.left:=cint32(ddx);
da.right:=cint32(ddx)+cint32(ddw-1);
da.top:=cint32(ddy);
da.bottom:=cint32(ddy)+cint32(ddh-1);

//.da_clip - limit to dimensions of "d" - 05sep2017
da_clip.left:=frcrange(da_clip.left,0,dw-1);
da_clip.right:=frcrange(da_clip.right,da_clip.left,dw-1);
da_clip.top:=frcrange(da_clip.top,0,dH-1);
da_clip.bottom:=frcrange(da_clip.bottom,0,dH-1);

//.optimise actual x-pixels scanned -> d1 + d2 -> 05sep2017
//.warning: Do not alter boundary handling below or failure will result - 27sep2017
d1:=largest(largest(da.left,da_clip.left),0);//range: 0..maxint
d2:=smallest(smallest(da.right,da_clip.right),dw-1);//range: minint..dw-1
if (d2<d1) then goto skipend;

//.optimise actual y-pixels scanned -> d3 + d4 -> 05sep2017
//.warning: Do not alter boundary handling below or failure will result - 27sep2017
d3:=largest(largest(da.top,da_clip.top),0);//range: 0..maxint
d4:=smallest(smallest(da.bottom,da_clip.bottom),dH-1);//range: minint..dh-1
if (d4<d3) then goto skipend;

//.create temp buffer -> needs no lock/unlock - 23may2020
if not low__createimg24(a,'copyareaxx_a24',bol1) then goto skipend;
if (misb(a)<>24) then goto skipend;
//.adjust image dimensions
if (a.width>(dw+2000)) or (a.height>(dh+2000)) then//too big -> make small first
   begin
   a.sizeto(1,1);
   end;
if (a.width<dw)  then a.sizeto(dw,a.height);
if (a.height<dh) then a.sizeto(a.width,dh);
aok1:=false;
aok2:=false;
dok1:=false;
dok2:=false;
dok3:=false;
dok4:=false;
//.xoptions
c8.val:=xoptions;
xinvert :=(0 in c8.bits);
xgrey   :=(1 in c8.bits);
xsepia  :=(2 in c8.bits);
xnoise  :=(3 in c8.bits);
xfilters:=xinvert or xgrey or xsepia or xnoise;
//.xtrans
xtrans:=frcrange(xtrans,0,3);//0=none, 1=1bit, 2=8bit, 3=8bit enhanced -> dual purpose -> sharp, blur, blur2 AND transparent color
xtranscolok:=(xtc<>clnone);
if xtranscolok then xtranscol:=low__intrgb(xtc);
//.other
daW:=low__posn(da.right-da.left)+1;
daH:=low__posn(da.bottom-da.top)+1;
saW:=low__posn(sa.right-sa.left)+1;
saH:=low__posn(sa.bottom-sa.top)+1;
dx1:=frcrange(da.left,0,dw-1);
dx2:=frcrange(da.right,0,dw-1);
dy1:=frcrange(da.top,0,dh-1);
dy2:=frcrange(da.bottom,0,dh-1);
//.check area -> do nothing
if (daw=0) or (dah=0) or (saw=0) or (sah=0) then goto skipend;
if (sa.right<sa.left) or (sa.bottom<sa.top) or (da.right<da.left) or (da.bottom<da.top) then goto skipend;
if (dx2<dx1) or (dy2<dy1) then goto skipend;

//.locks
if mismustlock(d)   then dmustunlock:=mislock(d);
if mismustlock(s)   then smustunlock:=mislock(s);
if mismustlock(dm)  then dmmustunlock:=mislock(dm);
if mismustlock(dm2) then dm2mustunlock:=mislock(dm2);
if mismustlock(sm)  then smmustunlock:=mislock(sm);
if mismustlock(sm2) then sm2mustunlock:=mislock(sm2);

//.x-scroll
if (xscroll<>0) then
   begin
   xscroll:=-xscroll;//logic inversion -> match user expectation -> neg.vals=left, pos.vals=right
   bol1:=(xscroll<0);
   xscroll:=low__posn(xscroll);
   xscroll:=xscroll-((xscroll div saW)*saW);
   xscroll:=frcrange(xscroll,0,saW-1);
   if bol1 then xscroll:=-xscroll;
   end;

//.y-scroll
if (yscroll<>0) then
   begin
   yscroll:=-yscroll;//logic inversion -> match user expectation -> neg.vals=up, pos.vals=down
   bol1:=(yscroll<0);
   yscroll:=low__posn(yscroll);
   yscroll:=yscroll-((yscroll div saH)*saH);
   yscroll:=frcrange(yscroll,0,saH-1);
   if bol1 then yscroll:=-yscroll;
   end;

//.mx (mapped dx) - highly optimised - 06sep2017
if ref_use(refX) then int1:=ref_count(refX) else int1:=0;
if (int1>=1) then str1:='.ref'+inttostr(ref_id(refX))+'_'+inttostr(int1)+'_'+inttostr(low__crc32b(refX)) else str1:='';
if not low__createint(_mx,'copyareaxx_mx.'+inttostr(daW)+'.0.'+inttostr(sa.left)+'.'+inttostr(sa.right)+'.'+inttostr(saW)+str1,bol1) then goto skipend;
if not bol1 then
   begin
   //init
   zcount:=0;
   zmin:=0;
   zmax:=daW-1;
   _mx.setparams(daW,daW,0);
   mx:=_mx.core;
   //get
   for p:=0 to (daW-1) do
   begin
   mx[p]:=frcrange(sa.left+trunc(p*(saW/daW)),sa.left,sa.right);//06apr2017
   if (int1>=1) then mx[p]:=ref_valrange32(refX,mx[p],sa.left,sa.right,p,zmin,zmax,zoff,zcount);

   //.fasttimer - xcheck - 07jul2021
   inc(sysfasttimer_xcount); if (sysfasttimer_xcount>=sysfasttimer_xtrigger) then fasttimer_xcheck;
   end;//p
   end;
mx:=_mx.core;

//.my (mapped dy) - highly optimised - 06sep2017
if ref_use(refY) then int1:=ref_count(refY) else int1:=0;
if (int1>=1) then str1:='.ref'+inttostr(ref_id(refY))+'_'+inttostr(int1)+'_'+inttostr(low__crc32b(refY)) else str1:='';
if not low__createint(_my,'copyareaxx_my.'+inttostr(daH)+'.0.'+inttostr(sa.top)+'.'+inttostr(sa.bottom)+'.'+inttostr(saH)+str1,bol1) then goto skipend;
if not bol1 then
   begin
   //init
   zcount:=0;
   zmin:=0;
   zmax:=daH-1;
   _my.setparams(daH,daH,0);
   my:=_my.core;
   //get
   for p:=0 to (daH-1) do
   begin
   my[p]:=frcrange(sa.top+trunc(p*(saH/daH)),sa.top,sa.bottom);//24SEP2011
   if (int1>=1) then my[p]:=ref_valrange32(refY,my[p],sa.top,sa.bottom,p,zmin,zmax,zoff,zcount);

   //.fasttimer - xcheck - 07jul2021
   inc(sysfasttimer_xcount); if (sysfasttimer_xcount>=sysfasttimer_xtrigger) then fasttimer_xcheck;
   end;//p
   end;
my:=_my.core;

//-- Draw Color Pixels ---------------------------------------------------------
//dy
//...was: for dy:=da.top to da.bottom do if (dy>=0) and (dy<dH) and (dy>=da_clip.top) and (dy<=da_clip.bottom) then
for dy:=d3 to d4 do
   begin
   //.fasttimer - ycheck
   inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;
   //.ar
   ar:=a.prows24[dy];
   if xflip then sy:=my[(da.bottom-da.top)-(dy-da.top)] else sy:=my[dy-da.top];//zero base
   if (sselshowbits<>0) then
      begin
      case xflip of
      true:begin
         //.sya
         v1:=dy-1;
         if (v1<d3) then v1:=d3;
         sya:=my[(da.bottom-da.top)-(v1-da.top)];
         //.syb
         v1:=dy+1;
         if (v1>d4) then v1:=d4;
         syb:=my[(da.bottom-da.top)-(v1-da.top)];
         end;
      false:begin
         //.sya
         v1:=dy-1;
         if (v1<d3) then v1:=d3;
         sya:=my[v1-da.top];//zero base
         //.syb
         v1:=dy+1;
         if (v1>d4) then v1:=d4;
         syb:=my[v1-da.top];//zero base
         end;
      end;//case
      end;//if
   //.y-scroll
   if (yscroll<>0) then
      begin
      sy:=sy+yscroll;
      if (sy<sa.top) then sy:=sa.bottom-(-sy-sa.top)
      else if (sy>sa.bottom) then sy:=sa.top+(sy-sa.bottom);
      end;
   //.sy
   if (sy>=0) and (sy<sH) then
      begin
      if (dmaskval>=0) then mr8:=dmask.prows8[dy];
      if not misscan82432(d,dy,dr8,dr24,dr32)                     then goto skipend;//25apr2020, 28may2019
      if not misscan82432(s,sy,sr8,sr24,sr32)                     then goto skipend;//25apr2020,
      if (dmbits<>0)  and (not misscan824(dm,dy,dmr8,dmr24))      then goto skipend;
      if (dmbits2<>0) and (not misscan824(dm2,dy,dmr8b,dmr24b))   then goto skipend;
      if (smbits<>0)  and (not misscan824(sm,sy,smr8,smr24))      then goto skipend;
      if (sselshowbits<>0) then
         begin
         if not misscan824(sselshow,sya,sselshowr8a,sselshowr24a) then goto skipend;
         if not misscan824(sselshow,sy,sselshowr8,sselshowr24)    then goto skipend;
         if not misscan824(sselshow,syb,sselshowr8b,sselshowr24b) then goto skipend;
         end;
      //dx - Note: xeven only updated at this stage for speed during "sselshowbits<>0" - 08jul2019
      //...was: for dx:=da.left to da.right do if (dx>=0) and (dx<dw) and (dx>=da_clip.left) and (dx<=da_clip.right) then
      for dx:=d1 to d2 do
         begin
         if xmirror then sx:=mx[(da.right-da.left)-(dx-da.left)] else sx:=mx[dx-da.left];//zero base
         if (sselshowbits<>0) then
            begin
            case xmirror of
            true:begin
               //.sxa
               v1:=dx-1;
               if (v1<d1) then v1:=d1;
               sxa:=mx[(da.right-da.left)-(v1-da.left)];
               //.sxb
               v1:=dx+1;
               if (v1>d2) then v1:=d2;
               sxb:=mx[(da.right-da.left)-(v1-da.left)];
               end;
            false:begin
               //.sxa
               v1:=dx-1;
               if (v1<d1) then v1:=d1;
               sxa:=mx[v1-da.left];//zero base
               //.sxb
               v1:=dx+1;
               if (v1>d2) then v1:=d2;
               sxb:=mx[v1-da.left];//zero base
               end;
            end;//case
            end;//if
         //.x-scroll
         if (xscroll<>0) then
            begin
            sx:=sx+xscroll;
            if (sx<sa.left) then
               begin
               //.math quirk for "animation cell area" referencing - 25sep2017
               if (sx<=0) then sx:=sa.right-(-sx-sa.left) else sx:=sa.right-(sa.left-sx);
               end
            else if (sx>sa.right) then sx:=sa.left+(sx-sa.right);
            end;
         //.sx
         if (sx>=0) and (sx<sW) then
            begin
            //init
            if      (sbits=32) then//25apr2020
               begin
               sc32:=sr32[sx];
               if socOK then
                  begin
                  //greyscale value
                  socLevel:=sc32.r;
                  if (sc32.g>socLevel) then socLevel:=sc32.g;
                  if (sc32.b>socLevel) then socLevel:=sc32.b;
                  sc24:=soc24;
                  //get
//                  sc24.r:=(soc24.r*socLevel) div 255;
//                  sc24.g:=(soc24.g*socLevel) div 255;
//                  sc24.b:=(soc24.b*socLevel) div 255;
                  end
               else
                  begin
                  sc24.r:=sc32.r;
                  sc24.g:=sc32.g;
                  sc24.b:=sc32.b;
                  end;
               xalpha255:=sc32.a;//new - 27jan2021
               end
            else if (sbits=24) then
               begin
               sc24:=sr24[sx];
               if socOK then
                  begin
                  //greyscale value
                  socLevel:=sc24.r;
                  if (sc24.g>socLevel) then socLevel:=sc24.g;
                  if (sc24.b>socLevel) then socLevel:=sc24.b;
                  sc24:=soc24;
                  //get
//                  sc24.r:=(soc24.r*socLevel) div 255;
//                  sc24.g:=(soc24.g*socLevel) div 255;
//                  sc24.b:=(soc24.b*socLevel) div 255;
                  end;
               end
            else if (sbits=8) then
               begin
               //8bit -> 24bit
               if socOK then
                  begin
                  //greyscale value
                  socLevel:=sr8[sx];
                  sc24:=soc24;
                  //get

//                  sc24.r:=(soc24.r*socLevel) div 255;
//                  sc24.g:=(soc24.g*socLevel) div 255;
//                  sc24.b:=(soc24.b*socLevel) div 255;
                  end
               else
                  begin
                  sc24.r:=sr8[sx];
                  sc24.g:=sc24.r;
                  sc24.b:=sc24.r;
                  end;
               end;
            //draw pixel -> using "dpower" - 15may2019, 14apr2019, 25jul2017
//..was:    if ((xtrans=0) or (not xtranscolok) or ( (sc.r<>xtranscol.r) or (sc.g<>xtranscol.g) or (sc.b<>xtranscol.b) )) and ((not mok) or (mr[dx].r>=1)) and ((not mok2) or (mr2[dx].r>=1)) and ((not smok) or (smr[sx].r>=1)) then
            if ((xalpha255>=1) or (not xusealpha)) and
               ( (xtrans=0) or (not xtranscolok) or ( (sc24.r<>xtranscol.r) or (sc24.g<>xtranscol.g) or (sc24.b<>xtranscol.b) ) ) and
               ( (dmbits=0) or ((dmbits=8) and (dmr8[dx]>=1)) or ((dmbits=24) and (dmr24[dx].r>=1)) ) and
               ( (dmbits2=0) or ((dmbits2=8) and (dmr8b[dx]>=1)) or ((dmbits2=24) and (dmr24b[dx].r>=1)) ) and
               ( (smbits=0) or ((smbits=8) and (smr8[sx]>=1)) or ((smbits=24) and (smr24[sx].r>=1)) ) and
               (socLevel>=1) then
               begin
               //.xpower2 init
               xpower2:=xpower255;
               if (socLevel<255) and (xpower2>=1) then
                  begin
                  xpower2:=(xpower255*socLevel) div 255;
                  if (xpower2<1) then xpower2:=1;
                  end;

               //.ref pattern support - 24aug2018
               if refuse then
                  begin
                  if (reflistOP<>nil) then
                     begin
                     int1:=sc24.r;
                     if (sc24.g>int1) then int1:=sc24.g;
                     if (sc24.b>int1) then int1:=sc24.b;
                     xpower2:=reflistOP[int1];//-255..+255
                     if (xpower2<0) then xpower2:=0 else if (xpower2>255) then xpower2:=255;
                     end;
                  if (reflistRGB<>nil) then
                     begin
                     sc24.r:=reflistRGB[sc24.r];
                     sc24.g:=reflistRGB[sc24.g];
                     sc24.b:=reflistRGB[sc24.b];
                     end;
                  if (reflistR<>nil) then sc24.r:=reflistR[sc24.r];
                  if (reflistG<>nil) then sc24.g:=reflistG[sc24.g];
                  if (reflistB<>nil) then sc24.b:=reflistB[sc24.b];
                  end;
               //.filters
               if xfilters then
                  begin
                  if xnoise   then    fbNoise3(sc24.r,sc24.g,sc24.b);
//was:            if xinvert  then    fbInvert(sc24.r,sc24.g,sc24.b);
                  if xgrey    then fbGreyscale(sc24.r,sc24.g,sc24.b);
                  if xsepia   then     fbSepia(sc24.r,sc24.g,sc24.b);
                  if xinvert  then    fbInvert(sc24.r,sc24.g,sc24.b);//put last for more predictable USER EXPECTATIONS - 05jun2021
                  end;
               //.xpower2 modification
               case dmbits of
               8:if (dmr8[dx]=0) then xpower2:=0 else xpower2:=(xpower2*dmr8[dx]) div 255;
               24:if (dmr24[dx].r=0) then xpower2:=0 else xpower2:=(xpower2*dmr24[dx].r) div 255;
               end;

               //.xpower2 modification - 2nd mask - 14apr2019
               case dmbits2 of
               8:if (dmr8b[dx]=0) then xpower2:=0 else xpower2:=(xpower2*dmr8b[dx]) div 255;
               24:if (dmr24b[dx].r=0) then xpower2:=0 else xpower2:=(xpower2*dmr24b[dx].r) div 255;
               end;
               //.sm modification of xpower2 - 11jan2018
               case smbits of
               8:if (smr8[sx]=0) then xpower2:=0 else xpower2:=(xpower2*smr8[sx]) div 255;
               24:if (smr24[sx].r=0) then xpower2:=0 else xpower2:=(xpower2*smr24[sx].r) div 255;
               end;

               //.32bit alpha channel handling - 26jan2021
               if xusealpha and (xpower2>=1) and (xalpha255<255) then
                  begin
                  xpower2:=trunc(xpower2*(xalpha255/255));
                  if (xpower2<1) then xpower2:=1;
                  end;

               //.xpower2 finalise
               case dbits of
               32:begin
                  if dcoloriseOK then d_sys24;
                  sc32.r:=sc24.r;
                  sc32.g:=sc24.g;
                  sc32.b:=sc24.b;
                  sc32.a:=xalpha255;
                  if (xpower2<255) then//fixed on 25jan2021 (had been accidently using "dr24[dx] for 32bit instead of dr32[dx]"
                     begin
                     sc32.r:=ref65025_div_255[((dr32[dx].r*(255-xpower2))+(sc32.r*xpower2))];//18ms
                     sc32.g:=ref65025_div_255[((dr32[dx].g*(255-xpower2))+(sc32.g*xpower2))];//18ms
                     sc32.b:=ref65025_div_255[((dr32[dx].b*(255-xpower2))+(sc32.b*xpower2))];//18ms
                     if not xusealpha then sc32.a:=ref65025_div_255[((dr32[dx].a*(255-xpower2))+(sc32.a*xpower2))];//18ms
                     end;
                  if xusealpha then sc32.a:=dr32[dx].a;
                  if (dmaskval=-1) or (mr8[dx]=dmaskval) then dr32[dx]:=sc32;//25apr2020
                  end;
               24:begin
                  if dcoloriseOK then d_sys24;
                  if (xpower2<255) then
                     begin
                     sc24.r:=ref65025_div_255[((dr24[dx].r*(255-xpower2))+(sc24.r*xpower2))];//18ms
                     sc24.g:=ref65025_div_255[((dr24[dx].g*(255-xpower2))+(sc24.g*xpower2))];//18ms
                     sc24.b:=ref65025_div_255[((dr24[dx].b*(255-xpower2))+(sc24.b*xpower2))];//18ms
                     end;
                  if (dmaskval=-1) or (mr8[dx]=dmaskval) then dr24[dx]:=sc24;
                  end;
               8:begin
                  if dcoloriseOK then d_sys24;
                  if (xpower2<255) then
                     begin
                     //24bit -> 8bit
                     sc24.r:=ref65025_div_255[((dr8[dx]*(255-xpower2))+(sc24.r*xpower2))];//18ms
                     sc24.g:=ref65025_div_255[((dr8[dx]*(255-xpower2))+(sc24.g*xpower2))];//18ms
                     sc24.b:=ref65025_div_255[((dr8[dx]*(255-xpower2))+(sc24.b*xpower2))];//18ms
                     if (sc24.g>sc24.r) then sc24.r:=sc24.g;
                     if (sc24.b>sc24.r) then sc24.r:=sc24.b;
                     end;
                  if (dmaskval=-1) or (mr8[dx]=dmaskval) then dr8[dx]:=sc24.r;
                  end;
               end;//case
               //set
               ar[dx].r:=1;//1=color, 0=transparent
               end
            else ar[dx].r:=0;//1=color, 0=transparent

            //-- SelShow ---------------------------------------------------------------------
            //Note: Draw in realtime a stride-based (variable length black/white line)
            //      highlight line -> realtime, no ref. required - 09jul2019
            //.sel24 + d32
            if (sselshowbits=24) and (dbits=32) then
               begin
               v1:=sselshowr24a[sx].r;//sy-1
               v2:=sselshowr24[sxa].r;//sx-1
               v3:=sselshowr24[sxb].r;//sx+1
               v4:=sselshowr24b[sx].r;//sy+1
               if (sselshowr24[sx].r<=254) and ( (v2=255) or (v3=255) or ((v1=255) and (sselshowr24a<>sselshowr24)) or ((v4=255) and (sselshowr24b<>sselshowr24)) ) then
                  begin
                  //.realtime highlight stride calculations - 08jul2019
                  bol1:=(dx-((dx div xselstride)*xselstride))>=(xselstride div 2);
                  if   ((dy-((dy div xselstride)*xselstride))>=(xselstride div 2)) then bol1:=not bol1;
                  if xselshowEVENINIT then bol1:=not bol1;
                  if (dmaskval=-1) or (mr8[dx]=dmaskval) then
                     begin
                     if bol1 then dr32[dx]:=xcwhite32 else dr32[dx]:=xcblack32;
                     end;
                  end;
               end
            //.sel8 + d32
            else if (sselshowbits=8) and (dbits=32) then
               begin
               v1:=sselshowr8a[sx];//sy-1
               v2:=sselshowr8[sxa];//sx-1
               v3:=sselshowr8[sxb];//sx+1
               v4:=sselshowr8b[sx];//sy+1
               if (sselshowr8[sx]<=254) and ( (v2=255) or (v3=255) or ((v1=255) and (sselshowr8a<>sselshowr8)) or ((v4=255) and (sselshowr8b<>sselshowr8)) ) then
                  begin
                  //.realtime highlight stride calculations - 08jul2019
                  bol1:=(dx-((dx div xselstride)*xselstride))>=(xselstride div 2);
                  if   ((dy-((dy div xselstride)*xselstride))>=(xselstride div 2)) then bol1:=not bol1;
                  if xselshowEVENINIT then bol1:=not bol1;
                  if (dmaskval=-1) or (mr8[dx]=dmaskval) then
                     begin
                     if bol1 then dr32[dx]:=xcwhite32 else dr32[dx]:=xcblack32;
                     end;
                  end;
               end
            //.sel24 + d24
            else if (sselshowbits=24) and (dbits=24) then
               begin
               v1:=sselshowr24a[sx].r;//sy-1
               v2:=sselshowr24[sxa].r;//sx-1
               v3:=sselshowr24[sxb].r;//sx+1
               v4:=sselshowr24b[sx].r;//sy+1
               if (sselshowr24[sx].r<=254) and ( (v2=255) or (v3=255) or ((v1=255) and (sselshowr24a<>sselshowr24)) or ((v4=255) and (sselshowr24b<>sselshowr24)) ) then
                  begin
                  //.realtime highlight stride calculations - 08jul2019
                  bol1:=(dx-((dx div xselstride)*xselstride))>=(xselstride div 2);
                  if   ((dy-((dy div xselstride)*xselstride))>=(xselstride div 2)) then bol1:=not bol1;
                  if xselshowEVENINIT then bol1:=not bol1;
                  if (dmaskval=-1) or (mr8[dx]=dmaskval) then
                     begin
                     if bol1 then dr24[dx]:=xcwhite24 else dr24[dx]:=xcblack24;
                     end;
                  end;
               end
            //.sel8 + d24
            else if (sselshowbits=8) and (dbits=24) then
               begin
               v1:=sselshowr8a[sx];//sy-1
               v2:=sselshowr8[sxa];//sx-1
               v3:=sselshowr8[sxb];//sx+1
               v4:=sselshowr8b[sx];//sy+1
               if (sselshowr8[sx]<=254) and ( (v2=255) or (v3=255) or ((v1=255) and (sselshowr8a<>sselshowr8)) or ((v4=255) and (sselshowr8b<>sselshowr8)) ) then
                  begin
                  //.realtime highlight stride calculations - 08jul2019
                  bol1:=(dx-((dx div xselstride)*xselstride))>=(xselstride div 2);
                  if   ((dy-((dy div xselstride)*xselstride))>=(xselstride div 2)) then bol1:=not bol1;
                  if xselshowEVENINIT then bol1:=not bol1;
                  if (dmaskval=-1) or (mr8[dx]=dmaskval) then
                     begin
                     if bol1 then dr24[dx]:=xcwhite24 else dr24[dx]:=xcblack24;
                     end;
                  end;
               end
            //.sel8 + d8
            else if (sselshowbits=8) and (dbits=8) then
               begin
               v1:=sselshowr8a[sx];//sy-1
               v2:=sselshowr8[sxa];//sx-1
               v3:=sselshowr8[sxb];//sx+1
               v4:=sselshowr8b[sx];//sy+1
               if (sselshowr8[sx]<=254) and ( (v2=255) or (v3=255) or ((v1=255) and (sselshowr8a<>sselshowr8)) or ((v4=255) and (sselshowr8b<>sselshowr8)) ) then
                  begin
                  //.realtime highlight stride calculations - 08jul2019
                  bol1:=(dx-((dx div xselstride)*xselstride))>=(xselstride div 2);
                  if   ((dy-((dy div xselstride)*xselstride))>=(xselstride div 2)) then bol1:=not bol1;
                  if xselshowEVENINIT then bol1:=not bol1;
                  if (dmaskval=-1) or (mr8[dx]=dmaskval) then
                     begin
                     if bol1 then dr8[dx]:=255 else dr8[dx]:=0;
                     end;
                  end;
               end
            //.sel24 + d8
            else if (sselshowbits=24) and (dbits=8) then
               begin
               v1:=sselshowr24a[sx].r;//sy-1
               v2:=sselshowr24[sxa].r;//sx-1
               v3:=sselshowr24[sxb].r;//sx+1
               v4:=sselshowr24b[sx].r;//sy+1
               if (sselshowr24[sx].r<=254) and ( (v2=255) or (v3=255) or ((v1=255) and (sselshowr24a<>sselshowr24)) or ((v4=255) and (sselshowr24b<>sselshowr24)) ) then
                  begin
                  //.realtime highlight stride calculations - 08jul2019
                  bol1:=(dx-((dx div xselstride)*xselstride))>=(xselstride div 2);
                  if   ((dy-((dy div xselstride)*xselstride))>=(xselstride div 2)) then bol1:=not bol1;
                  if xselshowEVENINIT then bol1:=not bol1;
                  if (dmaskval=-1) or (mr8[dx]=dmaskval) then
                     begin
                     if bol1 then dr8[dx]:=255 else dr8[dx]:=0;
                     end;
                  end;
               end;
            end
         else ar[dx].r:=0;//1=color, 0=transparent - sx
         end;//dx
      end//dy
   else for dx:=d1 to d2 do ar[dx].r:=0;
   end;//dy
//.xtrans check
if (xtrans<=1) and zznil(dm,2115) and zznil(dm2,2116) then goto skiptrans;
if (smbits<>0) then goto skiptrans;

//-- Draw Transparent Edge Soft Pixels (blur) ----------------------------------
//dy
//...was: for dy:=da.top to da.bottom do if (dy>=0) and (dy<dH) and (dy>=da_clip.top) and (dy<=da_clip.bottom) then
for dy:=d3 to d4 do
   begin
   //.fasttimer - ycheck
   inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;
   //ar
   if (dmaskval>=0) then mr8:=dmask.prows8[dy];
   ar:=a.prows24[dy];
   //.aok1
   int1:=dy-1;
   aok1:=(int1>=d3) and (int1<=d4);
   if aok1 then ar1:=a.prows24[int1];
   //.aok2
   int1:=dy+1;
   aok2:=(int1>=d3) and (int1<=d4);
   if aok2 then ar2:=a.prows24[int1];
   //dr
   if not misscan82432(d,dy,dr8,dr24,dr32) then goto skipend;//25apr2020, 28may2019
   //.dok1
   int1:=dy-1;
   dok1:=(int1>=d3) and (int1<=d4);
   if dok1 and (not misscan82432(d,int1,dr18,dr1,dr132)) then goto skipend;
   //.dok2
   int1:=dy+1;
   dok2:=(int1>=d3) and (int1<=d4);
   if dok2 and (not misscan82432(d,int1,dr28,dr2,dr232)) then goto skipend;
   //.dok3
   int1:=dy-2;
   dok3:=(int1>=d3) and (int1<=d4);
   if dok3 and (not misscan82432(d,int1,dr38,dr3,dr332)) then goto skipend;
   //.dok4
   int1:=dy+2;
   dok4:=(int1>=d3) and (int1<=d4);
   if dok4 and (not misscan82432(d,int1,dr48,dr4,dr432)) then goto skipend;
   //dx
   //...was: for dx:=da.left to da.right do if (dx>=0) and (dx<dw) and (dx>=da_clip.left) and (dx<=da_clip.right) then
   for dx:=d1 to d2 do if (dmaskval=-1) or (mr8[dx]=dmaskval) then//23may2020
      begin
      //init
      bs[0]:=false;
      bs[1]:=false;
      //get
      if (xtrans=2) then
         begin//new range: d1..d2
         //.y+0
         if (ar[dx].r=0) then bs[0]:=true;
         if ((dx-1)>=d1) and (ar[dx-1].r=1) then bs[1]:=true;
         if ((dx+1)<=d2) and (ar[dx+1].r=1) then bs[1]:=true;
         //.y-1
         if aok1 and (ar1[dx].r=1) then bs[1]:=true;
         //.y+1
         if aok2 and (ar2[dx].r=1) then bs[1]:=true;
         end
      else if (xtrans>=3) then
         begin//new range: d1..d2
         //.y+0
         bs[ar[dx].r]:=true;
         if ((dx-1)>=d1) then bs[ar[dx-1].r]:=true;
         if ((dx+1)<=d2) then bs[ar[dx+1].r]:=true;
         //.y-1
         if aok1 then
            begin
            bs[ar1[dx].r]:=true;
            if ((dx-1)>=d1) then bs[ar1[dx-1].r]:=true;
            if ((dx+1)<=d2) then bs[ar1[dx+1].r]:=true;
            end;
         //.y+1
         if aok2 then
            begin
            bs[ar2[dx].r]:=true;
            if ((dx-1)>=d1) then bs[ar2[dx-1].r]:=true;
            if ((dx+1)<=d2) then bs[ar2[dx+1].r]:=true;
            end;
         end;
      //set
      if bs[0] and bs[1] then
         begin
         case dbits of
         32:begin
            //Special Note: Always use a 5x5 blur matrix, even when "xtrans=2" (single blur boundary) for smoothest visual results - 27jul2017
            //--#--
            //-###-
            //#####
            //-###-
            //--#--
            //.y+0
            vr:=dr32[dx].r;
            vg:=dr32[dx].g;
            vb:=dr32[dx].b;
            vc:=1;
            xinc32(dr32,-1);
            xinc32(dr32,+1);
            xinc32(dr32,-2);
            xinc32(dr32,+2);
            //.y-1 / y+1
            if dok1 then
               begin
               xinc32(dr132,0);
               xinc32(dr132,-1);
               xinc32(dr132,+1);
               end;
            if dok2 then
               begin
               xinc32(dr232,0);
               xinc32(dr232,-1);
               xinc32(dr232,+1);
               end;
            //y-2 / y+2
            if dok3 then xinc32(dr332,0);
            if dok4 then xinc32(dr432,0);
            //set
            dc32.r:=byte(vr div vc);
            dc32.g:=byte(vg div vc);
            dc32.b:=byte(vb div vc);
            dc32.a:=255;
            //.xpower - 28aug2018
            xpower2:=xpower255;
            if (xpower2<255) then//does not use "m" at this point
               begin
               dc32.r:=ref65025_div_255[((dr32[dx].r*(255-xpower2))+(dc32.r*xpower2))];//18ms
               dc32.g:=ref65025_div_255[((dr32[dx].g*(255-xpower2))+(dc32.g*xpower2))];//18ms
               dc32.b:=ref65025_div_255[((dr32[dx].b*(255-xpower2))+(dc32.b*xpower2))];//18ms
               end;
            //.color
            dr32[dx]:=dc32;
            end;
         24:begin
            //Special Note: Always use a 5x5 blur matrix, even when "xtrans=2" (single blur boundary) for smoothest visual results - 27jul2017
            //--#--
            //-###-
            //#####
            //-###-
            //--#--
            //.y+0
            vr:=dr24[dx].r;
            vg:=dr24[dx].g;
            vb:=dr24[dx].b;
            vc:=1;
            xinc24(dr24,-1);
            xinc24(dr24,+1);
            xinc24(dr24,-2);
            xinc24(dr24,+2);
            //.y-1 / y+1
            if dok1 then
               begin
               xinc24(dr1,0);
               xinc24(dr1,-1);
               xinc24(dr1,+1);
               end;
            if dok2 then
               begin
               xinc24(dr2,0);
               xinc24(dr2,-1);
               xinc24(dr2,+1);
               end;
            //y-2 / y+2
            if dok3 then xinc24(dr3,0);
            if dok4 then xinc24(dr4,0);
            //set
            dc24.r:=byte(vr div vc);
            dc24.g:=byte(vg div vc);
            dc24.b:=byte(vb div vc);
            //.xpower - 28aug2018
            xpower2:=xpower255;
            if (xpower2<255) then//does not use "m" at this point
               begin
               dc24.r:=ref65025_div_255[((dr24[dx].r*(255-xpower2))+(dc24.r*xpower2))];//18ms
               dc24.g:=ref65025_div_255[((dr24[dx].g*(255-xpower2))+(dc24.g*xpower2))];//18ms
               dc24.b:=ref65025_div_255[((dr24[dx].b*(255-xpower2))+(dc24.b*xpower2))];//18ms
               end;
            //.color
            dr24[dx]:=dc24;
            end;
         8:begin
            //Special Note: Always use a 5x5 blur matrix, even when "xtrans=2" (single blur boundary) for smoothest visual results - 27jul2017
            //--#--
            //-###-
            //#####
            //-###-
            //--#--
            //.y+0
            vr:=dr8[dx];
            vg:=vr;
            vb:=vr;
            vc:=1;
            xinc8(dr8,-1);
            xinc8(dr8,+1);
            xinc8(dr8,-2);
            xinc8(dr8,+2);
            //.y-1 / y+1
            if dok1 then
               begin
               xinc8(dr18,0);
               xinc8(dr18,-1);
               xinc8(dr18,+1);
               end;
            if dok2 then
               begin
               xinc8(dr28,0);
               xinc8(dr28,-1);
               xinc8(dr28,+1);
               end;
            //y-2 / y+2
            if dok3 then xinc8(dr38,0);
            if dok4 then xinc8(dr48,0);
            //set
            dc24.r:=byte(vr div vc);
            dc24.g:=byte(vg div vc);
            dc24.b:=byte(vb div vc);
            //.xpower - 28aug2018
            xpower2:=xpower255;
            if (xpower2<255) then//does not use "m" at this point
               begin
               dc24.r:=ref65025_div_255[((dr8[dx]*(255-xpower2))+(dc24.r*xpower2))];//18ms
               dc24.g:=ref65025_div_255[((dr8[dx]*(255-xpower2))+(dc24.g*xpower2))];//18ms
               dc24.b:=ref65025_div_255[((dr8[dx]*(255-xpower2))+(dc24.b*xpower2))];//18ms
               end;
            //.color
            if (dc24.g>dc24.r) then dc24.r:=dc24.g;
            if (dc24.b>dc24.r) then dc24.r:=dc24.b;
            dr8[dx]:=dc24.r;
            end;
         end;//case
         end;
      end;//dx
   end;//dy

skiptrans:
//successful
result:=true;
skipend:
except;end;
try
//.unlocks
if dmustunlock     then misunlock(d);
if smustunlock     then misunlock(s);
if dmmustunlock    then misunlock(dm);
if dm2mustunlock   then misunlock(dm2);
if smmustunlock    then misunlock(sm);
if sm2mustunlock   then misunlock(sm2);
//.free
low__freeint(_mx);
low__freeint(_my);
low__freeimg(a);
//.ref pattern
if (refcoreR<>nil) or (refcoreG<>nil) or (refcoreB<>nil) or (refcoreRGB<>nil) or (refcoreOP<>nil) then
   begin
   freeobj(@refcoreR);
   freeobj(@refcoreG);
   freeobj(@refcoreB);
   freeobj(@refcoreRGB);
   freeobj(@refcoreOP);
   end;
//.refs -> auto free - 30aug2020
if (refOP<>nil)  then bunlockautofree(refOP);
if (refRGB<>nil) then bunlockautofree(refRGB);
if (refR<>nil)   then bunlockautofree(refR);
if (refG<>nil)   then bunlockautofree(refG);
if (refB<>nil)   then bunlockautofree(refB);
if (refX<>nil)   then bunlockautofree(refX);
if (refY<>nil)   then bunlockautofree(refY);
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//aaaaaaaaaaaaaaaaaaaaaaaaaa
//## miscopyarea32 ##
function miscopyarea32(ddx,ddy,ddw,ddh:currency;sa:trect;d,s:tobject):boolean;//can copy ALL 32bits of color
begin
try;result:=miscopyarea322(maxarea,ddx,ddy,ddw,ddh,sa,d,s,0,0);except;end;
end;
//## miscopyarea322 ##
function miscopyarea322(da_clip:trect;ddx,ddy,ddw,ddh:currency;sa:trect;d,s:tobject;xscroll,yscroll:longint):boolean;//can copy ALL 32bits of color
label
   skipend;
var//Note: Speed optimised using x-pixel limiter "d1,d2", y-pixel limiter "d3,d4"
   //      and object caching "1x createtmp" and "2x createint" with a typical speed
   //      increase in PicWork of 45x, or a screen paint time originally of 3,485ms now 78ms
   //      with layer 2 image at 80,000px wide @ 1,000% zoom as of 06sep2017.
   //Note: s and d are required - 25jul2017
   //Note: da,sa are zero-based areas, e.g: da.left/right=0..[width-1],
   //Critical Note: must use "trunc" instead of "round" for correct rounding behaviour - 24SEP2011
   //.locks
   dmustunlock,smustunlock:boolean;
   dr32,sr32:pcolorrow32;//25apr2020
   dr24,sr24:pcolorrow24;
   dr8,sr8:pcolorrow8;
   sc32:tcolor32;
   sc24:tcolor24;
   sc8:tcolor8;
   mx,my:pdllongint;
   _mx,_my:tdynamicinteger;//mapper support
   p,daW,daH,saW,saH:longint;
   d1,d2,d3,d4:longint;//x-pixel(d) and y-pixel(d) speed optimisers -> represent ACTUAL d.area needed to be processed - 05sep2017
   //.image values
   sw,sh,sbits:longint;
   shasai:boolean;
   dw,dh,dbits:longint;
   dhasai:boolean;
   //.other
   dx,dy,sx,sy:longint;
   dx1,dx2,dy1,dy2:longint;
   bol1,xmirror,xflip:boolean;
   da:trect;
   //## cint32 ##
   function cint32(x:currency):longint;
   begin//Note: Clip a 64bit integer to a 32bit integer range
   if (x>maxint) then x:=maxint
   else if (x<minint) then x:=minint;
   result:=trunc(x);
   end;
begin
try
//defaults
result:=false;
_mx:=nil;
_my:=nil;
//.locks
dmustunlock     :=false;
smustunlock     :=false;

//check
if (sa.right<sa.left) or (sa.bottom<sa.top) then goto skipend;
if not misinfo82432(s,sbits,sw,sh,shasai) then goto skipend;
if not misinfo82432(d,dbits,dw,dh,dhasai) then goto skipend;

//.mirror + flip
xmirror:=(ddw<0);if xmirror then ddw:=-ddw;
xflip  :=(ddh<0);if xflip   then ddh:=-ddh;
da.left:=cint32(ddx);
da.right:=cint32(ddx)+cint32(ddw-1);
da.top:=cint32(ddy);
da.bottom:=cint32(ddy)+cint32(ddh-1);

//.da_clip - limit to dimensions of "d" - 05sep2017
da_clip.left:=frcrange(da_clip.left,0,dw-1);
da_clip.right:=frcrange(da_clip.right,da_clip.left,dw-1);
da_clip.top:=frcrange(da_clip.top,0,dH-1);
da_clip.bottom:=frcrange(da_clip.bottom,0,dH-1);

//.optimise actual x-pixels scanned -> d1 + d2 -> 05sep2017
//.warning: Do not alter boundary handling below or failure will result - 27sep2017
d1:=largest(largest(da.left,da_clip.left),0);//range: 0..maxint
d2:=smallest(smallest(da.right,da_clip.right),dw-1);//range: minint..dw-1
if (d2<d1) then goto skipend;

//.optimise actual y-pixels scanned -> d3 + d4 -> 05sep2017
//.warning: Do not alter boundary handling below or failure will result - 27sep2017
d3:=largest(largest(da.top,da_clip.top),0);//range: 0..maxint
d4:=smallest(smallest(da.bottom,da_clip.bottom),dH-1);//range: minint..dh-1
if (d4<d3) then goto skipend;

//.other
daW:=low__posn(da.right-da.left)+1;
daH:=low__posn(da.bottom-da.top)+1;
saW:=low__posn(sa.right-sa.left)+1;
saH:=low__posn(sa.bottom-sa.top)+1;
dx1:=frcrange(da.left,0,dw-1);
dx2:=frcrange(da.right,0,dw-1);
dy1:=frcrange(da.top,0,dh-1);
dy2:=frcrange(da.bottom,0,dh-1);
//.check area -> do nothing
if (daw=0) or (dah=0) or (saw=0) or (sah=0) then goto skipend;
if (sa.right<sa.left) or (sa.bottom<sa.top) or (da.right<da.left) or (da.bottom<da.top) then goto skipend;
if (dx2<dx1) or (dy2<dy1) then goto skipend;

//.locks
if mismustlock(d)   then dmustunlock:=mislock(d);
if mismustlock(s)   then smustunlock:=mislock(s);

//.x-scroll
if (xscroll<>0) then
   begin
   xscroll:=-xscroll;//logic inversion -> match user expectation -> neg.vals=left, pos.vals=right
   bol1:=(xscroll<0);
   xscroll:=low__posn(xscroll);
   xscroll:=xscroll-((xscroll div saW)*saW);
   xscroll:=frcrange(xscroll,0,saW-1);
   if bol1 then xscroll:=-xscroll;
   end;

//.y-scroll
if (yscroll<>0) then
   begin
   yscroll:=-yscroll;//logic inversion -> match user expectation -> neg.vals=up, pos.vals=down
   bol1:=(yscroll<0);
   yscroll:=low__posn(yscroll);
   yscroll:=yscroll-((yscroll div saH)*saH);
   yscroll:=frcrange(yscroll,0,saH-1);
   if bol1 then yscroll:=-yscroll;
   end;

//.mx (mapped dx) - highly optimised - 06sep2017
if not low__createint(_mx,'copyareaxx_mx.'+inttostr(daW)+'.0.'+inttostr(sa.left)+'.'+inttostr(sa.right)+'.'+inttostr(saW),bol1) then goto skipend;
if not bol1 then
   begin
   //init
   _mx.setparams(daW,daW,0);
   mx:=_mx.core;
   //get
   for p:=0 to (daW-1) do
   begin
   mx[p]:=frcrange(sa.left+trunc(p*(saW/daW)),sa.left,sa.right);//06apr2017
   //.fasttimer - xcheck - 07jul2021
   inc(sysfasttimer_xcount); if (sysfasttimer_xcount>=sysfasttimer_xtrigger) then fasttimer_xcheck;
   end;//p
   end;
mx:=_mx.core;

//.my (mapped dy) - highly optimised - 06sep2017
if not low__createint(_my,'copyareaxx_my.'+inttostr(daH)+'.0.'+inttostr(sa.top)+'.'+inttostr(sa.bottom)+'.'+inttostr(saH),bol1) then goto skipend;
if not bol1 then
   begin
   //init
   _my.setparams(daH,daH,0);
   my:=_my.core;
   //get
   for p:=0 to (daH-1) do
   begin
   my[p]:=frcrange(sa.top+trunc(p*(saH/daH)),sa.top,sa.bottom);//24SEP2011
   //.fasttimer - xcheck - 07jul2021
   inc(sysfasttimer_xcount); if (sysfasttimer_xcount>=sysfasttimer_xtrigger) then fasttimer_xcheck;
   end;//p
   end;
my:=_my.core;

//-- Draw Color Pixels ---------------------------------------------------------
//dy
//...was: for dy:=da.top to da.bottom do if (dy>=0) and (dy<dH) and (dy>=da_clip.top) and (dy<=da_clip.bottom) then
for dy:=d3 to d4 do
   begin
   //.fasttimer - ycheck
   inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;
   //.ar
   if xflip then sy:=my[(da.bottom-da.top)-(dy-da.top)] else sy:=my[dy-da.top];//zero base
   //.y-scroll
   if (yscroll<>0) then
      begin
      sy:=sy+yscroll;
      if (sy<sa.top) then sy:=sa.bottom-(-sy-sa.top) else if (sy>sa.bottom) then sy:=sa.top+(sy-sa.bottom);
      end;
   //.sy
   if (sy>=0) and (sy<sH) then
      begin
      if not misscan82432(d,dy,dr8,dr24,dr32)                     then goto skipend;//25apr2020, 28may2019
      if not misscan82432(s,sy,sr8,sr24,sr32)                     then goto skipend;//25apr2020,
      //dx - Note: xeven only updated at this stage for speed during "sselshowbits<>0" - 08jul2019
      //...was: for dx:=da.left to da.right do if (dx>=0) and (dx<dw) and (dx>=da_clip.left) and (dx<=da_clip.right) then
      for dx:=d1 to d2 do
         begin
         if xmirror then sx:=mx[(da.right-da.left)-(dx-da.left)] else sx:=mx[dx-da.left];//zero base
         //.x-scroll
         if (xscroll<>0) then
            begin
            sx:=sx+xscroll;
            if (sx<sa.left) then
               begin
               //.math quirk for "animation cell area" referencing - 25sep2017
               if (sx<=0) then sx:=sa.right-(-sx-sa.left) else sx:=sa.right-(sa.left-sx);
               end
            else if (sx>sa.right) then sx:=sa.left+(sx-sa.right);
            end;
         //.sx
         if (sx>=0) and (sx<sW) then
            begin
            //.32 + 32
            if (sbits=32) and (dbits=32) then
               begin
               sc32:=sr32[sx];
               dr32[dx]:=sc32;
               end
            //.32 + 24
            else if (sbits=32) and (dbits=24) then
               begin
               sc32:=sr32[sx];
               sc24.r:=sc32.r;
               sc24.g:=sc32.g;
               sc24.b:=sc32.b;
               dr24[dx]:=sc24;
               end
            //.32 + 8
            else if (sbits=32) and (dbits=8) then
               begin
               sc32:=sr32[sx];
               if (sc32.g>sc32.r) then sc32.r:=sc32.g;
               if (sc32.b>sc32.r) then sc32.r:=sc32.b;
               dr8[dx]:=sc32.r;
               end
            //.24 + 32
            else if (sbits=24) and (dbits=32) then
               begin
               sc24:=sr24[sx];
               sc32.r:=sc24.r;
               sc32.g:=sc24.g;
               sc32.b:=sc24.b;
               sc32.a:=255;
               dr32[dx]:=sc32;
               end
            //.24 + 24
            else if (sbits=24) and (dbits=24) then
               begin
               sc24:=sr24[sx];
               dr24[dx]:=sc24;
               end
            //.24 + 8
            else if (sbits=24) and (dbits=8) then
               begin
               sc24:=sr24[sx];
               if (sc24.g>sc24.r) then sc24.r:=sc24.g;
               if (sc24.b>sc24.r) then sc24.r:=sc24.b;
               dr8[dx]:=sc24.r;
               end
            //.8 + 32
            else if (sbits=8) and (dbits=32) then
               begin
               sc32.r:=sr8[sx];
               sc32.g:=sc32.r;
               sc32.b:=sc32.r;
               sc32.a:=255;
               dr32[dx]:=sc32;
               end
            //.8 + 24
            else if (sbits=8) and (dbits=24) then
               begin
               sc24.r:=sr8[sx];
               sc24.g:=sc24.r;
               sc24.b:=sc24.r;
               dr24[dx]:=sc24;
               end
            //.8 + 8
            else if (sbits=8) and (dbits=8) then
               begin
               sc8:=sr8[sx];
               dr8[dx]:=sc8;
               end;
            end;//sx
         end;//dx
      end;//sy
   end;//dy

//successful
result:=true;
skipend:
except;end;
try
//.unlocks
if dmustunlock     then misunlock(d);
if smustunlock     then misunlock(s);
//.free
low__freeint(_mx);
low__freeint(_my);
except;end;
end;

//## trefedit ##################################################################
//## ref_blankX ##
function ref_blankX(x:tstr8;xlabel:string;xsize:longint):boolean;
var
   xlen,p:longint;
   v:text10;
begin  //hdr   id       use style          label
//defaults
result:=false;
//check
if zznil(x,2117) then exit;
//get
//was: result:='REF1'+#0#0#0#0+#0+#0+copy(xlabel+#0#0#0#0#0#0#0#0#0#0#0#0#0#0,1,14);
x.clear;
x.addbyt1(82);//R
x.addbyt1(69);//E
x.addbyt1(70);//F
x.addbyt1(49);//1
for p:=1 to 6 do x.addbyt1(0);
//.label
xlen:=length(xlabel);
for p:=1 to 14 do if (p<=xlen) then x.addbyt1(ord(xlabel[p-1+stroffset])) else x.addbyt1(0);
//.X blank blocks
if (xsize>=1) then
   begin
   v.val:=0;
   for p:=1 to xsize do
   begin
   x.addbyt1(v.bytes[0]);
   x.addbyt1(v.bytes[1]);
   x.addbyt1(v.bytes[2]);
   x.addbyt1(v.bytes[3]);
   x.addbyt1(v.bytes[4]);
   x.addbyt1(v.bytes[5]);
   x.addbyt1(v.bytes[6]);
   x.addbyt1(v.bytes[7]);
   x.addbyt1(v.bytes[8]);
   x.addbyt1(v.bytes[9]);
   end;//p
   end;
//size
x.setlen(x.count);
bautofree(x);//22aug2020
end;
//## ref_blank1000 ##
function ref_blank1000(x:tstr8;xlabel:string):boolean;
begin;
result:=zzok(x,7000) and ref_blankX(x,xlabel,1000);
end;
//## ref_valid ##
function ref_valid(x:tstr8):boolean;
begin                                           //R                    E                    F                    1
result:=zzok(x,7001) and (x.len>=24) and (x.bytes1[1]=82) and (x.bytes1[2]=69) and (x.bytes1[3]=70) and (x.bytes1[4]=49);
bautofree(x);
//was: (copy(x,1,4)='REF1');
end;
//## ref_id ##
function ref_id(x:tstr8):longint;
var
   a:tint4;
begin
result:=0;
if block(x) and ref_valid(x) then//27apr2021
   begin
   a.bytes[0]:=x.bytes1[5];
   a.bytes[1]:=x.bytes1[6];
   a.bytes[2]:=x.bytes1[7];
   a.bytes[3]:=x.bytes1[8];
   result:=a.val;
   end;
bunlockautofree(x);//27apr2021
end;
//## ref_setid ##
procedure ref_setid(x:tstr8;y:longint);
var
   a:tint4;
begin
if block(x) and ref_valid(x) then
   begin
   a.val:=y;
   x.bytes1[5]:=a.bytes[0];
   x.bytes1[6]:=a.bytes[1];
   x.bytes1[7]:=a.bytes[2];
   x.bytes1[8]:=a.bytes[3];
   end;
bunlockautofree(x);
end;
//## ref_incid ##
procedure ref_incid(x:tstr8);
var
   a:tint4;
begin
if block(x) and ref_valid(x) then//27apr2021
   begin
   a.bytes[0]:=x.bytes1[5];
   a.bytes[1]:=x.bytes1[6];
   a.bytes[2]:=x.bytes1[7];
   a.bytes[3]:=x.bytes1[8];
   low__iroll(a.val,1);
   x.bytes1[5]:=a.bytes[0];
   x.bytes1[6]:=a.bytes[1];
   x.bytes1[7]:=a.bytes[2];
   x.bytes1[8]:=a.bytes[3];
   end;
bunlockautofree(x);
end;
//## ref_count ##
function ref_count(x:tstr8):longint;
begin
block(x);
if ref_valid(x) then result:=(x.len-24) div 10 else result:=0;
bunlockautofree(x);
end;
//## ref_setcount ##
procedure ref_setcount(x:tstr8;xcount:longint);
var//Ultra fast -> no header checking etc
   a:text10;
   p,ocount:longint;
begin
try
//check
if zznil(x,2118) then exit;
//init
block(x);
ocount:=ref_count(x);
xcount:=frcmin(xcount,0);
x.setlen(24+(xcount*10));
if (ocount>=1) and (xcount>ocount) then for p:=ocount to (xcount-1) do ref_setval(x,p,0);
//inc
ref_incid(x);
except;end;
try;bunlockautofree(x);except;end;
end;
//## ref_use ##
function ref_use(x:tstr8):boolean;
begin
block(x);
result:=ref_valid(x) and (x.bytes1[9]<>0);
bunlockautofree(x);
end;
//## ref_setuse ##
procedure ref_setuse(x:tstr8;y:boolean);
begin
if block(x) and ref_valid(x) then
   begin
   if y then x.bytes1[9]:=1 else x.bytes1[9]:=0;
   //inc
   ref_incid(x);
   end;
bunlockautofree(x);
end;
//## ref_style ##
function ref_style(x:tstr8):byte;
begin
if block(x) and ref_valid(x) then result:=x.bytes1[10] else result:=0;
bunlockautofree(x);
end;
//## ref_setstyle ##
procedure ref_setstyle(x:tstr8;y:byte);
begin
if block(x) and ref_valid(x) then
   begin
   x.bytes1[10]:=y;
   //inc
   ref_incid(x);
   end;
bunlockautofree(x);
end;
//## ref_stylelabel ##
function ref_stylelabel(x:tstr8):string;
begin
try
if block(x) and ref_valid(x) then result:=ref_stylelabel2(x.bytes1[10]) else result:='?';
bunlockautofree(x);
except;end;
end;
//## ref_stylelabel2 ##
function ref_stylelabel2(x:longint):string;
var
   xcount:longint;
begin
try;result:=ref_stylelabel3(x,xcount);except;end;
end;
//## ref_stylelabel3 ##
function ref_stylelabel3(x:longint;var xcount:longint):string;
begin
try
//defaults
result:='?';
xcount:=7;//return style limit => count (0..count-1) - 01sep2018
//get
case x of
0:result:=ntranslate('addition');
1:result:=ntranslate('multiply');
2:result:=ntranslate('invert');
3:result:=ntranslate('double');
4:result:=ntranslate('triple');
5:result:=ntranslate('r-double');
6:result:=ntranslate('r-triple');
end;
except;end;
end;
//## ref_stylecount ##
function ref_stylecount:longint;//slow
begin
try;ref_stylelabel3(-1,result);except;end;
end;
//## ref_proc ##
function ref_proc(xstyle:longint;xval,xmin,xmax,xref:extended;xpos,xcount:longint):extended;
var
   v:extended;
begin//Error protection adds an extra 150ms per 10million calls - 27aug2018
try
//defaults
result:=0;
//range
if (xcount<1) then xcount:=1;
if (xpos<0) then xpos:=0 else if (xpos>=xcount) then xpos:=xcount-1;
//get
case xstyle of
0:result:=xval+((xmax-xmin+1)*xref);//add
1:result:=xmin+(xval-xmin)*((1+xref)/1);//multiply
2:result:=xmax-((xval-xmin)*((1+xref)/1));//invert
3:result:=xval+(2*(xval-xmin)*xref);
4:result:=xval+(3*(xval-xmin)*xref);
5:result:=xmax-(2*(xval-xmin)*xref);
6:result:=xmax-(3*(xval-xmin)*xref);

{
//OLD's
//yyyyyyyyyyyyyyyyyyyy1:result:=xval*((1+xref)/1);//multiply
//yyyyyyyyyyyyyyyyyyyy 2:result:=xmax-((xval*((1+xref)/1))-xmin);//invert
   4:begin//balanced #1
      if (xval>=128) then result:=xval+round(128*a.val) else result:=xval-round(128*a.val);
      end;
   5:begin//balanced #2
      if (xval>=128) then result:=xval-round(128*a.val) else result:=xval+round(128*a.val);
      end;
   end;//case
{}//yyyyyyyyyyyyyyyyyyyy
end;//case
except;end;
end;
//## ref_label ##
function ref_label(x:tstr8):string;
var
   p:longint;
begin
//defaults
result:='';
//check
if not block(x) then exit;
//get
if ref_valid(x) then
   begin
   for p:=11 to 24 do if (x.bytes1[p]<>0) then result:=result+char(x.bytes1[p]);
   //was:
   //result:=copy(x,11,14);
   //for p:=1 to length(result) do if (result[p-1+stroffset]=#0) then
   //   begin
   //   result:=strcopy1(result,1,p-1);
   //   break;
   //   end;
   end;
if (result='') then result:='?';
bunlockautofree(x);
end;
//## ref_setlabel ##
procedure ref_setlabel(x:tstr8;y:string);
var
   i,ylen,p:longint;
begin
if block(x) and ref_valid(x) then
   begin
   ylen:=length(y);
   //was: y:=strcopy1(y+#0#0#0#0#0#0#0#0#0#0#0#0#0#0,1,14);
   for p:=11 to 24 do
   begin
   i:=p-10;//1-based
   if (i<=ylen) then x.bytes1[p]:=ord(y[i-1+stroffset]) else x.bytes1[p]:=0;
   end;
   //inc
   ref_incid(x);
   end;
bunlockautofree(x);
end;
//## ref_paste ##
procedure ref_paste(xref,xnew:tstr8;xfit:boolean);
begin
try;ref_paste2(xref,xnew,xfit,true);except;end;
end;
//## ref_paste2 ##
procedure ref_paste2(xref,xnew:tstr8;xfit,xretainlabel:boolean);
label
   skipend;
var
   xn:string;
   i,p,nc,xc,xid:longint;
begin
try
//check
block(xref);
block(xnew);
if zznil(xref,2120) or zznil(xnew,2121) then goto skipend;
//init
xn:=ref_label(xref);
xid:=ref_id(xref);
xc:=ref_count(xref);
nc:=ref_count(xnew);

//check
if (nc<=0) then goto skipend;//nothing to paste

//get
if (xc<=0) then
   begin
   xref.replace:=xnew;//replace
   ref_setid(xref,xid);//carry over old iud
   end
else if xfit then//pastefit
   begin
   for p:=1 to xc do//value for value accurate - 29aug2018
   begin
   i:=frcrange(round((p/xc)*nc)-1,0,nc-1);
   ref_setval(xref,p-1,ref_val(xnew,i));
   end;//p
   end
else//paste
   begin
   //sync size
   ref_setcount(xref,nc);
   //sync values
   for p:=0 to (nc-1) do ref_setval(xref,p,ref_val(xnew,p));
   end;

//re-enstate label and new values -> note: id is automatically inc'ed by the procs
if xretainlabel then ref_setlabel(xref,xn) else ref_setlabel(xref,ref_label(xnew));//label
ref_setuse(xref,ref_use(xnew));//new use
ref_setstyle(xref,ref_style(xnew));//new style
skipend:
except;end;
try
bunlockautofree(xref);
bunlockautofree(xnew);
except;end;
end;
//## ref_smooth ##
procedure ref_smooth(x:tstr8;xmore:boolean);
label
   skipend;
var
   maxi,maxp,i,p:longint;
   v,v2:extended;
begin
try
//check
if not block(x) then exit;
//init
maxp:=ref_count(x)-1;
//check
if (maxp<1) then goto skipend;
if xmore then maxi:=10 else maxi:=1;
//get
for i:=1 to maxi do for p:=0 to maxp do
begin
v:=0;
v2:=0;
//-4
v:=v+ref_valex(x,p-4,true);
v2:=v2+1;
//-3
v:=v+ref_valex(x,p-3,true);
v2:=v2+1;
//-2
v:=v+ref_valex(x,p-2,true);
v2:=v2+1;
//-1
v:=v+ref_valex(x,p-1,true);
v2:=v2+1;
//0
v:=v+ref_valex(x,p,true);
v2:=v2+1;
//+1
v:=v+ref_valex(x,p+1,true);
v2:=v2+1;
//+2
v:=v+ref_valex(x,p+2,true);
v2:=v2+1;
//+3
v:=v+ref_valex(x,p+3,true);
v2:=v2+1;
//+4
v:=v+ref_valex(x,p+4,true);
v2:=v2+1;
//set
if (v2>=2) then ref_setval(x,p,v/v2);
end;//p
//inc
ref_incid(x);
skipend:
except;end;
try;bunlockautofree(x);except;end;
end;
//## ref_texture ##
procedure ref_texture(x:tstr8;xmore:boolean);
label
   skipend;
var
   maxp,p:longint;
   v2,v:extended;
begin
try
//check
if not block(x) then exit;
//init
maxp:=ref_count(x)-1;
//check
if (maxp<1) then goto skipend;
//get
for p:=0 to maxp do
begin
v:=ref_val(x,p);
if xmore then v2:=random(10000)/10000 else v2:=random(1000)/10000;
if (v>0) then v:=v+v2 else if (v<0) then v:=v-v2;
ref_setval(x,p,v);
end;//p
//inc
ref_incid(x);
skipend:
except;end;
try;bunlockautofree(x);except;end;
end;
//## ref_mirror ##
procedure ref_mirror(x:tstr8);
label
   skipend;
var
   y:tstr8;
   c,p:longint;
begin
try
//defaults
y:=nil;
//check
if not block(x) then exit;
//init
c:=ref_count(x);
if (c<=0) then goto skipend;
//get
y:=bnewfrom(x);//take a copy
for p:=0 to (c-1) do ref_setval(x,p,ref_val(y,(c-1)-p));
//inc
ref_incid(x);
skipend:
except;end;
try;bfree(y);except;end;
try;bunlockautofree(x);except;end;
end;
//## ref_flip ##
procedure ref_flip(x:tstr8);
var
   p:longint;
begin
try
if block(x) and (ref_count(x)>=1) then
   begin
   for p:=0 to (ref_count(x)-1) do ref_setval(x,p,-ref_val(x,p));
   //inc
   ref_incid(x);
   end;
except;end;
try;bunlockautofree(x);except;end;
end;
//## ref_shiftx ##
procedure ref_shiftx(x:tstr8;xby:longint);
label
   skipend;
var//xby=-N=slide left, +N=slide right
   y:tstr8;
   c,p,p2:longint;
   xneg:boolean;
begin
try
//defaults
y:=nil;
//check
if not block(x) then exit;
//check
c:=ref_count(x);
if (c<=0) then goto skipend;
//range
xneg:=(xby<0);
if xneg then xby:=-xby;
xby:=xby-((xby div c)*c);
if xneg then xby:=-xby;
if (xby=0) then exit;
//init
y:=bnewfrom(x);//take a copy
p2:=xby;
if (p2<0) then inc(p2,c);
if (p2>=c) then p2:=0;
//get
for p:=0 to (c-1) do
begin
ref_setval(x,p,ref_val(y,p2));
inc(p2);
if (p2>=c) then p2:=0;
end;//p
//inc
ref_incid(x);
skipend:
except;end;
try;bfree(y);except;end;
try;bunlockautofree(x);except;end;
end;
//## ref_shifty ##
procedure ref_shifty(x:tstr8;xby:extended);
var
   p:longint;
begin
try
if block(x) and (xby<>0) and (ref_count(x)>=1) then
   begin
   for p:=0 to (ref_count(x)-1) do ref_setval(x,p,ref_val(x,p)+xby);
   //inc
   ref_incid(x);
   end;
except;end;
try;bunlockautofree(x);except;end;
end;
//## ref_zoom ##
procedure ref_zoom(x:tstr8;xby:extended);
var
   p:longint;
begin
try
if block(x) and (xby<>0) and (ref_count(x)>=1) then
   begin
   for p:=0 to (ref_count(x)-1) do ref_setval(x,p,ref_val(x,p)*xby);
   //inc
   ref_incid(x);
   end;
except;end;
try;bunlockautofree(x);except;end;
end;
//## ref_val ##
function ref_val(x:tstr8;xindex:longint):extended;//raw only, no style
begin
try;result:=ref_valex(x,xindex,false);except;end;
end;
//## ref_valex ##
function ref_valex(x:tstr8;xindex:longint;xloop:boolean):extended;//raw only, no style
var//Ultra fast -> no header checking etc
   a:text10;
   c:longint;
begin
//defaults
result:=0;
//check
if not block(x) then exit;
//loop
if xloop then
   begin
   c:=frcmin(ref_count(x),1);
   if (xindex<0) then xindex:=frcrange(c+xindex,0,c-1)
   else if (xindex>=c) then xindex:=frcrange(xindex-c,0,c-1);
   end;
//get
xindex:=25+(xindex*10);
if (xindex>=25) and ((xindex+9)<=x.len) then
   begin
   a.bytes[0]:=x.bytes1[xindex+0];
   a.bytes[1]:=x.bytes1[xindex+1];
   a.bytes[2]:=x.bytes1[xindex+2];
   a.bytes[3]:=x.bytes1[xindex+3];
   a.bytes[4]:=x.bytes1[xindex+4];
   a.bytes[5]:=x.bytes1[xindex+5];
   a.bytes[6]:=x.bytes1[xindex+6];
   a.bytes[7]:=x.bytes1[xindex+7];
   a.bytes[8]:=x.bytes1[xindex+8];
   a.bytes[9]:=x.bytes1[xindex+9];
   result:=a.val;
   end;
bunlockautofree(x);
end;
//## ref_val2 ##
function ref_val2(x:tstr8;xindex,xval,xmin,xmax:longint):longint;//raw only, no style
begin
try;result:=ref_val2ex(x,xindex,xval,xmin,xmax,false);except;end;
end;
//## ref_val2ex ##
function ref_val2ex(x:tstr8;xindex,xval,xmin,xmax:longint;xloop:boolean):longint;//raw only, no style
var//Ultra fast -> no header checking etc
   a:text10;
   c:longint;
begin
//defaults
result:=0;
//check
if not block(x) then exit;
//loop
if xloop then
   begin
   c:=frcmin(ref_count(x),1);
   if (xindex<0) then xindex:=frcrange(c+xindex,0,c-1)
   else if (xindex>=c) then xindex:=frcrange(xindex-c,0,c-1);
   end;
//get
xindex:=25+(xindex*10);
if (xindex>=25) and ((xindex+9)<=x.len) then
   begin
   a.bytes[0]:=x.bytes1[xindex+0];
   a.bytes[1]:=x.bytes1[xindex+1];
   a.bytes[2]:=x.bytes1[xindex+2];
   a.bytes[3]:=x.bytes1[xindex+3];
   a.bytes[4]:=x.bytes1[xindex+4];
   a.bytes[5]:=x.bytes1[xindex+5];
   a.bytes[6]:=x.bytes1[xindex+6];
   a.bytes[7]:=x.bytes1[xindex+7];
   a.bytes[8]:=x.bytes1[xindex+8];
   a.bytes[9]:=x.bytes1[xindex+9];
   result:=round(xval*a.val);
   end;
//range
if (result<xmin) then result:=xmin
else if (result>xmax) then result:=xmax;
//free
bunlockautofree(x);
end;
//## ref_val32 ##
function ref_val32(x:tstr8;xindex,xval,xmin,xmax:longint):longint;
var//Ultra fast -> no header checking etc
   a:text10;
begin
//defaults
result:=0;
//check
if not block(x) then exit;
//get
xindex:=25+(xindex*10);
if (xindex>=25) and ((xindex+9)<=x.len) then
   begin
   a.bytes[0]:=x.bytes1[xindex+0];
   a.bytes[1]:=x.bytes1[xindex+1];
   a.bytes[2]:=x.bytes1[xindex+2];
   a.bytes[3]:=x.bytes1[xindex+3];
   a.bytes[4]:=x.bytes1[xindex+4];
   a.bytes[5]:=x.bytes1[xindex+5];
   a.bytes[6]:=x.bytes1[xindex+6];
   a.bytes[7]:=x.bytes1[xindex+7];
   a.bytes[8]:=x.bytes1[xindex+8];
   a.bytes[9]:=x.bytes1[xindex+9];
   result:=round(ref_proc(x.bytes1[10],xval,xmin,xmax,a.val,(xindex-25) div 10,(x.len-24) div 10));
   end
else result:=round(ref_proc(0,xval,xmin,xmax,0,0,0));
//range
if (result<xmin) then result:=xmin
else if (result>xmax) then result:=xmax;
//free
bunlockautofree(x);
end;
//## ref_val0255 ##
function ref_val0255(x:tstr8;xval:longint):longint;
var//Ultra fast -> no header checking etc
   a:text10;
   xindex:longint;
begin
//defaults
result:=0;
//check
if not block(x) then exit;
//get                 //count  * percentage * blocksize
xindex:=25+(round((xval/255)*(((x.len-24) div 10)-1))*10);
if (xindex>=25) and ((xindex+9)<=x.len) then
   begin
   a.bytes[0]:=x.bytes1[xindex+0];
   a.bytes[1]:=x.bytes1[xindex+1];
   a.bytes[2]:=x.bytes1[xindex+2];
   a.bytes[3]:=x.bytes1[xindex+3];
   a.bytes[4]:=x.bytes1[xindex+4];
   a.bytes[5]:=x.bytes1[xindex+5];
   a.bytes[6]:=x.bytes1[xindex+6];
   a.bytes[7]:=x.bytes1[xindex+7];
   a.bytes[8]:=x.bytes1[xindex+8];
   a.bytes[9]:=x.bytes1[xindex+9];
   result:=round(ref_proc(x.bytes1[10],xval,0,255,a.val,(xindex-25) div 10,(x.len-24) div 10));
   end
else result:=round(ref_proc(0,xval,0,255,0,0,0));
//range
if (result<0) then result:=0
else if (result>255) then result:=255;
//free
bunlockautofree(x);
end;
//## ref_val255255 ##
function ref_val255255(x:tstr8;xval:longint):longint;
var//Ultra fast -> no header checking etc
   a:text10;
   xindex:longint;
begin
//defaults
result:=0;
//check
if not block(x) then exit;
//get                 //count  * percentage * blocksize
xindex:=25+(round((xval/255)*(((x.len-24) div 10)-1))*10);
if (xindex>=25) and ((xindex+9)<=x.len) then
   begin
   a.bytes[0]:=x.bytes1[xindex+0];
   a.bytes[1]:=x.bytes1[xindex+1];
   a.bytes[2]:=x.bytes1[xindex+2];
   a.bytes[3]:=x.bytes1[xindex+3];
   a.bytes[4]:=x.bytes1[xindex+4];
   a.bytes[5]:=x.bytes1[xindex+5];
   a.bytes[6]:=x.bytes1[xindex+6];
   a.bytes[7]:=x.bytes1[xindex+7];
   a.bytes[8]:=x.bytes1[xindex+8];
   a.bytes[9]:=x.bytes1[xindex+9];
   result:=round(ref_proc(x.bytes1[10],xval,-255,255,a.val,(xindex-25) div 10,(x.len-24) div 10));
   end
else result:=round(ref_proc(0,xval,-255,255,0,0,0));
//range
if (result<-255) then result:=-255
else if (result>255) then result:=255;
//free
bunlockautofree(x);
end;
//## ref_valrange32 ##
function ref_valrange32(x:tstr8;xval,xmin,xmax,zpos:longint;var zmin,zmax,zoff,zcount:longint):longint;
var//Ultra fast -> no header checking etc
   a:text10;
   int1:longint;
begin
//defaults
result:=0;
//check
if not block(x) then exit;
//init
if (zcount=0) then
   begin
   //.vars
   zcount:=ref_count(x);
   zoff:=0;
   //.small -> large
   if (zmax<zmin) then
      begin
      int1:=zmax;
      zmax:=zmin;
      zmin:=int1;
      end;
   //.convert range to "0..max"
   if (zmin<0) or (zmin>0) then
      begin
      zoff:=-zmin;
      zmax:=zmax+zoff;
      zmin:=0;
      end;
   //.zmax MUST be 1 or higher
   if (zmax<1) then zmax:=1;
   end;
//.zpos
inc(zpos,zoff);
if (zpos<zmin) then zpos:=zmin
else if (zpos>zmax) then zpos:=zmax;
//get
zpos:=25+(round((zpos/zmax)*(zcount-1))*10);
if (zpos>=25) and ((zpos+9)<=x.len) then
   begin
   a.bytes[0]:=x.bytes1[zpos+0];
   a.bytes[1]:=x.bytes1[zpos+1];
   a.bytes[2]:=x.bytes1[zpos+2];
   a.bytes[3]:=x.bytes1[zpos+3];
   a.bytes[4]:=x.bytes1[zpos+4];
   a.bytes[5]:=x.bytes1[zpos+5];
   a.bytes[6]:=x.bytes1[zpos+6];
   a.bytes[7]:=x.bytes1[zpos+7];
   a.bytes[8]:=x.bytes1[zpos+8];
   a.bytes[9]:=x.bytes1[zpos+9];
   result:=round(ref_proc(x.bytes1[10],xval,xmin,xmax,a.val,(zpos-25) div 10,(x.len-24) div 10));
   end
else result:=round(ref_proc(0,xval,xmin,xmax,0,0,0));
//range
if (result<xmin) then result:=xmin
else if (result>xmax) then result:=xmax;
//free
bunlockautofree(x);
end;
//## ref_val80 ##
function ref_val80(x:tstr8;xindex:longint;xval,xmin,xmax:extended):extended;
var//Ultra fast -> no header checking etc
   a:text10;
begin
//defaults
result:=0;
//check
if not block(x) then exit;
//get
xindex:=25+(xindex*10);
if (xindex>=25) and ((xindex+9)<=x.len) then
   begin
   a.bytes[0]:=x.bytes1[xindex+0];
   a.bytes[1]:=x.bytes1[xindex+1];
   a.bytes[2]:=x.bytes1[xindex+2];
   a.bytes[3]:=x.bytes1[xindex+3];
   a.bytes[4]:=x.bytes1[xindex+4];
   a.bytes[5]:=x.bytes1[xindex+5];
   a.bytes[6]:=x.bytes1[xindex+6];
   a.bytes[7]:=x.bytes1[xindex+7];
   a.bytes[8]:=x.bytes1[xindex+8];
   a.bytes[9]:=x.bytes1[xindex+9];
   result:=xval*a.val;
   end
else result:=0;
//range
if (result<xmin) then result:=xmin
else if (result>xmax) then result:=xmax;
//free
bunlockautofree(x);
end;
//## ref_valrange80 ##
function ref_valrange80(x:tstr8;xval,xmin,xmax:extended;zpos:longint;var zmin,zmax,zoff,zcount:longint):extended;
var//Ultra fast -> no header checking etc
   a:text10;
   int1:longint;
begin
//defaults
result:=0;
//check
if not block(x) then exit;
//init
if (zcount=0) then
   begin
   //.vars
   zcount:=ref_count(x);
   zoff:=0;
   //.small -> large
   if (zmax<zmin) then
      begin
      int1:=zmax;
      zmax:=zmin;
      zmin:=int1;
      end;
   //.convert range to "0..max"
   if (zmin<0) or (zmin>0) then
      begin
      zoff:=-zmin;
      zmax:=zmax+zoff;
      zmin:=0;
      end;
   //.zmax MUST be 1 or higher
   if (zmax<1) then zmax:=1;
   end;
//.zpos
inc(zpos,zoff);
if (zpos<zmin) then zpos:=zmin
else if (zpos>zmax) then zpos:=zmax;
//get
zpos:=25+(round((zpos/zmax)*(zcount-1))*10);
if (zpos>=25) and ((zpos+9)<=x.len) then
   begin
   a.bytes[0]:=x.bytes1[zpos+0];
   a.bytes[1]:=x.bytes1[zpos+1];
   a.bytes[2]:=x.bytes1[zpos+2];
   a.bytes[3]:=x.bytes1[zpos+3];
   a.bytes[4]:=x.bytes1[zpos+4];
   a.bytes[5]:=x.bytes1[zpos+5];
   a.bytes[6]:=x.bytes1[zpos+6];
   a.bytes[7]:=x.bytes1[zpos+7];
   a.bytes[8]:=x.bytes1[zpos+8];
   a.bytes[9]:=x.bytes1[zpos+9];
   result:=ref_proc(x.bytes1[10],xval,xmin,xmax,a.val,(zpos-25) div 10,(x.len-24) div 10);
   end
else result:=ref_proc(0,xval,xmin,xmax,0,0,0);
//range
if (result<xmin) then result:=xmin
else if (result>xmax) then result:=xmax;
//free
bunlockautofree(x);
end;
//## ref_setval ##
procedure ref_setval(x:tstr8;xindex:longint;y:extended);
var//Ultra fast -> no header checking etc
   a:text10;
   i:longint;
begin
xindex:=25+(xindex*10);
if block(x) and (xindex>=25) and ((xindex+9)<=x.len) then
   begin
   a.val:=y;
   x.bytes1[xindex+0]:=a.bytes[0];
   x.bytes1[xindex+1]:=a.bytes[1];
   x.bytes1[xindex+2]:=a.bytes[2];
   x.bytes1[xindex+3]:=a.bytes[3];
   x.bytes1[xindex+4]:=a.bytes[4];
   x.bytes1[xindex+5]:=a.bytes[5];
   x.bytes1[xindex+6]:=a.bytes[6];
   x.bytes1[xindex+7]:=a.bytes[7];
   x.bytes1[xindex+8]:=a.bytes[8];
   x.bytes1[xindex+9]:=a.bytes[9];
   end;
//free
bunlockautofree(x);
end;
//## ref_setall ##
procedure ref_setall(x:tstr8;y:extended);
var
   c,p:longint;
begin
try
block(x);
c:=ref_count(x);
if (c>=1) then for p:=0 to (c-1) do
   begin
   ref_setval(x,p,y);
   //inc
   ref_incid(x);
   end;
//free
bunlockautofree(x);
except;end;
end;
//-- temp support --------------------------------------------------------------
//## createtmp ##
function low__createimg24(var x:tbasicimage;xid:string;var xwascached:boolean):boolean;
var
   i,p:longint;
   _ms64:currency;
   //## _init ##
   function _init(x:longint):tbasicimage;
   begin
   try
   result:=nil;
   systmpstyle[x]:=2;//0=free, 1=available, 2=locked
   systmptime[x]:=ms64+30000;//1 minute
   systmpid[x]:=xid;
   if zznil(systmpbmp[x],2122) then systmpbmp[x]:=misimg(24,1,1);
   result:=systmpbmp[x];
   except;end;
   end;
begin
try
//defaults
result:=false;
x:=nil;
xwascached:=false;
//find existing
for p:=0 to high(systmpstyle) do if (systmpstyle[p]=1) and (xid=systmpid[p]) then
   begin
   x:=_init(p);
   xwascached:=true;//signal to calling proc the int.list was cacched intact -> allows for optimisation at the calling proc's end - 06sep2017
   break;
   end;
//find new
if zznil(x,2123) then for p:=0 to high(systmpstyle) do if (systmpstyle[p]=0) then
   begin
   x:=_init(p);
   break;
   end;
//find oldest
if zznil(x,2124) then
   begin
   i:=-1;
   _ms64:=0;
   //find
   for p:=0 to high(systmpstyle) do if (systmpstyle[p]=1) and ((systmptime[p]<_ms64) or (_ms64=0)) then
      begin
      i:=p;
      _ms64:=systmptime[p];
      end;//p
   //get
   if (i>=0) then x:=_init(i);
   end;
//successful
result:=(x<>nil);
except;end;
end;
//## low__freeimg ##
procedure low__freeimg(var x:tbasicimage);
var
   p:longint;
begin
try
if zzok(x,7003) then for p:=0 to high(systmpstyle) do if (x=systmpbmp[p]) then
   begin
   if (systmpstyle[p]=2) then//locked
      begin
      systmptime[p]:=ms64+30000;//1 minute - hold onto this before trying to free it via "checktmp"
      systmpstyle[p]:=1;//unlock -> make this buffer available again
      x:=nil;
      end;
   break;
   end;//p
except;end;
end;
//## checkimg ##
procedure low__checkimg;
begin
try
//init
inc(systmppos);
if (systmppos<0) or (systmppos>high(systmpstyle)) then systmppos:=0;
//shrink buffer
if (systmpstyle[systmppos]=1) and (ms64>=systmptime[systmppos]) and zzok(systmpbmp[systmppos],7005) and ((systmpbmp[systmppos].width>1) or (systmpbmp[systmppos].height>1)) then
   begin
   systmpstyle[systmppos]:=2;//lock
   try
   systmpid[systmppos]:='';//clear id - 06sep2017
   if (systmpbmp[systmppos].width>1) or (systmpbmp[systmppos].height>1) then systmpbmp[systmppos].sizeto(1,1);//23may2020
   except;end;
   systmpstyle[systmppos]:=1;//unlock
   end;
except;end;
end;
//## createint ##
function low__createint(var x:tdynamicinteger;xid:string;var xwascached:boolean):boolean;
var
   _ms64:currency;
   i,p:longint;
   //## _init ##
   function _init(x:longint):tdynamicinteger;
   begin
   try
   result:=nil;
   sysintstyle[x]:=2;//0=free, 1=available, 2=locked
   sysinttime[x]:=ms64+30000;//1 minute
   sysintid[x]:=xid;//set the id (duplicate id's are allowed)
   if zznil(sysintobj[x],2125) then sysintobj[x]:=tdynamicinteger.create;
   result:=sysintobj[x];
   except;end;
   end;
begin
try
//defaults
result:=false;
xwascached:=false;
x:=nil;
//find existing
for p:=0 to high(sysintstyle) do if (sysintstyle[p]=1) and (xid=sysintid[p]) then
   begin
   x:=_init(p);
   xwascached:=true;//signal to calling proc the int.list was cacched intact -> allows for optimisation at the calling proc's end - 06sep2017
   break;
   end;
//find new
if zznil(x,2126) then for p:=0 to high(sysintstyle) do if (sysintstyle[p]=0) then
   begin
   x:=_init(p);
   break;
   end;
//find oldest
if zznil(x,2127) then
   begin
   i:=-1;
   _ms64:=0;
   //find
   for p:=0 to high(sysintstyle) do if (sysintstyle[p]=1) and ((sysinttime[p]<_ms64) or (_ms64=0)) then
      begin
      i:=p;
      _ms64:=sysinttime[p];
      end;//p
   //get
   if (i>=0) then x:=_init(i);
   end;
//successful
result:=(x<>nil);
except;end;
end;
//## freeint ##
procedure low__freeint(var x:tdynamicinteger);
var
   p:longint;
begin
try
if (x<>nil) then for p:=0 to high(sysintstyle) do if (x=sysintobj[p]) then
   begin
   if (sysintstyle[p]=2) then//locked
      begin
      sysinttime[p]:=ms64+30000;//1 minute - hold onto this before trying to free it via "checktmp"
      sysintstyle[p]:=1;//unlock -> make this buffer available again
      x:=nil;
      end;
   break;
   end;//p
except;end;
end;
//## checkint ##
procedure low__checkint;
begin
try
//init
inc(sysintpos);
if (sysintpos<0) or (sysintpos>high(sysintstyle)) then sysintpos:=0;
//shrink buffer
if (sysintstyle[sysintpos]=1) and (ms64>=sysinttime[sysintpos]) and zzok(sysintobj[sysintpos],7006) and (sysintobj[sysintpos].size>1) then
   begin
   sysintstyle[sysintpos]:=2;//lock
   sysintid[sysintpos]:='';//clear id - 06sep2017
   sysintobj[sysintpos].clear;
   sysintstyle[sysintpos]:=1;//unlock
   end;
except;end;
end;
//## createbyte ##
function low__createbyte(var x:tdynamicbyte;xid:string;var xwascached:boolean):boolean;
var
   _ms64:currency;
   i,p:longint;
   //## _init ##
   function _init(x:longint):tdynamicbyte;
   begin
   try
   result:=nil;
   sysbytestyle[x]:=2;//0=free, 1=available, 2=locked
   sysbytetime[x]:=ms64+30000;//1 minute
   sysbyteid[x]:=xid;//set the id (duplicate id's are allowed)
   if zznil(sysbyteobj[x],2128) then sysbyteobj[x]:=tdynamicbyte.create;
   result:=sysbyteobj[x];
   except;end;
   end;
begin
try
//defaults
result:=false;
xwascached:=false;
x:=nil;
//find existing
for p:=0 to high(sysbytestyle) do if (sysbytestyle[p]=1) and (xid=sysbyteid[p]) then
   begin
   x:=_init(p);
   xwascached:=true;//signal to calling proc the int.list was cacched intact -> allows for optimisation at the calling proc's end - 06sep2017
   break;
   end;
//find new
if zznil(x,2129) then for p:=0 to high(sysbytestyle) do if (sysbytestyle[p]=0) then
   begin
   x:=_init(p);
   break;
   end;
//find oldest
if zznil(x,2130) then
   begin
   i:=-1;
   _ms64:=0;
   //find
   for p:=0 to high(sysbytestyle) do if (sysbytestyle[p]=1) and ((sysbytetime[p]<_ms64) or (_ms64=0)) then
      begin
      i:=p;
      _ms64:=sysbytetime[p];
      end;//p
   //get
   if (i>=0) then x:=_init(i);
   end;
//successful
result:=(x<>nil);
except;end;
end;
//## freebyte ##
procedure low__freebyte(var x:tdynamicbyte);
var
   p:longint;
begin
try
if (x<>nil) then for p:=0 to high(sysbytestyle) do if (x=sysbyteobj[p]) then
   begin
   if (sysbytestyle[p]=2) then//locked
      begin
      sysbytetime[p]:=ms64+30000;//1 minute - hold onto this before trying to free it via "checktmp"
      sysbytestyle[p]:=1;//unlock -> make this buffer available again
      x:=nil;
      end;
   break;
   end;//p
except;end;
end;
//## checkbyte ##
procedure low__checkbyte;
begin
try
//init
inc(sysbytepos);
if (sysbytepos<0) or (sysbytepos>high(sysbytestyle)) then sysbytepos:=0;
//shrink buffer
if (sysbytestyle[sysbytepos]=1) and (ms64>=sysbytetime[sysbytepos]) and zzok(sysbyteobj[sysbytepos],7007) and (sysbyteobj[sysbytepos].size>1) then
   begin
   sysbytestyle[sysbytepos]:=2;//lock
   sysbyteid[sysbytepos]:='';//clear id - 06sep2017
   sysbyteobj[sysbytepos].clear;
   sysbytestyle[sysbytepos]:=1;//unlock
   end;
except;end;
end;
//-- pixel modifiers -----------------------------------------------------------
//## fbNoise3 ##
procedure fbNoise3(var r,g,b:byte);//faster - 29jul2017
var
   tmp:byte;
begin
tmp:=random(31);
r:=fb255[r+(tmp-15)];
g:=fb255[g+(tmp-15)];
b:=fb255[b+(tmp-15)];
end;
//## fbInvert ##
procedure fbInvert(var r,g,b:byte);
begin
r:=255-r;
g:=255-g;
b:=255-b;
end;
//## fbGreyscale ##
procedure fbGreyscale(var r,g,b:byte);
var
   v:byte;
begin
//get
v:=r;
if (g>v) then v:=g;
if (b>v) then v:=b;
//set
r:=v;
g:=v;
b:=v;
end;
//## fbSepia ##
procedure fbSepia(var r,g,b:byte);
var//Sepia base color is "128,91,36"
   v1,v2,v3:longint;
begin
//get
v1:=128;
v2:=r;
if (g>v2) then v2:=g;
if (b>v2) then v2:=b;
v3:=v1-v2;
//set
r:=fb255[128-v3];
g:=fb255[91-v3];
b:=fb255[36-v3];
end;
//## misscreenw ##
function misscreenw:longint;
begin
try;result:=screen.width;except;end;
end;
//## misscreenh ##
function misscreenh:longint;
begin
try;result:=screen.height;except;end;
end;
//## misscreenresin248K ##
function misscreenresin248K:longint;//returns 2(K), 4(K) or 8(K)
var
   sw,sh:longint;
begin
try
//defaults
result:=2;
//init
sw:=misscreenw;
sh:=misscreenh;
//get
if      (sw>=7680) and (sh>=4320) then result:=8
else if (sw>=3840) and (sh>=2160) then result:=4;
except;end;
end;
//## misrect ##
function misrect(x,y,x2,y2:longint):trect;
begin
try
result.left:=x;
result.top:=y;
result.right:=x2;
result.bottom:=y2;
except;end;
end;
//## misarea ##
function misarea(s:tobject):trect;
begin
try
result:=nilrect;
if zzok(s,7008) then result:=rect(0,0,misw(s)-1,mish(s)-1);
except;end;
end;
//## misworkarea ##
function misworkarea:trect;//supports multiple horizontal monitors
{$ifdef D3}
var
   a:tcustomform;
   int1,sw:longint;
begin
try
//defaults
result:=low__rect(0,0,0,0);
//get
systemparametersinfo(SPI_GETWORKAREA,0,@result,0);
a:=application.mainform;
if (a<>nil) then
   begin
   sw:=misscreenw;
   if (a.left>sw) then
      begin
      //shift work area to the right by X screenwidth's -> assumes multiple monitors are in a horizontal line - 18mar2020
      int1:=(a.left div sw)*sw;
      inc(result.left,int1);
      inc(result.right,int1);
      end;
   end;
{$endif}
{$ifdef D10}
begin
try
result:=low__rect(0,0,misscreenw-1,misscreenh-1);
{$endif}
except;end;
end;
//## misworkh ##
function misworkh:longint;
var
   a:trect;
begin
try;a:=misworkarea;result:=a.bottom-a.top;except;end;
end;
//## misworkw ##
function misworkw:longint;
var
   a:trect;
begin
try;a:=misworkarea;result:=a.right-a.left;except;end;
end;
//## misscreenarea ##
function misscreenarea:trect;
begin
try;result:=rect(0,0,misscreenw-1,misscreenh-1);except;end;
end;
//## miscursorpos ##
function miscursorpos:tpoint;
begin
try
{$ifdef D3}
getcursorpos(result);
{$endif}
{$ifdef D10}
result.x:=miscursorpos_x;
result.y:=miscursorpos_y;
{$endif}
except;end;
end;
//## mistodata ##
function mistodata(s:tobject;ddata:tstr8;dformat:string;var e:string):boolean;//02jun2020
begin                                       //asis
try;result:=mistodata2(s,ddata,dformat,clnone,-1,0,false,e);except;end;
end;
//## mistodata2 ##
function mistodata2(s:tobject;ddata:tstr8;dformat:string;dtranscol,dfeather,dlessdata:longint;dtransframe:boolean;var e:string):boolean;//04sep2021, 03jun2020
begin
try;result:=mistodata3(s,ddata,dformat,dtranscol,dfeather,dlessdata,dtransframe,false,e);except;end;
end;
//## mistodata3 ##
function mistodata3(_s:tobject;ddata:tstr8;dformat:string;dtranscol,dfeather,dlessdata:longint;dtransframe,xuseacopy:boolean;var e:string):boolean;//04sep2021, 03jun2020
label//xformat: BMP, JPG, JIF, JPEG, TEM, TEH, TEA, RAW24, RAW32
   skipend;
var
   s:tobject;
   a:tbmp;
   xalpha:tbasicimage;
   sbmp:tobject;
   xmustunlock,bol1,smustfree:boolean;
   m:tmemstr8;
   xouttranscol:longint;
{$ifdef jpeg}
   j:tjpegimage;
{$else}
   j:tobject;
{$endif}
   int1,int2,int3:longint;
   bol2:boolean;
   str1:string;
   //## ainit ##
   procedure ainit;
   begin
   if zznil(a,2131) then
      begin
      a:=misbmp32(misw(s),mish(s));
      miscopyareaxx1(0,0,misw(s),mish(s),rect(0,0,misw(s)-1,mish(s)-1),a,s);
      end;
   end;
   //## sbmpinit ##
   procedure sbmpinit;//converts "s.bitmap" into a managed bitmap "tbmp" - 21aug2020
   begin
   if (s is tbasicimage) or (s is tbmp) then sbmp:=s
   else if (s is tbitmap) then
      begin
      smustfree:=true;
      sbmp:=tbmp.create;
      (sbmp as tbmp).assign(s);
      end;
   //.lock
   bmplock(sbmp);//required - 18jun2022
   end;
   //## minit ##
   procedure minit;
   begin
   if zznil(m,2132) then m:=tmemstr8.create(ddata);
   end;
   //## jinit ##
   procedure jinit;
   begin
{$ifdef jpeg}
   if zznil(j,2133) then j:=misjpg;
{$endif}
   end;
begin
try
//defaults
result:=false;
e:='Task failed';
s:=_s;
xmustunlock:=mislocked(_s);
a:=nil;
xalpha:=nil;
m:=nil;
sbmp:=nil;
smustfree:=false;
block(ddata);
j:=nil;
dformat:=low__extractfileext2(dformat,dformat,true);//accepts filename and extension only - 12apr2021
//check
if zznil(ddata,2134) then goto skipend else ddata.clear;
if zznil(_s,2135) or (misw(_s)<1) or (mish(_s)<1) then goto skipend;
//copy "_s" to "s" in order to retain original state of "_s" - 12feb2022
if xuseacopy then
   begin
   s:=misimg32(1,1);
   if not miscopy(_s,s) then goto skipend;
   end;
//get
if (dformat='BMP') then
   begin
   ainit;
   //.alpha - supports feather and transparent color - 05jun2021
   if (misb(a)=32) then
      begin
      int1:=dtranscol;
      if (int1=clnone) and mishasai(s) and misai(s).transparent then int1:=mispixel24VAL(s,0,0);
      //.make alpha
      a.lock;
      try
      xalpha:=misimg8(misw(a),mish(a));
      bol1:=mask__feather2(a,xalpha,dfeather,int1,dtransframe,xouttranscol) and mask__copy(a,xalpha);
      except;end;
      a.unlock;
      if not bol1 then goto skipend;//01aug2021
      end;
   minit;
   a.core.savetostream(m);
   end
else if (dformat='GIF') then//22may2022, 01aug2021
   begin
   bmplock(s);
   case misai(_s).use32 of
   false:bol1:=low__togif2(s,dtranscol,ddata,e);//permit transparent color override - 09sep2021
   true:result:=low__togif3(s,dtranscol,true,true,ddata,e);//22may2022
   end;
   bmpunlock(s);
   if not bol1 then goto skipend;
   end
else if (dformat='JPG') or (dformat='JIF') then
   begin
{$ifdef jpeg}
   e:='Out of memory';
   ainit;
   jinit;
   j.assign(a.core);
   minit;
   //.auto-adaptive for high quality images that exceed JPEG limit -> quality is reduced to ensure stability - 04sep2021
   int2:=dlessdata;//start at X% and step down till there is no error -> Dephi's JPEG is prone to fail at high-quality and large image sizes -> e.g. ~1200x800 @ 100% failes - 06aug2019
   if (int2>=1) then
      begin
      while true do
      begin
      bol2:=false;
      try;j.compressionquality:=int2;j.savetostream(m);bol2:=true;except;end;
      if bol2 then break;
      dec(int2,5);
      if (int2<5) then break;//04sep2021
      end;//while
      //.error
      if not bol2 then goto skipend;
      end
   else j.savetostream(m);
{$else}
   e:='Image format not supported: '+dformat;
   goto skipend;
{$endif}
   end
else if (dformat='JPEG') then//automatically create best size jpeg with good quality
   begin
   //init
{$ifdef jpeg}
   e:='Out of memory';
   ainit;
   jinit;
   j.assign(a.core);
   int2:=100;//start at 100% and step down till there is no error -> Dephi's JPEG is prone to fail at high-quality and large image sizes -> e.g. ~1200x800 @ 100% failes - 06aug2019
   //get
   minit;
   while true do
   begin
   bol2:=false;
   try;j.compressionquality:=int2;j.savetostream(m);bol2:=true;except;end;
   if bol2 then break;
   dec(int2,5);
   if (int2<=10) then break;
   end;//while
   //.error
   if not bol2 then goto skipend;
{$else}
   e:='Image format not supported: '+dformat;
   goto skipend;
{$endif}
   end
else if (dformat='PNG') then
   begin
   sbmpinit;
   int1:=dtranscol;
   if (int1=clnone) and mishasai(sbmp) and misai(sbmp).transparent then int1:=mispixel24VAL(sbmp,0,0);
   if not mistopng82432(sbmp,int1,dfeather,dlessdata,dtransframe,ddata,e) then goto skipend;
   end
else if (dformat='TEA') then
   begin
   sbmpinit;
   if not low__teamake2(sbmp,true,misai(sbmp).transparent,misai(sbmp).syscolors,0,0,ddata,e) then goto skipend;//12apr2021
   end
{
else if (dformat='RAW24') then
   begin
   ainit;
   if not low__bmptoraw24(a,ddata,int1,int2,int3) then goto skipend;
   end
else if (dformat='RAW32') then
   begin
   ainit;
   if not low__bmptoraw32(a,ddata,int1,int2,int3) then goto skipend;
   end
{}//xxxxxxxxxx
else
   begin
   e:='Unsupported format';
   goto skipend;
   end;
//successful
result:=true;
skipend:
except;end;
try
if (not result) and zzok(ddata,7009) then ddata.clear;//reset
freeobj(@a);
freeobj(@xalpha);
{$ifdef jpeg}
freeobj(@j);
{$endif}
if smustfree then freeobj(@sbmp);
freeobj(@m);//do last
bunlockautofree(ddata);
//.s - 12feb2022
if (s<>_s) then freeobj(@s);
//.unlock
if (_s<>nil) and xmustunlock and mislocked(_s) then misunlock(_s);
except;end;
end;
//## low__findbpp82432 ##
function low__findbpp82432(i:tobject;iarea:trect;imask32:boolean):longint;//limited color count 07feb2022, 19jan2021, 21-SEP-2004
label
   skipone,skipok;
var
   sr8:pcolorrow8;
   sr24:pcolorrow24;
   sr32:pcolorrow32;
   x:array[word] of tcolor32;
   xlimit,ibits,iw,ih,p,count,rx,ry:integer;
   lc32,c32:tcolor32;
   lc24,c24:tcolor24;
   lc8,c8:tcolor8;
   lcok,ok:boolean;
begin
try
//defaults
result:=1;
//check
if not misok82432(i,ibits,iw,ih) then exit;
//init
xlimit:=258;
count:=0;
lcok:=false;
iarea.left:=frcrange(iarea.left,0,iw-1);
iarea.right:=frcrange(iarea.right,iarea.left,iw-1);
iarea.top:=frcrange(iarea.top,0,ih-1);
iarea.bottom:=frcrange(iarea.bottom,iarea.top,ih-1);

//get
for ry:=iarea.top to iarea.bottom do
begin
if not misscan82432(i,ry,sr8,sr24,sr32) then break;
if (count>xlimit) then break;
//.32
if (ibits=32) then
   begin
   for rx:=iarea.left to iarea.right do
   begin
   c32:=sr32[rx];
   if (not lcok) or (lc32.r<>c32.r) or (lc32.g<>c32.g) or (lc32.b<>c32.b) or (imask32 and (lc32.a<>c32.a)) then
      begin
      //init
      ok:=true;
      //find existing
      if (count>=1) then
         begin
         for p:=0 to (count-1) do if (x[p].r=c32.r) and (x[p].g=c32.g) and (x[p].b=c32.b) and ((not imask32) or (x[p].a=c32.a)) then
            begin
            ok:=false;
            break;
            end;//p
         end;
      //add
      if ok then
         begin
         x[count].r:=c32.r;
         x[count].g:=c32.g;
         x[count].b:=c32.b;
         x[count].a:=c32.a;
         inc(count);
         if (count>xlimit) then goto skipok;
         end;//ok
      end;
   lc32:=c32;
   lcok:=true;
   end;//rx
   end//32
//.24
else if (ibits=24) then
   begin
   for rx:=iarea.left to iarea.right do
   begin
   c24:=sr24[rx];
   if (not lcok) or (lc24.r<>c24.r) or (lc24.g<>c24.g) or (lc24.b<>c24.b) then
      begin
      //init
      ok:=true;
      //find existing
      if (count>=1) then
         begin
         for p:=0 to (count-1) do if (x[p].r=c24.r) and (x[p].g=c24.g) and (x[p].b=c24.b) then
            begin
            ok:=false;
            break;
            end;//p
         end;
      //add
      if ok then
         begin
         x[count].r:=c24.r;
         x[count].g:=c24.g;
         x[count].b:=c24.b;
         inc(count);
         if (count>xlimit) then goto skipok;
         end;//ok
      end;
   lc24:=c24;
   lcok:=true;
   end;//rx
   end//24
//.8
else if (ibits=8) then
   begin
   for rx:=iarea.left to iarea.right do
   begin
   c8:=sr8[rx];
   if (not lcok) or (lc8<>c8) then
      begin
      //init
      ok:=true;
      //find existing
      if (count>=1) then
         begin
         for p:=0 to (count-1) do if (x[p].r=c8) then
            begin
            ok:=false;
            break;
            end;//p
         end;
      //add
      if ok then
         begin
         x[count].r:=c8;
         inc(count);
         if (count>xlimit) then goto skipok;
         end;//ok
      end;
   lc8:=c8;
   lcok:=true;
   end;//rx
   end;//8
end;//ry

skipok:
//return result
case count of
minint..2:result:=1;
3..16:result:=4;
17..256:result:=8;
257..maxint:result:=24;
end;
except;end;
end;
//## low__icosizes ##
function low__icosizes(x:longint):longint;//18JAN2012, 25APR2011
const
   step=8;
   min=16;
   max=256;//Note: Icon writing routines must clip "256" to "255" for 256x256 icons - 18JAN2012
begin
try
//defaults
result:=32;
//range
x:=frcrange(x,min,max);
//step
x:=frcrange((x div nozero(1100144,step))*step,min,max);
//set
result:=x;
except;end;
end;
//## low__palfind24 ##
function low__palfind24(var a:array of tcolor24;acount:longint;var z:tcolor24):byte;
var//assumes "a is 0..X"
   p:longint;
begin
try
//defaults
result:=0;
//range
if (acount<=0) then exit else if (acount>256) then acount:=256;
//scan - Note: r/b are swapped
for p:=0 to (acount-1) do if (a[p].r=z.r) and (a[p].g=z.g) and (a[p].b=z.b) then
   begin
   result:=p;
   break;
   end;//end of if
except;end;
end;


//-- Start of ICO/CUR/ANI Support ----------------------------------------------------------------------
{$ifdef ico}
//Approximate code cost: 6K - 07feb2022
//## low__toico ##
function low__toico(s:tobject;dcursor:boolean;dsize,dBPP,dtranscol,dfeather:longint;dtransframe:boolean;dhotX,dhotY:longint;xdata:tstr8;var e:string):boolean;//handles 1-32 bpp icons - 03jan2019, 14mar2015, 16JAN2012
label//Note: dBPP=1,4,8,24 and 32, 0=automatic 1-24 but not 32 - 16JAN2012
     //Note: Does not alter "d", but instead takes a copy of it and works on that - 16JAN2012
     //Note: Output icon format is made up of three headers: [TCursorOrIcon=6b]+[TIconRec=16b]+ An array 0..X of "[TBitmapInfoHeader=40b]+[Palette 2/16/256 x BGR0]+[Image bits in 4byte blocks]+[MonoMask bits in 4byte blocks]" - 18JAN2012
     //Note: dformat: <nil> or "ico"=default=icon, "cur"=cursor
     //Note: dnewsize=0=automatic size=default
   skipend;
const
   feather=50;//%
var
   pal:array[0..1023] of tcolor24;
   s24:tbasicimage;
   s8:tbasicimage;//8bit mask - 08apr2015
   sr8:pcolorrow8;
   sr24:pcolorrow24;
   p,palcount,mrowfix,rowfix,mrowlen,rowlen,sx,sy,maxx,mi,int1:longint;
   c,zc,c2,rgbBlack:tcolor24;
   vals1,vals2,valspos1,valspos2,zv8,zv1,v8:byte;
   z,z2:string;
   i4:tint4;
   bol1,ok:boolean;
   //.s
   sbits,sw,sh,tr,tg,tb:longint;
   shasai:boolean;
   //.header records
   typhdr:tcursororicon;
   icohdr:ticonrec;
   imghdr:tbitmapinfoheader;
   //.cores
   xpal,ximg,xmask:tstr8;
   //## pushpixel4 ##
   procedure pushpixel4(data:tstr8;var vals,valspos:byte;_val16:byte;reset:boolean);
   const
      bits4:array[0..1] of longint=(16,1);
   begin
   try
   //get
   if (valspos>=0) and (valspos<=1) then
      begin
      //range
      if (_val16>15) then _val16:=15;
      //add
      if (_val16>=1) then vals:=vals+bits4[valspos]*_val16;
      //inc
      inc(valspos);
      end;
   //set
   if (valspos>=2) or (reset and (valspos>=1)) then
      begin
      data.addbyt1(vals);//pushb(datalen,data,char(vals));
      //reset
      vals:=0;
      valspos:=0;
      end;
   except;end;
   end;
   //## pushpixel1 ##
   procedure pushpixel1(data:tstr8;var vals,valspos:byte;_val1:byte;reset:boolean);
   const
      bits1:array[0..7] of longint=(128,64,32,16,8,4,2,1);
   begin
   try
   //get
   if (valspos>=0) and (valspos<=7) then
      begin
      //range
      if (_val1>1) then _val1:=1;
      //add
      if (_val1>=1) then vals:=vals+bits1[valspos]*_val1;
      //inc
      inc(valspos);
      end;
   //set
   if (valspos>=8) or (reset and (valspos>=1)) then
      begin
      data.addbyt1(vals);//pushb(datalen,data,char(vals));
      //reset
      vals:=0;
      valspos:=0;
      end;
   except;end;
   end;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
s8:=nil;
s24:=nil;
xpal:=nil;
ximg:=nil;
xmask:=nil;
//check
if not low__true2(block(xdata),misinfo82432(s,sbits,sw,sh,shasai)) then goto skipend;
xdata.clear;
//size
if (dsize<=0) then dsize:=(sw+sh) div 2;
dsize:=low__icosizes(dsize);//16..256
maxx:=dsize-1;
//copy "d" => "a"
s8:=misimg8(dsize,dsize);//07apr2015
s24:=misimg24(dsize,dsize);
if not miscopyareaxx1(0,0,dsize,dsize,rect(0,0,sw-1,sh-1),s24,s) then goto skipend;
//init
xpal:=bnew;
ximg:=bnew;
xmask:=bnew;
fillchar(pal,sizeof(pal),0);
palcount:=0;
//.transparent color as 24bit color
if (dtranscol<>clnone) then
   begin
   misfindtranscol82432ex(s,dtranscol,tr,tg,tb);
   dtranscol:=low__rgb(tr,tg,tb);
   end
else
   begin
   tr:=-1;
   tg:=-1;
   tb:=-1;
   end;
//.force sharp feather when a transparent color is specified - 17jan2021
if (dtranscol<>clnone) and (dfeather<0) then dfeather:=0;
if (dfeather<>0) or dtransframe then dBPP:=32;
//.hotspot
dhotX:=frcrange(dhotX,-1,dsize-1);
dhotY:=frcrange(dhotY,-1,dsize-1);
if (dhotX<0) or (dhotY<0) then
   begin
   //init
   bol1:=true;
   dhotX:=0;
   dhotY:=0;
   //get
   //.y
   for sy:=0 to (dsize-1) do
   begin
   if not misscan24(s24,sy,sr24) then goto skipend;
   //.x
   for sx:=0 to (dsize-1) do
   begin
   c:=sr24[sx];
   if (c.r<>tr) or (c.g<>tg) or (c.b<>tb) then
      begin
      dhotX:=sx;
      dhotY:=sy;
      bol1:=false;
      break;
      end;
   end;//sx
   if not bol1 then break;
   end;//sy
   end;

rgbBlack.r:=0;rgbBlack.g:=0;rgbBlack.b:=0;
rowfix:=0;
mrowfix:=0;

//-- GET --
//.automatic bpp
if (dBPP<=0) then dBPP:=low__findbpp82432(s,misarea(s),false);//07feb2022

//.reduce colors to fit dBPP
case dBPP of
1:begin
   if not mislimitcolors82432(s24,dtranscol,2,true,pal,palcount,e) then goto skipend;//1bit = 2 colors
   palcount:=2;//force to static limit - 17JAN2012
   rowlen:=dsize div 8;
   mrowlen:=dsize div 8;
   end;
4:begin
   if not mislimitcolors82432(s24,dtranscol,16,true,pal,palcount,e) then goto skipend;//4bit = 16 colors
   palcount:=16;//force to static limit - 17JAN2012
   rowlen:=dsize div 2;
   mrowlen:=dsize div 8;
   end;
8:begin
   if not mislimitcolors82432(s24,dtranscol,256,true,pal,palcount,e) then goto skipend;//8bit = 256 colors
   palcount:=256;//force to static limit - 17JAN2012
   rowlen:=dsize;
   mrowlen:=dsize div 8;
   end;
24:begin
   rowlen:=dsize*3;
   mrowlen:=dsize div 8;
   end;
32:begin//Important Note: 32bpp icons still store a 1bit mask - confirmed - 18JAN2012
   rowlen:=dsize*4;
   mrowlen:=dsize div 8;
   end;
end;//case

//.rowfix
rowfix:=(rowlen-((rowlen div 4)*4));//0..3
if (rowfix>=1) then rowfix:=4-rowfix;
//.mrowfix
mrowfix:=(mrowlen-((mrowlen div 4)*4));//0..3
if (mrowfix>=1) then mrowfix:=4-mrowfix;

//.make mask "s8" - 07feb2022
e:=gecTaskfailed;
if not mask__feather2(s24,s8,dfeather,dtranscol,dtransframe,int1) then goto skipend;

//-- SET --
//.build images
for sy:=(dsize-1) downto 0 do
begin
if not misscan24(s24,sy,sr24) then goto skipend;
if not misscan8(s8,sy,sr8) then goto skipend;
//.init
mi:=0;
vals1:=0;
vals2:=0;
valspos1:=0;
valspos2:=0;
//.x
for sx:=0 to maxx do
begin
zc:=sr24[sx];
zv1:=sr8[sx];//1bit mask for all icons including 32bpp - 18JAN2012
zv8:=sr8[sx];//8bit mask for 32bpp icons
//-- zv1 filter --
if (zv1=0) then zv1:=1 else zv1:=0;
//-- zv8 filter --
if (zv8<=0) then zv8:=1;//Special Note: 8bit mask for 32bit icons: 0=mask error, 1=fully transparent, 10=less transparent, 127=even less transparent, 255=fully solid - not transparent - 18JAN2012
//.decide
case dBPP of
32:begin//"BGRT" - 16JAN2012
   ximg.aadd([zc.b,zc.g,zc.r,zv8]);//pushb(dIMAGELEN,dIMAGE,char(zc.b)+char(zc.g)+char(zc.r)+char(zv8));
   pushpixel1(xmask,vals1,valspos1,zv1,sx=maxx);//required - 18JAN2012
   end;
24:begin//"BGR" + 1bit MASK - 17JAN2012
   if (zv1=1) then zc:=pal[0];//rgbBlack;//transparent pixels are BLACK
   ximg.aadd([zc.b,zc.g,zc.r]);//pushb(dIMAGELEN,dIMAGE,char(zc.b)+char(zc.g)+char(zc.r));
   pushpixel1(xmask,vals1,valspos1,zv1,sx=maxx);
   end;
8:begin//"PalIndex" + 1bit MASK - 17JAN2012
   if (zv1=1) then v8:=0 else v8:=low__palfind24(pal,palcount,zc);//transparent pixels are BLACK
   ximg.addbyt1(v8);//pushb(dIMAGELEN,dIMAGE,char(v8));
   pushpixel1(xmask,vals1,valspos1,zv1,sx=maxx);
   end;
4:begin//"PalIndex" + 1bit MASK - 17JAN2012
   if (zv1=1) then v8:=0 else v8:=low__palfind24(pal,palcount,zc);//transparent pixels are BLACK
   pushpixel4(ximg,vals2,valspos2,v8,sx=maxx);
   pushpixel1(xmask,vals1,valspos1,zv1,sx=maxx);
   end;
1:begin//"PalIndex" + 1bit MASK - 17JAN2012
   if (zv1=1) then v8:=0 else v8:=low__palfind24(pal,palcount,zc);//transparent pixels are BLACK
   pushpixel1(ximg,vals2,valspos2,v8,sx=maxx);
   pushpixel1(xmask,vals1,valspos1,zv1,sx=maxx);
   end;
end;//case
end;//sx
//.rowfix -> pushb(ximg,copy(#0#0#0#0,1,rowfix));
if (rowfix>=3) then ximg.addbyt1(0);
if (rowfix>=2) then ximg.addbyt1(0);
if (rowfix>=1) then ximg.addbyt1(0);
//.mrowfix -> pushb(dMASKLEN,dMASK,copy(#0#0#0#0,1,mrowfix));
if (mrowfix>=3) then xmask.addbyt1(0);
if (mrowfix>=2) then xmask.addbyt1(0);
if (mrowfix>=1) then xmask.addbyt1(0);
end;//sy

//.1st pal entry is BLACK for transparent icons - 07feb2022
if (dtranscol<>clnone) then
   begin
   pal[0].r:=0;
   pal[0].g:=0;
   pal[0].b:=0;
   end;
//.build palette - "BGR0"
if (palcount>=1) then for p:=0 to (palcount-1) do xpal.aadd([pal[p].b,pal[p].g,pal[p].r,0]);//pushb(dPALLEN,dPAL,char(pal[p].b)+char(pal[p].g)+char(pal[p].r)+#0);

//-- Build Icon ----------------------------------------------------------------
//.init
fillchar(typhdr,sizeof(typhdr),0);
fillchar(icohdr,sizeof(icohdr),0);
fillchar(imghdr,sizeof(imghdr),0);
//.image header - 40b
imghdr.bisize:=sizeof(imghdr);
imghdr.biwidth:=dsize;
imghdr.biheight:=2*dsize;
imghdr.biplanes:=1;
imghdr.bibitcount:=dBPP;
imghdr.bicompression:=0;
imghdr.bisizeimage:=xpal.len+ximg.len+xmask.len;
//.icon header - 16b
icohdr.width:=byte(frcrange(dsize,0,255));
icohdr.height:=byte(frcrange(dsize,0,255));
case dBPP of
1:int1:=2;
4:int1:=16;
8:int1:=256;//17JAN2012
else int1:=0;
end;
icohdr.colors:=word(int1);
icohdr.dibsize:=sizeof(imghdr)+imghdr.bisizeimage;//length of "dibHEADER+dibDATA"
icohdr.diboffset:=22;//zero-based position of start of "image header" below
icohdr.reserved1:=word(frcrange(dhotx,0,maxword));//24JAN2012
icohdr.reserved2:=word(frcrange(dhoty,0,maxword));//24JAN2012
//.file header - 6b
typhdr.wtype:=low__aorb(1,2,dcursor);//0=stockicon, 1=icon (default for icons), 2=cursor
typhdr.count:=1;//number of icons
//set -> icondata:=fromstruc(@typhdr,sizeof(typhdr))+fromstruc(@icohdr,sizeof(icohdr))+fromstruc(@imghdr,sizeof(imghdr))+dPAL+dIMAGE+dMASK;
xdata.addrec(@typhdr,sizeof(typhdr));
xdata.addrec(@icohdr,sizeof(icohdr));
xdata.addrec(@imghdr,sizeof(imghdr));
xdata.add(xpal);
xdata.add(ximg);
xdata.add(xmask);
//successful
result:=true;
skipend:
except;end;
try
if (not result) and (xdata<>nil) then xdata.clear;
freeobj(@s8);
freeobj(@s24);
bfree(xpal);
bfree(ximg);
bfree(xmask);
bunlockautofree(xdata);
except;end;
end;
//## low__toani ##
function low__toani(s:tobject;slist:tfindlistimage;dsize,dBPP,dtranscolor,dfeather:longint;dtransframe:boolean;ddelay,dhotX,dhotY:longint;xdata:tstr8;var e:string):boolean;//07aug2021 (disabled repeat checker as it breaks the ANI file!), 24JAN2012
label
   //Note: Known anirec.flags: 1=win7/ours, 3=ms old/our
   //dfeather:  -1=asis, 0=none(sharp), 1=feather(1px/blur), 2=feather(2px/blur), 3=feather(1px), 4=feather(2px)
   //dtranscol: clnone=solid (no see thru parts), clTopLeft=pixel(0,0), else=user specified color
   skipend;
var
   dtranscol,int1,dw,dh,p2,p,len,pos:integer;
   anirec:tanirec;
   xicon,xiconlist:tstr8;
   xonce:boolean;
   scellcount:longint;
   dcell:tbasicimage;//temp image for each icon to be read onto - 14feb2022
   //## xpullcell ##
   function xpullcell(x:longint;xdraw:boolean):boolean;
   label
      skipend;
   var
      xcell:tobject;//pointer only
      p,xbits,xcellw,xcellh,xw,xh,int1,int2,int3,xdelay:longint;
      xhasai,xtransparent:boolean;
   begin
   try
   //defaults
   result:=false;
   xcell:=s;
   //get
   if assigned(slist) then
      begin
      int1:=1;
      slist(nil,'ani',x,int1,dtranscol,xcell);
      scellcount:=frcmin(int1,1);
      if not miscells(xcell,xbits,xw,xh,int1,int2,int3,xdelay,xhasai,xtransparent) then goto skipend;
      xcellw:=xw;
      xcellh:=xh;
      //.draw
      if xdraw and zzok2(dcell) and (not miscopyarea32(0,0,dw,dh,rect(0,0,xcellw-1,xcellh-1),dcell,xcell)) then goto skipend;
      //.translate transparent color if required - 14feb2022
      dtranscol:=mistranscol(dcell,dtranscol,dtranscol<>clnone);
      end
   else
      begin
      if not miscells(s,xbits,xw,xh,scellcount,xcellw,xcellh,xdelay,xhasai,xtransparent) then goto skipend;
      //.draw
      if xdraw and zzok2(dcell) and (not miscopyarea32(0,0,dw,dh,rect(x*xcellw,0,((x+1)*xcellw)-1,xcellh-1),dcell,s)) then goto skipend;
      //.transcol - per cell
      dtranscol:=mistranscol(dcell,dtranscolor,dtranscolor<>clnone);
      end;
   //.val defaults
   if xonce then
      begin
      xonce:=false;
      if (ddelay<=0) then ddelay:=xdelay;
      if (dsize<=0) then dsize:=(xcellw+xcellh) div 2;//vals set by call to "xpullcell(0)" above
      end;
   //successful
   result:=true;
   skipend:
   except;end;
   end;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
xonce:=true;
xicon:=nil;
xiconlist:=nil;
dcell:=nil;
//check
if not block(xdata) then exit;
if not xpullcell(0,false) then goto skipend;
//init
xdata.clear;
fillchar(anirec,sizeof(anirec),0);
ddelay:=frcmin(ddelay,1);
dsize:=low__icosizes(dsize);//16..256
dw:=dsize;
dh:=dsize;
dcell:=misimg32(dw,dh);
xicon:=bnew;
xiconlist:=bnew;
//.force sharp feather when a transparent color is specified - 17jan2021
if (dtranscol<>clnone) and (dfeather<0) then dfeather:=0;
if (dfeather<>0) or dtransframe then dBPP:=32;

//-- GET -----------------------------------------------------------------------
//.dBPP - scan each cell and return the highest BPP rating to cover ALL cells - 22JAN2012
case dBPP of
1,4,8,24,32:;
else
   begin
   //max "bpp" for all cells
   dBPP:=1;
   for p:=0 to (scellcount-1) do
   begin
   if not xpullcell(p,true) then goto skipend;
   int1:=low__findbpp82432(dcell,rect(0,0,dw-1,dh-1),false);
   if (int1>dBPP) then dBPP:=int1;
   if (dBPP>=24) then break;
   end;//p
   end;
end;//case

//.anirec - do last
anirec.cbsizeof:=sizeof(anirec);
anirec.cframes:=scellcount;//number of unique images
anirec.csteps:=scellcount;//number of cells in anmiation
anirec.cbitcount:=dBPP;
anirec.jifrate:=frcmin(round(ddelay/16.666),1);
anirec.flags:=1;//win7/some of ours

//.cells -> icons
for p:=0 to (scellcount-1) do
begin
//.get cell
if not xpullcell(p,true) then goto skipend;
//.make icon
if not low__toico(dcell,true,dsize,dBPP,dtranscol,dfeather,dtransframe,dhotX,dhotY,xicon,e) then goto skipend;
//.add icon -> 'icon'+from32bit(length(imgs.items[p]^))+imgs.items[p]^
xiconlist.addstr('icon');
xiconlist.addint4(xicon.len);
xiconlist.add(xicon);
xicon.clear;
end;//p

//-- RIFF ----------------------------------------------------------------------
//.riff -> 'RIFF'+from32bit(length(data)+4)+data;
xdata.addstr('RIFF');
xdata.addint4(0);//set last
//._anih - 'ACONanih'+from32bit(sizeof(anirec))+fromstruc(@anirec,sizeof(anirec));
xdata.addstr('ACONanih');
xdata.addint4(sizeof(anirec));
xdata.addrec(@anirec,sizeof(anirec));
//._list
xdata.addstr('LIST');
xdata.addint4(4+xiconlist.len);
xdata.addstr('fram');
xdata.add(xiconlist);
//.reduce mem
xiconlist.clear;
//.set overal size
xdata.int4[4]:=frcmin(xdata.len-4,0);
//successful
result:=true;
skipend:
except;end;
try
if (not result) and (xdata<>nil) then xdata.clear;
bfree(xicon);
bfree(xiconlist);
freeobj(@dcell);
bunlockautofree(xdata);
except;end;
end;
//## fromicon32 ##
function low__fromico32(d:tobject;sdata:tstr8;dsize:longint;xuse32:boolean;var e:string):boolean;//handles 1-32 bpp icons - 26JAN2012
label//Note: dsize=0=extract biggest icon we can from datastream, else=attempt to extract an icon that matches the dimsensions of dsize - 20JAN2012
   skiprec,dofinalise,skipdone,skipend;
var
   dtmp32,dm8:tbasicimage;//mask - 07apr2015
   dtmp:tstr8;
   z:string;
   lastWH,lastS,lastS2,bestindex,bestindex2,int1,mrowlen,mrowfix,rowlen,rowfix,tc,len,bmpLEN,maskLEN,p,pos,palcount,mbpp,bpp,dx,dy,dw,dh,dbits:longint;
   pal:array[0..255] of tcolor24;
   dr32:pcolorrow32;
   dr24:pcolorrow24;
   dr8,r8:pcolorrow8;
   whitec:tcolor24;
   c32:tcolor32;
   bol1,transparentOK:boolean;
   typhdr:tcursororicon;
   icohdrs:array[0..999] of ticonrec;//16,000 bytes - 20JAN2012
   imghdrs:array[0..999] of tbitmapinfoheader;//40,000 bytes - 20JAN2012
   imghdrsPNG:array[0..999] of boolean;//23may2022
   i2:twrd2;
   v8:byte;
   //## iconOK ##
   function iconOK:boolean;
   begin
   try
   //defaults
   result:=false;
   //dw AND dh
   if (dw<>low__icosizes(dw)) or (dh<>low__icosizes(dh)) then exit;
   //bpp - 16JAN2012
   case bpp of
   1,4,8,24,32:;
   else exit;
   end;
   //mbpp
   case mbpp of
   0,1:;
   else exit;
   end;
   //other
   if (bmpLEN=0) then exit;
   //successful - icon is of an known format - 14JAN2012
   result:=true;
   except;end;
   end;
   //## readpixels ##
   function readpixels(asmask:boolean):boolean;
   label
      skipend;
   const
      bits4:array[0..1] of integer=(16,1);
      bits1:array[0..7] of integer=(128,64,32,16,8,4,2,1);
   var
      mode,p,v,v1,v2,v3,v4,v5,v6,v7,v8:integer;
      z:tcolor24;
      //## pushpixel32 ##
      function pushpixel32(col:tcolor24;mcol:longint):boolean;
      var
         c32:tcolor32;
         c8:longint;
      begin
      try
      //defaults
      result:=false;
      //get
      if (dx>=0) and (dx<dw) then
         begin
         //filter
         if (not xuse32) and (col.r=255) and (col.g=255) and (col.b=255) then col.r:=254;//don't use WHITE, reserved for transparent color - 14JAN2012
         if (mcol>=0) and (mcol<=255) then r8[dx]:=byte(mcol);//for 32bpp
         //get
         case dbits of
         32:begin
            c32.r:=col.r;
            c32.g:=col.g;
            c32.b:=col.b;
            c32.a:=255;//correct alpha value will be set later
            dr32[dx]:=c32;
            end;
         24:dr24[dx]:=col;
         8:begin
            c8:=col.r;
            if (col.g>c8) then c8:=col.g;
            if (col.b>c8) then c8:=col.b;
            dr8[dx]:=c8;
            end;
         end;//case
         //inc
         inc(dx);
         //successful
         result:=true;
         end;
      except;end;
      end;
      //## pushpixel8 ##
      function pushpixel8(col8:integer):boolean;
      begin
      try
      //defaults
      result:=false;
      //get
      if (dx>=0) and (dx<dw) then
         begin
         //range
         if (col8<0) then col8:=0
         else if (col8>255) then col8:=255;
         //set
         r8[dx]:=byte(col8);
         //inc
         inc(dx);
         //successful
         result:=true;
         end;
      except;end;
      end;
      //## takefrom ##
      function takefrom(var v:longint;vdiv:longint):longint;
      begin
      try
      //range
      v:=frcmin(v,0);
      vdiv:=frcmin(vdiv,1);
      //set
      result:=v div vdiv;
      v:=v-result*vdiv;
      except;end;
      end;
   begin
   try
   //defaults
   result:=false;
   //check
   if (dx>=dw) then exit;
   if (not asmask) and ((pos>len) or (pos<1)) then exit;
   //get
   if asmask then mode:=-mbpp else mode:=bpp;
   case mode of
   -1:begin//write to mask "dm8.r8" -> was 255=solid, 0=transparent
      if (pos>=1) and (pos<=len) then
         begin
         v:=255-sdata.bytes1[pos];//now invert transparent values to line up with standard 32bit alpha mask values - 23may2022, was: v:=sdata.bytes1[pos]//byte(icondata[pos]);
         inc(pos,1);
         end
      else v:=255;//not transparent by default
      for p:=0 to high(bits1) do if not pushpixel8(takefrom(v,bits1[p])*255) then goto skipend;
      end;
   1:begin
      v:=sdata.bytes1[pos];//byte(icondata[pos]);
      for p:=0 to high(bits1) do if not pushpixel32(pal[takefrom(v,bits1[p])],-1) then goto skipend;
      inc(pos,1);
      end;
   4:begin
      v:=sdata.bytes1[pos];//byte(icondata[pos]);
      for p:=0 to high(bits4) do if not pushpixel32(pal[takefrom(v,bits4[p])],-1) then goto skipend;
      inc(pos,1);
      end;
   8:begin
//was:      if not pushpixel32(pal[byte(icondata[pos])],-1) then goto skipend;
      if not pushpixel32(pal[sdata.bytes1[pos]],-1) then goto skipend;
      inc(pos,1);
      end;
   24:begin//pixel color order "BGR" - 14JAN2012
      if ((pos+2)>len) then goto skipend;
      z.b:=sdata.bytes1[pos+0];//byte(icondata[pos+0]);
      z.g:=sdata.bytes1[pos+1];//byte(icondata[pos+1]);
      z.r:=sdata.bytes1[pos+2];//byte(icondata[pos+2]);
      if not pushpixel32(z,-1) then goto skipend;
      inc(pos,3);
      end;
   32:begin//pixel color order "BGRT" - 16JAN2012
      if ((pos+3)>len) then goto skipend;
      z.b:=sdata.bytes1[pos+0];//byte(icondata[pos+0]);
      z.g:=sdata.bytes1[pos+1];//byte(icondata[pos+1]);
      z.r:=sdata.bytes1[pos+2];//byte(icondata[pos+2]);
      //was: if not pushpixel32(z,byte(icondata[pos+3])) then goto skipend;
      if not pushpixel32(z,sdata.bytes1[pos+3]) then goto skipend;
      inc(pos,4);
      end;
   end;//end of case
   //successful
   result:=true;
   //round up to nearest 4th byte
   skipend:
   if (dx>=dw) then inc(pos,low__aorb(rowfix,mrowfix,asmask));
   except;end;
   end;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
dm8:=nil;
dtmp32:=nil;
dtmp:=nil;
//check
if not misok82432(d,dbits,dw,dh) then exit;
if (dbits<>32) then xuse32:=false;
//init
tc:=clNone;
dw:=0;
dh:=0;
bpp:=0;
mbpp:=0;
bmpLEN:=0;
maskLEN:=0;
rowfix:=0;
mrowfix:=0;
fillchar(pal,sizeof(pal),0);
palcount:=0;
len:=0;//set below
bestindex:=-1;
bestindex2:=-1;
//.dsize
if (dsize<=0) then dsize:=0 else dsize:=low__icosizes(dsize);//20JAN2012
//.whitec
whitec.r:=255;
whitec.g:=255;
whitec.b:=255;
transparentOK:=false;

//-- Type Header (main file header) --------------------------------------------
//init
fillchar(typhdr,sizeof(typhdr),0);
fillchar(icohdrs,sizeof(icohdrs),0);
fillchar(imghdrs,sizeof(imghdrs),0);
fillchar(imghdrsPNG,sizeof(imghdrsPNG),0);//23may2022
//main file header - typhdr - 20JAN2012
e:=gecUnknownFormat;
pos:=1;
//was: if not pullstruc(pos,icondata,@typhdr,sizeof(typhdr)) then goto fromwinINSTEAD;//use Windows
if not sdata.writeto1b(@typhdr,sizeof(typhdr),pos,sizeof(typhdr)) then goto skipend;//use Windows

//.wtype
case typhdr.wtype of
0,1,2:;//0=stockicon, 1=icon (default for icons), 2=cursor
else goto skipend;//failed
end;
//.count
if (typhdr.count<=0) or ((typhdr.count-1)>high(icohdrs)) then goto skipend;//failed

//-- Icon Header(s) ------------------------------------------------------------
//init
lastWH:=0;
lastS:=0;
lastS2:=0;
bestindex:=-1;
bestindex2:=-1;
//icon headers
//was: for p:=0 to (typhdr.count-1) do if not pullstruc(pos,icondata,@icohdrs[p],sizeof(icohdrs[p])) then goto fromwinINSTEAD;
for p:=0 to (typhdr.count-1) do if not sdata.writeto1b(@icohdrs[p],sizeof(icohdrs[p]),pos,sizeof(icohdrs[p])) then goto skipend;

//image headers
for p:=0 to (typhdr.count-1) do
begin
pos:=icohdrs[p].diboffset+1;
//.png detector - 23may2022
if sdata.asame2(pos-1,[137,uuP,uuN,uuG]) then
   begin
   //init
   if (dtmp=nil) then dtmp:=bnew;
   if (dtmp32=nil) then dtmp32:=misimg32(1,1);
   //get
   dtmp.clear;
   dtmp.add31(sdata,pos,icohdrs[p].dibsize);
   misfrompng82432(dtmp32,clnone,dtmp,e);
   imghdrs[p].biwidth:=misw(dtmp32);
   imghdrs[p].biheight:=mish(dtmp32)*2;//required
   imghdrs[p].biBitCount:=misai(dtmp32).bpp;
   imghdrs[p].bisize:=icohdrs[p].dibsize;
   imghdrsPNG[p]:=true;
   goto skiprec;
   end;

//was: if not pullstruc(pos,icondata,@imghdrs[p],sizeof(imghdrs[p])) then goto fromwinINSTEAD;
if not sdata.writeto1b(@imghdrs[p],sizeof(imghdrs[p]),pos,sizeof(imghdrs[p])) then goto skipend;

skiprec:
//.corrections
imghdrs[p].biwidth:=imghdrs[p].biwidth;
imghdrs[p].biheight:=imghdrs[p].biheight div 2;
//.find best
if (imghdrs[p].biwidth=imghdrs[p].biheight) and
   (imghdrs[p].biwidth=low__icosizes(imghdrs[p].biwidth)) then
   begin
   if (imghdrs[p].biwidth>=lastWH) and (icohdrs[p].dibsize>=lastS) then
      begin
      bestindex:=p;
      lastWH:=imghdrs[p].biwidth;
      lastS:=icohdrs[p].dibsize;
      end;
   if (dsize>=1) and (dsize=imghdrs[p].biwidth) and (icohdrs[p].dibsize>=lastS2) then
      begin
      bestindex2:=p;
      lastS2:=icohdrs[p].dibsize;
      end;
   end;//if
end;//p

//decide
//.best match
if (bestindex2>=0) then bestindex:=bestindex2;
if (bestindex<0) then goto skipend;
//set
dw:=imghdrs[bestindex].biwidth;
dh:=imghdrs[bestindex].biheight;
bpp:=imghdrs[bestindex].biBitCount;
pos:=frcrange(icohdrs[bestindex].diboffset+imghdrs[bestindex].bisize+1,1,sdata.len);//20JAN2012
len:=pos+icohdrs[bestindex].dibsize-1;//last pos for this icon data chunk - don't read past this point - 20JAN2012
//hotspot - for information purposes only - 21JAN2012
misai(d).hotspotX:=icohdrs[bestindex].reserved1;
misai(d).hotspotY:=icohdrs[bestindex].reserved2;

//.bpp
case bpp of
1:begin
   palcount:=2;
   bmpLEN:=(dw*dh) div 8;
   rowlen:=dw div 8;
   mbpp:=1;
   end;
4:begin
   palcount:=16;
   bmpLEN:=(dw*dh) div 2;
   rowlen:=dw div 2;
   mbpp:=1;
   end;
8:begin
   palcount:=256;
   bmpLEN:=dw*dh;
   rowlen:=dw;
   mbpp:=1;
   end;
24:begin
   palcount:=0;
   bmpLEN:=dw*dh*3;
   rowlen:=dw*3;
   mbpp:=1;
   end;
32:begin//20JAN2012
   palcount:=0;
   bmpLEN:=dw*dh*4;
   rowlen:=dw*4;
   mbpp:=0;//present BUT not used
   end;
else
   begin
   palcount:=0;
   bmpLEN:=0;
   rowlen:=4;
   mbpp:=1;
   end;
end;//end of case
//.mbpp
if (mbpp=1) then
   begin//1bit mask
   maskLEN:=(dw*dh) div 8;
   mrowlen:=dw div 8;
   end;//end of if
//.row
rowfix:=(rowlen-((rowlen div 4)*4));//0..3
if (rowfix>=1) then rowfix:=4-rowfix;
//.mrow
mrowfix:=(mrowlen-((mrowlen div 4)*4));//0..3
if (mrowfix>=1) then mrowfix:=4-mrowfix;
//.check
if not iconOK then goto skipend;

//.images
missize(d,dw,dh);
dm8:=misimg8(dw,dh);

//-- Read Icon Elements -------------------------------------------------------
//init
e:=gecOutofmemory;

//.png
if imghdrsPNG[bestindex] and (dtmp32<>nil) then
   begin
   missize(dtmp32,1,1);
   dtmp.clear;
   dtmp.add31(sdata,icohdrs[bestindex].diboffset+1,icohdrs[bestindex].dibsize);
   if not misfrompng82432(dtmp32,clnone,dtmp,e) then goto skipend;
   if not miscopyarea32(0,0,dw,dh,misarea(dtmp32),d,dtmp32) then goto skipend;
   if not mask__copy(dtmp32,dm8) then goto skipend;
   goto dofinalise;
   end;

//palette - stored in "B,G,R,0" order - 14JAN2012
if (palcount>=1) then for p:=0 to (palcount-1) do
   begin
   //get
   if ((p+3)>sdata.len) then
      begin
      e:=gecDataCorrupt;
      goto skipend;
      end;
   //set
   pal[p].b:=sdata.bytes1[pos+0];
   pal[p].g:=sdata.bytes1[pos+1];
   pal[p].r:=sdata.bytes1[pos+2];
   //n/a: pal[p].a:=sdata.bytes1[pos+3];
   //inc
   inc(pos,4);
   end;//end of if

//image
for dy:=(dh-1) downto 0 do
begin
if not misscan82432(d,dy,dr8,dr24,dr32) then goto skipend;
if not misscan8(dm8,dy,r8) then goto skipend;
dx:=0;
while true do if not readpixels(false) then break;
if (dx<dw) then
   begin
   e:=gecDataCorrupt;
   goto skipend;
   end;//end of if
end;//end of loop

//mask
if (mbpp=1) then
   begin
   for dy:=(dh-1) downto 0 do
   begin
   if not misscan8(dm8,dy,r8) then goto skipend;
   dx:=0;
   while true do
   begin
   readpixels(true);//read in pixels, regardless of whether there is a mask present or not
   if (dx>=dw) then break;
   end;//end of loop
   end;//end of loop
   end;//end of if

//implement transparent mode
dofinalise:
//.dy
for dy:=0 to (dh-1) do
begin
if not misscan82432(d,dy,dr8,dr24,dr32) then goto skipend;
if not misscan8(dm8,dy,r8) then goto skipend;
//.32 + xuse32
if (dbits=32) and xuse32 then
   begin
   for dx:=0 to (dw-1) do
   begin
   v8:=r8[dx];
   if (v8<=1) then v8:=0;//icons use 1 for transparency so convert it to 0
   dr32[dx].a:=v8;
   if (v8<255) then transparentOK:=true;
   end;//dx
   end
//.32
else if (dbits=32) then
   begin
   for dx:=0 to (dw-1) do if (r8[dx]<=1) then
      begin
      c32.r:=whitec.r;
      c32.g:=whitec.g;
      c32.b:=whitec.b;
      c32.a:=255;
      dr32[dx]:=c32;
      transparentOK:=true;
      end;
   end
//.24
else if (dbits=24) then
   begin
   for dx:=0 to (dw-1) do if (r8[dx]<=1) then
      begin
      dr24[dx]:=whitec;
      transparentOK:=true;
      end;
   end//24
//.8
else if (dbits=8) then
   begin
   for dx:=0 to (dw-1) do if (r8[dx]<=1) then
      begin
      dr8[dx]:=whitec.r;
      transparentOK:=true;
      end;
   end;
end;//end of loop - y

skipdone:
if transparentOK and (not xuse32) then
   begin
   c32.r:=whitec.r;
   c32.g:=whitec.g;
   c32.b:=whitec.b;
   c32.a:=255;
   missetpixel32(d,0,0,c32);
   end;
//animation information
//.clear
bol1:=misai(d).use32;
misaiclear2(d);
//.set - 22JAN2012
misai(d).use32:=bol1;
misai(d).transparent:=transparentOK;
misai(d).cellwidth:=dw;
misai(d).cellheight:=dh;
misai(d).delay:=0;
misai(d).count:=1;
misai(d).format:=low__aorbstr('ICO','CUR',(typhdr.wtype=2));//0=stockicon, 1=icon (default for icons), 2=cursor - fixed 23may2022
misai(d).subformat:='';
//.information
misai(d).bpp:=bpp;
misai(d).owrite32bpp:=(bpp=32);//maintain 32bit icons - 23JAN2012
//.cursor hotspots - 20JAN2012
misai(d).hotspotX:=icohdrs[bestindex].reserved1;
misai(d).hotspotY:=icohdrs[bestindex].reserved2;
//successful
result:=true;
skipend:
except;end;
try
freeobj(@dm8);
freeobj(@dtmp32);
bfree(dtmp);
except;end;
end;
//xxxxxxxxxxxxxxxx needs converting into new format xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//## low__fromani32 ##
function low__fromani32(d:tobject;sdata:tstr8;dsize:longint;xuse32:boolean;var e:string):boolean;//handles 1-32 bpp animated icons - 23may2022, 26JAN2012
label
   //Note: Known anirec.flags: 1=win7/ours, 3=ms old/our
   skipend;
type
   tlabelANDsize=packed record
      cap:array[0..3] of char;
      size:dword;
      end;
   tlabelonly=packed record
      cap:array[0..3] of char;
      end;
var
   a,imgs:tbasicimage;//temp image for each icon to be read onto
   str1:string;
   int1,imgscount,dcount,ddelay,dbits,dw,dh,i,p,len,pos:integer;
   csrec:tlabelANDsize;
   crec:tlabelonly;
   anirec:tanirec;
   irate,iseq,iseq2:tstr8;
   iseqptr:tstr8;//pointer only
   z:tstr8;
   firsticon:boolean;
   //## pullstrucex ##
   function pullstrucex(var pos:integer;len:longint;data:tstr8;a:pointer;asize:longint):boolean;//23may2022
   begin
   try
   //defaults
   result:=false;
   //range
   if (data=nil) then exit;
   if (len<=0) then len:=data.len;
   if (asize<1) then exit;
   if (pos<1) then pos:=1;
   if (pos>len) then exit;
   //get
   result:=data.writeto1b(a,asize,pos,asize);
   except;end;
   end;
   //## pullrec ##
   function pullrec(a:pointer;asize:longint):boolean;//22JAN2012
   begin
   try;result:=pullstrucex(pos,len,sdata,a,asize);except;end;
   end;
begin
try
//defaults
result:=false;
e:=gecOutofmemory;
a:=nil;
imgs:=nil;
irate:=nil;
iseq:=nil;
iseq2:=nil;
iseqptr:=nil;
z:=nil;
//check
if not misok82432(d,dbits,dw,dh) then exit;
if (dbits<>32) then xuse32:=false;
//init
fillchar(csrec,sizeof(csrec),0);
fillchar(crec,sizeof(crec),0);
fillchar(anirec,sizeof(anirec),0);
irate:=bnew;
iseq:=bnew;
iseq2:=bnew;
z:=bnew;
dw:=32;//cell width
dh:=32;//cell height
ddelay:=500;//in milliseconds
dcount:=1;//number of cells in total
firsticon:=false;
//was: if (d is tbitmapenhanced) then aiClear((d as tbitmapenhanced).ai);
misaiclear2(d);

a:=misimg32(1,1);
imgs:=misimg32(1,1);
imgscount:=0;

//-- GET -----------------------------------------------------------------------
//RIFF - main data header [RIFF+<overall size including RIFF>] - 22JAN2012
e:=gecUnknownFormat;
pos:=1;
//was: if (not pullstruc(pos,sdata,@csrec,sizeof(csrec))) or (string(csrec.cap)<>'RIFF') then goto skipend;
if (not sdata.writeto1b(@csrec,sizeof(csrec),pos,sizeof(csrec))) or (string(csrec.cap)<>'RIFF') then goto skipend;
len:=csrec.size;//enforce length from now on
//read chunks
while true do
begin
if (pos<1) or (pos>len) then break
else if (sdata.bytes1[pos]<=32) then inc(pos)//bad data, a plain text name is expected, skip over - 22JAN2012
else if pullrec(@csrec,sizeof(csrec)) then
   begin
   str1:=lowercase(string(csrec.cap));
   if (str1='acon') or (str1='info') or (str1='fram') then dec(pos,4)//has no size field so go back 4 bytes to correct - 22JAN2012
   else if (str1='list') then
      begin
      //nil
      end
   else if (str1='icon') then
      begin
      //get
//was:  z:=copy(data,pos,csrec.size);
//      if (d is tbitmapenhanced) then a.ocleanmask32bpp:=(d as tbitmapenhanced).ocleanmask32bpp;//26JAN2012
//      if not fromicon32(a,0,z,e) then goto skipend;
      z.clear;
      z.add31(sdata,pos,csrec.size);
      //was: if mishasai(d) then a.ocleanmask32bpp:=misai(d).ocleanmask32bpp;//26JAN2012
      if not low__fromico32(a,z,0,xuse32,e) then goto skipend;

      //first
      if not firsticon then
         begin
         firsticon:=true;
         dw:=a.width;
         dh:=a.height;
         ddelay:=frcmin(round(anirec.jifrate*16.666),20);//no faster than 50fps
         dcount:=frcmin(anirec.csteps,1);
         //animation information
         misai(d).cellwidth:=dw;
         misai(d).cellheight:=dh;
         misai(d).delay:=ddelay;
         misai(d).count:=dcount;
         misai(d).transparent:=a.ai.transparent;
         misai(d).bpp:=a.ai.bpp;
         misai(d).owrite32bpp:=(a.ai.bpp=32);//maintain 32bit animated cursors - 23JAN2012
         misai(d).hotspotx:=a.ai.hotspotx;
         misai(d).hotspoty:=a.ai.hotspoty;
         //size image strip
         //was: d.width:=dcount*dw;d.height:=dh;
         missize(d,dcount*dw,dh);
         //draw icon onto "imgs" for reference later
         missize(imgs,dcount*dw,dh);
         end;
      //.fit image to "imgs" strip cell dimensions
      miscopyarea32(imgscount*dw,0,dw,dh,rect(0,0,a.width-1,a.height-1),imgs,a);
      //seq2
      iseq2.int4i[iseq2.count div 4]:=imgscount;//used instead of "seq" when "seq" is omitted from data - 22JAN2012
      //inc
      inc(pos,csrec.size);
      inc(imgscount);
      end
   else if (str1='seq ') then
      begin
//was:      iseq.text:=copy(data,pos,csrec.size);
      iseq.clear;
      iseq.add31(sdata,pos,csrec.size);
      inc(pos,csrec.size);
      end
   else if (str1='rate') then
      begin
//was:      irate.text:=copy(data,pos,csrec.size);
      irate.clear;
      irate.add31(sdata,pos,csrec.size);
      inc(pos,csrec.size);
      end
   else if (str1='anih') then
      begin
      if not pullrec(@anirec,sizeof(anirec)) then goto skipend;
      //range
      if (anirec.csteps<=0) then//this tells us how many CELLS are used to represent the animation - 22JAN2012
         begin
         e:=gecDataCorrupt;
         goto skipend;
         end;
      end
   else
      begin//unknow chunks - skip over - 22JAN2012
      inc(pos,csrec.size);
      end;
   end
else break;
end;

//-- Build Animation -----------------------------------------------------------
//check
if not firsticon then goto skipend;
//decide - Note: "seq" is not always providied so in these cases use our "seq2"
//.seqptr
iseqptr:=iseq;
if (iseq.count=0) then iseqptr:=iseq2;
//.rate - only if providied else use the rate that came as part of "anirec" - 22JAN2012
if (irate.count>=1) then
   begin
   //get
   int1:=0;
   for p:=0 to (irate.count-1) do inc(int1,irate.int4i[p]);
   int1:=int1 div nozero(1100145,irate.count);
   //set
   ddelay:=frcmin(round(int1*16.666),20);//no faster than 50fps
   misai(d).delay:=ddelay;
   end;
//draw - using "seqptr" to refer to cells stored in "imgs", note: d should already be sized correctly - 22JAN2012
for p:=0 to ((iseqptr.count div 4)-1) do
begin
i:=iseqptr.int4i[p];//cell index
miscopyarea32(p*dw,0,dw,dh,rect(i*dw,0,i*dw+(dw-1),dh-1),d,imgs);
end;//p
//successful
result:=true;
skipend:
except;end;
try
freeobj(@a);
freeobj(@imgs);
bfree(irate);
bfree(iseq);
bfree(iseq2);
bfree(z);
except;end;
end;
//## low__toico32 ##
function low__toico32(s:tobject;dcursor,dpng:boolean;dsize,dBPP,dhotX,dhotY:longint;var xouthotX,xouthotY,xoutBPP:longint;xdata:tstr8;var e:string):boolean;//handles 1-32 bpp icons - 03jan2019, 14mar2015, 16JAN2012
label//Note: dBPP=1,4,8,24 and 32, 0=automatic 1-24 but not 32 - 16JAN2012
     //Note: Does not alter "d", but instead takes a copy of it and works on that - 16JAN2012
     //Note: Output icon format is made up of three headers: [TCursorOrIcon=6b]+[TIconRec=16b]+ An array 0..X of "[TBitmapInfoHeader=40b]+[Palette 2/16/256 x BGR0]+[Image bits in 4byte blocks]+[MonoMask bits in 4byte blocks]" - 18JAN2012
     //Note: dformat: <nil> or "ico"=default=icon, "cur"=cursor
     //Note: dnewsize=0=automatic size=default
   skipend;
const
   feather=50;//%
var
   pal:array[0..1023] of tcolor24;
   s32:tbasicimage;
   sr32:pcolorrow32;
   sc32:tcolor32;
   sc24:tcolor24;
   p,palcount,mrowfix,rowfix,mrowlen,rowlen,sx,sy,maxx,mi,int1:longint;
   vals1,vals2,valspos1,valspos2,zv8,zv1,v8:byte;
   z,z2:string;
   i4:tint4;
   bol1,ok:boolean;
   //.s
   stranscol,sbits,sw,sh,tr,tg,tb:longint;
   stransparent,shasai:boolean;
   //.header records
   typhdr:tcursororicon;
   icohdr:ticonrec;
   imghdr:tbitmapinfoheader;
   //.cores
   xpal,ximg,xmask:tstr8;
   //## pushpixel4 ##
   procedure pushpixel4(data:tstr8;var vals,valspos:byte;_val16:byte;reset:boolean);
   const
      bits4:array[0..1] of longint=(16,1);
   begin
   try
   //get
   if (valspos>=0) and (valspos<=1) then
      begin
      //range
      if (_val16>15) then _val16:=15;
      //add
      if (_val16>=1) then vals:=vals+bits4[valspos]*_val16;
      //inc
      inc(valspos);
      end;
   //set
   if (valspos>=2) or (reset and (valspos>=1)) then
      begin
      data.addbyt1(vals);//pushb(datalen,data,char(vals));
      //reset
      vals:=0;
      valspos:=0;
      end;
   except;end;
   end;
   //## pushpixel1 ##
   procedure pushpixel1(data:tstr8;var vals,valspos:byte;_val1:byte;reset:boolean);
   const
      bits1:array[0..7] of longint=(128,64,32,16,8,4,2,1);
   begin
   try
   //get
   if (valspos>=0) and (valspos<=7) then
      begin
      //range
      if (_val1>1) then _val1:=1;
      //add
      if (_val1>=1) then vals:=vals+bits1[valspos]*_val1;
      //inc
      inc(valspos);
      end;
   //set
   if (valspos>=8) or (reset and (valspos>=1)) then
      begin
      data.addbyt1(vals);//pushb(datalen,data,char(vals));
      //reset
      vals:=0;
      valspos:=0;
      end;
   except;end;
   end;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
s32:=nil;
xpal:=nil;
ximg:=nil;
xmask:=nil;
xouthotX:=0;
xouthotY:=0;
xoutBPP:=1;
//check
if not low__true2(block(xdata),misinfo82432(s,sbits,sw,sh,shasai)) then goto skipend;
if (sbits<>32) then dpng:=false;//23may2022
if dpng then dbpp:=32;//23may2022
xdata.clear;
//size
if (dsize<=0) then dsize:=(sw+sh) div 2;
dsize:=low__icosizes(dsize);//16..256
maxx:=dsize-1;
//copy "d" => "a"
s32:=misimg32(dsize,dsize);
if not miscopyarea32(0,0,dsize,dsize,rect(0,0,sw-1,sh-1),s32,s) then goto skipend;//includes 8bit mask - 15feb2022
stransparent:=mask__transparent(s32);
stranscol:=low__aorb(clnone,0,stransparent);//15feb2022
//init
xpal:=bnew;
ximg:=bnew;
xmask:=bnew;
fillchar(pal,sizeof(pal),0);
palcount:=0;

//.hotspot
dhotX:=frcrange(dhotX,-1,dsize-1);
dhotY:=frcrange(dhotY,-1,dsize-1);
if (dhotX<0) or (dhotY<0) then
   begin
   //init
   bol1:=true;
   dhotX:=0;
   dhotY:=0;
   int1:=0;
   //get
   //.y
   for sy:=0 to (dsize-1) do
   begin
   if not misscan32(s32,sy,sr32) then goto skipend;
   //.x
   for sx:=0 to (dsize-1) do
   begin
   sc32:=sr32[sx];
   if (sc32.a>int1) then
      begin
      int1:=sc32.a;
      dhotX:=sx;
      dhotY:=sy;
      if (int1>=2) then
         begin
         bol1:=false;
         break;
         end;
      end;//a
   end;//sx
   if not bol1 then break;
   end;//sy
   end;

xouthotX:=dhotX;
xouthotY:=dhotY;
rowfix:=0;
mrowfix:=0;

//-- GET --
//.automatic bpp
if (dBPP<=0) then dBPP:=low__findbpp82432(s,misarea(s),false);//07feb2022
xoutBPP:=dBPP;//24may2022

//.reduce colors to fit dBPP
case dBPP of
1:begin
   if not mislimitcolors82432(s32,stranscol,2,true,pal,palcount,e) then goto skipend;//1bit = 2 colors
   palcount:=2;//force to static limit - 17JAN2012
   rowlen:=dsize div 8;
   mrowlen:=dsize div 8;
   end;
4:begin
   if not mislimitcolors82432(s32,stranscol,16,true,pal,palcount,e) then goto skipend;//4bit = 16 colors
   palcount:=16;//force to static limit - 17JAN2012
   rowlen:=dsize div 2;
   mrowlen:=dsize div 8;
   end;
8:begin
   if not mislimitcolors82432(s32,stranscol,256,true,pal,palcount,e) then goto skipend;//8bit = 256 colors
   palcount:=256;//force to static limit - 17JAN2012
   rowlen:=dsize;
   mrowlen:=dsize div 8;
   end;
24:begin
   rowlen:=dsize*3;
   mrowlen:=dsize div 8;
   end;
32:begin//Important Note: 32bpp icons still store a 1bit mask - confirmed - 18JAN2012
   rowlen:=dsize*4;
   mrowlen:=dsize div 8;
   end;
end;//case

//.rowfix
rowfix:=(rowlen-((rowlen div 4)*4));//0..3
if (rowfix>=1) then rowfix:=4-rowfix;
//.mrowfix
mrowfix:=(mrowlen-((mrowlen div 4)*4));//0..3
if (mrowfix>=1) then mrowfix:=4-mrowfix;

//-- SET --
//.build images
for sy:=(dsize-1) downto 0 do
begin
if not misscan32(s32,sy,sr32) then goto skipend;
//.init
mi:=0;
vals1:=0;
vals2:=0;
valspos1:=0;
valspos2:=0;
//.x
for sx:=0 to maxx do
begin
sc32:=sr32[sx];
sc24.r:=sc32.r;
sc24.g:=sc32.g;
sc24.b:=sc32.b;
case sc32.a of
0:begin
   zv1:=1;
   zv8:=1;//Special Note: 8bit mask for 32bit icons: 0=mask error, 1=fully transparent, 10=less transparent, 127=even less transparent, 255=fully solid - not transparent - 18JAN2012
   end;
else
   begin
   zv1:=0;     //1bit mask for all icons including 32bpp - 18JAN2012
   zv8:=sc32.a;//8bit mask for 32bpp icons
   end;
end;//case
//.decide
case dBPP of
32:begin//"BGRT" - 16JAN2012
   ximg.aadd([sc24.b,sc24.g,sc24.r,zv8]);//pushb(dIMAGELEN,dIMAGE,char(zc.b)+char(zc.g)+char(zc.r)+char(zv8));
   pushpixel1(xmask,vals1,valspos1,zv1,sx=maxx);//required - 18JAN2012
   end;
24:begin//"BGR" + 1bit MASK - 17JAN2012
   if (zv1=1) then sc24:=pal[0];//rgbBlack;//transparent pixels are BLACK
   ximg.aadd([sc24.b,sc24.g,sc24.r]);//pushb(dIMAGELEN,dIMAGE,char(zc.b)+char(zc.g)+char(zc.r));
   pushpixel1(xmask,vals1,valspos1,zv1,sx=maxx);
   end;
8:begin//"PalIndex" + 1bit MASK - 17JAN2012
   if (zv1=1) then v8:=0 else v8:=low__palfind24(pal,palcount,sc24);//transparent pixels are BLACK
   ximg.addbyt1(v8);//pushb(dIMAGELEN,dIMAGE,char(v8));
   pushpixel1(xmask,vals1,valspos1,zv1,sx=maxx);
   end;
4:begin//"PalIndex" + 1bit MASK - 17JAN2012
   if (zv1=1) then v8:=0 else v8:=low__palfind24(pal,palcount,sc24);//transparent pixels are BLACK
   pushpixel4(ximg,vals2,valspos2,v8,sx=maxx);
   pushpixel1(xmask,vals1,valspos1,zv1,sx=maxx);
   end;
1:begin//"PalIndex" + 1bit MASK - 17JAN2012
   if (zv1=1) then v8:=0 else v8:=low__palfind24(pal,palcount,sc24);//transparent pixels are BLACK
   pushpixel1(ximg,vals2,valspos2,v8,sx=maxx);
   pushpixel1(xmask,vals1,valspos1,zv1,sx=maxx);
   end;
end;//case
end;//sx
//.rowfix -> pushb(ximg,copy(#0#0#0#0,1,rowfix));
if (rowfix>=3) then ximg.addbyt1(0);
if (rowfix>=2) then ximg.addbyt1(0);
if (rowfix>=1) then ximg.addbyt1(0);
//.mrowfix -> pushb(dMASKLEN,dMASK,copy(#0#0#0#0,1,mrowfix));
if (mrowfix>=3) then xmask.addbyt1(0);
if (mrowfix>=2) then xmask.addbyt1(0);
if (mrowfix>=1) then xmask.addbyt1(0);
end;//sy

//.1st pal entry is BLACK for transparent icons - 07feb2022
if stransparent then
   begin
   pal[0].r:=0;
   pal[0].g:=0;
   pal[0].b:=0;
   end;
//.build palette - "BGR0"
if (palcount>=1) then for p:=0 to (palcount-1) do xpal.aadd([pal[p].b,pal[p].g,pal[p].r,0]);//pushb(dPALLEN,dPAL,char(pal[p].b)+char(pal[p].g)+char(pal[p].r)+#0);

//-- Build Icon ----------------------------------------------------------------
//.png - 23may2022
if dpng then
   begin
   ximg.clear;
   if not mistopng82432(s32,clnone,-1,0,false,ximg,e) then goto skipend;
   end;
//.init
fillchar(typhdr,sizeof(typhdr),0);
fillchar(icohdr,sizeof(icohdr),0);
fillchar(imghdr,sizeof(imghdr),0);
//.image header - 40b
imghdr.bisize:=sizeof(imghdr);
imghdr.biwidth:=dsize;
imghdr.biheight:=2*dsize;
imghdr.biplanes:=1;
imghdr.bibitcount:=dBPP;
imghdr.bicompression:=0;
imghdr.bisizeimage:=xpal.len+ximg.len+xmask.len;
//.icon header - 16b
//was: icohdr.width:=byte(frcrange(dsize,0,255));
//was: icohdr.height:=byte(frcrange(dsize,0,255));
//..sourced from https://en.wikipedia.org/wiki/ICO_(file_format) - 24may2022 @ 3:05am
if (dsize>=256) then
   begin
   icohdr.width:=0;
   icohdr.height:=0;
   end
else
   begin
   icohdr.width:=byte(frcrange(dsize,0,255));
   icohdr.height:=byte(frcrange(dsize,0,255));
   end;

case dBPP of
1:int1:=2;
4:int1:=16;
8:int1:=256;//17JAN2012
else int1:=0;
end;
icohdr.colors:=word(int1);
icohdr.diboffset:=22;//zero-based position of start of "image header" below
if dcursor then//23may2022
   begin
   icohdr.reserved1:=word(frcrange(dhotx,0,maxword));//24JAN2012
   icohdr.reserved2:=word(frcrange(dhoty,0,maxword));//24JAN2012
   end
else
   begin
   icohdr.reserved1:=0;
   icohdr.reserved2:=dbpp;
   end;
//.file header - 6b
typhdr.wtype:=low__aorb(1,2,dcursor);//0=stockicon, 1=icon (default for icons), 2=cursor
typhdr.count:=1;//number of icons
//.size
case dpng of
true:icohdr.dibsize:=ximg.len;
false:icohdr.dibsize:=sizeof(imghdr)+imghdr.bisizeimage;//length of "dibHEADER+dibDATA"
end;//case

//set -> icondata:=fromstruc(@typhdr,sizeof(typhdr))+fromstruc(@icohdr,sizeof(icohdr))+fromstruc(@imghdr,sizeof(imghdr))+dPAL+dIMAGE+dMASK;
xdata.addrec(@typhdr,sizeof(typhdr));
xdata.addrec(@icohdr,sizeof(icohdr));
if dpng then
   begin
   xdata.add(ximg);
   end
else
   begin
   xdata.addrec(@imghdr,sizeof(imghdr));
   xdata.add(xpal);
   xdata.add(ximg);
   xdata.add(xmask);
   end;
//successful
result:=true;
skipend:
except;end;
try
if (not result) and (xdata<>nil) then xdata.clear;
freeobj(@s32);
bfree(xpal);
bfree(ximg);
bfree(xmask);
bunlockautofree(xdata);
except;end;
end;
//## low__toani32 ##
function low__toani32(s:tobject;slist:tfindlistimage;dformat:string;dpng:boolean;dsize:longint;ddelay,dhotX,dhotY:longint;xonehotspot:boolean;xdata:tstr8;var e:string):boolean;//15feb2022
var
   xoutbpp:longint;
begin
try;result:=low__toani32b(s,slist,dformat,dpng,dsize,0,ddelay,dhotX,dhotY,xonehotspot,xoutbpp,xdata,e);except;end;
end;
//## low__toani32b ##
function low__toani32b(s:tobject;slist:tfindlistimage;dformat:string;dpng:boolean;dsize,dforceBPP:longint;ddelay,dhotX,dhotY:longint;xonehotspot:boolean;var xoutbpp:longint;xdata:tstr8;var e:string):boolean;//15feb2022
label
   //Note: Known anirec.flags: 1=win7/ours, 3=ms old/our
   //uses alpha channel to write transparency - 15feb2022
   //Note: for the time being "dpng" is DISABLED as we cannot find information pertaining to support for PNG enabled icons for ANI cursors - 24may2022
   //Force to dBPP when >=1, 0=automatic bpp
   skipend;
var
   int1,int2,dw,dh,p2,p,len,pos:integer;
   anirec:tanirec;
   xicon,xiconlist:tstr8;
   dcursor,dtransparent,xonce:boolean;
   xfoundhotX,xfoundhotY,dbpp,scellcount:longint;
   dcell:tbasicimage;//temp image for each icon to be read onto - 14feb2022
   //.mask support
   v0,v255,vother:boolean;
   xmin,xmax:longint;
   //## xpullcell ##
   function xpullcell(x:longint;xdraw:boolean):boolean;
   label
      skipend;
   var
      xcell:tobject;//pointer only
      xtranscol,p,xbits,xcellw,xcellh,xw,xh,int1,int2,int3,xdelay:longint;
      xhasai,xtransparent:boolean;
   begin
   try
   //defaults
   result:=false;
   xcell:=s;
   //get
   if assigned(slist) then
      begin
      int1:=1;
      slist(nil,dformat,x,int1,xtranscol,xcell);
      scellcount:=frcmin(int1,1);
      if not miscells(xcell,xbits,xw,xh,int1,int2,int3,xdelay,xhasai,xtransparent) then goto skipend;
      xcellw:=xw;
      xcellh:=xh;
      //.draw
      if xdraw and zzok2(dcell) and (not miscopyarea32(0,0,dw,dh,rect(0,0,xcellw-1,xcellh-1),dcell,xcell)) then goto skipend;
      end
   else
      begin
      if not miscells(s,xbits,xw,xh,scellcount,xcellw,xcellh,xdelay,xhasai,xtransparent) then goto skipend;
      //.draw
      if xdraw and zzok2(dcell) and (not miscopyarea32(0,0,dw,dh,rect(x*xcellw,0,((x+1)*xcellw)-1,xcellh-1),dcell,s)) then goto skipend;
      end;
   //.val defaults
   if xonce then
      begin
      xonce:=false;
      if (ddelay<=0) then ddelay:=xdelay;
      if (dsize<=0) then dsize:=(xcellw+xcellh) div 2;//vals set by call to "xpullcell(0)" above
      end;
   //successful
   result:=true;
   skipend:
   except;end;
   end;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
xonce:=true;
xicon:=nil;
xiconlist:=nil;
dcell:=nil;
xoutbpp:=1;
//check
if not block(xdata) then exit;
if not xpullcell(0,false) then goto skipend;
//disabled options - 24may2022 - awaiting for more information before proceeding further with format construction/completion, though a version is able to run - 24may2022
dpng:=false;
//range
dforceBPP:=frcrange(dforceBPP,0,32);
//init
xdata.clear;
fillchar(anirec,sizeof(anirec),0);
ddelay:=frcmin(ddelay,1);
dsize:=low__icosizes(dsize);//16..256
dw:=dsize;
dh:=dsize;
dcell:=misimg32(dw,dh);
dbpp:=1;
dtransparent:=false;
xicon:=bnew;
xiconlist:=bnew;
dformat:=low__extractfileext3(dformat,dformat);//accepts filename and extension only - 12apr2021
dcursor:=(dformat='cur') or (dformat='ico');

//-- GET -----------------------------------------------------------------------
//.dbpp - scan each cell and return the highest BPP rating to cover ALL cells - 22JAN2012
dbpp:=1;
for p:=0 to (scellcount-1) do
begin
if (dforceBPP>=1) then
   begin
   dbpp:=dforceBPP;
   break;
   end;
if not xpullcell(p,true) then goto skipend;
int1:=low__findbpp82432(dcell,rect(0,0,dw-1,dh-1),false);
if (int1>dbpp) then dbpp:=int1;
if mask__range2(dcell,v0,v255,vother,xmin,xmax) then
   begin
   if vother then dbpp:=32;
   if not v255 then dtransparent:=true;
   end;
if (dbpp>=32) then break;
if (p=0) and dcursor then break;//only need first reported cell for a static cursor/icon
end;//p

//.dpng
if (misb(s)<>32) then dpng:=false;//23may2022
if dpng then dbpp:=32;//23may2022

//decide
//.cur + ico
if (dformat='cur') or (dformat='ico') then
   begin
   if not xpullcell(0,true) then goto skipend;
   result:=low__toico32(dcell,(dformat='cur'),dpng,dsize,dBPP,dhotX,dhotY,xfoundhotX,xfoundhotY,int2,xdata,e);
   if (int2>xoutbpp) then xoutbpp:=int2;
   goto skipend;
   end
//.ani
else if (dformat='ani') then
   begin
   //drop below to finish
   end
//.unsupported format
else goto skipend;

//.anirec - do last
anirec.cbsizeof:=sizeof(anirec);
anirec.cframes:=scellcount;//number of unique images
anirec.csteps:=scellcount;//number of cells in anmiation
anirec.cbitcount:=dbpp;
anirec.jifrate:=frcmin(round(ddelay/16.666),1);
anirec.flags:=1;//win7/some of ours

//.cells -> icons
for p:=0 to (scellcount-1) do
begin
//.get cell
if not xpullcell(p,true) then goto skipend;
//.make icon
if not low__toico32(dcell,true,dpng,dsize,dBPP,dhotX,dhotY,xfoundhotX,xfoundhotY,int2,xicon,e) then goto skipend;
if (int2>xoutbpp) then xoutbpp:=int2;
//.hotspot -> reuse 1st hotspot (cell 1) for all remaining cells - 15feb2022
if xonehotspot and ((dhotX<0) or (dhotY<0)) then
   begin
   dhotX:=xfoundhotX;
   dhotY:=xfoundhotY;
   end;
//.add icon -> 'icon'+from32bit(length(imgs.items[p]^))+imgs.items[p]^
xiconlist.addstr('icon');
xiconlist.addint4(xicon.len);
xiconlist.add(xicon);
xicon.clear;
end;//p

//-- RIFF ----------------------------------------------------------------------
//.riff -> 'RIFF'+from32bit(length(data)+4)+data;
xdata.addstr('RIFF');
xdata.addint4(0);//set last
//._anih - 'ACONanih'+from32bit(sizeof(anirec))+fromstruc(@anirec,sizeof(anirec));
xdata.addstr('ACONanih');
xdata.addint4(sizeof(anirec));
xdata.addrec(@anirec,sizeof(anirec));
//._list
xdata.addstr('LIST');
xdata.addint4(4+xiconlist.len);
xdata.addstr('fram');
xdata.add(xiconlist);
//.reduce mem
xiconlist.clear;
//.set overal size
xdata.int4[4]:=frcmin(xdata.len-4,0);

//successful
result:=true;
skipend:
except;end;
try
if (not result) and (xdata<>nil) then xdata.clear;
bfree(xicon);
bfree(xiconlist);
freeobj(@dcell);
bunlockautofree(xdata);
except;end;
end;
{$else}
//## low__toico ##
function low__toico(s:tobject;dcursor:boolean;dsize,dBPP,dtranscol,dfeather:longint;dtransframe:boolean;dhotX,dhotY:longint;xdata:tstr8;var e:string):boolean;//handles 1-32 bpp icons - 03jan2019, 14mar2015, 16JAN2012
begin
result:=false;
end;
//## low__toani ##
function low__toani(s:tobject;slist:tfindlistimage;dsize,dBPP,dtranscolor,dfeather:longint;dtransframe:boolean;ddelay,dhotX,dhotY:longint;xdata:tstr8;var e:string):boolean;//07aug2021 (disabled repeat checker as it breaks the ANI file!), 24JAN2012
begin
result:=false;
end;
//## low__fromico32 ##
function low__fromico32(d:tobject;sdata:tstr8;dsize:longint;xuse32:boolean;var e:string):boolean;//handles 1-32 bpp icons - 26JAN2012
begin
result:=false;
bautofree(sdata);
end;
//## low__fromani32 ##
function low__fromani32(d:tobject;sdata:tstr8;dsize:longint;xuse32:boolean;var e:string):boolean;//handles 1-32 bpp animated icons - 23may2022, 26JAN2012
begin
result:=false;
bautofree(sdata);
end;
//## low__toico32 ##
function low__toico32(s:tobject;dcursor,dpng:boolean;dsize,dBPP,dhotX,dhotY:longint;var xouthotX,xouthotY,xoutBPP:longint;xdata:tstr8;var e:string):boolean;//handles 1-32 bpp icons - 03jan2019, 14mar2015, 16JAN2012
begin
xouthotX:=0;
xouthotY:=0;
xoutbpp:=1;
result:=false;
bautofree(xdata);
end;
//## low__toani32 ##
function low__toani32(s:tobject;slist:tfindlistimage;dformat:string;dpng:boolean;dsize:longint;ddelay,dhotX,dhotY:longint;xonehotspot:boolean;xdata:tstr8;var e:string):boolean;//15feb2022
begin
result:=false;
bautofree(xdata);
end;
//## low__toani32b ##
function low__toani32b(s:tobject;slist:tfindlistimage;dformat:string;dpng:boolean;dsize,dForceBPP:longint;ddelay,dhotX,dhotY:longint;xonehotspot:boolean;var xoutbpp:longint;xdata:tstr8;var e:string):boolean;//15feb2022
begin
xoutbpp:=1;
result:=false;
bautofree(xdata);
end;

{$endif}
//-- End of ICO/CUR/ANI Support ----------------------------------------------------------------------


//## misempty ##
function misempty(s:tobject):boolean;
var
   sw,sh:longint;
begin
try
result:=false;
sw:=misw(s);
sh:=mish(s);
if (sw<=0) or (sh<=0) or ((sw<=1) and (sh<=1)) or (misb(s)<=0) then result:=true;
except;end;
end;
//## misbytes ##
function misbytes(s:tobject):comp;
begin
try;result:=low__mult64(low__mult64(misw(s),mish(s)),misb(s) div 8);except;end;
end;
//## misbytes32 ##
function misbytes32(s:tobject):longint;
begin
try;result:=restrict32(misbytes(s));except;end;
end;
//## misfromfile ##
function misfromfile(s:tobject;xfilename:string;var e:string):boolean;//09jul2021
var
   a:tstr8;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
a:=nil;
a:=bnew;
//get
result:=low__fromfile(xfilename,a,e) and misfromdata(s,a,e);
except;end;
try;bfree(a);except;end;
end;
//## mistofile ##
function mistofile(s:tobject;xfilename,dformat:string;var e:string):boolean;//12feb2022, 02jun2020
begin                                       //asis
try;result:=mistofile3(s,xfilename,dformat,clnone,-1,0,false,TRUE,e);except;end;
end;
//## mistofile2 ##
function mistofile2(s:tobject;xfilename,dformat:string;xusecopy:boolean;var e:string):boolean;//02jun2020
begin                                       //asis
try;result:=mistofile3(s,xfilename,dformat,clnone,-1,0,false,xusecopy,e);except;end;
end;
//## mistofile3 ##
function mistofile3(s:tobject;xfilename,dformat:string;dtranscol,dfeather,dlessdata:longint;dtransframe,xusecopy:boolean;var e:string):boolean;//03jun2020
var
   b:tstr8;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
b:=nil;
b:=bnew;
//get
result:=mistodata3(s,b,dformat,dtranscol,dfeather,dlessdata,dtransframe,xusecopy,e) and low__tofile(xfilename,b,e);
except;end;
try;bfree(b);except;end;
end;
//## misfromdata2 ##
function misfromdata2(s:tobject;xdata:array of byte;var e:string):boolean;//02jun2020
var
   b:tstr8;
begin
try
result:=false;
b:=nil;
e:=gecTaskfailed;
b:=bnew;
b.aadd(xdata);
result:=misfromdata(s,b,e);
except;end;
try;bfree(b);except;end;
end;
//## misfromdata ##
function misfromdata(s:tobject;xdata:tstr8;var e:string):boolean;//21aug2020
label//xformat: BMP, JPG, JIF, JPEG, TEA, GIF - 21aug2020
     //optional: ICO, CUR, ANI - 22may2022
   skipend;
var
   a:tbmp;
   m:tmemstr8;
{$ifdef jpeg}
   j:tjpegimage;
{$endif}
{$ifdef nojpeg}
   j:tobject;
{$endif}
   int1,int2:longint;
   xformat:string;
   bol1,xbase64:boolean;
   //## minit ##
   procedure minit;
   begin
   if zznil(m,2136) then m:=tmemstr8.create(xdata);
   m.position:=0;
   end;
   //## jinit ##
   procedure jinit;
   begin
{$ifdef jpeg}
   if zznil(j,2137) then j:=misjpg;
{$endif}
   end;
   //## aset ##
   function aset:boolean;
   begin
   try
   if zznil(a,2138) then exit;
   if (a.bits<24) then a.bits:=24;//system needs 24 or more to work - 08jun2021
   result:=missize(s,misw(a),mish(a)) and miscopyareaxx1(0,0,misw(a),mish(a),rect(0,0,misw(a)-1,mish(a)-1),s,a) and misaicopy(a,s);
   except;end;
   end;
begin
try
//defaults
result:=false;
e:='Task failed';
a:=nil;
m:=nil;
block(xdata);
bmplock(s);
{$ifdef jpeg}
j:=nil;
{$endif}

//check
if zznil(s,2138) or zznil(xdata,2139) then goto skipend;
//init
if not misformat(xdata,xformat,xbase64) then
   begin
   e:='Unknown format';
   goto skipend;
   end;

//Note: Can't work directly with a "tbitmap" as it must be locked so instead use "tbascimage" or "tbmp" - 21aug2020
a:=misbmp32(1,1);
misai(a).use32:=misai(s).use32;//22may2022
misai(a)^.format:=xformat;//may be adjusted further down in the procs 23may2022
misai(a)^.subformat:='';

//decode
if xbase64 then//take a copy and skip over header
   begin
   //Note: Take a copy of xdata, skipping over the "b64:" header - 21aug2020
   if not low__fromb641(xdata,xdata,5,e) then goto skipend;
   end;
//get
if (xformat='BMP') then
   begin
   //get
   bol1:=false;
   minit;
   a.lock;
   try;a.core.loadfromstream(m);bol1:=true;except;end;
   a.unlock;//now calls "a.xinfo" to update width/height etc
   //set
   if not bol1 then goto skipend;
   if not aset then goto skipend;
   end
else if (xformat='GIF') then
   begin
   a.lock;
   //was: bol1:=low__fromgif(a,xdata,e);
   bol1:=low__fromgif1(a,xdata,misai(a).use32,e);//now supports 32bit image format - 22may2022
   a.unlock;
   //set
   if not bol1 then goto skipend;
   if not aset then goto skipend;
   end
else if (xformat='ICO') or (xformat='CUR') then
   begin
   a.lock;
   bol1:=low__fromico32(a,xdata,0,misai(a).use32,e);
   a.unlock;//now calls "a.xinfo" to update width/height etc
   if not bol1 then goto skipend;//27jan2021
   if not aset then goto skipend;
   end
else if (xformat='ANI') then
   begin
   a.lock;
   bol1:=low__fromani32(a,xdata,0,misai(a).use32,e);
   a.unlock;//now calls "a.xinfo" to update width/height etc
   if not bol1 then goto skipend;//27jan2021
   if not aset then goto skipend;
   end
else if (xformat='PNG') then
   begin
   a.lock;
   bol1:=misfrompng82432(a,clnone,xdata,e);
   a.unlock;//now calls "a.xinfo" to update width/height etc
   if not bol1 then goto skipend;//27jan2021
   if not aset then goto skipend;
   end
else if (xformat='JPG') then
   begin
{$ifdef jpeg}
   minit;
   jinit;
   j.loadfromstream(m);
   a.assign(j);
   //set
   if not aset then goto skipend;
{$endif}
{$ifdef nojpeg}
   e:='Image format not supported: '+xformat;
   goto skipend;
{$endif}
   end
else if (xformat='TEA') then
   begin
   if not low__teatobmp(xdata,a,int1,int2) then goto skipend;
   if not aset then goto skipend;
   end
else
   begin
   e:='Unknown format';
   goto skipend;
   end;

//fallback - incase ANY of the above procs accidently sets FORMAT to nil we refill it in with the best value we have at hand - 23may2022
if (misai(s)^.format='') then misai(s)^.format:=xformat;

//successful
result:=true;
skipend:
except;end;
try
{$ifdef jpeg}
freeobj(@j);
{$endif}
freeobj(@a);//27jan2021
freeobj(@m);//do last
bunlockautofree(xdata);
bmpunlock(s);
except;end;
end;
//## misblur82432 ##
function misblur82432(s:tobject):boolean;//03sep2021
begin
try;result:=misblur82432b(s,false,255,clnone);except;end;
end;
//## misblur82432b ##
function misblur82432b(s:tobject;xwraprange:boolean;xpower255,xtranscol:longint):boolean;//11sep2021, 03sep2021
begin
try;result:=misblur82432c(s,maxarea,xwraprange,xpower255,xtranscol);except;end;
end;
//## misblur82432c ##
function misblur82432c(s:tobject;scliparea:trect;xwraprange:boolean;xpower255,xtranscol:longint):boolean;//17may2022 - cell-based clipping, 27apr2022, 11sep2021, 03sep2021
label
   skipend;
var
   tr,tg,tb,trsafe,tgsafe,tbsafe:longint;//transparency support - 11sep2021
   r,g,b,a,c,sx,sy,sbits,sw,sh:longint;
   srows8:pcolorrows8;
   srows24:pcolorrows24;
   srows32:pcolorrows32;
   c8,sc8:tcolor8;
   c24,sc24:tcolor24;
   c32,sc32:tcolor32;
   //## xadd32 ##
   procedure xadd32(sx,sy:longint);
   begin
   //wrap range
   if xwraprange then
      begin
      if (sx<scliparea.left) then inc(sx,(scliparea.right-scliparea.left+1)) else if (sx>scliparea.right) then dec(sx,(scliparea.right-scliparea.left+1));
      if (sy<scliparea.top) then inc(sy,(scliparea.bottom-scliparea.top+1)) else if (sy>scliparea.bottom) then dec(sy,(scliparea.bottom-scliparea.top+1));
      end;
   //check
   if (sx<scliparea.left) or (sx>scliparea.right) or (sy<scliparea.top) or (sy>scliparea.bottom) then exit;//17may2022
   //get
   sc32:=srows32[sy][sx];
   if (sc32.a<=0) then exit;
   if (tr=sc32.r) and (tg=sc32.g) and (tb=sc32.b) then exit;//transparency check
   inc(r,sc32.r);
   inc(g,sc32.g);
   inc(b,sc32.b);
   inc(a,sc32.a);
   inc(c);
   end;
   //## xadd24 ##
   procedure xadd24(sx,sy:longint);
   begin
   //wrap range
   if xwraprange then
      begin
      if (sx<scliparea.left) then inc(sx,(scliparea.right-scliparea.left+1)) else if (sx>scliparea.right) then dec(sx,(scliparea.right-scliparea.left+1));
      if (sy<scliparea.top) then inc(sy,(scliparea.bottom-scliparea.top+1)) else if (sy>scliparea.bottom) then dec(sy,(scliparea.bottom-scliparea.top+1));
      end;
   //check
   if (sx<scliparea.left) or (sx>scliparea.right) or (sy<scliparea.top) or (sy>scliparea.bottom) then exit;//17may2022
   //get
   sc24:=srows24[sy][sx];
   if (tr=sc24.r) and (tg=sc24.g) and (tb=sc24.b) then exit;//transparency check
   inc(r,sc24.r);
   inc(g,sc24.g);
   inc(b,sc24.b);
   inc(c);
   end;
   //## xadd8 ##
   procedure xadd8(sx,sy:longint);
   begin
   //wrap range
   if xwraprange then
      begin
      if (sx<scliparea.left) then inc(sx,(scliparea.right-scliparea.left+1)) else if (sx>scliparea.right) then dec(sx,(scliparea.right-scliparea.left+1));
      if (sy<scliparea.top) then inc(sy,(scliparea.bottom-scliparea.top+1)) else if (sy>scliparea.bottom) then dec(sy,(scliparea.bottom-scliparea.top+1));
      end;
   //check
   if (sx<scliparea.left) or (sx>scliparea.right) or (sy<scliparea.top) or (sy>scliparea.bottom) then exit;//17may2022
   //get
   sc8:=srows8[sy][sx];
   if (tr=sc8) then exit;//transparency check
   inc(r,sc8);
   inc(c);
   end;
   //## sblur32 ##
   procedure sblur32;
   begin
   //init
   r:=0;
   g:=0;
   b:=0;
   a:=0;
   c:=0;
   //get
   xadd32(sx,sy);
   if (c=0) then exit;

   xadd32(sx-1,sy);
   xadd32(sx+1,sy);
   xadd32(sx,sy-1);
   xadd32(sx,sy+1);

   xadd32(sx-2,sy);
   xadd32(sx+2,sy);
   xadd32(sx,sy-2);
   xadd32(sx,sy+2);

   //set
   sc32.r:=trunc(r div c);
   sc32.g:=trunc(g div c);
   sc32.b:=trunc(b div c);
   sc32.a:=trunc(a div c);
   end;
   //## sblur24 ##
   procedure sblur24;
   begin
   //init
   r:=0;
   g:=0;
   b:=0;
   a:=0;
   c:=0;
   //get
   xadd24(sx,sy);
   if (c=0) then exit;

   xadd24(sx-1,sy);
   xadd24(sx+1,sy);
   xadd24(sx,sy-1);
   xadd24(sx,sy+1);

   xadd24(sx-2,sy);
   xadd24(sx+2,sy);
   xadd24(sx,sy-2);
   xadd24(sx,sy+2);

   //set
   sc24.r:=trunc(r div c);
   sc24.g:=trunc(g div c);
   sc24.b:=trunc(b div c);
   end;
   //## sblur8 ##
   procedure sblur8;
   begin
   //init
   r:=0;
   g:=0;
   b:=0;
   a:=0;
   c:=0;
   //get
   xadd8(sx,sy);
   if (c=0) then exit;

   xadd8(sx-1,sy);
   xadd8(sx+1,sy);
   xadd8(sx,sy-1);
   xadd8(sx,sy+1);

   xadd8(sx-2,sy);
   xadd8(sx+2,sy);
   xadd8(sx,sy-2);
   xadd8(sx,sy+2);

   //set
   sc8:=trunc(r div c);
   end;
begin
try
//defaults
result:=false;
//check
if not misok82432(s,sbits,sw,sh) then exit;
//init
if not misrows82432(s,srows8,srows24,srows32) then goto skipend;
//.scliparea - 27apr2022
scliparea.left:=frcrange(scliparea.left,0,sw-1);
scliparea.right:=frcrange(scliparea.right,scliparea.left,sw-1);
scliparea.top:=frcrange(scliparea.top,0,sh-1);
scliparea.bottom:=frcrange(scliparea.bottom,scliparea.top,sh-1);
//.transparency - leave transparent pixels FULLY intact - 11sep2021
tr:=-1;
tg:=-1;
tb:=-1;
trsafe:=0;
tgsafe:=0;
tbsafe:=0;
if (xtranscol=clTopLeft) then xtranscol:=mispixel24VAL(s,0,0);
if (xtranscol<>clnone) then
   begin
   sc24:=low__intrgb(xtranscol);
   tr:=sc24.r;
   tg:=sc24.g;
   tb:=sc24.b;
   //.safe alternative
   if (tr>=1) then trsafe:=tr-1 else trsafe:=1;
   tgsafe:=tg;
   tbsafe:=tb;
   end;

//range
xpower255:=frcrange(xpower255,0,255);//11sep2021
//get
//.32
if (sbits=32) then
   begin
   for sy:=scliparea.top to scliparea.bottom do
   begin
   for sx:=scliparea.left to scliparea.right do
   begin
   sblur32;
   if (c>=1) then
      begin
      if (xpower255<255) then
         begin
         c32:=srows32[sy][sx];
         sc32.r:=ref65025_div_255[((c32.r*(255-xpower255))+(sc32.r*xpower255))];//18ms
         sc32.g:=ref65025_div_255[((c32.g*(255-xpower255))+(sc32.g*xpower255))];//18ms
         sc32.b:=ref65025_div_255[((c32.b*(255-xpower255))+(sc32.b*xpower255))];//18ms
         sc32.a:=ref65025_div_255[((c32.a*(255-xpower255))+(sc32.a*xpower255))];//18ms
         end;
      //.don't use transparent color - 11sep2021
      if (tr>=0) then
         begin
         if (tr=sc32.r) and (tg=sc32.g) and (tb=sc32.b) then
            begin
            sc32.r:=trsafe;
            sc32.g:=tgsafe;
            sc32.b:=tbsafe;
            end;
         end;
      srows32[sy][sx]:=sc32;
      end;
   end;//dx
   end;//dy
   end
//.24
else if (sbits=24) then
   begin
   for sy:=scliparea.top to scliparea.bottom do
   begin
   for sx:=scliparea.left to scliparea.right do
   begin
   sblur24;
   if (c>=1) then
      begin
      if (xpower255<255) then
         begin
         c24:=srows24[sy][sx];
         sc24.r:=ref65025_div_255[((c24.r*(255-xpower255))+(sc24.r*xpower255))];//18ms
         sc24.g:=ref65025_div_255[((c24.g*(255-xpower255))+(sc24.g*xpower255))];//18ms
         sc24.b:=ref65025_div_255[((c24.b*(255-xpower255))+(sc24.b*xpower255))];//18ms
         end;
      //.don't use transparent color - 11sep2021
      if (tr>=0) then
         begin
         if (tr=sc24.r) and (tg=sc24.g) and (tb=sc24.b) then
            begin
            sc24.r:=trsafe;
            sc24.g:=tgsafe;
            sc24.b:=tbsafe;
            end;
         end;
      srows24[sy][sx]:=sc24;
      end;
   end;//dx
   end;//dy
   end
//.8
else if (sbits=8) then
   begin
   for sy:=scliparea.top to scliparea.bottom do
   begin
   for sx:=scliparea.left to scliparea.right do
   begin
   sblur8;
   if (c>=1) then
      begin
      if (xpower255<255) then
         begin
         c8:=srows8[sy][sx];
         sc8:=ref65025_div_255[((c8*(255-xpower255))+(sc8*xpower255))];//18ms
         end;
      //.don't use transparent color - 11sep2021
      if (tr>=0) then
         begin
         if (tr=sc8) then sc8:=trsafe;
         end;
      srows8[sy][sx]:=sc8;
      end;
   end;//dx
   end;//dy
   end;

//successful
result:=true;
skipend:
except;end;
end;
//## misIconArt82432 ##
function misIconArt82432(s,s2:tobject;xzoom,xbackcolor,xtranscolor:longint;xpadding:boolean):boolean;//27apr2022
label
   skipend;
const
   szoom=4;
var
   d:tbasicimage;
   sr8,dr8:pcolorrows8;
   sr24,dr24:pcolorrows24;
   sr32,dr32:pcolorrows32;
   tr,tg,tb,dx,dy,scol,sx,sy,sw,sh,sbits,dw,dh:longint;
   sc8:tcolor8;
   tcSAFE24,sc24:tcolor24;
   sc32:tcolor32;
   e:string;
   xuse32,tok:boolean;
   //## dinit ##
   procedure dinit;
   begin
   dx:=sx*szoom;
   dy:=sy*szoom;
   end;
   //## dcol8 ##
   function dcol8(xshift:longint):tcolor8;
   var
      v:longint;
   begin
   //check
   if (sc8=tr) then
      begin
      result:=sc8;
      exit;
      end;
   //r
   v:=(sc8*(255+xshift) div 255);
   if (v<0) then v:=0 else if (v>255) then v:=255;
   result:=v;
   //tc safe
   if (tr=result) then result:=tcSAFE24.r;
   end;
   //## dcol24 ##
   function dcol24(xshift:longint):tcolor24;
   var
      v:longint;
   begin
   //check
   if (sc24.r=tr) and (sc24.g=tg) and (sc24.b=tb) then
      begin
      result:=sc24;
      exit;
      end;
   //r
   v:=(sc24.r*(255+xshift) div 255);
   if (v<0) then v:=0 else if (v>255) then v:=255;
   result.r:=v;
   //g
   v:=sc24.g*(255+xshift) div 255;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   result.g:=v;
   //b
   v:=sc24.b*(255+xshift) div 255;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   result.b:=v;
   //tc safe
   if (tr=result.r) and (tg=result.g) and (tb=result.b) then result:=tcSAFE24;
   end;
   //## dcol32 ##
   function dcol32(xshift:longint):tcolor32;
   var
      v:longint;
   begin
   //check
   if (sc32.a=0) then
      begin
      result:=sc32;
      exit;
      end
   else if (sc32.r=tr) and (sc32.g=tg) and (sc32.b=tb) then
      begin
      result:=sc32;
      result.a:=0;//fully transparent
      exit;
      end;
   //r
   v:=(sc32.r*(255+xshift) div 255);
   if (v<0) then v:=0 else if (v>255) then v:=255;
   result.r:=v;
   //g
   v:=sc32.g*(255+xshift) div 255;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   result.g:=v;
   //b
   v:=sc32.b*(255+xshift) div 255;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   result.b:=v;
   //a
   result.a:=sc32.a;
   //tc safe
   if (tr=result.r) and (tg=result.g) and (tb=result.b) then
      begin
      result.r:=tcSAFE24.r;
      result.g:=tcSAFE24.g;
      result.b:=tcSAFE24.b;
      end;
   end;
   //## d8 ##
   procedure d8(xshift,yshift,cshift:longint);
   begin
   dr8[dy+yshift][dx+xshift]:=dcol8(cshift);
   end;
   //## d24 ##
   procedure d24(xshift,yshift,cshift:longint);
   begin
   dr24[dy+yshift][dx+xshift]:=dcol24(cshift);
   end;
   //## d32 ##
   procedure d32(xshift,yshift,cshift:longint);
   begin
   dr32[dy+yshift][dx+xshift]:=dcol32(cshift);
   end;
   //## dadd8 ##
   procedure dadd8;
   begin
   //init
   dinit;

   //center 2x2
   d8(1,1,50);
   d8(2,1,40);
   d8(1,2,30);
   d8(2,2,60);

   //top 2x1
   d8(1,0,22);
   d8(2,0,17);

   //bottom 2x1
   d8(1,3,-17);
   d8(2,3,-22);

   //left 1x2
   d8(0,1,-19);
   d8(0,2,-10);

   //right 1x2
   d8(3,1,17);
   d8(3,2,22);

   //top-left
   d8(0,0,11);
   //top-right
   d8(3,0,11);
   //bottom-left
   d8(0,3,-11);
   //bottom-right
   d8(3,3,-11);
   end;
   //## dadd24 ##
   procedure dadd24;
   begin
   //init
   dinit;

   //center 2x2
   d24(1,1,50);
   d24(2,1,40);
   d24(1,2,30);
   d24(2,2,60);

   //top 2x1
   d24(1,0,22);
   d24(2,0,17);

   //bottom 2x1
   d24(1,3,-17);
   d24(2,3,-22);

   //left 1x2
   d24(0,1,-19);
   d24(0,2,-10);

   //right 1x2
   d24(3,1,17);
   d24(3,2,22);

   //top-left
   d24(0,0,11);
   //top-right
   d24(3,0,11);
   //bottom-left
   d24(0,3,-11);
   //bottom-right
   d24(3,3,-11);
   end;
   //## dadd32 ##
   procedure dadd32;
   begin
   //init
   dinit;

   //center 2x2
   d32(1,1,50);
   d32(2,1,40);
   d32(1,2,30);
   d32(2,2,60);

   //top 2x1
   d32(1,0,22);
   d32(2,0,17);

   //bottom 2x1
   d32(1,3,-17);
   d32(2,3,-22);

   //left 1x2
   d32(0,1,-19);
   d32(0,2,-10);

   //right 1x2
   d32(3,1,17);
   d32(3,2,22);

   //top-left
   d32(0,0,11);
   //top-right
   d32(3,0,11);
   //bottom-left
   d32(0,3,-11);
   //bottom-right
   d32(3,3,-11);
   end;
begin
try
//defaults
d:=nil;
//check
if not misok82432(s,sbits,sw,sh) then goto skipend;
if not misrows82432(s,sr8,sr24,sr32) then goto skipend;
//range
xzoom:=frcrange(xzoom,1,10);
//init
dw:=sw*szoom;
dh:=sh*szoom;
d:=misimg(sbits,dw,dh);
if not misrows82432(d,dr8,dr24,dr32) then goto skipend;
//.use32 - 11jun2022
xuse32:=(sbits=32) and misai(s).use32 and (misb(s2)=32);
if xuse32 then
   begin
   xtranscolor:=clnone;
   xbackcolor:=clnone;
   end;
//.transparent color
tr:=-1;
tg:=-1;
tb:=-1;
xtranscolor:=mistranscol(s,xtranscolor,xtranscolor<>clnone);
if (xtranscolor<>clnone) then
   begin
   sc24:=low__intrgb(xtranscolor);
   tr:=sc24.r;
   tg:=sc24.g;
   tb:=sc24.b;
   tcSAFE24:=sc24;
   //fixed out of bounds / integer overflow error - 17sep202
   if (tcSAFE24.r>=3) then//avoid using BLACK
      begin
      dec(tcSAFE24.r);
      if (tcSAFE24.g>=1) then dec(tcSAFE24.g);
      if (tcSAFE24.b>=1) then dec(tcSAFE24.b);
      end
   else
      begin
      inc(tcSAFE24.r);
      if (tcSAFE24.g<255) then inc(tcSAFE24.g);
      if (tcSAFE24.b<255) then inc(tcSAFE24.b);
      end;
   end;
//.cls
if xuse32                    then mask__setval(d,0)//mask=0=transparent - 11jun2022
else if (tr>=0)              then miscls(d,xtranscolor)
else if (xbackcolor<>clnone) then miscls(d,xbackcolor)
else                              miscls(d,mispixel24VAL(s,0,0));
//get
for sy:=0 to (sh-1) do
begin
if (sbits=8) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sc8:=sr8[sy][sx];
   dadd8;
   end;//sx
   end
else if (sbits=24) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sc24:=sr24[sy][sx];
   dadd24;
   end;//sx
   end
else if (sbits=32) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sc32:=sr32[sy][sx];
   dadd32;
   end;//sx
   end;
end;//sy

//set
if not missize(s2,(dw*xzoom)+low__insint(2,xpadding),(dh*xzoom)+low__insint(2,xpadding)) then goto skipend;
if xpadding then
   begin
   if xuse32                    then mask__setval(s2,0)//mask=0=transparent - 11jun2022
   else if (tr>=0)              then miscls(s2,xtranscolor)
   else if (xbackcolor<>clnone) then miscls(s2,xbackcolor)
   else                              miscls(s2,mispixel24VAL(s,0,0));
   end;

case xpadding of
true:if not miscopyarea32(1,1,misw(s2)-2,mish(s2)-2,misarea(d),s2,d) then goto skipend;
false:if not miscopyarea32(0,0,misw(s2),mish(s2),misarea(d),s2,d) then goto skipend;
end;//case

//successful
result:=true;
skipend:
except;end;
try;freeobj(@d);except;end;
end;
//## miscrop82432 ##
function miscrop82432(s:tobject):boolean;
var
   l,t,r,b:longint;
begin
try;result:=miscrop82432b(s,mispixel32(s,0,0),l,t,r,b,false,false,true);except;end;
end;
//## miscrop82432b ##
function miscrop82432b(s:tobject;t32:tcolor32;var l,t,r,b:longint;xcalonly,xusealpha,xretainT32:boolean):boolean;//21jun20221
label
   skipend;
var
   a:tbasicimage;
   c32:tcolor32;
   c24:tcolor24;
   c8:tcolor8;
   v,sx,sy,sy2,sbits,sw,sh:longint;
   sr32,sr32b:pcolorrow32;
   sr24,sr24b:pcolorrow24;
   sr8,sr8b:pcolorrow8;
   t8:byte;
   tok,bok:boolean;
begin
try
//defaults
result:=false;
a:=nil;
l:=0;
t:=0;
r:=0;
b:=0;
//check
if not misok82432(s,sbits,sw,sh) then goto skipend;
if (sw<=1) and (sh<=1) then
   begin
   result:=true;
   goto skipend;
   end;
//init
l:=sw-1;
r:=0;
t:=0;
b:=sh-1;
t8:=low__greyscale2b(low__rgb32to24(t32));
//.left/right
tok:=true;
bok:=true;
for sy:=0 to (sh-1) do
begin
sy2:=(sh-1)-sy;
if not misscan82432(s,sy,sr8,sr24,sr32) then goto skipend;
if not misscan82432(s,sy2,sr8b,sr24b,sr32b) then goto skipend;
//.32
if (sbits=32) then
   begin
   for sx:=0 to (sw-1) do
   begin
   c32:=sr32[sx];
   //l
   if (sx<l) and ((c32.r<>t32.r) or (c32.g<>t32.g) or (c32.b<>t32.b) or ((not xusealpha) or (c32.a>=1))) then l:=sx;
   //r
   if (sx>r) and ((c32.r<>t32.r) or (c32.g<>t32.g) or (c32.b<>t32.b) or ((not xusealpha) or (c32.a>=1))) then r:=sx;
   //t
   if tok and (sy>t) and ((c32.r<>t32.r) or (c32.g<>t32.g) or (c32.b<>t32.b) or ((not xusealpha) or (c32.a>=1))) then
      begin
      t:=sy;
      tok:=false;
      end;
   //b
   c32:=sr32b[sx];
   if bok and (sy2<b) and ((c32.r<>t32.r) or (c32.g<>t32.g) or (c32.b<>t32.b) or ((not xusealpha) or (c32.a>=1))) then
      begin
      b:=sy2;
      bok:=false;
      end;
   end;//sx
   end
//.24
else if (sbits=24) then
   begin
   for sx:=0 to (sw-1) do
   begin
   c24:=sr24[sx];
   //l
   if (sx<l) and ((c24.r<>t32.r) or (c24.g<>t32.g) or (c24.b<>t32.b)) then l:=sx;
   //r
   if (sx>r) and ((c24.r<>t32.r) or (c24.g<>t32.g) or (c24.b<>t32.b)) then r:=sx;
   //t
   if tok and (sy>t) and ((c24.r<>t32.r) or (c24.g<>t32.g) or (c24.b<>t32.b)) then
      begin
      t:=sy;
      tok:=false;
      end;
   //b
   c24:=sr24b[sx];
   if bok and (sy2<b) and ((c24.r<>t32.r) or (c24.g<>t32.g) or (c24.b<>t32.b)) then
      begin
      b:=sy2;
      bok:=false;
      end;
   end;//sx
   end
//.8
else if (sbits=8) then
   begin
   for sx:=0 to (sw-1) do
   begin
   c8:=sr8[sx];
   //l
   if (sx<l) and (c8<>t8) then l:=sx;
   //r
   if (sx>r) and (c8<>t8) then r:=sx;
   //t
   if tok and (sy>t) and (8<>t8) then
      begin
      t:=sy;
      tok:=false;
      end;
   //b
   c8:=sr8b[sx];
   if bok and (sy2<b) and (8<>t8) then
      begin
      b:=sy2;
      bok:=false;
      end;
   end;//sx
   end;
//check -> stop early - 21jun2022
if (not tok) and (not bok) and (l>=(sw-1)) and (r<=0) or (r<=l) or (b<=t) then break;
end;//sy
//range
l:=frcrange(l,0,sw-1);
r:=frcrange(r,l,sw-1);
t:=frcrange(t,0,sh-1);
b:=frcrange(b,t,sh-1);
//check
if xcalonly or ((l=0) and (t=0) and (r=(sw-1)) and (b=(sh-1))) then
   begin
   result:=true;
   goto skipend;
   end;
//redraw
a:=misimg(sbits,r-l+1,b-t+1);
if not miscopyarea32(0,0,misw(a),mish(a),rect(l,t,r,b),a,s) then goto skipend;
//set
if not missize(s,misw(a),mish(a)) then goto skipend;
if not miscls(s,low__rgb(t32.r,t32.g,t32.b)) then goto skipend;
if not miscopyarea32(0,0,misw(a),mish(a),misarea(a),s,a) then goto skipend;
//top-left pixel
if xretainT32 then
   begin
   c32.r:=t32.r;
   c32.g:=t32.g;
   c32.b:=t32.b;
   c32.a:=t32.a;
   missetpixel32(s,0,0,c32);
   end;
//successful
result:=true;
skipend:
except;end;
try;freeobj(@a);except;end;
end;
//## mismakesplashart2432 ##
function mismakesplashart2432(s:tobject;xtitle,xtext,xborder,xback,xback2,xminW,xminH,xmaxW,xmaxH:longint):boolean;//27jun2022, 27apr2022
label
   skipend;
const
   xpad=20;
var
   a:tbasicimage;
   b,xfc:tstr8;
   c:tdynamicstring;
   cl,ct,cr,cb,xzoom,titley,int1,infoMAXW,titleH,fspad,iconw,iconh,ox,oy,aw,ah,p,xcol2,fl,flW,flH,fs,fsH,tc,dx,dy,dw,dh,sbits,sx,sy,sw,sh:longint;
   sr8:pcolorrows8;
   ar24,sr24:pcolorrows24;
   sr32:pcolorrows32;
   sc24:tcolor24;
   xprogramname,str1,e:string;
   bol1:boolean;
begin
try
//defaults
result:=false;
a:=nil;
b:=nil;
c:=nil;
xfc:=nil;
infoMAXW:=0;
xprogramname:=programname;
xzoom:=vizoom;

//check
if not misok82432(s,sbits,sw,sh) then goto skipend;

//filter - 0 is reserved for transparent background - 27apr2022
if (xtitle=0) then xtitle:=1;//0 is reserved
if (xtext=0) then xtext:=1;//0 is reserved

//range
if (xmaxW<0) and (sysprogram<>nil) and (sysprogram.rootwin<>nil) then xmaxW:=sysprogram.rootwin.clientwidth else if (xmaxW<=0) then xmaxW:=maxint;
if (xmaxH<0) and (sysprogram<>nil) and (sysprogram.rootwin<>nil) then xmaxH:=sysprogram.rootwin.clientheight else if (xmaxH<=0) then xmaxH:=maxint;
xminW:=frcrange(xminW,0,xmaxW);
xminH:=frcrange(xminH,0,xmaxH);

//init
a:=misimg24(1,1);
b:=bnew;
c:=tdynamicstring.create;
xfc:=bnew;

//.font large
titleH:=round(1.4*xzoom*frcmax(130,largest(round(xminH*0.25),round(xmaxH*0.25))));//175;
b.text:=xprogramname;
fl:=low__fontdata(low__font1('Arial',round(1.4*48*xzoom),true));
flW:=low__fromLGF_textwidth(sysfont_data[fl],b);
flH:=low__fromLGF_height(sysfont_data[fl]);

//.font small
b.text:=xprogramname;
fs:=low__fontdata(low__font1('Arial',low__aorb(8,11,xmaxW>=600)*xzoom,false));
fspad:=6*xzoom;
fsH:=low__fromLGF_height(sysfont_data[fs])+fspad;

//init information
for p:=0 to 99 do if splash__findvalue(p,false,false,str1) then c.value[p]:=str1 else break;
for p:=0 to (c.count-1) do
begin
b.text:=c.value[p];
int1:=low__fromLGF_textwidth(sysfont_data[fs],b);
if (int1>infoMAXW) then infoMAXW:=int1;
end;//p

//init icon
if not misfromdata2(a,program_icon32h,e) then goto skipend;
miscrop82432b(a,mispixel32(a,0,0),cl,ct,cr,cb,true,false,false);//crop blank areas away - 21jun2022
cb:=(mish(a)-1)-cb;
cr:=(misw(a)-1)-cr;
tc:=mispixel24VAL(a,0,0);
if not misIconArt82432(a,a,2,clnone,tc,true) then goto skipend;
int1:=smallest( frcmax(misw(a),round(xmaxW*0.35)),frcmax(mish(a),xmaxH-(2*xpad)));
iconw:=xzoom*frcmax( misw(a) , int1);
iconh:=xzoom*frcmax( mish(a) , int1);

//size
sw:=frcmax( frcmin(frcmin(largest(iconW+infoMAXW,round(flW*0.75))+(3*xpad),500)+(3*xpad),xminW) ,xmaxW);
sh:=frcmax( frcmin(frcmin(iconH, (fsH*c.count) + titleH) + (xpad*2),xminH) ,xmaxH);
if not missize(s,sw,sh) then goto skipend;
if not misrows82432(s,sr8,sr24,sr32) then goto skipend;
//cls
if not misclsarea2(s,misarea(s),xback,xback2) then goto skipend;
//draw icon
if not miscopyareaxx(maxarea,xpad,xpad,iconW,iconH,misarea(a),s,a,255,2,tc,0) then goto skipend;
xcol2:=xpad+iconW+xpad;
//title
b.text:=xprogramname;
missize(a,2+flW,2+flH);
aw:=misw(a);
ah:=mish(a);
miscls(a,0);
low__fromLGF_drawtext2432(sysfont_data[fl],b,1,1,aw,ah,xtitle,misarea(a),misarea(a),a.prows24,nil,nil,0,nil,0,false,false,false,false,false,false,corNone);
dx:=xcol2-(cr*5);
dy:=xpad;
dw:=sw-xcol2-round(1.5*xpad);
dw:=frcmax(dw,(round(aw*1.5)));//Special Width Reduction: Make short names look good but no exceeding 150% their own width - 27jun2022
dh:=titleH;
dh:=frcmax(dh,(round(ah*1.5)));//Special Height Reduction: Reduce overal height of title, does not exceed 150% of original height - 27jun2022

//.find x/y offset
ox:=aw-1;
oy:=ah-1;
ar24:=a.prows24;
for sy:=0 to (ah-1) do
begin
bol1:=false;
for sx:=0 to (aw-1) do
begin
if (sx>ox) then break
else if (ar24[sy][sx].r<>0) or (ar24[sy][sx].g<>0) or (ar24[sy][sx].b<>0) then
   begin
   bol1:=true;
   ox:=sx;
   break;
   end;
end;//sx
if bol1 and (sy<oy) then oy:=sy;
if (ox<=0) and (oy<=0) then break;
end;//sy
//.zoom int1 value
ox:=round(ox*(dw/aw));
oy:=round(oy*(dh/ah));
if not miscopyareaxx(maxarea,dx,dy-oy,dw,dh,misarea(a),s,a,200,2,0,0) then goto skipend;//27apr2022
titley:=dy-oy+dh;
//information
dx:=xcol2+ox-(cr*5);
dy:=sh-xpad+fspad-(cb*5*xzoom);
for p:=(c.count-1) downto 0 do
begin
str1:=c.value[p];
dec(dy,fsH);
if (dy<titley) then break;
b.text:=str1;
case sbits of
24:low__fromLGF_drawtext2432(sysfont_data[fs],b,dx,dy,misw(s),mish(s),xtext,misarea(s),misarea(s),sr24,nil,nil,0,xfc,vifeather,false,false,false,false,false,false,corNone);//27apr2022
32:low__fromLGF_drawtext2432(sysfont_data[fs],b,dx,dy,misw(s),mish(s),xtext,misarea(s),misarea(s),nil,sr32,nil,0,xfc,vifeather,false,false,false,false,false,false,corNone);//27apr2022
end;//case
end;//p
//border
if (xborder<>clnone) then
   begin
   misclsarea(s,rect(0,0,1*xzoom,sh-1),xborder);//left
   misclsarea(s,rect(0,0,sw-1,1*xzoom),xborder);//top
   misclsarea(s,rect(sw-1-(1*xzoom),0,sw-1,sh-1),xborder);//right
   misclsarea(s,rect(0,sh-1-(1*xzoom),sw-1,sh-1),xborder);//bottom
   end;
//successful
result:=true;
skipend:
except;end;
try
freeobj(@a);
bfree(b);
freeobj(@c);
bfree(xfc);
except;end;
end;
//## low__mask8_drawto ##
function low__mask8_drawto(s:tmask8;x:tbmp):boolean;
label
   skipend;
var
   sr24:pcolorrow24;
   sr32:pcolorrow32;
   dc24:tcolor24;
   dc32:tcolor32;
   xbits,i,dx,dy,dw,dh:longint;
   v:byte;
begin
try
//defaults
result:=false;
//check
if zznil(s,2140) or zznil(x,2141) then exit;
//init
if not missize(x,s.width,s.height) then goto skipend;
if not x.lock then goto skipend;
dw:=x.width;//dw and dh were missing - 27apr2021
dh:=x.height;
//get
i:=0;
for dy:=0 to (dh-1) do
begin
case xbits of
24:sr24:=x.prows24[dy];
32:sr32:=x.prows32[dy];
end;//case

for dx:=0 to (dw-1) do
begin
v:=s.core.bytes[i+dx];

case v of
0..33:begin
   dc24.r:=v*7;
   dc24.g:=0;
   dc24.b:=0;
   end;
34..66:begin
   dc24.r:=0;
   dc24.g:=(v-34)*7;
   dc24.b:=0;
   end;
67..100:begin
   dc24.r:=0;
   dc24.g:=0;
   dc24.b:=(v-67)*7;
   end;
else
   begin
   dc24.r:=255;
   dc24.g:=255;
   dc24.b:=255;
   end;
end;//case

//set
case xbits of
24:sr24[dx]:=dc24;
32:begin
   dc32.r:=dc24.r;
   dc32.g:=dc24.g;
   dc32.b:=dc24.b;
   dc32.a:=255;
   sr32[dx]:=dc32;
   end;
end;//case
end;//dx
inc(i,s.rowsize);
end;//dy

//successful
result:=true;
skipend:
except;end;
try;x.unlock;except;end;
end;
//## mask__empty ##
function mask__empty(s:tobject):boolean;
var
   xmin,xmax:longint;
begin
try
result:=true;
if mask__range(s,xmin,xmax) then result:=(xmax<=0);
except;end;
end;
//## mask__transparent ##
function mask__transparent(s:tobject):boolean;
var
   v0,v255,vother:boolean;
   xmin,xmax:longint;
begin
try;result:=mask__range2(s,v0,v255,vother,xmin,xmax) and (not v255);except;end;
end;
//## mask__range ##
function mask__range(s:tobject;var xmin,xmax:longint):boolean;//15feb2022
var
   v0,v255,vother:boolean;
begin
try;result:=mask__range2(s,v0,v255,vother,xmin,xmax);except;end;
end;
//## mask__range2 ##
function mask__range2(s:tobject;var v0,v255,vother:boolean;var xmin,xmax:longint):boolean;//15feb2022
label
   skipend;
var
   sx,sy,sw,sh,sbits:longint;
   sr32:pcolorrow32;
   sr8:pcolorrow8;
   v:byte;
begin
try
//defaults
result:=false;
v0:=false;
v255:=false;
vother:=false;
xmin:=255;
xmax:=0;
//check
if not misok82432(s,sbits,sw,sh) then exit;
//get
//.24
if (sbits=24) then
   begin
   xmin:=255;
   xmax:=255;
   v255:=true;
   result:=true;
   goto skipend;
   end;
//get
//.sy
for sy:=0 to (sh-1) do
begin
if not misscan832(s,sy,sr8,sr32) then goto skipend;
//.32
if (sbits=32) then
   begin
   for sx:=0 to (sw-1) do
   begin
   v:=sr32[sx].a;
   if (v>xmax) then xmax:=v;
   if (v<xmin) then xmin:=v;
   case v of
   0   :v0:=true;
   255 :v255:=true;
   else vother:=true;
   end;//case
   end;//sx
   end
//.8
else if (sbits=8) then
   begin
   for sx:=0 to (sw-1) do
   begin
   v:=sr8[sx];
   if (v>xmax) then xmax:=v;
   if (v<xmin) then xmin:=v;
   case v of
   0   :v0:=true;
   255 :v255:=true;
   else vother:=true;
   end;//case
   end;//sx
   end;
//check
if (xmin<=0) and (xmax>=255) and v0 and v255 and vother then break;
end;//sy
//successful
result:=true;
skipend:
except;end;
end;
//## mask__maxave ##
function mask__maxave(s:tobject):longint;//0..255
label
   skipend;
var
   dtotal,dcount:comp;
   sx,sy,sw,sh,sbits:longint;
   sr32:pcolorrow32;
   sr8:pcolorrow8;
   v:byte;
begin
try
//defaults
result:=0;
dtotal:=0;
dcount:=0;
//check
if not misok82432(s,sbits,sw,sh) then exit;
//get
//.24
if (sbits=24) then
   begin
   result:=255;
   goto skipend;
   end;
//get
//.sy
for sy:=0 to (sh-1) do
begin
if not misscan832(s,sy,sr8,sr32) then goto skipend;
//.32
if (sbits=32) then
   begin
   for sx:=0 to (sw-1) do dtotal:=dtotal+sr32[sx].a;
   dcount:=dcount+sw;
   end
//.8
else if (sbits=8) then
   begin
   for sx:=0 to (sw-1) do dtotal:=dtotal+sr8[sx];
   dcount:=dcount+sw;
   end;
end;//sy
skipend:
//.finalise
if (dcount>=1) then result:=frcrange(restrict32(low__div64(dtotal,dcount)),0,255);
except;end;
end;
//## mask__setval ##
function mask__setval(s:tobject;xval:longint):boolean;
label
   skipend;
var
   sx,sy,sw,sh,sbits:longint;
   sr32:pcolorrow32;
   sr8:pcolorrow8;
   v:byte;
begin
try
//defaults
result:=false;
//check
if not misok82432(s,sbits,sw,sh) then exit;
//.24
if (sbits=24) then//ignore
   begin
   result:=true;
   goto skipend;
   end;
//range
v:=frcrange(xval,0,255);
//get
//.sy
for sy:=0 to (sh-1) do
begin
if not misscan832(s,sy,sr8,sr32) then goto skipend;
//.32
if (sbits=32) then
   begin
   for sx:=0 to (sw-1) do sr32[sx].a:=v;
   end
//.8
else if (sbits=8) then
   begin
   for sx:=0 to (sw-1) do sr8[sx]:=v;
   end;
end;//dy
//successful
result:=true;
skipend:
except;end;
end;
//## mask__copy ##
function mask__copy(s,d:tobject):boolean;//15feb2022
begin
try;result:=mask__copy3(s,d,clnone,-1);except;end;
end;
//## mask__copy2 ##
function mask__copy2(s,d:tobject;stranscol:longint):boolean;
begin
try;result:=mask__copy3(s,d,stranscol,-1);except;end;
end;
//## mask__copy3 ##
function mask__copy3(s,d:tobject;stranscol,sremove:longint):boolean;
label//extracts 8bit alpha from d32 and copies it to a8
     //note: strancols adds transparency to existing mask as it copies it over
     //note: sremove=0..255 = removes original mask as its copied over
   skipend;
var
   tr,tg,tb,sx,sy,sw,sh,sbits,dbits,dw,dh:longint;
   sr8,dr8:pcolorrow8;
   sr24,dr24:pcolorrow24;
   sr32,dr32:pcolorrow32;
   sc32:tcolor32;
   sc24:tcolor24;
   sc8:tcolor8;
begin
try
//defaults
result:=false;
//check
if not misok82432(s,sbits,sw,sh) then exit;
if not misok82432(d,dbits,dw,dh) then exit;
if (sw>dw) or (sh>dh) then exit;
//init
tr:=-1;
tg:=-1;
tb:=-1;
stranscol:=mistranscol(s,stranscol,stranscol<>clnone);
if (stranscol<>clnone) then
   begin
   sc24:=low__intrgb(stranscol);
   tr:=sc24.r;
   tg:=sc24.g;
   tb:=sc24.b;
   end;
//.sremove
if (sremove=clnone) then sremove:=-1;//off
sremove:=frcrange(sremove,-1,255);//-1=off
//get
//.dy
for sy:=0 to (sh-1) do
begin
if not misscan82432(s,sy,sr8,sr24,sr32) then goto skipend;
if not misscan82432(d,sy,dr8,dr24,dr32) then goto skipend;
//.32 + 32
if (sbits=32) and (dbits=32) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sc32:=sr32[sx];
   if (tr=sc32.r) and (tg=sc32.g) and (tb=sc32.b) then dr32[sx].a:=0
   else if (sremove>=0)                           then dr32[sx].a:=byte(sremove)
   else                                                dr32[sx].a:=sc32.a;
   end;//sx
   end
//.32 + 24
else if (sbits=32) and (dbits=24) then
   begin
   result:=true;
   goto skipend;
   end
//.32 + 8
else if (sbits=32) and (dbits=8) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sc32:=sr32[sx];
   if (tr=sc32.r) and (tg=sc32.g) and (tb=sc32.b) then dr8[sx]:=0
   else if (sremove>=0)                           then dr8[sx]:=byte(sremove)
   else                                                dr8[sx]:=sc32.a;
   end;//sx
   end
//.24 + 32
else if (sbits=24) and (dbits=32) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sc24:=sr24[sx];
   if (tr=sc24.r) and (tg=sc24.g) and (tb=sc24.b) then dr32[sx].a:=0
   else                                                dr32[sx].a:=255;
   end;//sx
   end
//.24 + 24
else if (sbits=24) and (dbits=24) then
   begin
   result:=true;
   goto skipend;
   end
//.24 + 8
else if (sbits=24) and (dbits=8) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sc24:=sr24[sx];
   if (tr=sc24.r) and (tg=sc24.g) and (tb=sc24.b) then dr8[sx]:=0
   else                                                dr8[sx]:=255;
   end;//sx
   end
//.8 + 32
else if (sbits=8) and (dbits=32) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sc8:=sr8[sx];
   sc32:=dr32[sx];
   if (tr=sc32.r) and (tg=sc32.g) and (tb=sc32.b) then dr32[sx].a:=0
   else if (sremove>=0) then                           dr32[sx].a:=byte(sremove)
   else                                                dr32[sx].a:=sc8;
   end;//sx
   end
//.8 + 24
else if (sbits=8) and (dbits=24) then
   begin
   result:=true;
   goto skipend;
   end
//.8 + 8
else if (sbits=8) and (dbits=8) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sc8:=sr8[sx];
   if (sremove>=0) then dr8[sx]:=byte(sremove)
   else                 dr8[sx]:=sc8;
   end;//sx
   end;
end;//dy
//successful
result:=true;
skipend:
except;end;
end;
//## mask__copymin ##
function mask__copymin(s,d:tobject):boolean;//15feb2022
label
   skipend;
var
   sx,sy,sw,sh,sbits,dbits,dw,dh:longint;
   sr8,dr8:pcolorrow8;
   sr24,dr24:pcolorrow24;
   sr32,dr32:pcolorrow32;
   sv,dv:tcolor8;
begin
try
//defaults
result:=false;
//check
if not misok82432(s,sbits,sw,sh) then exit;
if not misok82432(d,dbits,dw,dh) then exit;
if (sw>dw) or (sh>dh) then exit;
if (s=d) then
   begin
   result:=true;
   exit;
   end;
//get
//.dy
for sy:=0 to (sh-1) do
begin
if not misscan82432(s,sy,sr8,sr24,sr32) then goto skipend;
if not misscan82432(d,sy,dr8,dr24,dr32) then goto skipend;
//.32 + 32
if (sbits=32) and (dbits=32) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sv:=sr32[sx].a;
   dv:=dr32[sx].a;
   if (dv<sv) then sv:=dv;
   dr32[sx].a:=sv;
   end;//sx
   end
//.32 + 24
else if (sbits=32) and (dbits=24) then
   begin
   result:=true;
   goto skipend;
   end
//.32 + 8
else if (sbits=32) and (dbits=8) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sv:=sr32[sx].a;
   dv:=dr8[sx];
   if (dv<sv) then sv:=dv;
   dr8[sx]:=sv;
   end;//sx
   end
//.24 + 32
else if (sbits=24) and (dbits=32) then
   begin
   result:=true;
   goto skipend;
   end
//.24 + 24
else if (sbits=24) and (dbits=24) then
   begin
   result:=true;
   goto skipend;
   end
//.24 + 8
else if (sbits=24) and (dbits=8) then
   begin
   result:=true;
   goto skipend;
   end
//.8 + 32
else if (sbits=8) and (dbits=32) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sv:=sr8[sx];
   dv:=dr32[sx].a;
   if (dv<sv) then sv:=dv;
   dr32[sx].a:=sv;
   end;//sx
   end
//.8 + 24
else if (sbits=8) and (dbits=24) then
   begin
   result:=true;
   goto skipend;
   end
//.8 + 8
else if (sbits=8) and (dbits=8) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sv:=sr8[sx];
   dv:=dr8[sx];
   if (dv<sv) then sv:=dv;
   dr8[sx]:=sv;
   end;//sx
   end;
end;//dy
//successful
result:=true;
skipend:
except;end;
end;
//## mask__setopacity ##
function mask__setopacity(s:tobject;xopacity255:longint):boolean;//06jun2021
label
   skipend;
var
   sx,sy,sw,sh,sbits:longint;
   sr32:pcolorrow32;
   sr8:pcolorrow8;
   sv,v8:byte;
begin
try
//defaults
result:=false;
//check
if not misok82432(s,sbits,sw,sh) then exit;
//range
v8:=frcrange(xopacity255,0,255);
//.nothing to do -> ignore
if (v8=255) then
   begin
   result:=true;
   exit;
   end;
//get
//.sy
for sy:=0 to (sh-1) do
begin
if not misscan832(s,sy,sr8,sr32) then goto skipend;
//.32
if (sbits=32) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sv:=sr32[sx].a;
   if (sv>=1) then
      begin
      sv:=(sv*v8) div 255;
      if (sv<=0) then sv:=1;
      sr32[sx].a:=sv;
      end;
   end;//sx
   end
//.24
else if (sbits=24) then
   begin
   result:=true;
   goto skipend;
   end
//.8
else if (sbits=8) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sv:=sr8[sx];
   if (sv>=1) then
      begin
      sv:=(sv*v8) div 255;
      if (sv<=0) then sv:=1;
      sr8[sx]:=sv;
      end;
   end;//sx
   end;
end;//sy
//successful
result:=true;
skipend:
except;end;
end;
//## mask__multiple ##
function mask__multiple(s:tobject;xby:currency):boolean;//18sep2022
label
   skipend;
var
   sv,sx,sy,sw,sh,sbits:longint;
   sr32:pcolorrow32;
   sr8:pcolorrow8;
begin
try
//defaults
result:=false;
//check
if not misok82432(s,sbits,sw,sh) then exit;
//.nothing to do -> ignore
if (xby=1) or (xby<0) then exit;
//get
//.sy
for sy:=0 to (sh-1) do
begin
if not misscan832(s,sy,sr8,sr32) then goto skipend;
//.32
if (sbits=32) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sv:=sr32[sx].a;
   if (sv>=1) then
      begin
      sv:=round(sv*xby);
      if (sv<=0) then sv:=1 else if (sv>255) then sv:=255;
      sr32[sx].a:=byte(sv);
      end;
   end;//sx
   end
//.24
else if (sbits=24) then
   begin
   result:=true;
   goto skipend;
   end
//.8
else if (sbits=8) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sv:=sr8[sx];
   if (sv>=1) then
      begin
      sv:=round(sv*xby);
      if (sv<=0) then sv:=1 else if (sv>255) then sv:=255;
      sr8[sx]:=byte(sv);
      end;
   end;//sx
   end;
end;//sy
//successful
result:=true;
skipend:
except;end;
end;
//## mask__feather ##
function mask__feather(s,d:tobject;sfeather,stranscol:longint;var xouttranscol:longint):boolean;//20jan2021
begin
try;result:=mask__feather2(s,d,sfeather,stranscol,false,xouttranscol);except;end;
end;
//## mask__feather2 ##
function mask__feather2(s,d:tobject;sfeather,stranscol:longint;stransframe:boolean;var xouttranscol:longint):boolean;//15feb2022, 18jun2021, 08jun2021, 20jan2021
label//sfeather:  -1=asis, 0=none(sharp), 1=feather(1px/blur), 2=feather(2px/blur), 3=feather(1px), 4=feather(2px)
     //stranscol: clnone=solid (no see thru parts), clTopLeft=pixel(0,0), else=user specified color
   doasis,dosolid,dofeather,doblur,skipdone,skipend;
const
   xfeather1=110;//more inline with a sine curve - 20jan2021
   xfeather2=30;
var
   xlist:array[0..255] of longint;//used to cache a feather curve that drifts off towards zero for more effective edge softening - 20jan2021
   srows8,drows8:pcolorrows8;
   srows24,drows24:pcolorrows24;
   srows32,drows32:pcolorrows32;
   sr8,dr8:pcolorrow8;
   sr24:pcolorrow24;
   sr32,dr32:pcolorrow32;
   ac8,sc8:tcolor8;
   ac24,sc24:tcolor24;
   ac32,sc32:tcolor32;
   yhalf,xhalf,xlen,ylen,xylen,xshortlen,dval,fx,fy,xfeather,i,dv,dc,sbits,sw,sh,dbits,dx,dy,dw,dh,sxx,sx,sy,sf:longint;
   fval,fval2:byte;
   tr,tg,tb:longint;
   xinitrows8OK,tok,xblur,xalternate:boolean;
   //## xinitrows832 ##
   procedure xinitrows832;
   begin
   if xinitrows8OK then exit;
   misrows82432(d,drows8,drows24,drows32);
   xinitrows8OK:=true;
   end;
   //## drect832 ##
   procedure drect832(dx,dy,dx2,dy2,dval:longint);
   var
      sx,sy:longint;
   begin
   //range
   if (dval<=0) then dval:=1 else if (dval>=255) then dval:=254;//never 0 or 255
   //check
   if (dx2<dx) or (dy2<dy) or (dx<0) or (dx>=sw) or (dy<0) or (dy>=sh) or (dx2<0) or (dx2>=sw) or (dy2<0) or (dy2>=sh) then exit;
   //.32
   if (dbits=32) then
      begin
      for sx:=dx to dx2 do drows32[dy][sx].a:=byte(dval);//top
      for sx:=dx to dx2 do drows32[dy2][sx].a:=byte(dval);//bottom
      for sy:=dy to dy2 do drows32[sy][dx].a:=byte(dval);//left
      for sy:=dy to dy2 do drows32[sy][dx2].a:=byte(dval);//right
      end
   //.8
   else if (dbits=8) then
      begin
      for sx:=dx to dx2 do drows8[dy][sx]:=byte(dval);//top
      for sx:=dx to dx2 do drows8[dy2][sx]:=byte(dval);//bottom
      for sy:=dy to dy2 do drows8[sy][dx]:=byte(dval);//left
      for sy:=dy to dy2 do drows8[sy][dx2]:=byte(dval);//right
      end;
   end;
begin
try
//defaults
result:=false;
xinitrows8OK:=false;
xouttranscol:=clnone;
//init
if not misok82432(s,sbits,sw,sh) then exit;
if not misok82432(d,dbits,dw,dh) then
   begin
   //special case: allow "s32" to write to own mask e.g. "s32.mask" - 15feb2022
   if (d=nil) and (sbits=32) then
      begin
      d:=s;
      dbits:=sbits;
      dw:=sw;
      dh:=sh;
      end
   else exit;
   end;
if (sw>dw) or (sh>dh) then exit;

//feather
xfeather:=frcrange(sfeather,-1,100);//-1=asis
xblur:=(xfeather>=1);

//.force sharp feather when transparent color is specified - 17jan2021
if (xfeather<0) and (stranscol<>clnone) then xfeather:=0;

//.feather curve -> used for feathers 3px+
if (xfeather>=1) and (not miscurveAirbrush2(xlist,high(xlist)+1,0,255,false,false)) then goto skipend;

//transcol
tr:=-1;
tg:=-1;
tb:=-1;
tok:=false;//no transparency -> solid
if (xfeather>=0) and (stranscol<>clnone) then
   begin
   //.ok
   tok:=true;
   if not misfindtranscol82432ex(s,stranscol,tr,tg,tb) then goto skipend;
   xouttranscol:=low__rgb(tr,tg,tb);
   end;

//decide
if (xfeather=-1)  then goto doasis
else if not tok   then goto dosolid
else                   goto dofeather;

//asis -------------------------------------------------------------------------
doasis:
//get
for sy:=0 to (sh-1) do
begin
if not misscan82432(s,sy,sr8,sr24,sr32) then goto skipend;
if not misscan832(d,sy,dr8,dr32) then goto skipend;

//.32 + 32 + (s=d)
if (sbits=32) and (dbits=32) and (s=d) then
   begin
   result:=true;
   goto skipend;
   end
//.32 + 32
else if (sbits=32) and (dbits=32) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sc8:=sr32[sx].a;
   dr32[sx].a:=sc8;
   end;//sx
   end
//.32 + 24
else if (sbits=32) and (dbits=24) then
   begin
   result:=true;
   goto skipend;
   end
//.32 + 8
else if (sbits=32) and (dbits=8) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sc8:=sr32[sx].a;
   dr8[sx]:=sc8;
   end;//sx
   end
//.24 + 32
else if (sbits=24) and (dbits=32) then
   begin
   for sx:=0 to (sw-1) do dr32[sx].a:=255;
   end
//.24 + 24
else if (sbits=24) and (dbits=24) then
   begin
   result:=true;
   goto skipend;
   end
//.24 + 8
else if (sbits=24) and (dbits=8) then
   begin
   for sx:=0 to (sw-1) do dr8[sx]:=255;
   end
//.8 + 32
else if (sbits=8) and (dbits=32) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sc8:=sr8[sx];
   dr32[sx].a:=sc8;
   end;//sx
   end
//.8 + 24
else if (sbits=8) and (dbits=24) then
   begin
   result:=true;
   goto skipend;
   end
//.8 + 8
else if (sbits=8) and (dbits=8) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sc8:=sr8[sx];
   dr8[sx]:=sc8;
   end;//sx
   end;
end;//sy
goto skipdone;


//solid ------------------------------------------------------------------------
dosolid:
//cls
for sy:=0 to (sh-1) do
begin
if not misscan832(d,sy,dr8,dr32) then goto skipend;
//.32
if (dbits=32) then
   begin
   for sx:=0 to (sw-1) do dr32[sx].a:=255;
   end
//.24
else if (dbits=24) then
   begin
   result:=true;
   goto skipend;
   end
//.8
else if (dbits=8) then
   begin
   for sx:=0 to (sw-1) do dr8[sx]:=255;
   end;
end;//sy
//get
xinitrows832;
case xfeather of
1..2:begin
   for sx:=0 to (xfeather-1) do
   begin
   if (xfeather=1) then dval:=xfeather1
   else if (sx=0) then dval:=xfeather2 else dval:=xfeather1;

   drect832(sx,sx,sw-1-sx,sh-1-sx,dval);
   end;//sx
   end;
3..maxint:begin
   for sx:=0 to (xfeather-1) do drect832(sx,sx,sw-1-sx,sh-1-sx,xlist[round((sx/xfeather)*255)]);
   end;
end;//case
//.blur
goto doblur;


//feather ----------------------------------------------------------------------
dofeather:

//init
if (xfeather>=1) and (not misrows82432(s,srows8,srows24,srows32)) then goto skipend;

//get
for sy:=0 to (sh-1) do
begin
if not misscan82432(s,sy,sr8,sr24,sr32) then goto skipend;
if not misscan832(d,sy,dr8,dr32) then goto skipend;

case xfeather of
//sharp
0:begin
   //.32 + 32
   if (sbits=32) and (dbits=32) then
      begin
      for sx:=0 to (sw-1) do
      begin
      sc32:=sr32[sx];
      if (tr=sc32.r) and (tg=sc32.g) and (tb=sc32.b) then dr32[sx].a:=0 else dr32[sx].a:=255;
      end;//sx
      end
   //.32 + 24
   else if (sbits=32) and (dbits=24) then
      begin
      goto skipend;
      result:=true;
      end
   //.32 + 8
   else if (sbits=32) and (dbits=8) then
      begin
      for sx:=0 to (sw-1) do
      begin
      sc32:=sr32[sx];
      if (tr=sc32.r) and (tg=sc32.g) and (tb=sc32.b) then dr8[sx]:=0 else dr8[sx]:=255;
      end;//sx
      end
   //.24 + 32
   else if (sbits=24) and (dbits=32) then
      begin
      for sx:=0 to (sw-1) do
      begin
      sc24:=sr24[sx];
      if (tr=sc24.r) and (tg=sc24.g) and (tb=sc24.b) then dr32[sx].a:=0 else dr32[sx].a:=255;
      end;//sx
      end
   //.24 + 24
   else if (sbits=24) and (dbits=24) then
      begin
      result:=true;
      goto skipend;
      end
   //.24 + 8
   else if (sbits=24) and (dbits=8) then
      begin
      for sx:=0 to (sw-1) do
      begin
      sc24:=sr24[sx];
      if (tr=sc24.r) and (tg=sc24.g) and (tb=sc24.b) then dr8[sx]:=0 else dr8[sx]:=255;
      end;//sx
      end
   //.8 + 32
   else if (sbits=8) and (dbits=32) then
      begin
      for sx:=0 to (sw-1) do
      begin
      sc8:=sr8[sx];
      if (tr=sc8) then dr32[sx].a:=0 else dr32[sx].a:=255;
      end;//sx
      end
   //.8 + 24
   else if (sbits=8) and (dbits=24) then
      begin
      result:=true;
      goto skipend;
      end
    //.8 + 8
   else if (sbits=8) and (dbits=8) then
      begin
      for sx:=0 to (sw-1) do
      begin
      sc8:=sr8[sx];
      if (tr=sc8) then dr8[sx]:=0 else dr8[sx]:=255;
      end;//sx
      end;
   end;//begin
//slow feather -----------------------------------------------------------------
3..maxint:begin
   //.32 + 32/24/8
   if (sbits=32) then
      begin
      for sx:=0 to (sw-1) do
      begin
      //init
      sc32:=sr32[sx];
      dval:=0;
      //get
      if (tr<>sc32.r) or (tg<>sc32.g) or (tb<>sc32.b) then
         begin
         //init
         dval:=255;
         xshortlen:=xfeather+1;
         //.fy
         for fy:=(sy-xfeather) to (sy+xfeather) do
         begin
         if (fy>=0) and (fy<sh) then
            begin
            //.y len
            ylen:=fy-sy;
            if (ylen<0) then ylen:=-ylen;
            //.fx
            for fx:=(sx-xfeather) to (sx+xfeather) do
            begin
            if (fx>=0) and (fx<sw) and ((fx<>sx) or (fy<>sy)) then
               begin
               //get
               ac32:=srows32[fy][fx];
               if ((tr=ac32.r) and (tg=ac32.g) and (tb=ac32.b)) or (stransframe and ( (fx<=0) or (fx>=(sw-1)) or (fy<=0) or (fy>=(sh-1)) ) ) then
                  begin
                  //get
                  //.x len
                  xlen:=fx-sx;
                  if (xlen<0) then xlen:=-xlen;
                  //.yx len
                  xylen:=trunc(sqrt((xlen*xlen)+(ylen*ylen)));
                  if (xylen<xshortlen) then xshortlen:=xylen;
                  if (xshortlen<1) then xshortlen:=1;
                  if (xshortlen<=1) then break;
                  end;//tr -> ac32
               end;
            end;//fx
            end;
         //check
         if (xshortlen<=1) then break;
         end;//fy
         //set
         if (xshortlen<(xfeather+1)) then
            begin
            dval:=round((xshortlen/(xfeather+1))*255);
            //.curve the feather
            if (dval<0) then dval:=0 else if (dval>255) then dval:=255;
            dval:=xlist[dval];
            //.limit the feather to visible shades (not 0=off, not 255=solid)
            if (dval<=0) then dval:=1 else if (dval>=255) then dval:=254;//never 0 or 255
            end;
         end;//tr -> sc32
      //set
      case dbits of
      32:dr32[sx].a:=dval;
      24:begin
         result:=true;
         goto skipend;
         end;
      8:dr8[sx]:=dval;
      end;//case
      end;//sx
      end//32
   //.24 + 32/24/8
   else if (sbits=24) then
      begin
      for sx:=0 to (sw-1) do
      begin
      //init
      sc24:=sr24[sx];
      dval:=0;
      //get
      if (tr<>sc24.r) or (tg<>sc24.g) or (tb<>sc24.b) then
         begin
         //init
         dval:=255;
         xshortlen:=xfeather+1;
         //.fy
         for fy:=(sy-xfeather) to (sy+xfeather) do
         begin
         if (fy>=0) and (fy<sh) then
            begin
            //.y len
            ylen:=fy-sy;
            if (ylen<0) then ylen:=-ylen;
            //.fx
            for fx:=(sx-xfeather) to (sx+xfeather) do
            begin
            if (fx>=0) and (fx<sw) and ((fx<>sx) or (fy<>sy)) then
               begin
               //get
               ac24:=srows24[fy][fx];
               if (tr=ac24.r) and (tg=ac24.g) and (tb=ac24.b) then
                  begin
                  //get
                  //.x len
                  xlen:=fx-sx;
                  if (xlen<0) then xlen:=-xlen;
                  //.yx len
                  xylen:=trunc(sqrt((xlen*xlen)+(ylen*ylen)));
                  if (xylen<xshortlen) then xshortlen:=xylen;
                  if (xshortlen<1) then xshortlen:=1;
                  if (xshortlen<=1) then break;
                  end;//tr -> ac24
               end;
            end;//fx
            end;
         //check
         if (xshortlen<=1) then break;
         end;//fy
         //set
         if (xshortlen<(xfeather+1)) then
            begin
            dval:=round((xshortlen/(xfeather+1))*255);
            //.curve the feather
            if (dval<0) then dval:=0 else if (dval>255) then dval:=255;
            dval:=xlist[dval];
            //.limit the feather to visible shades (not 0=off, not 255=solid)
            if (dval<=0) then dval:=1 else if (dval>=255) then dval:=254;//never 0 or 255
            end;
         end;//tr -> sc24
      //set
      case dbits of
      32:dr32[sx].a:=dval;
      24:begin
         result:=true;
         goto skipend;
         end;
      8:dr8[sx]:=dval;
      end;//case
      end;//sx
      end//24
   //.8 + 32/24/8
   else if (sbits=8) then
      begin
      for sx:=0 to (sw-1) do
      begin
      //init
      sc8:=sr8[sx];
      dval:=0;
      //get
      if (tr<>sc8) then
         begin
         //init
         dval:=255;
         xshortlen:=xfeather+1;
         //.fy
         for fy:=(sy-xfeather) to (sy+xfeather) do
         begin
         if (fy>=0) and (fy<sh) then
            begin
            //.y len
            ylen:=fy-sy;
            if (ylen<0) then ylen:=-ylen;
            //.fx
            for fx:=(sx-xfeather) to (sx+xfeather) do
            begin
            if (fx>=0) and (fx<sw) and ((fx<>sx) or (fy<>sy)) then
               begin
               //get
               ac8:=srows8[fy][fx];
               if (tr=ac8) then
                  begin
                  //get
                  //.x len
                  xlen:=fx-sx;
                  if (xlen<0) then xlen:=-xlen;
                  //.yx len
                  xylen:=trunc(sqrt((xlen*xlen)+(ylen*ylen)));
                  if (xylen<xshortlen) then xshortlen:=xylen;
                  if (xshortlen<1) then xshortlen:=1;
                  if (xshortlen<=1) then break;
                  end;//tr -> ac24
               end;
            end;//fx
            end;
         //check
         if (xshortlen<=1) then break;
         end;//fy
         //set
         if (xshortlen<(xfeather+1)) then
            begin
            dval:=round((xshortlen/(xfeather+1))*255);
            //.curve the feather
            if (dval<0) then dval:=0 else if (dval>255) then dval:=255;
            dval:=xlist[dval];
            //.limit the feather to visible shades (not 0=off, not 255=solid)
            if (dval<=0) then dval:=1 else if (dval>=255) then dval:=254;//never 0 or 255
            end;
         end;//tr -> sc24
      //set
      case dbits of
      32:dr32[sx].a:=dval;
      24:begin
         result:=true;
         goto skipend;
         end;
      8:dr8[sx]:=dval;
      end;//case
      end;//sx
      end;//8
   end;
//------------------------------------------------------------------------------
//fast feather 1 & 2 -> eat into image edge -> feather works in on solid parts of image -> never extends -> original color image remains unaltered - 12jan2021
1..2:begin
   //.8 + 32/24/8
   if (sbits=8) then
      begin
      for sx:=0 to (sw-1) do
      begin
      //init
      sc8:=sr8[sx];
      dval:=0;
      //get
      if (tr<>sc8) then
         begin
         //init
         dval:=255;
         if (xfeather=1) then fval:=xfeather1 else fval:=xfeather2;
         //stransframe
         if stransframe then
            begin
            //feather 1
            if ((sx-1)<=0) or ((sx+1)>=(sw-1)) then dval:=fval
            else if ((sy-1)<=0) or ((sy+1)>=(sh-1)) then dval:=fval;
            //feather 2
            if (dval=255) and (xfeather=2) then
               begin
               if ((sx-2)<=0) or ((sx+2)>=(sw-1)) then dval:=xfeather1
               else if ((sy-2)<=0) or ((sy+2)>=(sh-1)) then dval:=xfeather1;
               end;
            end;
         //x-1
         if (dval=255) and (sx>=1) then
            begin
            ac8:=srows8[sy][sx-1];
            if (tr=ac8) then dval:=fval;
            end;
         //x+1
         if (dval=255) and (sx<(sw-1)) then
            begin
            ac8:=srows8[sy][sx+1];
            if (tr=ac8) then dval:=fval;
            end;
         //y-1
         if (dval=255) and (sy>=1) then
            begin
            ac8:=srows8[sy-1][sx];
            if (tr=ac8) then dval:=fval;
            end;
         //y+1
         if (dval=255) and (sy<(sh-1)) then
            begin
            ac8:=srows8[sy+1][sx];
            if (tr=ac8) then dval:=fval;
            end;

         //.feather 2
         if (xfeather=2) and (dval=255) then
            begin
            //x-2
            if (dval=255) and (sx>=2) then
               begin
               ac8:=srows8[sy][sx-2];
               if (tr=ac8) then dval:=xfeather1;
               end;
            //x+2
            if (dval=255) and (sx<(sw-2)) then
               begin
               ac8:=srows8[sy][sx+2];
               if (tr=ac8) then dval:=xfeather1;
               end;
            //x-1,y-1
            if (dval=255) and (sx>=1) and (sy>=1) then
               begin
               ac8:=srows8[sy-1][sx-1];
               if (tr=ac8) then dval:=xfeather1;
               end;
            //x+1,y-1
            if (dval=255) and (sx<(sw-1)) and (sy>=1) then
               begin
               ac8:=srows8[sy-1][sx+1];
               if (tr=ac8) then dval:=xfeather1;
               end;
            //y-2
            if (dval=255) and (sy>=2) then
               begin
               ac8:=srows8[sy-2][sx];
               if (tr=ac8) then dval:=xfeather1;
               end;
            //x-1,y+1
            if (dval=255) and (sx>=1) and (sy<(sh-1)) then
               begin
               ac8:=srows8[sy+1][sx-1];
               if (tr=ac8) then dval:=xfeather1;
               end;
            //x+1,y+1
            if (dval=255) and (sx<(sw-1)) and (sy<(sh-1)) then
               begin
               ac8:=srows8[sy+1][sx+1];
               if (tr=ac8) then dval:=xfeather1;
               end;
            //y+2
            if (dval=255) and (sy<(sh-2)) then
               begin
               ac8:=srows8[sy+2][sx];
               if (tr=ac8) then dval:=xfeather1;
               end;
            end;//feather2
         end;//tr
      //set
      case dbits of
      32:dr32[sx].a:=dval;
      24:begin
         result:=true;
         goto skipend;
         end;
      8:dr8[sx]:=dval;
      end;//case
      end;//sx
      end//s8
   //.24 + 32/24/8
   else if (sbits=24) then
      begin
      for sx:=0 to (sw-1) do
      begin
      //init
      sc24:=sr24[sx];
      dval:=0;
      //get
      if (tr<>sc24.r) or (tg<>sc24.g) or (tb<>sc24.b) then
         begin
         //init
         dval:=255;
         if (xfeather=1) then fval:=xfeather1 else fval:=xfeather2;
         //stransframe
         if stransframe then
            begin
            //feather 1
            if ((sx-1)<=0) or ((sx+1)>=(sw-1)) then dval:=fval
            else if ((sy-1)<=0) or ((sy+1)>=(sh-1)) then dval:=fval;
            //feather 2
            if (dval=255) and (xfeather=2) then
               begin
               if ((sx-2)<=0) or ((sx+2)>=(sw-1)) then dval:=xfeather1
               else if ((sy-2)<=0) or ((sy+2)>=(sh-1)) then dval:=xfeather1;
               end;
            end;
         //x-1
         if (dval=255) and (sx>=1) then
            begin
            ac24:=srows24[sy][sx-1];
            if (tr=ac24.r) and (tg=ac24.g) and (tb=ac24.b) then dval:=fval;
            end;
         //x+1
         if (dval=255) and (sx<(sw-1)) then
            begin
            ac24:=srows24[sy][sx+1];
            if (tr=ac24.r) and (tg=ac24.g) and (tb=ac24.b) then dval:=fval;
            end;
         //y-1
         if (dval=255) and (sy>=1) then
            begin
            ac24:=srows24[sy-1][sx];
            if (tr=ac24.r) and (tg=ac24.g) and (tb=ac24.b) then dval:=fval;
            end;
         //y+1
         if (dval=255) and (sy<(sh-1)) then
            begin
            ac24:=srows24[sy+1][sx];
            if (tr=ac24.r) and (tg=ac24.g) and (tb=ac24.b) then dval:=fval;
            end;

         //.feather 2
         if (xfeather=2) and (dval=255) then
            begin
            //x-2
            if (dval=255) and (sx>=2) then
               begin
               ac24:=srows24[sy][sx-2];
               if (tr=ac24.r) and (tg=ac24.g) and (tb=ac24.b) then dval:=xfeather1;
               end;
            //x+2
            if (dval=255) and (sx<(sw-2)) then
               begin
               ac24:=srows24[sy][sx+2];
               if (tr=ac24.r) and (tg=ac24.g) and (tb=ac24.b) then dval:=xfeather1;
               end;
            //x-1,y-1
            if (dval=255) and (sx>=1) and (sy>=1) then
               begin
               ac24:=srows24[sy-1][sx-1];
               if (tr=ac24.r) and (tg=ac24.g) and (tb=ac24.b) then dval:=xfeather1;
               end;
            //x+1,y-1
            if (dval=255) and (sx<(sw-1)) and (sy>=1) then
               begin
               ac24:=srows24[sy-1][sx+1];
               if (tr=ac24.r) and (tg=ac24.g) and (tb=ac24.b) then dval:=xfeather1;
               end;
            //y-2
            if (dval=255) and (sy>=2) then
               begin
               ac24:=srows24[sy-2][sx];
               if (tr=ac24.r) and (tg=ac24.g) and (tb=ac24.b) then dval:=xfeather1;
               end;
            //x-1,y+1
            if (dval=255) and (sx>=1) and (sy<(sh-1)) then
               begin
               ac24:=srows24[sy+1][sx-1];
               if (tr=ac24.r) and (tg=ac24.g) and (tb=ac24.b) then dval:=xfeather1;
               end;
            //x+1,y+1
            if (dval=255) and (sx<(sw-1)) and (sy<(sh-1)) then
               begin
               ac24:=srows24[sy+1][sx+1];
               if (tr=ac24.r) and (tg=ac24.g) and (tb=ac24.b) then dval:=xfeather1;
               end;
            //y+2
            if (dval=255) and (sy<(sh-2)) then
               begin
               ac24:=srows24[sy+2][sx];
               if (tr=ac24.r) and (tg=ac24.g) and (tb=ac24.b) then dval:=xfeather1;
               end;
            end;//feather2
         end;//tr
      //set
      case dbits of
      32:dr32[sx].a:=dval;
      24:begin
         result:=true;
         goto skipend;
         end;
      8:dr8[sx]:=dval;
      end;//case
      end;//sx
      end//s24
   //.32 + 32/24/8
   else if (sbits=32) then
      begin
      for sx:=0 to (sw-1) do
      begin
      //init
      sc32:=sr32[sx];
      dval:=0;
      //get
      if (tr<>sc32.r) or (tg<>sc32.g) or (tb<>sc32.b) then
         begin
         //init
         dval:=255;
         if (xfeather=1) then fval:=xfeather1 else fval:=xfeather2;
         //stransframe
         if stransframe then
            begin
            //feather 1
            if ((sx-1)<=0) or ((sx+1)>=(sw-1)) then dval:=fval
            else if ((sy-1)<=0) or ((sy+1)>=(sh-1)) then dval:=fval;
            //feather 2
            if (dval=255) and (xfeather=2) then
               begin
               if ((sx-2)<=0) or ((sx+2)>=(sw-1)) then dval:=xfeather1
               else if ((sy-2)<=0) or ((sy+2)>=(sh-1)) then dval:=xfeather1;
               end;
            end;
         //x-1
         if (dval=255) and (sx>=1) then
            begin
            ac32:=srows32[sy][sx-1];
            if (tr=ac32.r) and (tg=ac32.g) and (tb=ac32.b) then dval:=fval;
            end;
         //x+1
         if (dval=255) and (sx<(sw-1)) then
            begin
            ac32:=srows32[sy][sx+1];
            if (tr=ac32.r) and (tg=ac32.g) and (tb=ac32.b) then dval:=fval;
            end;
         //y-1
         if (dval=255) and (sy>=1) then
            begin
            ac32:=srows32[sy-1][sx];
            if (tr=ac32.r) and (tg=ac32.g) and (tb=ac32.b) then dval:=fval;
            end;
         //y+1
         if (dval=255) and (sy<(sh-1)) then
            begin
            ac32:=srows32[sy+1][sx];
            if (tr=ac32.r) and (tg=ac32.g) and (tb=ac32.b) then dval:=fval;
            end;

         //.feather 2
         if (xfeather=2) and (dval=255) then
            begin
            //x-2
            if (dval=255) and (sx>=2) then
               begin
               ac32:=srows32[sy][sx-2];
               if (tr=ac32.r) and (tg=ac32.g) and (tb=ac32.b) then dval:=xfeather1;
               end;
            //x+2
            if (dval=255) and (sx<(sw-2)) then
               begin
               ac32:=srows32[sy][sx+2];
               if (tr=ac32.r) and (tg=ac32.g) and (tb=ac32.b) then dval:=xfeather1;
               end;
            //x-1,y-1
            if (dval=255) and (sx>=1) and (sy>=1) then
               begin
               ac32:=srows32[sy-1][sx-1];
               if (tr=ac32.r) and (tg=ac32.g) and (tb=ac32.b) then dval:=xfeather1;
               end;
            //x+1,y-1
            if (dval=255) and (sx<(sw-1)) and (sy>=1) then
               begin
               ac32:=srows32[sy-1][sx+1];
               if (tr=ac32.r) and (tg=ac32.g) and (tb=ac32.b) then dval:=xfeather1;
               end;
            //y-2
            if (dval=255) and (sy>=2) then
               begin
               ac32:=srows32[sy-2][sx];
               if (tr=ac32.r) and (tg=ac32.g) and (tb=ac32.b) then dval:=xfeather1;
               end;
            //x-1,y+1
            if (dval=255) and (sx>=1) and (sy<(sh-1)) then
               begin
               ac32:=srows32[sy+1][sx-1];
               if (tr=ac32.r) and (tg=ac32.g) and (tb=ac32.b) then dval:=xfeather1;
               end;
            //x+1,y+1
            if (dval=255) and (sx<(sw-1)) and (sy<(sh-1)) then
               begin
               ac32:=srows32[sy+1][sx+1];
               if (tr=ac32.r) and (tg=ac32.g) and (tb=ac32.b) then dval:=xfeather1;
               end;
            //y+2
            if (dval=255) and (sy<(sh-2)) then
               begin
               ac32:=srows32[sy+2][sx];
               if (tr=ac32.r) and (tg=ac32.g) and (tb=ac32.b) then dval:=xfeather1;
               end;
            end;//feather2
         end;//tr
      //set
      case dbits of
      32:dr32[sx].a:=dval;
      24:begin
         result:=true;
         goto skipend;
         end;
      8:dr8[sx]:=dval;
      end;//case
      end;//sx
      end;//s32
   end;//begin
end;//case
end;//sy

//.blur
goto doblur;


//blur -------------------------------------------------------------------------
doblur:
//check
if (xfeather<=0) or (not xblur) then goto skipdone;//xfeather=0=sharp(no feather, hence nothing to blur)

//init
xinitrows832;

//get -> blur x2 for both "feather 1" and "feather 2" for best most consistent results - 12jan2021
xalternate:=true;
for i:=0 to frcmin((xfeather div 5),1) do
begin
xalternate:=not xalternate;
for sy:=0 to (sh-1) do
begin
//.32
if (dbits=32) then
   begin
   for sxx:=0 to (sw-1) do
   begin
   if xalternate then sx:=sw-1-sxx else sx:=sxx;
   dv:=drows32[sy][sx].a;
   if (dv>=1) then//only adjust existing feather -> do not grow it outside of the scope of the image - 11jan2021
      begin
      dc:=1;
      //3x3
      //x-1
      if (sx>=1) then
         begin
         inc(dv,drows32[sy][sx-1].a);
         inc(dc);
         end;
      //x+1
      if (sx<(sw-1)) then
         begin
         inc(dv,drows32[sy][sx+1].a);
         inc(dc);
         end;
      //y-1
      if (sy>=1) then
         begin
         inc(dv,drows32[sy-1][sx].a);
         inc(dc);
         end;
      //y+1
      if (sy<(sh-1)) then
         begin
         inc(dv,drows32[sy+1][sx].a);
         inc(dc);
         end;
      //enlarge to a 5x5 - 20jan2021
      if (xfeather>=3) then
         begin
         //x-2
         if (sx>=2) then
            begin
            inc(dv,drows32[sy][sx-2].a);
            inc(dc);
            end;
         //x+2
         if (sx<(sw-2)) then
            begin
            inc(dv,drows32[sy][sx+2].a);
            inc(dc);
            end;
         //x-1,y-1
         if (sx>=1) and (sy>=1) then
            begin
            inc(dv,drows32[sy-1][sx-1].a);
            inc(dc);
            end;
         //x+1,y-1
         if (sx<(sw-1)) and (sy>=1) then
            begin
            inc(dv,drows32[sy-1][sx+1].a);
            inc(dc);
            end;
         //y-2
         if (sy>=2) then
            begin
            inc(dv,drows32[sy-2][sx].a);
            inc(dc);
            end;
         //x-1,y+1
         if (sx>=1) and (sy<(sh-1)) then
            begin
            inc(dv,drows32[sy+1][sx-1].a);
            inc(dc);
            end;
         //x+1,y+1
         if (sx<(sw-1)) and (sy<(sh-1)) then
            begin
            inc(dv,drows32[sy+1][sx+1].a);
            inc(dc);
            end;
         //y+2
         if (sy<(sh-2)) then
            begin
            inc(dv,drows32[sy+2][sx].a);
            inc(dc);
            end;
         end;//xfeather

      //set
      if (dc>=2) then
         begin
   //was: dv:=dv div dc;//Warning: This had been used but found to round down summed values e.g. 255*5 div 5 -> 254 and 253 etc where as using "round(x/y)" rounds up to 255 - 19jan2021
         dv:=round(dv/dc);
         drows32[sy][sx].a:=byte(dv);
         end;
      end;
   end;//sx
   end
//.24
else if (dbits=24) then goto skipdone
//.8
else if (dbits=8) then
   begin
   for sxx:=0 to (sw-1) do
   begin
   if xalternate then sx:=sw-1-sxx else sx:=sxx;
   dv:=drows8[sy][sx];
   if (dv>=1) then//only adjust existing feather -> do not grow it outside of the scope of the image - 11jan2021
      begin
      dc:=1;
      //3x3
      //x-1
      if (sx>=1) then
         begin
         inc(dv,drows8[sy][sx-1]);
         inc(dc);
         end;
      //x+1
      if (sx<(sw-1)) then
         begin
         inc(dv,drows8[sy][sx+1]);
         inc(dc);
         end;
      //y-1
      if (sy>=1) then
         begin
         inc(dv,drows8[sy-1][sx]);
         inc(dc);
         end;
      //y+1
      if (sy<(sh-1)) then
         begin
         inc(dv,drows8[sy+1][sx]);
         inc(dc);
         end;
      //enlarge to a 5x5 - 20jan2021
      if (xfeather>=3) then
         begin
         //x-2
         if (sx>=2) then
            begin
            inc(dv,drows8[sy][sx-2]);
            inc(dc);
            end;
         //x+2
         if (sx<(sw-2)) then
            begin
            inc(dv,drows8[sy][sx+2]);
            inc(dc);
            end;
         //x-1,y-1
         if (sx>=1) and (sy>=1) then
            begin
            inc(dv,drows8[sy-1][sx-1]);
            inc(dc);
            end;
         //x+1,y-1
         if (sx<(sw-1)) and (sy>=1) then
            begin
            inc(dv,drows8[sy-1][sx+1]);
            inc(dc);
            end;
         //y-2
         if (sy>=2) then
            begin
            inc(dv,drows8[sy-2][sx]);
            inc(dc);
            end;
         //x-1,y+1
         if (sx>=1) and (sy<(sh-1)) then
            begin
            inc(dv,drows8[sy+1][sx-1]);
            inc(dc);
            end;
         //x+1,y+1
         if (sx<(sw-1)) and (sy<(sh-1)) then
            begin
            inc(dv,drows8[sy+1][sx+1]);
            inc(dc);
            end;
         //y+2
         if (sy<(sh-2)) then
            begin
            inc(dv,drows8[sy+2][sx]);
            inc(dc);
            end;
         end;//xfeather

      //set
      if (dc>=2) then
         begin
   //was: dv:=dv div dc;//Warning: This had been used but found to round down summed values e.g. 255*5 div 5 -> 254 and 253 etc where as using "round(x/y)" rounds up to 255 - 19jan2021
         dv:=round(dv/dc);
         drows8[sy][sx]:=byte(dv);
         end;
      end;
   end;//sx
   end;
end;//sy
end;//i

//successful
skipdone:
result:=true;
skipend:
except;end;
end;
//## low__PNGfilter_textlatin1 ##
procedure low__PNGfilter_textlatin1(x:tstr8);//OK=27jan2021, 21jan2021
label
   skipend;
var
   v,lv,p,dlen,xlen:longint;
begin
try
//defaults
if not block(x) then exit;
//init
dlen:=0;
xlen:=x.len;
//check
if (xlen<=0) then goto skipend;
//latin 1 characters only + #10
lv:=-1;
for p:=1 to xlen do
begin
v:=x.pbytes[p-1];
case v of
10,32..126,161..255:if (v<>32) or (lv<>32) then//exclude duplicate spaces - 21jan2021
   begin
   inc(dlen);
   if (dlen<>p) then x.pbytes[dlen-1]:=x.pbytes[p-1];
   end;
end;//case
lv:=v;
end;//p
if (dlen<>xlen) then x.setlen(dlen);
//strip leading spaces
if (dlen>=1) then
   begin
   for p:=1 to dlen do if (x.pbytes[p-1]<>32) then
      begin
      if (p>=2) then
         begin
         //was: delete(x,1,p-1);
         x.del3(0,p-1);
         dlen:=x.len;
         end;
      break;
      end;//p
   end;
//strip trailing spaces
if (dlen>=1) then
   begin
   for p:=dlen downto 1 do if (x.pbytes[p-1]<>32) then//fixed - 27jan2021
      begin
      if (p<dlen) then
         begin
         //was: delete(x,p+1,dlen-p);
         x.del3(p,dlen-p);
         dlen:=x.len;
         end;
      break;
      end;//p
   end;
skipend:
except;end;
try;bunlockautofree(x);except;end;
end;
//## low__PNGfilter_nullsplit ##
function low__PNGfilter_nullsplit(xdata:tstr8;xfilterlatin1:boolean;xname,xval:tstr8):boolean;//OK=27jan2021
label
   skipend;
var
   p:longint;
begin
try
//defaults
result:=false;
//check
block(xdata);
block(xname);
block(xval);
if zznil(xdata,2142) or zznil(xname,2143) or zznil(xval,2144) then goto skipend;
//init
xname.add(xdata);
xval.clear;
//get
for p:=1 to xdata.len do if (xdata.pbytes[p-1]=0) then
   begin
   xname.clear;
   xname.add3(xdata,0,p-1);
   xval.add3(xdata,p,xdata.len);
   //was: xname:=copy(xdata,1,p-1);
   //was: xval:=copy(xdata,p+1,length(xdata));
   break;
   end;//p
//filter
if xfilterlatin1 then
   begin
   low__PNGfilter_textlatin1(xname);
   low__PNGfilter_textlatin1(xval);
   end;
//successful
result:=true;
skipend:
except;end;
try
bunlockautofree(xdata);
bunlockautofree(xname);
bunlockautofree(xval);
except;end;
end;
//## low__PNGfilter_fromsettings ##
function low__PNGfilter_fromsettings(xdata:tstr8;var stranscol,sfeather,slessdata:longint;var shadsettings:boolean):boolean;//OK=27jan2021
label
   skipend;
var
   vc,lp,p:longint;
   v,v1,v2,v3:string;
begin
try
//defaults
result:=false;
shadsettings:=false;
stranscol:=clnone;
sfeather:=-1;//asis
slessdata:=0;
block(xdata);
//check
if zznil(xdata,2146) or (xdata.len<=0) then goto skipend;
//filter
low__PNGfilter_textlatin1(xdata);
//check #2
if zznil(xdata,2147) or (xdata.len<=0) then goto skipend;
//get
//was: xdata:=xdata+'...';//pad out with 3x terminating dots
xdata.aadd([ssDot,ssDot,ssDot]);
v1:='';
v2:='';
v3:='';
lp:=1;
vc:=0;
for p:=1 to xdata.len do
begin
if (xdata.pbytes[p-1]=ssDot) then
   begin
   //was: v:=copy(xdata,lp,p-lp);
   v:=xdata.str1[lp,p-lp];
   lp:=p+1;
   inc(vc);
   case vc of
   1:v1:=v;
   2:v2:=v;
   3:begin
      v3:=v;
      break;
      end;
   end;//case
   end;//if
end;//p
//set
if (v1<>'') then stranscol:=strint(v1);
if (v2<>'') then sfeather:=frcrange(strint(v2),-1,100);//-1=asis, 0=none, 1..100=automatic feather size in px - 21jan2021
if (v3<>'') then slessdata:=frcrange(strint(v3),0,5);//0=none, 1=subtle color reduction..5=heavy color reduction
shadsettings:=(v1<>'') and (v2<>'') and (v3<>'');
//successful
result:=true;
skipend:
except;end;
try;bunlockautofree(xdata);except;end;
end;
//## mistopng82432 ##
function mistopng82432(x:tobject;stranscol,sfeather,slessdata:longint;stransframe:boolean;xdata:tstr8;var e:string):boolean;//OK=27jan2021, 20jan2021
var
   xoutbpp:longint;
begin
try;result:=mistopng82432b(x,stranscol,sfeather,slessdata,stransframe,xoutbpp,xdata,e);except;end;
end;
//## mistopng82432b ##
function mistopng82432b(x:tobject;stranscol,sfeather,slessdata:longint;stransframe:boolean;var xoutbpp:longint;xdata:tstr8;var e:string):boolean;//OK=27jan2021, 20jan2021
label
   //xtranscol: clNone=solid, clTopLeft=pixel(0,0), clwhite/clblack/clred/cllime/clblue=protected transparent colors, else unprotected user transparent color (note: white, black, red, lime, blue, yellow and grey are retained even with a reducer)
   //xfeather: -1=as is, 0=sharp, 1..100px (with dual mode 3x3 or 5x5 blurring)
   //xlessdata: 0=off, 1=subtle reduction, 2=normal reduction, 3=heavy reduction, 4=extra reduction, 5=extreme/damaging reduction
   redo,skipfeather,skipend;
var
   xalpha:tbasicimage;
   ar8,sr8:pcolorrow8;
   sr24:pcolorrow24;
   sr32:pcolorrow32;
   sc8:tcolor8;
   sc24:tcolor24;
   sc32:tcolor32;
   trSAFE,tgSAFE,tbSAFE,xtranscol,tr,tg,tb,int1,int2,int3,int4,dpos,xreducer1,xreducer2,xfeather,p,xcoltype,xi,dbits,xbits,xw,xh,sx,sy:longint;
   fval,byt1:byte;
   lastf2,f0,f1,f2,f3,f4,xrow,str1:tstr8;
   fbpp,flen,flen0,flen1,flen2,flen3,flen4:longint;
   xcollist:array[0..256] of tcolor32;//allow to overrun limit -> we can detect TOO MANY colors error - 19jan2021
   xcollistcount:longint;
   xreducerok,xblur,xmustwritePAL,xmustwritePALA:boolean;
   //## i32 ##
   function i32(xval:longint):longint;//26jan2021, 11jan2021, 11jun2017
   var
      a,b:tint4;
   begin
   //defaults
   a.val:=xval;
   //get
   b.bytes[3]:=a.bytes[0];
   b.bytes[2]:=a.bytes[1];
   b.bytes[1]:=a.bytes[2];
   b.bytes[0]:=a.bytes[3];
   //set
   result:=b.val;
   end;
   //## xaddchunk ##
   function xaddchunk(xname:array of byte;xval:tstr8):boolean;
   label
      skipend;
   var
      e:string;
   begin
   try
   //defaults
   result:=false;
   //check
   if system_debug and (sizeof(xname)<>4) then showbasic('PNG: Invalid chunk name length');
   if not block(xval) then goto skipend;

   //compress -> for "IDAT" chunks only -> must use standard linux "deflate" algorithm - 11jan2021
   if low__comparearray(xname,[uuI,uuD,uuA,uuT]) and (xval.len>=1) and (not low__compress(xval,e)) then goto skipend;

   //get
   xdata.addint4(i32(xval.len));
   xdata.aadd(xname);
   if (xval.len>=1) then xdata.add(xval);
   //.insert name at begining of val and then do crc32 on it - 26jan2021
   xval.ains(xname,0);
   xdata.addint4(i32(low__crc32b(xval)));
   //successful
   result:=true;
   skipend:
   except;end;
   try;bunlockautofree(xval);except;end;
   end;
   //## xaddTEXT ##
   function xaddTEXT(xkeyword,xtext:tstr8):boolean;
   label
      skipend;
   var
      xval:tstr8;
   begin
   try
   //defaults
   result:=false;
   xval:=nil;
   block(xkeyword);
   block(xtext);
   //xkeyword
   if zznil(xkeyword,2150) or (xkeyword.len<=0) then goto skipend;
   if (xkeyword.len>79) then xkeyword.setlen(79);
   low__PNGfilter_textlatin1(xkeyword);
   if (xkeyword.len<=0) then goto skipend;
   //xtext
   low__PNGfilter_textlatin1(xtext);
   //xval
   xval:=bnew_autofree;
   try
   xval.add(xkeyword);
   xval.addbyt1(0);//null sep
   xval.add(xtext);
   except;end;
   //get              "tEXt"
   result:=xaddchunk([llt,uuE,uuX,llt],xval);
   //was: result:=pushb(xdatalen,xdata,xchunkdata('tEXt',xkeyword+#0+xtext));
   skipend:
   except;end;
   try
   bunlockautofree(xkeyword);
   bunlockautofree(xtext);
   except;end;
   end;
   //## xaddcol32 ##
   function xaddcol32(x:tcolor32):byte;
   var
      p:longint;
   begin
   //1st
   if (xcollistcount<=0) then
      begin
      xcollist[0].r:=x.r;
      xcollist[0].g:=x.g;
      xcollist[0].b:=x.b;
      xcollist[0].a:=x.a;
      result:=0;
      xcollistcount:=1;//first item counted - 27jan2021
      exit;
      end;
   //find existing
   for p:=0 to (xcollistcount-1) do if (xcollist[p].r=x.r) and (xcollist[p].g=x.g) and (xcollist[p].b=x.b) and (xcollist[p].a=x.a) then
      begin
      if (p<=255) then result:=p else result:=0;
      exit;
      end;
   //add new
   if (xcollistcount<=high(xcollist)) then
      begin
      xcollist[xcollistcount].r:=x.r;
      xcollist[xcollistcount].g:=x.g;
      xcollist[xcollistcount].b:=x.b;
      xcollist[xcollistcount].a:=x.a;
      if (xcollistcount<=255) then result:=xcollistcount else result:=0;//default 1st item by default
      inc(xcollistcount);
      end;
   end;
   //## xreduce32 ##
   procedure xreduce32;
   const
      xthreshold=50;
   begin
   //.leave these primary colors FULLY intact - 13jan2021
   if ((sc32.r<>255) or (sc32.g<>255) or (sc32.b<>255)) and//white clwhite
      ((sc32.r<>0  ) or (sc32.g<>0  ) or (sc32.b<>0  )) and//black clblack
      ((sc32.r<>255) or (sc32.g<>0  ) or (sc32.b<>0  )) and//red   clred
      ((sc32.r<>0  ) or (sc32.g<>255) or (sc32.b<>0  )) and//lime  clime
      ((sc32.r<>0  ) or (sc32.g<>0  ) or (sc32.b<>255)) and//blue clblue
      ((sc32.r<>tr ) or (sc32.g<>tg ) or (sc32.b<>tb))  then//transparent color if specified - 20jan2021
      begin
      //get
      if (sc32.r>xthreshold) then sc32.r:=(sc32.r div xreducer1)*xreducer1 else sc32.r:=(sc32.r div xreducer2)*xreducer2;
      if (sc32.g>xthreshold) then sc32.g:=(sc32.g div xreducer1)*xreducer1 else sc32.g:=(sc32.g div xreducer2)*xreducer2;
      if (sc32.b>xthreshold) then sc32.b:=(sc32.b div xreducer1)*xreducer1 else sc32.b:=(sc32.b div xreducer2)*xreducer2;
      //restrict
      if (sc32.r=tr) and (sc32.g=tg) and (sc32.b=tb) then//transparent color
         begin
         sc32.r:=trSAFE;
         sc32.g:=tbSAFE;
         sc32.b:=tgSAFE;
         end
      else if (sc32.r=255) and (sc32.g=255) and (sc32.b=255) then//non-white
         begin
         sc32.r:=254;
         sc32.g:=254;
         sc32.b:=254;
         end
      else if (sc32.r=0) and (sc32.g=0) and (sc32.b=0) then//non-black
         begin
         sc32.r:=1;
         sc32.g:=1;
         sc32.b:=1;
         end
      else if (sc32.r=255) and (sc32.g=0) and (sc32.b=0) then//non-red
         begin
         sc32.r:=254;
         sc32.g:=0;
         sc32.b:=0;
         end
      else if (sc32.r=0) and (sc32.g=255) and (sc32.b=0) then//non-green
         begin
         sc32.r:=0;
         sc32.g:=254;
         sc32.b:=0;
         end
      else if (sc32.r=0) and (sc32.g=0) and (sc32.b=255) then//non-blue
         begin
         sc32.r:=0;
         sc32.g:=0;
         sc32.b:=254;
         end;
      end;
   //.leave these alpha values FULLY intact - 13jan2021
   if (sc32.a<>0) then//and (sc32.a<>127) and (sc32.a<>255) then
      begin
      if (sc32.a>xthreshold) then sc32.a:=(sc32.a div xreducer1)*xreducer1 else sc32.a:=(sc32.a div xreducer2)*xreducer2;
      if (sc32.a=0) then sc32.a:=xreducer1;
      end;
   end;
   //## xdeflatesize ##
   function xdeflatesize(x:tstr8):longint;//a value estimate of WHAT it might be if we were to actually compress "x" and return it's size - 16jan2021
   var//Typical way for PNG standard to determine best filter type to use - 16jan2021
      //Note: Tested against actual per filter compression, simple method below
      //      produces PNG images for about 107% larger than per filter compression
      //      checking but with only 21% time taken or 4.76x faster.
      p:longint;
   begin
   result:=0;
   if zzok(x,7010) and (x.len>=1) then
      begin
      for p:=1 to x.len do inc(result,x.pbytes[p-1]);
      end;
   end;
   //## xpaeth ##
   function xpaeth(a,b,c:byte):longint;
   var
      p,pa,pb,pc:longint;
   begin
   //a = left, b=above, c=upper left
   p:=a+b-c;//initial estimate
   pa:=abs(p-a);
   pb:=abs(p-b);
   pc:=abs(p-c);
   if (pa<=pb) and (pa<=pc) then result:=a
   else if (pb<=pc)         then result:=b
   else                          result:=c;
   end;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
xalpha:=nil;
xoutbpp:=8;

//check
if not block(xdata) then exit;
xdata.clear;

//range
sfeather:=frcrange(sfeather,-1,100);//-1=asis, 0=none(sharp), 1..100=feather(Npx/blur)
slessdata:=frcrange(slessdata,0,5);

//init
if not misok82432(x,xbits,xw,xh) then exit;
dbits:=xbits;
xalpha:=misimg8(xw,xh);
lastf2:=bnew;
f0:=bnew;
f1:=bnew;
f2:=bnew;
f3:=bnew;
f4:=bnew;
xrow:=bnew;
str1:=bnew;

//xfeather
xfeather:=sfeather;
xblur:=(xfeather>=1);
//.force sharp feather when a transparent color is specified - 17jan2021
if (stranscol<>clnone) and (xfeather<0) then xfeather:=0;

//slessdata
xreducer1:=slessdata;
xreducer2:=xreducer1+1;
xreducerok:=(xreducer1>=2) or (xreducer2>=2);

//make feather -> the alpha channel -> this takes control of all alpha values - 12jan2021
if not mask__feather2(x,xalpha,sfeather,stranscol,stransframe,xtranscol) then goto skipend;//requires "sfeather" and "stranscol" in their original formats

//xtranscol -> used in this proc for reduce32 (to avoid reducing this particular color)
tr:=-1;
tg:=-1;
tb:=-1;
if (xtranscol<>clnone) then
   begin
   sc24:=low__intrgb(xtranscol);
   tr:=sc24.r;
   tg:=sc24.g;
   tb:=sc24.b;
   if (tr=255) and (tg=255) and (tb=255) then
      begin
      trSAFE:=254;
      tgSAFE:=254;
      tbSAFE:=254;
      end
   else
      begin
      trSAFE:=255;
      tgSAFE:=255;
      tbSAFE:=255;
      end;
   end;

//start with 8bit mode - 19jan2021
dbits:=8;

//start ------------------------------------------------------------------------
redo:
//dbits
if (dbits=8) then
   begin
   if (xcollistcount>256) then dbits:=32;//we tried 8bit mode BUT ended up with more than 256 colors -> switch to 32bit mode instead - 19jan2021
   end
else if (dbits<32) and (xbits=24) and (xfeather>=0) then dbits:=32;
xoutbpp:=dbits;

//reset
xcollistcount:=0;
xmustwritePAL:=false;
xmustwritePALA:=false;
xdata.clear;

//color type
case dbits of
8:xcoltype:=3;//palette based (includes only RGB entries of any number between 1 and 256 entirely dependant on the size of DATA in "PLTE" chunk, need to use "tRNS" which like palette stores JUST the alpha values for each palette entry)
24:xcoltype:=2;//0=greyscale, 1=pallete used, 2=color used, 4=alpha used -> add these together to produce final value - 11jan2021
32:xcoltype:=6;
end;

//header
//was: pushb(xdatalen,xdata,#137 +#80 +#78 +#71 +#13 +#10 +#26 +#10);
xdata.aadd([137,80,78,71,13,10,26,10]);

//IHDR                         //name   width.4     height.4   bitdepth.1  colortype.1 (6=R8,G8,B8,A8)  compressionMethod.1(#0 only = deflate/inflate)  filtermethod.1(#0 only) interlacemethod.1(#0=LR -> TB scanline order)
//was: pushb(xdatalen,xdata,xchunkdata('IHDR', i32(xw)     +i32(xh)   +#8         +char(xcoltype)              +#0                                             +#0                     +#0));
str1.clear;
str1.addint4(i32(xw));
str1.addint4(i32(xh));
str1.addbyt1(8);
str1.addbyt1(xcoltype);
str1.addbyt1(0);
str1.addbyt1(0);
str1.addbyt1(0);
xaddchunk([uuI,uuH,uuD,uuR],str1);
str1.clear;

//text chunks
if not xaddTEXT(bcopystrall('Software'),bcopystrall(programname+' v'+programversion)) then goto skipend;
if not xaddTEXT(bcopystrall('be.png.settings'),bcopystrall(inttostr(stranscol)+'.'+inttostr(sfeather)+'.'+inttostr(slessdata))) then goto skipend;

//scanlines
//was: setlength(xrow, xh * (1+(xw*(dbits div 8))) );
xrow.setlen( xh * (1+(xw*(dbits div 8))) );
//.filter support
fbpp:=dbits div 8;//bytes per pixel
flen:=(xw*fbpp);//size of row excluding leading filter byte
//was: setlength(f0,flen);
//was: setlength(f1,flen);
//was: setlength(f2,flen);
//was: setlength(lastf2,flen);for p:=1 to flen do lastf2[p]:=#0;
//was: setlength(f3,flen);
//was: setlength(f4,flen);
f0.setlen(flen);
f1.setlen(flen);
f2.setlen(flen);
lastf2.setlen(flen);for p:=0 to (flen-1) do lastf2.pbytes[p]:=0;
f3.setlen(flen);
f4.setlen(flen);

xi:=0;
for sy:=0 to (xh-1) do
begin
if not misscan8(xalpha,sy,ar8) then goto skipend;
if not misscan82432(x,sy,sr8,sr24,sr32) then goto skipend;
inc(xi);xrow.pbytes[xi-1]:=0;//filter subtype=none (#0)
dpos:=xi;

//.32 => 32
if (xbits=32) and (dbits=32) then
   begin
   if xreducerok then
      begin
      for sx:=0 to (xw-1) do
      begin
      sc32:=sr32[sx];
      sc32.a:=ar8[sx];
      xreduce32;
      inc(xi);xrow.pbytes[xi-1]:=sc32.r;
      inc(xi);xrow.pbytes[xi-1]:=sc32.g;
      inc(xi);xrow.pbytes[xi-1]:=sc32.b;
      inc(xi);xrow.pbytes[xi-1]:=sc32.a;
      end;//sx
      end
   else
      begin
      for sx:=0 to (xw-1) do
      begin
      sc32:=sr32[sx];
      sc32.a:=ar8[sx];
      inc(xi);xrow.pbytes[xi-1]:=sc32.r;
      inc(xi);xrow.pbytes[xi-1]:=sc32.g;
      inc(xi);xrow.pbytes[xi-1]:=sc32.b;
      inc(xi);xrow.pbytes[xi-1]:=sc32.a;
      end;//sx
      end;
   end
//.32 => 24
else if (xbits=32) and (dbits=24) then
   begin
   if xreducerok then
      begin
      for sx:=0 to (xw-1) do
      begin
      sc32:=sr32[sx];
      xreduce32;
      inc(xi);xrow.pbytes[xi-1]:=sc32.r;
      inc(xi);xrow.pbytes[xi-1]:=sc32.g;
      inc(xi);xrow.pbytes[xi-1]:=sc32.b;
      end;//sx
      end
   else
      begin
      for sx:=0 to (xw-1) do
      begin
      sc32:=sr32[sx];
      inc(xi);xrow.pbytes[xi-1]:=sc32.r;
      inc(xi);xrow.pbytes[xi-1]:=sc32.g;
      inc(xi);xrow.pbytes[xi-1]:=sc32.b;
      end;//sx
      end;
   end
//.32 => 8
else if (xbits=32) and (dbits=8) then
   begin
   xmustwritePAL:=true;
   xmustwritePALA:=true;
   for sx:=0 to (xw-1) do
   begin
   sc32:=sr32[sx];
   sc32.a:=ar8[sx];
   if xreducerok then xreduce32;
   inc(xi);xrow.pbytes[xi-1]:=xaddcol32(sc32);
   end;//sx
   //check TOO MANY colors error - 19jan2021
   if (xcollistcount>256) then goto redo;
   end

//.24 => 32
else if (xbits=24) and (dbits=32) then
   begin
   for sx:=0 to (xw-1) do
   begin
   sc24:=sr24[sx];
   sc32.r:=sc24.r;
   sc32.g:=sc24.g;
   sc32.b:=sc24.b;
   sc32.a:=ar8[sx];
   if xreducerok then xreduce32;
   inc(xi);xrow.pbytes[xi-1]:=sc32.r;
   inc(xi);xrow.pbytes[xi-1]:=sc32.g;
   inc(xi);xrow.pbytes[xi-1]:=sc32.b;
   inc(xi);xrow.pbytes[xi-1]:=sc32.a;
   end;//sx
   end
//.24 => 24
else if (xbits=24) and (dbits=24) then
   begin
   if xreducerok then
      begin
      for sx:=0 to (xw-1) do
      begin
      sc24:=sr24[sx];
      sc32.r:=sc24.r;
      sc32.g:=sc24.g;
      sc32.b:=sc24.b;
      sc32.a:=255;
      xreduce32;
      inc(xi);xrow.pbytes[xi-1]:=sc32.r;
      inc(xi);xrow.pbytes[xi-1]:=sc32.g;
      inc(xi);xrow.pbytes[xi-1]:=sc32.b;
      end;//sx
      end
   else
      begin
      for sx:=0 to (xw-1) do
      begin
      sc24:=sr24[sx];
      sc32.r:=sc24.r;
      sc32.g:=sc24.g;
      sc32.b:=sc24.b;
      sc32.a:=255;
      inc(xi);xrow.pbytes[xi-1]:=sc32.r;
      inc(xi);xrow.pbytes[xi-1]:=sc32.g;
      inc(xi);xrow.pbytes[xi-1]:=sc32.b;
      end;//sx
      end;
   end
//.24 => 8
else if (xbits=24) and (dbits=8) then
   begin
   xmustwritePAL:=true;
   xmustwritePALA:=(xfeather>=1) or ((xfeather>=0) and (stranscol<>clnone));//specially for 8bit palette images -> required for alpha palette addon values - 13jan2021
   for sx:=0 to (xw-1) do
   begin
   sc24:=sr24[sx];
   sc32.r:=sc24.r;
   sc32.g:=sc24.g;
   sc32.b:=sc24.b;
   sc32.a:=ar8[sx];
   if xreducerok then xreduce32;
   inc(xi);xrow.pbytes[xi-1]:=xaddcol32(sc32);
   end;//sx
   //check TOO MANY colors error - 19jan2021
   if (xcollistcount>256) then goto redo;
   end

//.8 => 32
else if (xbits=8) and (dbits=32) then
   begin
   for sx:=0 to (xw-1) do
   begin
   sc32.r:=sr8[sx];
   sc32.g:=sc32.r;
   sc32.b:=sc32.r;
   sc32.a:=ar8[sx];
   if xreducerok then xreduce32;
   inc(xi);xrow.pbytes[xi-1]:=sc32.r;
   inc(xi);xrow.pbytes[xi-1]:=sc32.g;
   inc(xi);xrow.pbytes[xi-1]:=sc32.b;
   inc(xi);xrow.pbytes[xi-1]:=sc32.a;
   end;//sx
   end
//.8 => 24
else if (xbits=8) and (dbits=24) then
   begin
   for sx:=0 to (xw-1) do
   begin
   sc32.r:=sr8[sx];
   sc32.g:=sc32.r;
   sc32.b:=sc32.r;
   sc32.a:=255;
   if xreducerok then xreduce32;
   inc(xi);xrow.pbytes[xi-1]:=sc32.r;
   inc(xi);xrow.pbytes[xi-1]:=sc32.g;
   inc(xi);xrow.pbytes[xi-1]:=sc32.b;
   end;//sx
   end
//.8 => 8
else if (xbits=8) and (dbits=8) then
   begin
   xmustwritePAL:=true;
   xmustwritePALA:=(xfeather>=1) or ((xfeather>=0) and (stranscol<>clnone));//specially for 8bit palette images -> required for alpha palette addon values - 13jan2021
   for sx:=0 to (xw-1) do
   begin
   sc32.r:=sr8[sx];
   sc32.g:=sc32.r;
   sc32.b:=sc32.r;
   sc32.a:=ar8[sx];
   if xreducerok then xreduce32;
   inc(xi);xrow.pbytes[xi-1]:=xaddcol32(sc32);
   end;//sx
   end
//.?
else break;

//sample all filters and use the one that compresses the best
//.f0
//was: for p:=1 to flen do f0[p]:=xrow[dpos+p];
//for p:=1 to flen do f0.pbytes[p-1]:=xrow.pbytes[dpos+(p-1)];
for p:=1 to flen do f0.pbytes[p-1]:=xrow.pbytes[dpos+p-1];
flen0:=xdeflatesize(f0);

//.f1 -> sub -> write difference in pixels in horizontal lines
for p:=1 to flen do
begin
int1:=xrow.pbytes[dpos+p-1];
if ((p-fbpp)>=1) then int2:=xrow.pbytes[dpos+p-fbpp-1] else int2:=0;
int1:=int1-int2;
if (int1<0) then inc(int1,256);
f1.pbytes[p-1]:=int1;
end;//p
flen1:=xdeflatesize(f1);

//.f2 - up -> write difference in pixels in vertical lines
for p:=1 to flen do
begin
int2:=lastf2.pbytes[p-1];
int1:=xrow.pbytes[dpos+p-1];
int1:=int1-int2;
if (int1<0) then inc(int1,256);
f2.pbytes[p-1]:=int1;
end;//p
flen2:=xdeflatesize(f2);

//.f3 - average
for p:=1 to flen do
begin
int3:=lastf2.pbytes[p-1];
if ((p-fbpp)>=1) then int2:=xrow.pbytes[dpos+p-fbpp-1] else int2:=0;
int1:=xrow.pbytes[dpos+p-1];
int1:=int1-trunc((int2+int3)/2);
if (int1<0) then inc(int1,256);
f3.pbytes[p-1]:=int1;
end;//p
flen3:=xdeflatesize(f3);

//.f4 - paeth
for p:=1 to flen do
begin
if ((p-fbpp)>=1) then int4:=lastf2.pbytes[p-fbpp-1] else int4:=0;
int3:=lastf2.pbytes[p-1];
if ((p-fbpp)>=1) then int2:=xrow.pbytes[dpos+p-fbpp-1] else int2:=0;
int1:=xrow.pbytes[dpos+p-1];
int1:=int1-xpaeth(int2,int3,int4);
if (int1<0) then inc(int1,256);
f4.pbytes[p-1]:=int1;
end;//p
flen4:=xdeflatesize(f4);

//.sync lastf2 -> do here BEFORE xrow is modified below - 14jan2021
for p:=1 to flen do lastf2.pbytes[p-1]:=xrow.pbytes[dpos+p-1];

//.write filter back into row
int1:=flen0;
int2:=0;
//.1
if (flen1<int1) then
   begin
   int1:=flen1;
   int2:=1;
   end;
//.2
if (flen2<int1) then
   begin
   int1:=flen2;
   int2:=2;
   end;
//.3
if (flen3<int1) then
   begin
   int1:=flen3;
   int2:=3;
   end;
//.4
if (flen4<int1) then
   begin
   int1:=flen4;
   int2:=4;
   end;

//.write
case int2 of
1:begin
   xrow.pbytes[dpos-1]:=1;
   for p:=1 to flen do xrow.pbytes[dpos+p-1]:=f1.pbytes[p-1];
   end;
2:begin
   xrow.pbytes[dpos-1]:=2;
   for p:=1 to flen do xrow.pbytes[dpos+p-1]:=f2.pbytes[p-1];
   end;
3:begin
   xrow.pbytes[dpos-1]:=3;
   for p:=1 to flen do xrow.pbytes[dpos+p-1]:=f3.pbytes[p-1];
   end;
4:begin
   xrow.pbytes[dpos-1]:=4;
   for p:=1 to flen do xrow.pbytes[dpos+p-1]:=f4.pbytes[p-1];
   end;
end;

end;//sy

//.PLTE - color palette (RGB sets only) for 8bit images -> must preceed any "IDAT"
if xmustwritePAL then
   begin
   str1.clear;
   if (xcollistcount>=1) then
      begin
      //was: setlength(str1,xcollistcount*3);
      str1.setlen(xcollistcount*3);
      xi:=0;
      for p:=0 to (xcollistcount-1) do
      begin
      inc(xi);str1.pbytes[xi-1]:=xcollist[p].r;
      inc(xi);str1.pbytes[xi-1]:=xcollist[p].g;
      inc(xi);str1.pbytes[xi-1]:=xcollist[p].b;
      end;//p
      end;
   //add
   //was: pushb(xdatalen,xdata,xchunkdata('PLTE',str1));
   xaddchunk([uuP,uuL,uuT,uuE],str1);
   str1.clear;
   end;

//.tRNS - color palette alpha's (A bytes only from the RGBA color list) for 8bit images -> must come after "PLTE" and before any "IDAT" chunks
if xmustwritePALA then
   begin
   str1.clear;
   if (xcollistcount>=1) then
      begin
      //was: setlength(str1,xcollistcount);
      str1.setlen(xcollistcount);
      xi:=0;
      for p:=0 to (xcollistcount-1) do
      begin
      inc(xi);str1.pbytes[xi-1]:=xcollist[p].a;//alpha values (1 byte) only - 11jan2021
      end;//p
      end;
   //add
   //was: pushb(xdatalen,xdata,xchunkdata('tRNS',str1));
   xaddchunk([llt,uuR,uuN,uuS],str1);
   str1.clear;
   end;

//.IDAT
//was: pushb(xdatalen,xdata,xchunkdata('IDAT',xrow));
xaddchunk([uuI,uuD,uuA,uuT],xrow);

//IEND
//was: pushb(xdatalen,xdata,xchunkdata('IEND',''));
str1.clear;
xaddchunk([uuI,uuE,uuN,uuD],str1);//27jan2021
//successful
result:=true;
skipend:
except;end;
try
freeobj(@xalpha);
bfree(lastf2);
bfree(f0);
bfree(f1);
bfree(f2);
bfree(f3);
bfree(f4);
bfree(xrow);
bfree(str1);
except;end;
try
if (not result) and zzok(x,7011) then xdata.clear;
bunlockautofree(xdata);
except;end;
end;
//## misfrompng82432 ##
function misfrompng82432(s:tobject;sbackcol:longint;sdata:tstr8;var e:string):boolean;//26jan2021
var
   stranscol,sfeather,slessdata:longint;
   shadsettings:boolean;
begin
try;result:=misfrompng82432ex(s,sbackcol,stranscol,sfeather,slessdata,shadsettings,sdata,e);except;end;
end;
//## misfrompng82432ex ##
function misfrompng82432ex(s:tobject;sbackcol:longint;var stranscol,sfeather,slessdata:longint;var shadsettings:boolean;sdata:tstr8;var e:string):boolean;//OK=27jan2021, 23jan2021, 21jan2021
label
   //sbackcol: optional background color -> if not "clnone" then image is render onto background color primarily to display any feathering - 20jan2021
   skipfeather,skipend;
var
   sdata64:tstr8;//decoded base64 version of "sdata" -> automatic and optionally used to keep "sdata" unchanged
   srows8:pcolorrows8;
   srows24:pcolorrows24;
   srows32:pcolorrows32;
   ir8,sr8:pcolorrow8;
   ir24,sr24:pcolorrow24;
   sr32:pcolorrow32;
   sc8,bc8:tcolor8;
   sc24,bc24:tcolor24;
   sc32:tcolor32;
   xpos,xbitdepth,spos,int1,int2,int3,int4,p,xcoltype,sbits,xbits,sw,sh,xw,xh,sx,sy:longint;
   n,v,xdata,xval,lastfd,fd,str1,str2,str3:tstr8;
   fbpp,flen:longint;
   xnam:array[0..3] of byte;
   xcollist:array[0..255] of tcolor32;
   xcollistcount:longint;
   xtransparent,sbackcolok,sdataok:boolean;
   //## fi32 ##
   function fi32(xval:longint):longint;//26jan2021, 11jan2021, 11jun2017
   var
      a,b:tint4;
   begin
   //defaults
   result:=0;
   //get
   a.val:=xval;
   b.bytes[0]:=a.bytes[3];
   b.bytes[1]:=a.bytes[2];
   b.bytes[2]:=a.bytes[1];
   b.bytes[3]:=a.bytes[0];
   //set
   result:=b.val;
   end;
   //## xpullchunk ##
   function xpullchunk(var xname:array of byte;xdata:tstr8):boolean;
   label//Chunk structure: "i32(length(xdata))+xname+xdata+i32(misc.crc32b(xname+xdata))"
      skipend;
   var
      v,xlen:longint;
      e:string;
   begin
   try
   //defaults
   result:=false;
   //check
   if (not block(xdata)) or (sizeof(xname)<>4) then goto skipend;
   xdata.clear;
   xname[0]:=0;
   xname[1]:=0;
   xname[2]:=0;
   xname[3]:=0;
   //chunk length
   if sdataok then xlen:=fi32(sdata.int4[spos-1]) else xlen:=fi32(sdata64.int4[spos-1]);
   inc(spos,4);
   if (xlen<0) then goto skipend;
   //chunk name
   //was: if sdataok then xname:=copy(sdata,spos,4) else xname:=copy(sdata64,spos,4);
   if sdataok then
      begin
      xname[0]:=sdata.byt1[spos-1+0];
      xname[1]:=sdata.byt1[spos-1+1];
      xname[2]:=sdata.byt1[spos-1+2];
      xname[3]:=sdata.byt1[spos-1+3];
      end
   else
      begin
      xname[0]:=sdata64.byt1[spos-1+0];
      xname[1]:=sdata64.byt1[spos-1+1];
      xname[2]:=sdata64.byt1[spos-1+2];
      xname[3]:=sdata64.byt1[spos-1+3];
      end;
   inc(spos,4);
   //chunk data
   if (xlen>=1) then
      begin
      //was: if sdataok then xdata:=copy(sdata,spos,xlen) else xdata:=copy(sdata64,spos,xlen);
      if sdataok then xdata.add3(sdata,spos-1,xlen) else xdata.add3(sdata64,spos-1,xlen);
      end;
   if (xdata.len<>xlen) then goto skipend;
   inc(spos,xlen+4);//step over trailing crc32(4b)
   //successful
   result:=true;
   skipend:
   except;end;
   try;bunlockautofree(xdata);except;end;
   end;
   //## xpaeth ##
   function xpaeth(a,b,c:byte):longint;
   var
      p,pa,pb,pc:longint;
   begin
   //a = left, b=above, c=upper left
   p:=a+b-c;//initial estimate
   pa:=abs(p-a);
   pb:=abs(p-b);
   pc:=abs(p-c);
   if (pa<=pb) and (pa<=pc) then result:=a
   else if (pb<=pc)         then result:=b
   else                          result:=c;
   end;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
xtransparent:=false;
sdataok:=true;
n:=nil;
v:=nil;
xdata:=nil;
xval:=nil;
lastfd:=nil;
fd:=nil;
str1:=nil;
str2:=nil;
str3:=nil;
sdata64:=nil;
//.return values - 21jan2021
shadsettings:=false;
stranscol:=clnone;
sfeather:=-1;//asis
slessdata:=0;
//check
if not block(sdata) then exit;
//init
if not misok82432(s,sbits,sw,sh) then
   begin
   if (sw<1) then sw:=1;
   if (sh<1) then sh:=1;
   missize2(s,sw,sh,true);
   if not misok82432(s,sbits,sw,sh) then goto skipend;
   end;
spos:=1;
n:=bnew;
v:=bnew;
xdata:=bnew;
xval:=bnew;
lastfd:=bnew;
fd:=bnew;
str1:=bnew;
str2:=bnew;
str3:=bnew;

//.palette
for p:=0 to high(xcollist) do
begin
xcollist[p].r:=0;
xcollist[p].g:=0;
xcollist[p].b:=0;
xcollist[p].a:=255;//fully solid
end;//p

//.sbackcol - 16jan2021
sbackcolok:=(sbackcol<>clnone);
if sbackcolok then
   begin
   bc24:=low__intrgb(sbackcol);
   bc8:=bc24.r;
   if (bc24.g>bc8) then bc8:=bc24.g;
   if (bc24.b>bc8) then bc8:=bc24.b;
   end;

//header
//was: if (copy(sdata,1,8)<>(#137 +#80 +#78 +#71 +#13 +#10 +#26 +#10)) then
if not sdata.asame3(0,[137,80,78,71,13,10,26,10],true) then
   begin
   //switch to base64 encoded text mode
   //was: if (comparetext(copy(sdata,1,4),'b64:')=0) then
   if sdata.asame3(0,[98,54,52,58],true) then
      begin
      sdataok:=false;
      if zznil(sdata64,2151) then sdata64:=bnew;
      //was: sdata64:=copy(sdata,5,length(sdata));
      //was: sdata64:=low__fromb64b(sdata64);
      sdata64.add3(sdata,4,sdata.len);
      if not low__fromb64(sdata64,sdata64,e) then goto skipend;
      end
   else
      begin
      sdataok:=false;
      if zznil(sdata64,2152) then sdata64:=bnew;
      //was: sdata64:=low__fromb64b(sdata);
      if not low__fromb64(sdata,sdata64,e) then goto skipend;
      end;
   //check again
   //was: if (copy(sdata64,1,8)<>(#137 +#80 +#78 +#71 +#13 +#10 +#26 +#10)) then
   if not sdata64.asame3(0,[137,80,78,71,13,10,26,10],true) then
      begin
      e:=gecUnknownformat;
      goto skipend;
      end;
   end;
spos:=9;

//IHDR                         //name   width.4     height.4   bitdepth.1  colortype.1 (6=R8,G8,B8,A8)  compressionMethod.1(#0 only = deflate/inflate)  filtermethod.1(#0 only) interlacemethod.1(#0=LR -> TB scanline order)
//pushb(xdatalen,xdata,xchunkdata('IHDR', i32(xw)     +i32(xh)   +#8         +char(xcoltype)              +#0                                             +#0                     +#0));

//was: if (not xpullchunk(xnam,xval)) or (comparetext(xnam,'ihdr')<>0) or (length(xval)<13) then
if (not xpullchunk(xnam,xval)) or (not low__comparearray(xnam,[uuI,uuH,uuD,uuR])) or (xval.len<13) then
   begin
   e:=gecDatacorrupt;
   goto skipend;
   end;
xw:=fi32(xval.int4[1-1]);//1..4
xh:=fi32(xval.int4[5-1]);//5..8
if (xw<=0) or (xh<=0) then
   begin
   e:=gecDatacorrupt;
   goto skipend;
   end
else
   begin
   //size "s" to match datastream image
   if not missize2(s,xw,xh,true) then goto skipend;
   sw:=misw(s);
   sh:=mish(s);
   if (sw<>xw) or (sh<>xh) then goto skipend;
   end;
xbitdepth:=xval.byt1[9-1];
if (xbitdepth<>8) then//we support bit depth of 8bits only
   begin
   e:=gecUnsupportedFormat;
   goto skipend;
   end;
xcoltype:=xval.byt1[10-1];
if (xval.byt1[11-1]<>0) or (xval.byt1[12-1]<>0) or (xval.byt1[13-1]<>0) then
   begin
   e:=gecUnsupportedFormat;
   goto skipend;
   end;

//read remaining chunks
while true do
begin
if not xpullchunk(xnam,xval) then
   begin
   e:=gecDataCorrupt;
   goto skipend;
   end;

//.iend
//was: if      (comparetext(xnam,'iend')=0) then break
if low__comparearray(xnam,[uuI,uuE,uuN,uuD]) then break
//.text
//was: else if (comparetext(xnam,'text')=0) then
else if low__comparearray(xnam,[uuT,uuE,uuX,uuT]) then
   begin
   low__PNGfilter_nullsplit(xval,true,n,v);
   if low__comparetext(n.text,'be.png.settings') then low__PNGfilter_fromsettings(v,stranscol,sfeather,slessdata,shadsettings);
   end
//.idat
else if low__comparearray(xnam,[uuI,uuD,uuA,uuT]) then xdata.add(xval)//was: pushb(xdatalen,xdata,xval)
//.plte
else if low__comparearray(xnam,[uuP,uuL,uuT,uuE]) then
   begin
   int1:=frcrange(xval.len div 3,0,1+high(xcollist));
   if (int1>=1) then
      begin
      int2:=1;
      for p:=0 to (int1-1) do
      begin
      xcollist[p].r:=xval.pbytes[int2+0-1];
      xcollist[p].g:=xval.pbytes[int2+1-1];
      xcollist[p].b:=xval.pbytes[int2+2-1];
      inc(int2,3);
      end;//p
      end;//int1
   end
//.trns
else if low__comparearray(xnam,[uuT,uuR,uuN,uuS]) then
   begin
   int1:=frcrange(xval.len,0,1+high(xcollist));
   if (int1>=1) then
      begin
      for p:=0 to (int1-1) do xcollist[p].a:=xval.pbytes[p];
      end;//int1
   end;
end;//while

//.finalise
//was: pushb(xdatalen,xdata,'');
xval.clear;
//.decompress "xdata"
if ( (xdata.len>=1) and (not low__decompress(xdata,e)) ) or (xdata.len<=0) then
   begin
   e:=gecDataCorrupt;
   goto skipend;
   end;

//check datalen matches expected datalen ---------------------------------------
//   Color   Allowed     Interpretation
//   Type    Bit Depths
//   0       1,2,4,8,16  Each pixel is a grayscale sample.
//   2       8,16        Each pixel is an R,G,B triple.
//   3       1,2,4,8     Each pixel is a palette index;
//                       a PLTE chunk must appear.
//   4       8,16        Each pixel is a grayscale sample,
//                       followed by an alpha sample.
//   6       8,16        Each pixel is an R,G,B triple,
//                       followed by an alpha sample.
case xcoltype of
0:xbits:=8;
2:xbits:=24;
3:xbits:=8;
4:xbits:=16;
6:xbits:=32;
end;

if ( (xh * (1+(xw*(xbits div 8))) ) > xdata.len ) then
   begin
   e:=gecDataCorrupt;
   goto skipend;
   end;

//scanlines
//.filter support
fbpp:=xbits div 8;//bytes per pixel
flen:=(xw*fbpp);//size of row excluding leading filter byte
//was: setlength(fd,flen);
fd.setlen(flen);
//was: setlength(lastfd,flen);for p:=1 to flen do lastfd[p]:=#0;
lastfd.setlen(flen);for p:=1 to flen do lastfd.pbytes[p-1]:=0;

for sy:=0 to (xh-1) do
begin
if not misscan82432(s,sy,sr8,sr24,sr32) then goto skipend;
xpos:=1+(sy*(1+flen));

//.unscramble filter row "filtertype.1 + scanline"
case xdata.pbytes[xpos-1] of
0:;//none -> nothing to do
1:begin//.f1 -> sub -> write difference in pixels in horizontal lines
   for p:=1 to flen do
   begin
   int1:=xdata.pbytes[xpos+p-1];
   if ((p-fbpp)>=1) then int2:=xdata.pbytes[xpos+p-fbpp-1] else int2:=0;
   int1:=int1+int2;
   if (int1>255) then dec(int1,256);
   xdata.pbytes[xpos+p-1]:=int1;
   end;//p
   end;
2:begin//.f2 - up -> write difference in pixels in vertical lines
   for p:=1 to flen do
   begin
   int2:=lastfd.pbytes[p-1];
   int1:=xdata.pbytes[xpos+p-1];
   int1:=int1+int2;
   if (int1>255) then dec(int1,256);
   xdata.pbytes[xpos+p-1]:=int1;
   end;//p
   end;
3:begin//.f3 - average
   for p:=1 to flen do
   begin
   int3:=lastfd.pbytes[p-1];
   if ((p-fbpp)>=1) then int2:=xdata.pbytes[xpos+p-fbpp-1] else int2:=0;
   int1:=xdata.pbytes[xpos+p-1];
   int1:=int1+trunc((int2+int3)/2);
   if (int1>255) then dec(int1,256);
   xdata.pbytes[xpos+p-1]:=int1;
   end;//p
   end;
4:begin
   //.f4 - paeth
   for p:=1 to flen do
   begin
   if ((p-fbpp)>=1) then int4:=lastfd.pbytes[p-fbpp-1] else int4:=0;
   int3:=lastfd.pbytes[p-1];
   if ((p-fbpp)>=1) then int2:=xdata.pbytes[xpos+p-fbpp-1] else int2:=0;
   int1:=xdata.pbytes[xpos+p-1];
   int1:=int1+xpaeth(int2,int3,int4);
   if (int1>255) then dec(int1,256);
   xdata.pbytes[xpos+p-1]:=int1;
   end;//p
   end;
else
   begin
   e:=gecDatacorrupt;
   goto skipend;
   end;
end;//case

//.32 => 32
if (xbits=32) and (sbits=32) then
   begin
   if sbackcolok then//destructive preview mode -> transparency can't be reliabled upon to be maintained -> for viewing/previewing purposes only - 20jan2021
      begin
      for sx:=0 to (xw-1) do
      begin
      int1:=xdata.pbytes[xpos+4-1];
      sc32.r:=((xdata.pbytes[xpos+1-1]*int1)+(bc24.r*(255-int1))) div 255;
      sc32.g:=((xdata.pbytes[xpos+2-1]*int1)+(bc24.g*(255-int1))) div 255;
      sc32.b:=((xdata.pbytes[xpos+3-1]*int1)+(bc24.b*(255-int1))) div 255;
      if (int1=0) then xtransparent:=true;
      sc32.a:=255;
      sr32[sx]:=sc32;
      inc(xpos,4);
      end;//sx
      end
   else
      begin
      for sx:=0 to (xw-1) do
      begin
      sc32.r:=xdata.pbytes[xpos+1-1];
      sc32.g:=xdata.pbytes[xpos+2-1];
      sc32.b:=xdata.pbytes[xpos+3-1];
      sc32.a:=xdata.pbytes[xpos+4-1];
      if (sc32.a=0) then xtransparent:=true;//17jan2021
      sr32[sx]:=sc32;
      inc(xpos,4);
      end;//sx
      end;
   end
//.32 => 24
else if (xbits=32) and (sbits=24) then
   begin
   if sbackcolok then//destructive preview mode -> transparency can't be reliabled upon to be maintained -> for viewing/previewing purposes only - 20jan2021
      begin
      for sx:=0 to (xw-1) do
      begin
      int1:=xdata.pbytes[xpos+4-1];
      sc24.r:=((xdata.pbytes[xpos+1-1]*int1)+(bc24.r*(255-int1))) div 255;
      sc24.g:=((xdata.pbytes[xpos+2-1]*int1)+(bc24.g*(255-int1))) div 255;
      sc24.b:=((xdata.pbytes[xpos+3-1]*int1)+(bc24.b*(255-int1))) div 255;
      if (int1=0) then xtransparent:=true;
      sr24[sx]:=sc24;
      inc(xpos,4);
      end;//sx
      end
   else
      begin
      for sx:=0 to (xw-1) do
      begin
      sc24.r:=xdata.pbytes[xpos+1-1];
      sc24.g:=xdata.pbytes[xpos+2-1];
      sc24.b:=xdata.pbytes[xpos+3-1];
      if (xdata.pbytes[xpos+4-1]=0) then xtransparent:=true;//17jan2021
      sr24[sx]:=sc24;
      inc(xpos,4);
      end;//sx
      end;
   end
//.32 => 8
else if (xbits=32) and (sbits=8) then
   begin
   if sbackcolok then//destructive preview mode -> transparency can't be reliabled upon to be maintained -> for viewing/previewing purposes only - 20jan2021
      begin
      for sx:=0 to (xw-1) do
      begin
      int1:=xdata.pbytes[xpos+4-1];
      sc24.r:=xdata.pbytes[xpos+1-1];
      sc24.g:=xdata.pbytes[xpos+2-1];
      sc24.b:=xdata.pbytes[xpos+3-1];
      if (sc24.g>sc24.r) then sc24.r:=sc24.g;
      if (sc24.b>sc24.r) then sc24.r:=sc24.b;
      sc24.r:=((sc24.r*int1)+(bc8*(255-int1))) div 255;
      if (int1=0) then xtransparent:=true;
      sr8[sx]:=sc24.r;
      inc(xpos,4);
      end;//sx
      end
   else
      begin
      for sx:=0 to (xw-1) do
      begin
      sc24.r:=xdata.pbytes[xpos+1-1];
      sc24.g:=xdata.pbytes[xpos+2-1];
      sc24.b:=xdata.pbytes[xpos+3-1];
      if (sc24.g>sc24.r) then sc24.r:=sc24.g;
      if (sc24.b>sc24.r) then sc24.r:=sc24.b;
      if (xdata.pbytes[xpos+4-1]=0) then xtransparent:=true;//17jan2021
      sr8[sx]:=sc24.r;
      inc(xpos,4);
      end;//sx
      end;
   end

//.24 => 32
else if (xbits=24) and (sbits=32) then
   begin
   for sx:=0 to (xw-1) do
   begin
   sc32.r:=xdata.pbytes[xpos+1-1];
   sc32.g:=xdata.pbytes[xpos+2-1];
   sc32.b:=xdata.pbytes[xpos+3-1];
   sc32.a:=255;//fully solid
   sr32[sx]:=sc32;
   inc(xpos,3);
   end;//sx
   end
//.24 => 24
else if (xbits=24) and (sbits=24) then
   begin
   for sx:=0 to (xw-1) do
   begin
   sc24.r:=xdata.pbytes[xpos+1-1];
   sc24.g:=xdata.pbytes[xpos+2-1];
   sc24.b:=xdata.pbytes[xpos+3-1];
   sr24[sx]:=sc24;
   inc(xpos,3);
   end;//sx
   end
//.24 => 8
else if (xbits=32) and (sbits=8) then
   begin
   for sx:=0 to (xw-1) do
   begin
   sc24.r:=xdata.pbytes[xpos+1-1];
   sc24.g:=xdata.pbytes[xpos+2-1];
   sc24.b:=xdata.pbytes[xpos+3-1];
   if (sc24.g>sc24.r) then sc24.r:=sc24.g;
   if (sc24.b>sc24.r) then sc24.r:=sc24.b;
   sr8[sx]:=sc24.r;
   inc(xpos,3);
   end;//sx
   end

//.8 => 32
else if (xbits=8) and (sbits=32) then
   begin
   if sbackcolok then//destructive preview mode -> transparency can't be reliabled upon to be maintained -> for viewing/previewing purposes only - 20jan2021
      begin
      for sx:=0 to (xw-1) do
      begin
      sc32:=xcollist[xdata.pbytes[xpos+1-1]];
      int1:=sc32.a;
      sc32.r:=((sc32.r*int1)+(bc24.r*(255-int1))) div 255;
      sc32.g:=((sc32.g*int1)+(bc24.g*(255-int1))) div 255;
      sc32.b:=((sc32.b*int1)+(bc24.b*(255-int1))) div 255;
      sc32.a:=255;
      if (int1=0) then xtransparent:=true;
      sr32[sx]:=sc32;
      inc(xpos,1);
      end;//sx
      end
   else
      begin
      for sx:=0 to (xw-1) do
      begin
      sc32:=xcollist[xdata.pbytes[xpos+1-1]];
      if (sc32.a=0) then xtransparent:=true;//17jan2021
      sr32[sx]:=sc32;
      inc(xpos,1);
      end;//sx
      end;
   end
//.8 => 24
else if (xbits=8) and (sbits=24) then
   begin
   if sbackcolok then//destructive preview mode -> transparency can't be reliabled upon to be maintained -> for viewing/previewing purposes only - 20jan2021
      begin
      for sx:=0 to (xw-1) do
      begin
      sc32:=xcollist[xdata.pbytes[xpos+1-1]];
      int1:=sc32.a;
      sc24.r:=((sc32.r*int1)+(bc24.r*(255-int1))) div 255;
      sc24.g:=((sc32.g*int1)+(bc24.g*(255-int1))) div 255;
      sc24.b:=((sc32.b*int1)+(bc24.b*(255-int1))) div 255;
      if (int1=0) then xtransparent:=true;
      sr24[sx]:=sc24;
      inc(xpos,1);
      end;//sx
      end
   else
      begin
      for sx:=0 to (xw-1) do
      begin
      sc32:=xcollist[xdata.pbytes[xpos+1-1]];
      sc24.r:=sc32.r;
      sc24.g:=sc32.g;
      sc24.b:=sc32.b;
      if (sc32.a=0) then xtransparent:=true;//17jan2021
      sr24[sx]:=sc24;
      inc(xpos,1);
      end;//sx
      end;
   end
//.8 => 8
else if (xbits=8) and (sbits=8) then
   begin
   if sbackcolok then//destructive preview mode -> transparency can't be reliabled upon to be maintained -> for viewing/previewing purposes only - 20jan2021
      begin
      for sx:=0 to (xw-1) do
      begin
      sc32:=xcollist[xdata.pbytes[xpos+1-1]];
      int1:=sc32.a;
      if (sc32.g>sc32.r) then sc32.r:=sc32.g;
      if (sc32.b>sc32.r) then sc32.r:=sc32.b;
      sc32.r:=((sc32.r*int1)+(bc8*(255-int1))) div 255;
      if (int1=0) then xtransparent:=true;
      sr8[sx]:=sc32.r;
      inc(xpos,1);
      end;//sx
      end
   else
      begin
      for sx:=0 to (xw-1) do
      begin
      sc32:=xcollist[xdata.pbytes[xpos+1-1]];
      if (sc32.g>sc32.r) then sc32.r:=sc32.g;
      if (sc32.b>sc32.r) then sc32.r:=sc32.b;
      if (sc32.a=0) then xtransparent:=true;//17jan2021
      sr8[sx]:=sc32.r;
      inc(xpos,1);
      end;//sx
      end;
   end
//.?
else break;


//.sync lastf2 -> do here BEFORE xrow is modified below - 14jan2021
xpos:=1+(sy*(1+flen));
for p:=1 to flen do lastfd.pbytes[p-1]:=xdata.pbytes[xpos+p-1];
end;//sy


//.transparent feedback
if mishasai(s) then
   begin
   misai(s).format:='PNG';
   misai(s).subformat:=inttostr(stranscol)+'.'+inttostr(sfeather)+'.'+inttostr(slessdata);//23jan2021
   misai(s).transparent:=xtransparent;
   case xcoltype of
   0:misai(s).bpp:=8;
   2:misai(s).bpp:=24;
   3:misai(s).bpp:=8;
   4:misai(s).bpp:=16;
   6:misai(s).bpp:=32;
   end;//case
   end;

//successful
result:=true;
skipend:
except;end;
try
bfree(n);
bfree(v);
bfree(xdata);
bfree(xval);
bfree(lastfd);
bfree(fd);
bfree(str1);
bfree(str2);
bfree(str3);
bfree(sdata64);
bunlockautofree(sdata);//27jan2021
except;end;
end;
//## misframe82432 ##
function misframe82432(s:tobject;da_cliparea,xouterarea:trect;xautoouterarea:boolean;var slist:array of longint;scount:longint;var e:string):boolean;//28jan2021
begin
try;result:=misframe82432ex(s,da_cliparea,xouterarea,xautoouterarea,slist,scount,e);except;end;
end;
//## misframe82432ex ##
function misframe82432ex(s:tobject;da_cliparea,xouterarea:trect;xautoouterarea:boolean;var slist:array of longint;scount:longint;var e:string):boolean;//28jan2021
label//slist is a series of numbers that create a series of "framesets" that draw the frame
   skipdone,skipend;
const
   xblocks_per_frameset=5;//5x longint
var
   //framesets
   xfcount:longint;//frameset (c)ount => number of framesets in use
   xfs:array[0..199] of longint;//(s)ource color of frameset
   xfd:array[0..199] of longint;//(d)estination color of frameset
   xft:array[0..199] of longint;//(t)exture level in frameset (0=off, 1=subtle, 20=maximum) inline with Gossamer's own frame handling
   xfo:array[0..199] of longint;//(o)pacity level in frameset (0=not visible, 127=semi-see-thru, 255=fully solid) - used by Framer Plus
   xfw:array[0..199] of longint;//(w)idth of frameset in pixels
   //vars
   xopacity,xi,dpert,fs,fd,fi,si,fo,fw,xrich,xrich2,sbits,sw,sh,p,xsize:longint;
   sr8 :pcolorrow8;
   sr24:pcolorrow24;
   sr32:pcolorrow32;
   sc8 ,dc8 :tcolor8;
   sc24,dc24:tcolor24;
   sc32,dc32:tcolor32;
   srows8:pcolorrows8;
   srows24:pcolorrows24;
   srows32:pcolorrows32;
   fa:trect;
   //## xrich8 ##
   procedure xrich8;
   var
      v,b1:longint;
   begin
   b1:=random(xrich);
   //.v
   v:=sc8+b1-xrich2;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   dc8:=byte(v);
   end;
   //## xrich24 ##
   procedure xrich24;
   var
      v,b1:longint;
   begin
   //.sparkle
   b1:=random(xrich);
   //.r
   v:=sc24.r+b1-xrich2;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   dc24.r:=byte(v);
   //.g
   v:=sc24.g+b1-xrich2;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   dc24.g:=byte(v);
   //.b
   v:=sc24.b+b1-xrich2;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   dc24.b:=byte(v);
   end;
   //## xrich32 ##
   procedure xrich32;
   var
      v,b1:longint;
   begin
   //.sparkle
   b1:=random(xrich);
   //.r
   v:=sc32.r+b1-xrich2;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   dc32.r:=byte(v);
   //.g
   v:=sc32.g+b1-xrich2;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   dc32.g:=byte(v);
   //.b
   v:=sc32.b+b1-xrich2;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   dc32.b:=byte(v);
   end;
   //## fok ##
   function fok(xindex:longint):boolean;//frameset is OK
   begin
   result:=(xindex>=0) and (xindex<=high(xfs)) and (xindex<xfcount) and (xfw[xindex]>=1);
   end;
   //## xdrawframe ##
   procedure xdrawframe(xleft,xtop,xright,xbottom:longint);//draws a single line frame
   var
      sx,sy:longint;
   begin
   //top
   if (xtop>=da_cliparea.top) and (xtop<=da_cliparea.bottom) and (xright>=da_cliparea.left) and (xleft<=da_cliparea.right) then
      begin
      case sbits of
      //.8
      8:begin
         sr8:=srows8[xtop];
         if (xrich>=1) then
            begin
            for sx:=xleft to xright do if (sx>=da_cliparea.left) and (sx<=da_cliparea.right) then
            begin
            xrich8;
            sr8[sx]:=dc8;
            end;//sx
            end
         else
            begin
            for sx:=xleft to xright do if (sx>=da_cliparea.left) and (sx<=da_cliparea.right) then
            begin
            sr8[sx]:=dc8;
            end;//sx
            end;//if
         end;//8
      //.24
      24:begin
         sr24:=srows24[xtop];
         if (xrich>=1) then
            begin
            for sx:=xleft to xright do if (sx>=da_cliparea.left) and (sx<=da_cliparea.right) then
            begin
            xrich24;
            sr24[sx]:=dc24;
            end;//sx
            end
         else
            begin
            for sx:=xleft to xright do if (sx>=da_cliparea.left) and (sx<=da_cliparea.right) then
            begin
            sr24[sx]:=dc24;
            end;//sx
            end;//if
         end;//24
      //.32
      32:begin
         sr32:=srows32[xtop];
         if (xrich>=1) then
            begin
            for sx:=xleft to xright do if (sx>=da_cliparea.left) and (sx<=da_cliparea.right) then
            begin
            xrich32;
            sc32.a:=255;
            sr32[sx]:=dc32;
            end;//sx
            end
         else
            begin
            for sx:=xleft to xright do if (sx>=da_cliparea.left) and (sx<=da_cliparea.right) then
            begin
            sc32.a:=255;
            sr32[sx]:=dc32;
            end;//sx
            end;//if
         end;//32
      end;//case
      end;//top
   //bottom
   if (xbottom>=da_cliparea.top) and (xbottom<=da_cliparea.bottom) and (xright>=da_cliparea.left) and (xleft<=da_cliparea.right) then
      begin
      case sbits of
      //.8
      8:begin
         sr8:=srows8[xbottom];
         if (xrich>=1) then
            begin
            for sx:=xleft to xright do if (sx>=da_cliparea.left) and (sx<=da_cliparea.right) then
            begin
            xrich8;
            sr8[sx]:=dc8;
            end;//sx
            end
         else
            begin
            for sx:=xleft to xright do if (sx>=da_cliparea.left) and (sx<=da_cliparea.right) then
            begin
            sr8[sx]:=dc8;
            end;//sx
            end;//if
         end;//8
      //.24
      24:begin
         sr24:=srows24[xbottom];
         if (xrich>=1) then
            begin
            for sx:=xleft to xright do if (sx>=da_cliparea.left) and (sx<=da_cliparea.right) then
            begin
            xrich24;
            sr24[sx]:=dc24;
            end;//sx
            end
         else
            begin
            for sx:=xleft to xright do if (sx>=da_cliparea.left) and (sx<=da_cliparea.right) then
            begin
            sr24[sx]:=dc24;
            end;//sx
            end;//if
         end;//24
      //.32
      32:begin
         sr32:=srows32[xbottom];
         if (xrich>=1) then
            begin
            for sx:=xleft to xright do if (sx>=da_cliparea.left) and (sx<=da_cliparea.right) then
            begin
            xrich32;
            sc32.a:=255;
            sr32[sx]:=dc32;
            end;//sx
            end
         else
            begin
            for sx:=xleft to xright do if (sx>=da_cliparea.left) and (sx<=da_cliparea.right) then
            begin
            sc32.a:=255;
            sr32[sx]:=dc32;
            end;//sx
            end;//if
         end;//32
      end;//case
      end;//xbottom
   //left
   if (xbottom>=da_cliparea.top) and (xtop<=da_cliparea.bottom) and (xleft>=da_cliparea.left) and (xleft<=da_cliparea.right) then
      begin
      case sbits of
      //.8
      8:begin
         if (xrich>=1) then
            begin
            for sy:=xtop to xbottom do if (sy>=da_cliparea.top) and (sy<=da_cliparea.bottom) then
            begin
            xrich8;
            srows8[sy][xleft]:=dc8;
            end;//sx
            end
         else
            begin
            for sy:=xtop to xbottom do if (sy>=da_cliparea.top) and (sy<=da_cliparea.bottom) then
            begin
            srows8[sy][xleft]:=dc8;
            end;//sx
            end;//if
         end;//24
      //.24
      24:begin
         if (xrich>=1) then
            begin
            for sy:=xtop to xbottom do if (sy>=da_cliparea.top) and (sy<=da_cliparea.bottom) then
            begin
            xrich24;
            srows24[sy][xleft]:=dc24;
            end;//sx
            end
         else
            begin
            for sy:=xtop to xbottom do if (sy>=da_cliparea.top) and (sy<=da_cliparea.bottom) then
            begin
            srows24[sy][xleft]:=dc24;
            end;//sx
            end;//if
         end;//24
      //.32
      32:begin
         if (xrich>=1) then
            begin
            for sy:=xtop to xbottom do if (sy>=da_cliparea.top) and (sy<=da_cliparea.bottom) then
            begin
            xrich32;
            srows32[sy][xleft]:=dc32;
            end;//sx
            end
         else
            begin
            for sy:=xtop to xbottom do if (sy>=da_cliparea.top) and (sy<=da_cliparea.bottom) then
            begin
            srows32[sy][xleft]:=dc32;
            end;//sx
            end;//if
         end;//32
      end;//case
      end;//left
   //right
   if (xbottom>=da_cliparea.top) and (xtop<=da_cliparea.bottom) and (xright>=da_cliparea.left) and (xright<=da_cliparea.right) then
      begin
      case sbits of
      //.8
      8:begin
         if (xrich>=1) then
            begin
            for sy:=xtop to xbottom do if (sy>=da_cliparea.top) and (sy<=da_cliparea.bottom) then
            begin
            xrich8;
            srows8[sy][xright]:=dc8;
            end;//sx
            end
         else
            begin
            for sy:=xtop to xbottom do if (sy>=da_cliparea.top) and (sy<=da_cliparea.bottom) then
            begin
            srows8[sy][xright]:=dc8;
            end;//sx
            end;//if
         end;//8
      //.24
      24:begin
         if (xrich>=1) then
            begin
            for sy:=xtop to xbottom do if (sy>=da_cliparea.top) and (sy<=da_cliparea.bottom) then
            begin
            xrich24;
            srows24[sy][xright]:=dc24;
            end;//sx
            end
         else
            begin
            for sy:=xtop to xbottom do if (sy>=da_cliparea.top) and (sy<=da_cliparea.bottom) then
            begin
            srows24[sy][xright]:=dc24;
            end;//sx
            end;//if
         end;//24
      //.32
      32:begin
         if (xrich>=1) then
            begin
            for sy:=xtop to xbottom do if (sy>=da_cliparea.top) and (sy<=da_cliparea.bottom) then
            begin
            xrich32;
            srows32[sy][xright]:=dc32;
            end;//sx
            end
         else
            begin
            for sy:=xtop to xbottom do if (sy>=da_cliparea.top) and (sy<=da_cliparea.bottom) then
            begin
            srows32[sy][xright]:=dc32;
            end;//sx
            end;//if
         end;//32
      end;//case
      end;//right
   end;
begin
try
//defaults
result:=false;
xsize:=0;


{

fps_ver: v1
opacity: 255
logoopacity: 255
logocol1: 16711935
logocol2: 16776960
richness: 20
logocolors: 1
softenjoins: 0
shade: 148
shadeangle: 0
instagram: 0
resample: 0
logorelx: 23
logorely: 24
logorelm: 0
{}//xxxxxxxxxxxxxxxxxxxxxxxx

//check
if not misok82432(s,sbits,sw,sh) then exit;
if not misrows82432(s,srows8,srows24,srows32) then exit;

//init
//.da_cliparea
if (da_cliparea.left<0) then da_cliparea.left:=0;
if (da_cliparea.right>=sw) then da_cliparea.right:=sw-1;
if (da_cliparea.top<0) then da_cliparea.top:=0;
if (da_cliparea.bottom>=sh) then da_cliparea.bottom:=sh-1;
if (da_cliparea.right<da_cliparea.left) or (da_cliparea.bottom<da_cliparea.top) then goto skipdone;

//.xouterarea -> important: allow "xouterarea" to go out of range -> allows for slipping the frame off the edge of an image etc for tweaking etc - 27jan2021
if xautoouterarea then xouterarea:=misrect(0,0,sw-1,sh-1);
if (xouterarea.right<xouterarea.left) or (xouterarea.bottom<xouterarea.top) then goto skipdone;

//.extract framesets from "slist"
scount:=frcrange(  ((frcrange(scount,0,high(slist)+1) div xblocks_per_frameset)*xblocks_per_frameset)  ,0,high(xfs)+1);
if (scount<=0) then goto skipdone;
xi:=0;
xfcount:=scount;
for p:=1 to scount do
begin
xfs[p-1]:=slist[xi+0];//source color
xfd[p-1]:=slist[xi+1];//destination color
xft[p-1]:=frcrange(slist[xi+2],0,20);//texture (0..20)
xfo[p-1]:=frcrange(slist[xi+3],0,255);//opacity (0..255)
xfw[p-1]:=frcrange(slist[xi+4],0,1000);//size of frameset in pixels
inc(xsize,xfw[p-1]);//overall size of frame
inc(xi,xblocks_per_frameset);
end;//p

//framesets
fa:=xouterarea;
for p:=0 to (xfcount-1) do
begin
fs:=xfs[p];
fd:=xfd[p];
fw:=frcrange(xfw[p],0,1000);
xrich:=2*frcrange(xft[p],0,20);
xrich2:=frcmin(xrich div 2,1);
if (fw>=1) then
   begin
   for fi:=0 to (fw-1) do
   begin
   //calc. color
   dpert:=frcrange(round((fi/frcmin(fw,1))*100),0,100);
   //.sc24
   sc24:=low__intrgb(low__colsplice(dpert,fd,fs));
   //.sc32
   sc32.r:=sc24.r;
   sc32.g:=sc24.g;
   sc32.b:=sc24.b;
   sc32.a:=255;
   //.sc8
   sc8:=sc24.r;
   if (sc24.g>sc8) then sc8:=sc24.g;
   if (sc24.b>sc8) then sc8:=sc24.b;
   //.d8/24/32
   dc8 :=sc8;
   dc24:=sc24;
   dc32:=sc32;
   //draw a single pixel frame
   xdrawframe(fa.left,fa.top,fa.right,fa.bottom);
   //shrink the drawing area ready for the next single frame to be drawn
   inc(fa.left);
   dec(fa.right);
   inc(fa.top);
   dec(fa.bottom);
   //check
   if (fa.right<fa.left) or (fa.bottom<fa.top) then goto skipdone;
   end;//fi
   end;
end;//p
//successful
skipdone:
result:=true;
skipend:
except;end;
end;
//## low__framecols ##
procedure low__framecols(xback,xframe,xframe2:longint;var xminsize,xcol1,xcol2:longint);//24feb2022
var//note: runs the frame code to discover the innermost and outermost colors for system corner color patching "winLdr"
   xpos:longint;
   sremsize:longint;sframesize,dminsize,dsize,dcolor,dcolor2:longint;
   xonce:boolean;
begin
try
//init
xminsize:=0;
xcol1:=xback;//was: xframe2; - note: background is a more reliable default WHEN no frame present or framesize is ZERO - 26feb2022
xcol2:=xback;//was: xframe;
xonce:=true;
//get
if (viframecode<>nil) and (viframecode.len>=1) then
   begin
   sframesize:=vibordersize;
   sremsize:=sframesize;
   xpos:=0;
   while true do
   begin
   if not low__frameset(xpos,viframecode,sremsize,sframesize,xframe,xframe2,dminsize,dsize,dcolor,dcolor2) then break;
   if (dminsize>=1) then xminsize:=dminsize;//26feb2022
   if xonce and (dsize>=1) then
      begin
      xonce:=false;
      xcol1:=dcolor;//inner-most color of frame
      end;
   if (dsize>=1) then xcol2:=dcolor2;//fixed - super-fine control - 27feb2022
   end;//loop
   end;
except;end;
end;
//## low__frameset ##
function low__frameset(var xpos:longint;xdata:tstr8;var sremsize:longint;sframesize,scolor,scolor2:longint;var dminsize,dsize,dcolor,dcolor2:longint):boolean;
label//Accepts format: "v1,v2,v2<rcode>v1,v2,v3" or "v1,v2,v2<#10>v1,v2,v3" or "v1,v2,v2<#13>v1,v2,v3" or "v1,v2,v2|v1,v2,v3"
   loop,redo,skipend;
var
   lp,v,xcount,xlen:longint;
   n,v1,v2,v3:string;
   //## xclear ##
   procedure xclear;
   begin
   dsize:=0;
   dcolor:=scolor;
   dcolor2:=scolor2;
   xcount:=0;
   v1:='';
   v2:='';
   v3:='';
   end;
   //## xadd ##
   procedure xadd;
   label
      skipone;
   var
      n:string;
   begin
   //check
   if (xpos<=lp) then exit;
   //v
   n:=xdata.str[lp,xpos-lp];
   //special adjusters
   if (n='x') then
      begin
      low__swapint(scolor,scolor2);
      goto skipone;
      end;
   //set
   case xcount of
   0:v1:=n;
   1:v2:=n;
   2:v3:=n;
   end;//allow over run PAST 2 and ignore those entries - 23feb2022
   //inc
   inc(xcount);
   skipone:
   lp:=xpos+1;
   end;
   //## xmakecol ##
   procedure xmakecol(x:string;var xoutcolor:longint);
   var//frameset format: "<from color(1c)><to color(1c)><bal %(0..3c)>"
      c1,c2,b:longint;
      //## xfindcol ##
      function xfindcol(x:string;xdefcol:longint):longint;
      begin//supports both command Letters and command Numbers - 26feb2022 -> 0=black, 1=in color 1, 2=in color 2, 9=white, 3..8=not used
      //defaults
      result:=xdefcol;
      //get
      if (x='') then exit
      else if (x='s') or (x='1') then result:=scolor
      else if (x='d') or (x='2') then result:=scolor2
      else if (x='i') or (x='3') then low__invert(scolor,result)
      else if (x='j') or (x='4') then low__invert(scolor2,result)
      else if (x='r') or (x='5') then result:=255
      else if (x='g') or (x='8') then result:=low__rgb(128,128,128)
      else if (x='b') or (x='0') then result:=0
      else if (x='w') or (x='9') then result:=low__rgb(255,255,255)
      else                            result:=0;
      end;
   begin
   try
   //defaults
   xoutcolor:=0;
   //init
   c1:=xfindcol(strcopy1(x+'s',1,1),0);
   c2:=xfindcol(strcopy1(x+'d',2,1),c1);
   b :=frcrange(strint(strcopy1(x,3,length(x))),0,100);
   //get
   xoutcolor:=low__colsplice(b,c2,c1)//use 2nd color
   except;end;
   end;
begin
try//Important Note: Allow frame to process even when there is NO FRAMESIZE to work with or NO REMAINING SIZE so that "minsize" can always be obtained - 27feb2022
//defaults
result:=false;
dminsize:=0;//here only
xclear;
//check
if not block(xdata) then exit;
//init
sremsize:=frcrange(sremsize,0,sframesize);
xlen:=xdata.len;
xpos:=frcmin(xpos,0);
if (xpos>=xlen) then goto skipend;
if (scolor=clnone)  then scolor:=rgb(255,255,255);
if (scolor2=clnone) then scolor2:=rgb(128,128,128);
//get
lp:=xpos;
redo:
v:=xdata.byt1[xpos];
if ((v=10) or (v=13) or (v=124)) and (lp=xpos) then
   begin
   inc(lp);
   end
else if (v=10) or (v=13) or (v=124) or (v=44) then xadd
else if (xpos=(xlen-1))       then
   begin
   inc(xpos);//account for a non-terminating character
   xadd;
   end;
//.loop
inc(xpos);
if (xpos<xlen) and ((v<>10) and (v<>13) and (v<>124)) then goto redo;

//.catch and multiples of "10" and "13" with no data between them -> go back and try again
if (xcount<=0) then
   begin
   if (xpos<xlen) then goto redo;
   goto skipend;
   end;

//set
//1st
n:=strcopy1(v1,1,1);
if (n='m') then//special value: specifies recommended minimum size of frame - 26feb2022
   begin
   dminsize:=frcmin(strint(strcopy1(v1,2,length(v1))),0);
   goto loop;
   end
else if (n='') or (n='100')    then dsize:=sframesize//uses ALL remaining frame size
else                           dsize:=(frcrange(strint(v1),0,100)*sframesize) div 100;
//.restrict
dsize:=frcrange(dsize,0,sremsize);
//2nd
xmakecol(v2,dcolor);
//3rd
xmakecol(v3,dcolor2);
//.check
loop:
if (dsize<=0) and (xpos<xlen) then
   begin
   xclear;
   goto redo;
   end;
//dec
if (dsize>=1) then sremsize:=frcmin(sremsize-dsize,0);
//successful
result:=true;
skipend:
except;end;
try;bunlockautofree(xdata);except;end;
end;
//## low__sparklefill ##
procedure low__sparklefill(xrichlevel:longint);
var
   p:longint;
begin
try
xrichlevel:=2*frcrange(xrichlevel,0,20);
if low__setint(system_sparkleref,xrichlevel) then
   begin
   for p:=0 to high(system_sparklelist) do system_sparklelist[p]:=random(xrichlevel);
   low__iroll(system_sparklecount,1);
   end;
except;end;
end;
//## low__sparklestart ##
function low__sparklestart:longint;
begin
try;result:=system_sparklepos;except;end;
end;
//## low__sparklestop ##
procedure low__sparklestop(xpos:longint);
begin
try
if (xpos<0) then xpos:=0 else if (xpos>high(system_sparklelist)) then xpos:=0;
system_sparklepos:=xpos;
except;end;
end;
//## mistobmp82432 ##
function mistobmp82432(s:tobject;dbits:longint;xdata:tstr8;var e:string):boolean;//28jan2021
label
   skipend;
var
   a:tbmp;
   m:tmemstr8;
   sbits,sw,sh:longint;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
a:=nil;
m:=nil;
//init
bmplock(s);
if not block(xdata) then goto skipend;
xdata.clear;
if not misok82432(s,sbits,sw,sh) then goto skipend;
//dbits
if (dbits=0) then dbits:=sbits;//match inbound image "s"
case dbits of
8,24,32:;
else dbits:=32;
end;

//get
m:=tmemstr8.create(xdata);
m.position:=0;

a:=misbmp(dbits,sw,sh);
a.lock;
if not miscopyareaxx1(0,0,sw,sw,misrect(0,0,sw-1,sw-1),a,s) then goto skipend;
a.core.savetostream(m);
a.unlock;//now calls "a.xinfo" to update width/height etc

//successful
result:=true;
skipend:
except;end;
try
freeobj(@a);
freeobj(@m);//do last
if (not result) and zzok(xdata,7012) then xdata.clear;
bunlockautofree(xdata);
bmpunlock(s);
except;end;
end;
//## misfrombmp82432 ##
function misfrombmp82432(s:tobject;xdata:tstr8;var e:string):boolean;//28jan2021
label
   skipend;
var
   a:tbmp;
   m:tmemstr8;
   aw,ah,sbits,sw,sh:longint;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
a:=nil;
m:=nil;
//init
bmplock(s);
if not block(xdata) then goto skipend;
//get
m:=tmemstr8.create(xdata);
m.position:=0;
a:=misbmp32(1,1);
a.lock;
a.core.loadfromstream(m);
a.unlock;//now calls "a.xinfo" to update width/height etc
aw:=misw(a);
ah:=mish(a);
if (aw<=0) or (ah<=0) then goto skipend;
if not misok82432(s,sbits,sw,sh) then goto skipend;
if not missize2(s,aw,ah,true) then
   begin
   e:=gecOutofmemory;
   goto skipend;
   end;
if not misok82432(s,sbits,sw,sh) then goto skipend;
if not miscopyareaxx1(0,0,aw,aw,misrect(0,0,aw-1,aw-1),s,a) then goto skipend;
//successful
result:=true;
skipend:
except;end;
try
freeobj(@a);
freeobj(@m);//do last
bunlockautofree(xdata);
bmpunlock(s);
except;end;
end;
//## mistojpg82432 ##
function mistojpg82432(s:tobject;xdata:tstr8;var e:string):boolean;//28jan2021
begin
try;result:=mistojpg82432ex(s,clnone,0,0,false,xdata,e);except;end;
end;
//## mistojpg82432ex ##
function mistojpg82432ex(s:tobject;stranscol,sfeather,slessdata:longint;xforceenhanced:boolean;xdata:tstr8;var e:string):boolean;//28jan2021
label
   skipend2,skipend;
var
{$ifdef jpeg}
   j:tjpegimage;
{$endif}
   a:tbmp;
   m:tmemstr8;
   jlessdata,xtranscol,sbits,sw,sh:longint;
   xalpha:tbasicimage;
   xjdata:tstr8;
   ok:boolean;
{$ifdef jpeg}
   //## xquality ##
   function xquality(xstartpert:longint):boolean;
   var
      int2:longint;
      bol2:boolean;
   begin
   try
   //defaults
   result:=false;
   //check
   if zznil(m,2153) or zznil(j,2154) then exit;
   //init
   int2:=frcrange(xstartpert,1,100);//start at 100% and step down till there is no error -> Dephi's JPEG is prone to fail at high-quality and large image sizes -> e.g. ~1200x800 @ 100% fails - 06aug2019
   //get
   while true do
   begin
   bol2:=false;
   try;j.compressionquality:=int2;j.savetostream(m);bol2:=true;except;end;
   if bol2 then break;
   dec(int2,5);
   if (int2<=10) then break;
   end;//while
   //return result
   result:=bol2;
   except;end;
   end;
{$endif}
   //## xtranswhite ##
   function xtranswhite(s:tobject;var stranscol:longint):boolean;
   label
      skipend;
   var
      sc8 :tcolor8;
      sc24:tcolor24;
      sc32:tcolor32;
      sr8 :pcolorrow8;
      sr24:pcolorrow24;
      sr32:pcolorrow32;
      sbits,sx,sy,sw,sh,tr,tg,tb:longint;
   begin
   try
   //defaults
   result:=false;
   //check
   if (stranscol=clnone) then
      begin
      result:=true;
      goto skipend;
      end;
   if not misok82432(s,sbits,sw,sh) then goto skipend;
   if not misfindtranscol82432ex(s,stranscol,tr,tg,tb) then goto skipend;
   if (tr=255) and (tg=255) and (tb=255) then//already white -> nothing to do
      begin
      result:=true;
      goto skipend;
      end;
   //sync
   stranscol:=low__rgb(255,255,255);//update transcol to white
   //get
   for sy:=0 to (sh-1) do
   begin
   if not misscan82432(s,sy,sr8,sr24,sr32) then goto skipend;
   //.8
   if (sbits=8) then
      begin
      for sx:=0 to (sw-1) do
      begin
      sc8:=sr8[sx];
      if      (tr=sc8)  then sr8[sx]:=255
      else if (sc8=255) then sr8[sx]:=254;
      end;//sx
      end
   //.24
   else if (sbits=24) then
      begin
      for sx:=0 to (sw-1) do
      begin
      sc24:=sr24[sx];
      if (tr=sc24.r) and (tg=sc24.g) and (tb=sc24.b) then
         begin
         sc24.r:=255;
         sc24.g:=255;
         sc24.b:=255;
         sr24[sx]:=sc24;
         end
      else if (sc24.r=255) and (sc24.g=255) and (sc24.b=255) then
         begin
         sc24.r:=254;
         sc24.g:=254;
         sc24.b:=254;
         sr24[sx]:=sc24;
         end;
      end;//sx
      end
   //.32
   else if (sbits=32) then
      begin
      for sx:=0 to (sw-1) do
      begin
      sc32:=sr32[sx];
      if (tr=sc32.r) and (tg=sc32.g) and (tb=sc32.b) then
         begin
         sc32.r:=255;
         sc32.g:=255;
         sc32.b:=255;
         sr32[sx]:=sc32;
         end
      else if (sc32.r=255) and (sc32.g=255) and (sc32.b=255) then
         begin
         sc32.r:=254;
         sc32.g:=254;
         sc32.b:=254;
         sr32[sx]:=sc32;
         end;
      end;//sx
      end;
   end;//sy
   //successful
   result:=true;
   skipend:
   except;end;
   end;
begin
try
//defaults
result:=false;
ok:=false;
e:=gecTaskfailed;
xalpha:=nil;
xjdata:=nil;
sw:=1;
sh:=1;

//range
sfeather:=frcrange(sfeather,-1,100);//-1=asis, 0=none(sharp), 1..100=feather(Npx/blur)
slessdata:=frcrange(slessdata,0,5);
jlessdata:=slessdata;
slessdata:=0;//don't use our color reducer, instead rely on jpeg compression to save significant data storage - 29jan2021

//init
if not block(xdata) then goto skipend;
xdata.clear;
if not misok82432(s,sbits,sw,sh) then goto skipend;
xalpha:=misimg8(sw,sh);
xjdata:=bnew;

//make feather -> the alpha channel -> this takes control of all alpha values - 12jan2021
if xforceenhanced or (stranscol<>clnone) or (sfeather<>0) then
   begin
   if not mask__feather(s,xalpha,sfeather,stranscol,xtranscol) then goto skipend;//requires "sfeather" and "stranscol" in their original formats
   end;


//-- start of jpeg -------
e:='JPEG image format not supported';
{$ifdef jpeg}
try
//init -> note: "a/m/j" objects only to be created and freed within this code block
e:=gecTaskfailed;
a:=nil;
m:=nil;
j:=nil;

//m
m:=tmemstr8.create(xjdata);
m.position:=0;
//j
j:=misjpg;
//a
a:=misbmp(24,sw,sh);
a.lock;
//copy "s" -> "a"
if not miscopyareaxx1(0,0,sw,sh,misrect(0,0,sw-1,sh-1),a,s) then goto skipend2;
if not xtranswhite(a,stranscol) then goto skipend2;
//lessdata -> adjust compression quality - 29jan2021
if (slessdata>=1) and (not misreduce82432(a,stranscol,slessdata,e)) then goto skipend2;
//copy "a" -> "j"
j.assign(a.core);
case jlessdata of
0:if not xquality(90) then goto skipend2;
1:if not xquality(80) then goto skipend2;
2:if not xquality(70) then goto skipend2;
3:if not xquality(60) then goto skipend2;
4:if not xquality(50) then goto skipend2;
5:if not xquality(40) then goto skipend2;
end;//case
//free "a"
a.unlock;//now calls "a.xinfo" to update width/height etc
freeobj(@a);//reduce memory
//copy "j" -> "m" -> "xdata"
j.savetostream(m);

//successful
ok:=true;
skipend2:
except;end;

try
freeobj(@j);
freeobj(@a);
freeobj(@m);//do last
except;end;
{$endif}
//-- end of jpeg ---------


//check
if not ok then goto skipend;
e:=gecTaskfailed;

//store to "xdata"
//.enhanced datastream
if xforceenhanced or (stranscol<>clnone) or (sfeather<>0) then
   begin
   //.header
   xdata.aadd([uuJ,uuP,uuG,ssDash,uuE,nn1]);//JPG-E1 -> enhanced jpeg v1
   //.width
   xdata.addint4(1);xdata.addint4(sw);
   xdata.addint4(2);xdata.addint4(sh);
   xdata.addint4(3);xdata.addint4(stranscol);
   xdata.addint4(4);xdata.addint4(sfeather);
   xdata.addint4(5);xdata.addint4(slessdata);
   //.jpeg image
   xdata.addint4(100);xdata.addint4(xjdata.len);
   xdata.add(xjdata);
   //.zipped alpha image
   if not mistobmp82432(xalpha,0,xjdata,e) then goto skipend;//reuse "xjdata" handler
   if not low__compress(xjdata,e) then goto skipend;
   xdata.addint4(101);xdata.addint4(xjdata.len);
   xdata.add(xjdata);
   //.stop
   xdata.addint4(9);xdata.addint4(0);
   end
//.standard "jpeg" datastream
else
   begin
   xdata.add(xjdata);
   end;

//successful
result:=true;
skipend:
except;end;
try
freeobj(@xalpha);
freeobj(@xjdata);
if (not result) and zzok(xdata,7013) then xdata.clear;
bunlockautofree(xdata);
bmpunlock(s);
except;end;
end;
//## misfromjpg82432 ##
function misfromjpg82432(s:tobject;sbackcol:longint;xdata:tstr8;var e:string):boolean;//29jan2021
var
   stranscol,sfeather,slessdata:longint;
   swasenhanced:boolean;
begin
try;result:=misfromjpg82432ex(s,sbackcol,stranscol,sfeather,slessdata,swasenhanced,xdata,e);except;end;
end;
//## misfromjpg82432ex ##
function misfromjpg82432ex(s:tobject;sbackcol:longint;var stranscol,sfeather,slessdata:longint;var swasenhanced:boolean;xdata:tstr8;var e:string):boolean;//29jan2021
label
   doEnhanced,doNormal,skipdone,skipend;
var
{$ifdef jpeg}
   j:tjpegimage;
{$endif}
   ar8 :pcolorrow8;
   sr8 :pcolorrow8;
   sr24:pcolorrow24;
   sr32:pcolorrow32;
   bc8, sc8 :tcolor8;
   bc24,sc24:tcolor24;
   sc32:tcolor32;
   a:tbmp;
   m:tmemstr8;
   int1,n,v,xlen,xpos,xtranscol,sbits,sx,sy,sw,sh:longint;
   xalpha:tbasicimage;
   xjdata:tstr8;
   sbackcolok,xtransparent,xreadingimages,ok:boolean;
   xformat:string;
   //## xpullint4 ##
   function xpullint4(var xval:longint):boolean;
   begin
   //defaults
   result:=false;
   xval:=0;
   //get
   if ((xpos+3)<xlen) then
      begin
      xval:=xdata.int4[xpos];
      inc(xpos,4);
      result:=true;
      end;
   end;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
ok:=false;
xreadingimages:=false;
xtransparent:=false;
xalpha:=nil;
xjdata:=nil;
a:=nil;
m:=nil;
{$ifdef jpeg}
j:=nil;
{$endif}
xpos:=0;
sw:=0;
sh:=0;

//.return values - 21jan2021
stranscol:=clnone;
sfeather:=-1;//asis
slessdata:=0;
swasenhanced:=false;

//check -> ensure we support jpeg
{$ifdef jpeg}
ok:=true;
{$endif}
if not ok then
   begin
   e:='JPEG image format not supported';
   goto skipend;
   end;

//check
if not block(xdata) then goto skipend;
xlen:=xdata.len;
if not misok82432(s,sbits,sw,sh) then goto skipend;

//.sbackcol - 16jan2021
sbackcolok:=(sbackcol<>clnone);
if sbackcolok then
   begin
   bc24:=low__intrgb(sbackcol);
   bc8:=bc24.r;
   if (bc24.g>bc8) then bc8:=bc24.g;
   if (bc24.b>bc8) then bc8:=bc24.b;
   end;

//decide - 29jan2021
xformat:=anyformatb(xdata);
if (xformat='JPG')       then goto donormal
else if (xformat='JPGE') then goto doenhanced
else
   begin
   e:=gecUnknownformat;
   goto skipend;
   end;

//-- Normal JPEG ---------------------------------------------------------------
doNormal:
{$ifdef jpeg}
//m
m:=tmemstr8.create(xdata);
m.position:=0;
//j
j:=misjpg;
//a
j.loadfromstream(m);
sw:=j.width;
sh:=j.height;
a:=misbmp(24,sw,sh);
a.lock;
a.core.assign(j);
freeobj(@j);//do here **** 29jan2021 --> was very touchy with critcal errors when placed outside the "lock...unlock" block
a.unlock;//now calls "a.xinfo" to update width/height etc
//resize "s"
if not missize2(s,sw,sh,true) then goto skipend;
//copy "s" -> "a"
if not miscopyareaxx1(0,0,sw,sh,misrect(0,0,sw-1,sh-1),s,a) then goto skipend;
//free "a"
freeobj(@a);//reduce memory
{$endif}
goto skipdone;


//-- Enhanced JPEG -------------------------------------------------------------
//get -> read values -> all header values MUST be read BEFORE the first cell
doEnhanced:
inc(xpos,6);

{$ifdef jpeg}
while true do
begin
if not xpullint4(n) then goto skipend;//block style
if not xpullint4(v) then goto skipend;//block value (or cell datalen)

//.header values
if not xreadingimages then
   begin
   case n of
   1:sw:=v;//width
   2:sh:=v;//height
   3:stranscol:=v;
   4:sfeather:=v;
   5:slessdata:=v;
   100,101:begin
      xreadingimages:=true;
      //range
      if (sw<=0) or (sh<=0) then
         begin
         e:=gecDatacorrupt;
         goto skipend;
         end;
      sfeather:=frcrange(sfeather,-1,100);//-1=asis, 0=none(sharp), 1..100=feather(Npx/blur)
      slessdata:=frcrange(slessdata,0,5);
      //size
      if not missize2(s,sw,sh,true) then goto skipend;
      //xjdata
      if zznil(xjdata,2155) then xjdata:=bnew;
      end;
   end;//case
   end;

//.100 - jpeg image
if xreadingimages and (n=100) then
   begin
   //init
   xjdata.clear;
   if not xjdata.add3(xdata,xpos,v) then goto skipend;
   if zznil(m,2156) then m:=tmemstr8.create(xjdata);
   m.position:=0;
   if zznil(j,2157) then j:=misjpg;
   j.loadfromstream(m);
   if zznil(a,2158) then a:=misbmp(24,sw,sh);
   a.lock;
   a.core.assign(j);
   freeobj(@j);//do here **** 29jan2021 --> was very touchy with critcal errors when placed outside the "lock...unlock" block
   a.unlock;//now calls "a.xinfo" to update width/height etc
   //copy "s" -> "a"
   if not miscopyareaxx1(0,0,sw,sh,misrect(0,0,misw(a)-1,mish(a)-1),s,a) then goto skipend;
   //free "a"
   freeobj(@a);//reduce memory
   //free "m"
   freeobj(@m);//do last
   //inc
   inc(xpos,v);//inc past end of "jpeg.datastream"
   end;

//.101 - alpha channel
if xreadingimages and (n=101) then
   begin
   //init
   xjdata.clear;
   if not xjdata.add3(xdata,xpos,v) then goto skipend;
   if not low__decompress(xjdata,e) then goto skipend;
   if zznil(xalpha,2159) then xalpha:=misimg8(sw,sh);
   if not misfrombmp82432(xalpha,xjdata,e) then goto skipend;

   //get -> write the "a" values into "s.alphachannel"
   if (sw<=misw(xalpha)) and (sh<=mish(xalpha)) then
      begin
      if (not sbackcolok) and (sbits=32) then
         begin
         for sy:=0 to (sh-1) do
         begin
         if not misscan8(xalpha,sy,ar8) then goto skipend;
         if not misscan32(s,sy,sr32) then goto skipend;
         for sx:=0 to (sw-1) do
         begin
         sc8:=ar8[sx];
         sr32[sx].a:=sc8;
         if (sc8=0) then xtransparent:=true;
         end;//sx
         end;//sy
         end
      //.blend "sbackcol" with color pixels and REMOVE the alpha mask from the image rendering process (e.g. 255 or not present) - 29jan2021
      else if sbackcolok then//destructive preview mode -> transparency can't be reliabled upon to be maintained -> for viewing/previewing purposes only - 20jan2021
         begin
         for sy:=0 to (sh-1) do
         begin
         if not misscan8(xalpha,sy,ar8) then goto skipend;
         if not misscan82432(s,sy,sr8,sr24,sr32) then goto skipend;
         //.32
         if (sbits=32) then
            begin
            for sx:=0 to (sw-1) do
            begin
            int1:=ar8[sx];
            sc32:=sr32[sx];
            sc32.r:=((sc32.r*int1)+(bc24.r*(255-int1))) div 255;
            sc32.g:=((sc32.g*int1)+(bc24.g*(255-int1))) div 255;
            sc32.b:=((sc32.b*int1)+(bc24.b*(255-int1))) div 255;
            if (int1=0) then xtransparent:=true;
            sc32.a:=255;
            sr32[sx]:=sc32;
            end;//sx
            end
         //.24
         else if (sbits=24) then
            begin
            for sx:=0 to (sw-1) do
            begin
            int1:=ar8[sx];
            sc24:=sr24[sx];
            sc24.r:=((sc24.r*int1)+(bc24.r*(255-int1))) div 255;
            sc24.g:=((sc24.g*int1)+(bc24.g*(255-int1))) div 255;
            sc24.b:=((sc24.b*int1)+(bc24.b*(255-int1))) div 255;
            if (int1=0) then xtransparent:=true;
            sr24[sx]:=sc24;
            end;//sx
            end
         //.8
         else if (sbits=8) then
            begin
            for sx:=0 to (sw-1) do
            begin
            int1:=ar8[sx];
            sc8:=sr8[sx];
            sc8:=((sc8*int1)+(bc8*(255-int1))) div 255;
            if (int1=0) then xtransparent:=true;
            sr8[sx]:=sc8;
            end;//sx
            end;
         end;//sy
         end;
      //free "xalpha"
      freeobj(@xalpha);
      end;
  //inc
  inc(xpos,v);//inc past end of "alpha.datastream"
  end;

//.9 - stop reading datastream
if (n=9) then break;
end;//while
{$endif}
goto skipdone;

//successful
skipdone:
result:=true;
skipend:
except;end;
try
{$ifdef jpeg}
freeobj(@j);
{$endif}
freeobj(@a);
freeobj(@m);//do last
freeobj(@xalpha);
freeobj(@xjdata);
if (not result) and zzok(xdata,7014) then xdata.clear;
bunlockautofree(xdata);
bmpunlock(s);
except;end;
end;
//## mistransNEXT ##
function mistransNEXT(var xindex:longint;var xoutlabel:string;xstart:boolean):boolean;
var
   int1:longint;
   bol1:boolean;
begin
try;result:=mistransNEXT2(xindex,int1,xoutlabel,bol1,'',xstart);except;end;
end;
//## mistransNEXT2 ##
function mistransNEXT2(var xindex,xoutindex:longint;var xoutlabel:string;var xoutcustomok:boolean;xcustom:string;xstart:boolean):boolean;
begin
try
//defaults
result:=true;
xoutindex:=clTopleft;
xoutlabel:='';
xoutcustomok:=false;
//init
if xstart then xindex:=cltopleft;
//get
xoutindex:=xindex;
case xindex of
cltopleft:xindex:=clWhite;
clWhite:xindex:=clBlack;
clBlack:xindex:=clRed;
clRed:xindex:=clLime;
clLime:xindex:=clBlue;
clBlue:xindex:=-1000;//custom
-1000:begin
   xindex:=-1001;//stop
   xoutcustomok:=true;
   end;
else result:=false;
end;
//set
if result then xoutlabel:=mistransLABEL(xoutindex,xcustom);
except;end;
end;
//## mistransLABEL ##
function mistransLABEL(stranscolORstyle:longint;xcustom:string):string;
begin
try
case stranscolORstyle of
cltopleft:result:='Top-Left';
clwhite:result:='White';
clBlack:result:='Black';
clRed:result:='Red';
clLime:result:='Green';
clBlue:result:='Blue';
else result:=low__udv(xcustom,'Custom');
end;
except;end;
end;
//## mistransCUSTOM ##
function mistransCUSTOM(stranscolORstyle:longint):boolean;
   //## nok ##
   function nok(x:longint):boolean;
   begin
   result:=(x<>stranscolORstyle);
   end;
begin
try;result:=nok(cltopleft) and nok(clwhite) and nok(clblack) and nok(clred) and nok(cllime) and nok(clblue);except;end;
end;
//## mistransISOK ##
function mistransISOK(a,b:longint):boolean;
   //## nindex ##
   function nindex(x:longint):longint;
   begin
   case x of
   cltopleft:result:=1;
   clwhite:result:=2;
   clBlack:result:=3;
   clRed:result:=4;
   clLime:result:=5;
   clBlue:result:=6;
   else result:=0;
   end;//case
   end;
begin
try;result:=(nindex(a)=nindex(b));except;end;
end;
//## mistranscol ##
function mistranscol(s:tobject;stranscolORstyle:longint;senable:boolean):longint;
begin
try
case senable of
false:result:=clnone;
true:result:=misfindtranscol82432(s,stranscolORstyle);
end;
except;end;
end;
//## misfindtranscol82432 ##
function misfindtranscol82432(s:tobject;stranscol:longint):longint;
var
   tr,tg,tb:longint;
begin
try;misfindtranscol82432ex(s,stranscol,tr,tg,tb);result:=low__rgb(tr,tg,tb);except;end;
end;
//## misfindtranscol82432ex ##
function misfindtranscol82432ex(s:tobject;stranscol:longint;var tr,tg,tb:longint):boolean;
label
   skipend;
var
   sr8 :pcolorrow8;
   sr24:pcolorrow24;
   sr32:pcolorrow32;
   sc24:tcolor24;
   sbits,sw,sh:longint;
begin
try
//defaults
result:=false;
tr:=255;
tg:=255;
tb:=255;
//get
//.top-left
if (stranscol=cltopleft) then
   begin
   if not misok82432(s,sbits,sw,sh) then goto skipend;
   if not misscan82432(s,0,sr8,sr24,sr32) then goto skipend;
   if (sbits=8) then
      begin
      tr:=sr8[0];
      tg:=tr;
      tb:=tr;
      end
   else if (sbits=24) then
      begin
      tr:=sr24[0].r;
      tg:=sr24[0].g;
      tb:=sr24[0].b;
      end
   else if (sbits=32) then
      begin
      tr:=sr32[0].r;
      tg:=sr32[0].g;
      tb:=sr32[0].b;
      end;
   end
else if (stranscol=clwhite) then
   begin
   tr:=255;
   tg:=255;
   tb:=255;
   end
else if (stranscol=clblack) then
   begin
   tr:=0;
   tg:=0;
   tb:=0;
   end
else if (stranscol=clred) then
   begin
   tr:=255;
   tg:=0;
   tb:=0;
   end
else if (stranscol=cllime) then
   begin
   tr:=0;
   tg:=255;
   tb:=0;
   end
else if (stranscol=clblue) then
   begin
   tr:=0;
   tg:=0;
   tb:=255;
   end
//.user specified color
else
   begin
   sc24:=low__intrgb(stranscol);
   tr:=sc24.r;
   tg:=sc24.g;
   tb:=sc24.b;
   end;
//successful
result:=true;
skipend:
except;end;
end;
//## mislimitcolors82432 ##
function mislimitcolors82432(x:tobject;xtranscolor,colorlimit:longint;fast:boolean;var a:array of tcolor24;var acount:longint;var e:string):boolean;//01aug2021, 15SEP2007
begin
try;result:=mislimitcolors82432ex(x,0,maxint,xtranscolor,colorlimit,fast,true,a,acount,e);except;end;
end;
//## mislimitcolors82432ex ##
function mislimitcolors82432ex(x:tobject;sx,xcellw,xtranscolor,colorlimit:longint;fast,xreducetofit:boolean;var a:array of tcolor24;var acount:longint;var e:string):boolean;//01aug2021, 15SEP2007
label//colorlimit=2..1024
   redo,skipdone,skipend;
const
   dvLIMIT=240;
var
   dx1,dx2,xbits,xw,xh,i,alimit,p,dy,dx:longint;
   dv:byte;
   sr8:pcolorrow8;
   sr24:pcolorrow24;
   sr32:pcolorrow32;
   sc8:tcolor8;
   nontc,tc,zc:tcolor24;
   sc32:tcolor32;
   //## dvcolor ##
   procedure dvcolor;//divide the color
   begin
   //get - work only on non-transparent pixels
   if (zc.r<>tc.r) or (zc.g<>tc.g) or (zc.b<>tc.b) then
      begin
      //set
      zc.r:=byte((zc.r div dv)*dv);
      zc.g:=byte((zc.g div dv)*dv);
      zc.b:=byte((zc.b div dv)*dv);
      //filter - color collision - if color is same as transparent color use "non-transparent" color instead - 18JAN2012
      if (zc.r=tc.r) and (zc.g=tc.g) and (zc.b=tc.b) then zc:=nontc;
      end;
   end;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
acount:=0;
//check
if not misok82432(x,xbits,xw,xh) then exit;
if (low(a)<>0) and (high(a)<1) then exit;
e:=gecOutOfMemory;
//INIT
xcellw:=frcrange(xcellw,1,xw);
sx:=frcrange(sx,0,xw-1);
dx1:=frcrange(sx,0,xw-1);
dx2:=frcrange(sx+xcellw-1,0,xw-1);
fillchar(a,sizeof(a),0);
dv:=1;//divide color element by facter, increases in color limit is reached, to reduce colors gradually
//.maintain transparency information whether it's used or not
if (xtranscolor=clTopLeft) then tc:=mispixel24(x,sx,0)
else if (xtranscolor<>clnone) then tc:=low__intrgb(xtranscolor)
else tc:=mispixel24(x,sx,0);//was: tc:=intrgb(pixels[x,0,0]);//get transparent color

//..not white NOR black
nontc.r:=byte(frcrange(tc.r,1,254));
nontc.g:=byte(frcrange(tc.g,1,254));
nontc.b:=byte(frcrange(tc.b,1,254));
if (tc.r=nontc.r) and (tc.g=nontc.g) and (tc.b=nontc.b) then nontc.r:=nontc.r+1;//can go upto 255 - 18JAN2012
//.limit
alimit:=frcrange(colorlimit,2,high(a)+1);
//.default palette color
a[0]:=tc;
//GET
redo:
acount:=1;
//y
for dy:=0 to (xh-1) do
begin
if not misscan82432(x,dy,sr8,sr24,sr32) then goto skipend;
//x
//.8
if (xbits=8) then
   begin
   for dx:=dx1 to dx2 do
   begin
   //get
   sc8:=sr8[dx];
   zc.r:=sc8;
   zc.g:=sc8;
   zc.b:=sc8;
   //filter - only non-transparent colors
   if (dv>=2) then dvcolor;
   //scan - look in palette to see if we already have this color
   i:=-1;
   for p:=0 to (acount-1) do if (a[p].r=zc.r) and (a[p].g=zc.g) and (a[p].b=zc.b) then
      begin
      i:=p;
      break;
      end;
   //.counting colors only -> palette is full so we can stop - 22sep2021
   if (not xreducetofit) and ((acount>=alimit) or (i=-1)) then goto skipdone;
   //add color
   if (i=-1) then
      begin
      //.add to palette
      if (acount<alimit) then
         begin
         a[acount]:=zc;
         inc(acount);
         end
      //.palette full - retry at a higher DV rate
      else if (dv<dvLIMIT) then
         begin
         dv:=frcmax(dv+10,dvLIMIT);
         goto redo;
         end
      //.palette full and DV is maxed out - change color into first noh-transparent "a[1]" color and be done with it - 18JAN2012
      else sr8[dx]:=a[1].r;
      end;
   end;//dx
   end//8
//.24
else if (xbits=24) then
   begin
   for dx:=dx1 to dx2 do
   begin
   //get
   zc:=sr24[dx];
   //filter - only non-transparent colors
   if (dv>=2) then dvcolor;
   //scan - look in palette to see if we already have this color
   i:=-1;
   for p:=0 to (acount-1) do if (a[p].r=zc.r) and (a[p].g=zc.g) and (a[p].b=zc.b) then
      begin
      i:=p;
      break;
      end;
   //.counting colors only -> palette is full so we can stop - 22sep2021
   if (not xreducetofit) and ((acount>=alimit) or (i=-1)) then goto skipdone;
   //add color
   if (i=-1) then
      begin
      //.add to palette
      if (acount<alimit) then
         begin
         a[acount]:=zc;
         inc(acount);
         end
      //.palette full - retry at a higher DV rate
      else if (dv<dvLIMIT) then
         begin
         dv:=frcmax(dv+10,dvLIMIT);
         goto redo;
         end
      //.palette full and DV is maxed out - change color into first non-transparent "a[1]" color and be done with it - 18JAN2012
      else sr24[dx]:=a[1];
      end;
   end;//dx
   end//24
//.32
else if (xbits=32) then
   begin
   for dx:=dx1 to dx2 do
   begin
   //get
   sc32:=sr32[dx];
   zc.r:=sc32.r;
   zc.g:=sc32.g;
   zc.b:=sc32.b;
   //filter - only non-transparent colors
   if (dv>=2) then dvcolor;
   //scan - look in palette to see if we already have this color
   i:=-1;
   for p:=0 to (acount-1) do if (a[p].r=zc.r) and (a[p].g=zc.g) and (a[p].b=zc.b) then
      begin
      i:=p;
      break;
      end;
   //.counting colors only -> palette is full so we can stop - 22sep2021
   if (not xreducetofit) and ((acount>=alimit) or (i=-1)) then goto skipdone;
   //add color
   if (i=-1) then
      begin
      //.add to palette
      if (acount<alimit) then
         begin
         a[acount]:=zc;
         inc(acount);
         end
      //.palette full - retry at a higher DV rate
      else if (dv<dvLIMIT) then
         begin
         dv:=frcmax(dv+10,dvLIMIT);
         goto redo;
         end
      //.palette full and DV is maxed out - change color into first non-transparent "a[1]" color and be done with it - 18JAN2012
      else
         begin
         sc32.r:=a[1].r;
         sc32.g:=a[1].g;
         sc32.b:=a[1].b;//Note: sc32.a retained from above
         sr32[dx]:=sc32;
         end;
      end;
   end;//dx
   end;//32
end;//dy

//adjust image colors (dv>=2)
if xreducetofit and (dv>=2) then
   begin
   for dy:=0 to (xh-1) do
   begin
   if not misscan82432(x,dy,sr8,sr24,sr32) then goto skipend;
   //.8
   if (xbits=8) then
      begin
      for dx:=dx1 to dx2 do
      begin
      sc8:=sr8[dx];
      zc.r:=sc8;
      zc.g:=sc8;
      zc.b:=sc8;
      dvcolor;
      sr8[dx]:=zc.r;
      end;//dx
      end//24
   //.24
   else if (xbits=24) then
      begin
      for dx:=dx1 to dx2 do
      begin
      zc:=sr24[dx];
      dvcolor;
      sr24[dx]:=zc;
      end;//dx
      end//24
   //.32
   else if (xbits=32) then
      begin
      for dx:=dx1 to dx2 do
      begin
      sc32:=sr32[dx];
      zc.r:=sc32.r;
      zc.g:=sc32.g;
      zc.b:=sc32.b;
      dvcolor;
      sc32.r:=zc.r;
      sc32.g:=zc.g;
      sc32.b:=zc.b;//Note: sc32.a retained from above
      sr32[dx]:=sc32;
      end;//dx
      end;//32
   end;//dy
   end;

//successful
skipdone:
result:=true;
skipend:
except;end;
end;
//## misreduce82432 ##
function misreduce82432(s:tobject;stranscol,slessdata:longint;var e:string):boolean;
label
   skipend;
var
   sr8 :pcolorrow8;
   sr24:pcolorrow24;
   sr32:pcolorrow32;
   sc24:tcolor24;
   sc32:tcolor32;
   sx,sy,sw,sh,sbits,tr,tg,tb,trSAFE,tgSAFE,tbSAFE,xreducer1,xreducer2:longint;
   xreducerok:boolean;
   //## xreduce32 ##
   procedure xreduce32;
   const
      xthreshold=50;
   begin
   //.leave these primary colors FULLY intact - 13jan2021
   if ((sc32.r<>255) or (sc32.g<>255) or (sc32.b<>255)) and//white clwhite
      ((sc32.r<>0  ) or (sc32.g<>0  ) or (sc32.b<>0  )) and//black clblack
      ((sc32.r<>255) or (sc32.g<>0  ) or (sc32.b<>0  )) and//red   clred
      ((sc32.r<>0  ) or (sc32.g<>255) or (sc32.b<>0  )) and//lime  clime
      ((sc32.r<>0  ) or (sc32.g<>0  ) or (sc32.b<>255)) and//blue clblue
      ((sc32.r<>tr ) or (sc32.g<>tg ) or (sc32.b<>tb))  then//transparent color if specified - 20jan2021
      begin
      //get
      if (sc32.r>xthreshold) then sc32.r:=(sc32.r div xreducer1)*xreducer1 else sc32.r:=(sc32.r div xreducer2)*xreducer2;
      if (sc32.g>xthreshold) then sc32.g:=(sc32.g div xreducer1)*xreducer1 else sc32.g:=(sc32.g div xreducer2)*xreducer2;
      if (sc32.b>xthreshold) then sc32.b:=(sc32.b div xreducer1)*xreducer1 else sc32.b:=(sc32.b div xreducer2)*xreducer2;
      //restrict
      if (sc32.r=tr) and (sc32.g=tg) and (sc32.b=tb) then//transparent color
         begin
         sc32.r:=trSAFE;
         sc32.g:=tbSAFE;
         sc32.b:=tgSAFE;
         end
      else if (sc32.r=255) and (sc32.g=255) and (sc32.b=255) then//non-white
         begin
         sc32.r:=254;
         sc32.g:=254;
         sc32.b:=254;
         end
      else if (sc32.r=0) and (sc32.g=0) and (sc32.b=0) then//non-black
         begin
         sc32.r:=1;
         sc32.g:=1;
         sc32.b:=1;
         end
      else if (sc32.r=255) and (sc32.g=0) and (sc32.b=0) then//non-red
         begin
         sc32.r:=254;
         sc32.g:=0;
         sc32.b:=0;
         end
      else if (sc32.r=0) and (sc32.g=255) and (sc32.b=0) then//non-green
         begin
         sc32.r:=0;
         sc32.g:=254;
         sc32.b:=0;
         end
      else if (sc32.r=0) and (sc32.g=0) and (sc32.b=255) then//non-blue
         begin
         sc32.r:=0;
         sc32.g:=0;
         sc32.b:=254;
         end;
      end;
   //.leave these alpha values FULLY intact - 13jan2021
   if (sc32.a<>0) then
      begin
      if (sc32.a>xthreshold) then sc32.a:=(sc32.a div xreducer1)*xreducer1 else sc32.a:=(sc32.a div xreducer2)*xreducer2;
      if (sc32.a=0) then sc32.a:=xreducer1;
      end;
   end;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
//init
if not misok82432(s,sbits,sw,sh) then goto skipend;

//range
slessdata:=frcrange(slessdata,0,5);

//slessdata
xreducer1:=slessdata;
xreducer2:=xreducer1+1;
xreducerok:=(xreducer1>=2) or (xreducer2>=2);
if not xreducerok then//nothing to do when "slessdata=0"
   begin
   result:=true;
   goto skipend;
   end;
//xtranscol -> used in this proc for reduce32 (to avoid reducing this particular color)
tr:=-1;
tg:=-1;
tb:=-1;
if (stranscol<>clnone) then
   begin
   sc24:=low__intrgb(stranscol);
   if (sbits=8) then
      begin
      if (sc24.g>sc24.r) then sc24.r:=sc24.g;
      if (sc24.b>sc24.r) then sc24.r:=sc24.b;
      end;
   tr:=sc24.r;
   tg:=sc24.g;
   tb:=sc24.b;
   //.filter
   if (tr=255) and (tg=255) and (tb=255) then
      begin
      trSAFE:=254;
      tgSAFE:=254;
      tbSAFE:=254;
      end
   else
      begin
      trSAFE:=255;
      tgSAFE:=255;
      tbSAFE:=255;
      end;
   end;

//get
for sy:=0 to (sh-1) do
begin
if not misscan82432(s,sy,sr8,sr24,sr32) then goto skipend;
//.8
if (sbits=8) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sc32.r:=sr8[sx];
   sc32.g:=0;
   sc32.b:=0;
   sc32.a:=0;
   xreduce32;
   sr8[sx]:=sc32.r;
   end;//sx
   end
//.24
else if (sbits=24) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sc24:=sr24[sx];
   sc32.r:=sc24.r;
   sc32.g:=sc24.g;
   sc32.b:=sc24.b;
   sc32.a:=0;//not used
   xreduce32;
   sc24.r:=sc32.r;
   sc24.g:=sc32.g;
   sc24.b:=sc32.b;
   sr24[sx]:=sc24;
   end;//sx
   end
//.32
else if (sbits=32) then
   begin
   for sx:=0 to (sw-1) do
   begin
   sc32:=sr32[sx];
   xreduce32;
   sr32[sx]:=sc32;
   end;//sx
   end;
end;//sy

//successful
result:=true;
skipend:
except;end;
end;
//## mistoPngcells82432 ##
function mistoPngcells82432(s:tobject;sdelay,scellcount,stranscol,sfeather,slessdata:longint;stransframe,xbestsize:boolean;xdata:tstr8;var e:string):boolean;//28jan2021
label
   skipdone,skipend;
var
   xpngcellslen,dlen,p,cw,ch,sbits,sx,sw,sh:longint;
   img24:tbasicimage;
   scell:tbasicimage;
   scelldata:tstr8;
   str1:string;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
scell:=nil;
scelldata:=nil;
img24:=nil;
xpngcellslen:=0;
//check
if block(xdata) then xdata.clear else goto skipend;
//init
if not misok82432(s,sbits,sw,sh) then goto skipend;
sfeather:=frcrange(sfeather,-1,100);//-1=asis, 0=none(sharp), 1..100=feather(Npx/blur)
slessdata:=frcrange(slessdata,0,5);
sdelay:=frcrange(sdelay,0,60*1000);//0ms -> 60,0000ms
scellcount:=frcrange(scellcount,1,sw);
cw:=frcrange(sw div scellcount,1,sw);
ch:=sh;
scell:=misimg(sbits,cw,ch);//same level of bits as "s" - 28jan2021
scelldata:=bnew;
//header
xdata.aadd([uuP,uuN,uuG,ssDash,uuC,uuE,uuL,uuL,uuS,nn1]);//PNG-CELLS1
xdata.addint4(1);xdata.addint4(cw);//cellwidth
xdata.addint4(2);xdata.addint4(ch);//cellheight
xdata.addint4(3);xdata.addint4(sdelay);//delay
xdata.addint4(4);xdata.addint4(scellcount);//cellcount
xdata.addint4(5);xdata.addint4(stranscol);//transparent color
xdata.addint4(6);xdata.addint4(sfeather);//feather
xdata.addint4(7);xdata.addint4(slessdata);//lessdata
dlen:=xdata.len;//track how much data occurs BEFORE first cell
//get
sx:=0;
for p:=1 to scellcount do
begin
if not miscopyareaxx1(0,0,cw,ch,misrect(sx,0,sx+cw-1,ch-1),scell,s) then goto skipend;
if not mistopng82432(scell,stranscol,sfeather,slessdata,stransframe,scelldata,str1) then goto skipend;
//.write cell
xdata.addint4(101);xdata.addint4(scelldata.len);//type=cell(4) + datalen(4) + data(0..N)
inc(xpngcellslen,scelldata.len);//track combined data usage for all cells
xdata.add(scelldata);
inc(sx,cw);
end;//p
//end

//.non-feather mode -> see if storing the entire image as a zipped 24bit bmp is smaller than individual PNG cells - 28jan2021
if (sfeather=0) and (not xbestsize) then
   begin
   img24:=misimg(24,sw,sh);
   if not miscopyareaxx1(0,0,sw,sh,misrect(0,0,sw-1,sh-1),img24,s) then goto skipend;
   if (slessdata>=1) and (not misreduce82432(img24,stranscol,slessdata,e)) then goto skipend;
   if not mistodata(img24,scelldata,'bmp',e) then goto skipend;
   freeobj(@img24);//reduce memory
   if not low__compress(scelldata,e) then goto skipend;
   //use this ZIPPED image if it's smaller
   if (scelldata.len<xpngcellslen) then
      begin
      xdata.setlen(dlen);//delete png-cells
      xdata.addint4(100);xdata.addint4(scelldata.len);//store ZIPPED bmp imagestrip with NO MASK (mask is recreated in the reader proc) - 28jan2021
      xdata.add(scelldata);
      end;
   end;

skipdone:
//mark end of datastream - 28jan2021
xdata.addint4(9);xdata.addint4(0);

//successful
result:=true;
skipend:
except;end;
try
if (not result) and zzok(xdata,7015) then xdata.clear;
freeobj(@img24);
freeobj(@scell);
bfree(scelldata);
bunlockautofree(xdata);
except;end;
end;
//## misfromPngcells82432 ##
function misfromPngcells82432(s:tobject;sbackcol:longint;xdata:tstr8;var e:string):boolean;//28jan2021
var
   scellcount,scellwidth,scellheight,sdelay,stranscol,sfeather,slessdata:longint;
begin
try;result:=misfromPngcells82432ex(s,sbackcol,scellcount,scellwidth,scellheight,sdelay,stranscol,sfeather,slessdata,xdata,e);except;end;
end;
//## misfromPngcells82432ex ##
function misfromPngcells82432ex(s:tobject;sbackcol:longint;var sdelay,scellcount,scellwidth,scellheight,stranscol,sfeather,slessdata:longint;xdata:tstr8;var e:string):boolean;//28jan2021
label
   skipend;
var
   sr32:pcolorrow32;
   sc24:tcolor24;
   sc32:tcolor32;
   tr,tg,tb,n,v,xlen,xpos,p,cw,ch,sbits,sx,sy,sw,sh:longint;
   cmp1:comp;
   scell:tbasicimage;
   scelldata:tstr8;
   str1:string;
   xreadingcells:boolean;
   //## xpullint4 ##
   function xpullint4(var xval:longint):boolean;
   begin
   //defaults
   result:=false;
   xval:=0;
   //get
   if ((xpos+3)<xlen) then
      begin
      xval:=xdata.int4[xpos];
      inc(xpos,4);
      result:=true;
      end;
   end;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
scell:=nil;
scelldata:=nil;
sdelay:=0;
scellcount:=0;
scellwidth:=0;
scellheight:=0;
stranscol:=clnone;
sfeather:=-1;//asis
slessdata:=0;//off
xpos:=0;
//check
if not block(xdata) then goto skipend;
xlen:=xdata.len;
if (xlen<=0) then
   begin
   e:=gecUnknownformat;
   goto skipend;
   end;
//init
if not misok82432(s,sbits,sw,sh) then goto skipend;

//header
if not xdata.asame3(0,[uuP,uuN,uuG,ssDash,uuC,uuE,uuL,uuL,uuS,nn1],false) then//PNG-CELLS1
   begin
   e:=gecUnknownformat;
   goto skipend;
   end;
inc(xpos,10);//jump over header

//get -> read values -> all header values MUST be read BEFORE the first cell
sx:=0;
xreadingcells:=false;
while true do
begin
if not xpullint4(n) then goto skipend;//block style
if not xpullint4(v) then goto skipend;//block value (or cell datalen)

//.header values
if not xreadingcells then
   begin
   case n of
   1:scellwidth:=v;//cellwidth
   2:scellheight:=v;//cellheight
   3:sdelay:=v;//delay
   4:scellcount:=v;//cellheight
   5:stranscol:=v;
   6:sfeather:=v;
   7:slessdata:=v;
   100,101:begin//100=ZIPPED imagestrip of cells (one image/block of data), 101=separate PNG cells
      xreadingcells:=true;
      //range
      if (scellwidth<=0) or (scellheight<=0) or (scellcount<=0) then
         begin
         e:=gecDatacorrupt;
         goto skipend;
         end;
      sdelay:=frcrange(sdelay,0,60*1000);
      sfeather:=frcrange(sfeather,-1,100);//-1=asis, 0=none(sharp), 1..100=feather(Npx/blur)
      slessdata:=frcrange(slessdata,0,5);
      //.sh & sw
      sh:=scellheight;
      cmp1:=scellwidth;
      cmp1:=cmp1*scellcount;
      if (cmp1<=0) or (cmp1>maxint) or (sh<=0) then
         begin
         e:=gecDatacorrupt;
         goto skipend;
         end;
      sw:=scellwidth*scellcount;
      //init
      if zznil(scell,2160) then scell:=misimg(sbits,scellwidth,scellheight);//same level of bits as "s" - 28jan2021
      if zznil(scelldata,2161) then scelldata:=bnew;
      //.resize "s" to fit all cells
      if not missize2(s,sw,sh,true) then
         begin
         e:=gecOutofmemory;
         goto skipend;
         end;
      end;//begin
   end;//case
   end;

//.100 - zipped BMP imagestrip
if xreadingcells and (n=100) then
   begin
   //imagestrip has data
   if (v>=1) and (sx<sw) then
      begin
      scelldata.clear;
      if not scelldata.add3(xdata,xpos,v) then goto skipend;
      if not low__decompress(scelldata,e) then goto skipend;
      if not misfromdata(scell,scelldata,e) then goto skipend;
      if not miscopyareaxx1(0,0,sw,sh,misrect(0,0,sw-1,sh-1),s,scell) then goto skipend;
      //recreate mask if "s" is 32bit
      if (sbits=32) then
         begin
         tr:=-1;
         tg:=-1;
         tb:=-1;
         if (stranscol<>clnone) and (not misfindtranscol82432ex(s,stranscol,tr,tg,tb)) then goto skipend;
         //create a "sharp" 0/1 mask for 32bit image - 28jan2021
         for sy:=0 to (sh-1) do
         begin
         if not misscan32(s,sy,sr32) then goto skipend;
         for sx:=0 to (sw-1) do
         begin
         sc32:=sr32[sx];
         if (tr=sc32.r) and (tg=sc32.g) and (tb=sc32.b) then sc32.a:=0 else sc32.a:=255;
         sr32[sx]:=sc32;
         end;//sx
         end;//sy
         end;
      //inc
      inc(sx,sw);//inc to next cell
      inc(xpos,v);//inc past end of "cell.datastream"
      end;
   end;

//.101 - separate PNG cells
if xreadingcells and (n=101) then
   begin
   //cell has data
   if (v>=1) and (sx<sw) then
      begin
      scelldata.clear;
      if not scelldata.add3(xdata,xpos,v) then goto skipend;
      if not misfrompng82432(scell,sbackcol,scelldata,str1) then
         begin
         e:=gecDatacorrupt;
         goto skipend;
         end;
      if not miscopyareaxx1(sx,0,scellwidth,scellheight,misrect(0,0,misw(scell)-1,mish(scell)-1),s,scell) then goto skipend;
      //inc
      inc(sx,scellwidth);//inc to next cell
      inc(xpos,v);//inc past end of "cell.datastream"
      end;
   end;

//.9 - stop reading datastream
if (n=9) then break;
end;//with

//check
if (scellwidth<=0) or (scellheight<=0) or (scellcount<=0) then
   begin
   e:=gecDatacorrupt;
   goto skipend;
   end;

//transparent feedback
if mishasai(s) then
   begin
   misai(s).format:='PNGC';//png cells
   misai(s).subformat:=inttostr(stranscol)+'.'+inttostr(sfeather)+'.'+inttostr(slessdata);//23jan2021
   misai(s).transparent:=(stranscol<>clnone);
   misai(s).delay:=sdelay;
   misai(s).count:=scellcount;
   misai(s).cellwidth:=scellwidth;
   misai(s).cellheight:=scellheight;
   misai(s).bpp:=sbits;
   end;

//successful
result:=true;
skipend:
except;end;
try
freeobj(@scell);
freeobj(@scelldata);
bunlockautofree(xdata);
except;end;
end;
//## mistoJpgcells82432 ##
function mistoJpgcells82432(s:tobject;sdelay,scellcount,stranscol,sfeather,slessdata:longint;xbestsize:boolean;xdata:tstr8;var e:string):boolean;//29jan2021
label
   skipdone,skipend;
var
   xjpgcellslen,dlen,p,cw,ch,sbits,sx,sw,sh:longint;
   img24:tbasicimage;
   scell:tbasicimage;
   scelldata:tstr8;
   str1:string;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
img24:=nil;
scell:=nil;
scelldata:=nil;
xjpgcellslen:=0;
//check
if block(xdata) then xdata.clear else goto skipend;
//init
if not misok82432(s,sbits,sw,sh) then goto skipend;
sfeather:=frcrange(sfeather,-1,100);//-1=asis, 0=none(sharp), 1..100=feather(Npx/blur)
slessdata:=frcrange(slessdata,0,5);
sdelay:=frcrange(sdelay,0,60*1000);//0ms -> 60,0000ms
scellcount:=frcrange(scellcount,1,sw);
cw:=frcrange(sw div scellcount,1,sw);
ch:=sh;
scell:=misimg(sbits,cw,ch);//same level of bits as "s" - 29jan2021
scelldata:=bnew;
//header
xdata.aadd([uuJ,uuP,uuG,ssDash,uuC,uuE,uuL,uuL,uuS,nn1]);//JPG-CELLS1
xdata.addint4(1);xdata.addint4(cw);//cellwidth
xdata.addint4(2);xdata.addint4(ch);//cellheight
xdata.addint4(3);xdata.addint4(sdelay);//delay
xdata.addint4(4);xdata.addint4(scellcount);//cellcount
xdata.addint4(5);xdata.addint4(stranscol);//transparent color
xdata.addint4(6);xdata.addint4(sfeather);//feather
xdata.addint4(7);xdata.addint4(slessdata);//lessdata
dlen:=xdata.len;//track how much data occurs BEFORE first cell
//get
sx:=0;
for p:=1 to scellcount do
begin
if not miscopyareaxx1(0,0,cw,ch,misrect(sx,0,sx+cw-1,ch-1),scell,s) then goto skipend;
if not mistojpg82432ex(scell,stranscol,sfeather,slessdata,false,scelldata,str1) then goto skipend;
//.write cell
xdata.addint4(101);xdata.addint4(scelldata.len);//type=cell(4) + datalen(4) + data(0..N)
inc(xjpgcellslen,scelldata.len);
xdata.add(scelldata);
inc(sx,cw);
end;//p
//end

//.non-feather mode -> see if storing the entire image as a zipped 24bit bmp is smaller than individual JPG cells - 29jan2021
if (sfeather=0) and (not xbestsize) then
   begin
   img24:=misimg(24,sw,sh);
   if not miscopyareaxx1(0,0,sw,sh,misrect(0,0,sw-1,sh-1),img24,s) then goto skipend;
   if (slessdata>=1) and (not misreduce82432(img24,stranscol,slessdata,e)) then goto skipend;
   if not mistodata(img24,scelldata,'bmp',e) then goto skipend;
   freeobj(@img24);//reduce memory
   if not low__compress(scelldata,e) then goto skipend;
   //use this ZIPPED image if it's smaller
   if (scelldata.len<xjpgcellslen) then
      begin
      xdata.setlen(dlen);//delete jpg-cells
      xdata.addint4(100);xdata.addint4(scelldata.len);//store ZIPPED bmp imagestrip with NO MASK (mask is recreated in the reader proc) - 28jan2021
      xdata.add(scelldata);
      end;
   end;

skipdone:
//mark end of datastream - 28jan2021
xdata.addint4(9);xdata.addint4(0);

//successful
result:=true;
skipend:
except;end;
try
if (not result) and zzok(xdata,7016) then xdata.clear;
freeobj(@img24);
freeobj(@scell);
bfree(scelldata);
bunlockautofree(xdata);
except;end;
end;
//## misfromJpgcells82432 ##
function misfromJpgcells82432(s:tobject;sbackcol:longint;xdata:tstr8;var e:string):boolean;//28jan2021
var
   scellcount,scellwidth,scellheight,sdelay,stranscol,sfeather,slessdata:longint;
begin
try;result:=misfromJpgcells82432ex(s,sbackcol,scellcount,scellwidth,scellheight,sdelay,stranscol,sfeather,slessdata,xdata,e);except;end;
end;
//## misfromJpgcells82432ex ##
function misfromJpgcells82432ex(s:tobject;sbackcol:longint;var sdelay,scellcount,scellwidth,scellheight,stranscol,sfeather,slessdata:longint;xdata:tstr8;var e:string):boolean;//28jan2021
label
   skipend;
var
   sr32:pcolorrow32;
   sc24:tcolor24;
   sc32:tcolor32;
   tr,tg,tb,n,v,xlen,xpos,p,cw,ch,sbits,sx,sy,sw,sh:longint;
   cmp1:comp;
   scell:tbasicimage;
   scelldata:tstr8;
   str1:string;
   xreadingcells:boolean;
   //## xpullint4 ##
   function xpullint4(var xval:longint):boolean;
   begin
   //defaults
   result:=false;
   xval:=0;
   //get
   if ((xpos+3)<xlen) then
      begin
      xval:=xdata.int4[xpos];
      inc(xpos,4);
      result:=true;
      end;
   end;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
scell:=nil;
scelldata:=nil;
sdelay:=0;
scellcount:=0;
scellwidth:=0;
scellheight:=0;
stranscol:=clnone;
sfeather:=-1;//asis
slessdata:=0;//off
xpos:=0;
//check
if not block(xdata) then goto skipend;
xlen:=xdata.len;
if (xlen<=0) then
   begin
   e:=gecUnknownformat;
   goto skipend;
   end;
//init
if not misok82432(s,sbits,sw,sh) then goto skipend;

//header
if not xdata.asame3(0,[uuJ,uuP,uuG,ssDash,uuC,uuE,uuL,uuL,uuS,nn1],false) then//JPG-CELLS1
   begin
   e:=gecUnknownformat;
   goto skipend;
   end;
inc(xpos,10);//jump over header

//get -> read values -> all header values MUST be read BEFORE the first cell
sx:=0;
xreadingcells:=false;
while true do
begin
if not xpullint4(n) then goto skipend;//block style
if not xpullint4(v) then goto skipend;//block value (or cell datalen)

//.header values
if not xreadingcells then
   begin
   case n of
   1:scellwidth:=v;//cellwidth
   2:scellheight:=v;//cellheight
   3:sdelay:=v;//delay
   4:scellcount:=v;//cellheight
   5:stranscol:=v;
   6:sfeather:=v;
   7:slessdata:=v;
   100,101:begin//101=separate JPG cells (can't do a 100 -> zipped image stream as JPEG will blur into neighbouring cells)
      xreadingcells:=true;
      //range
      if (scellwidth<=0) or (scellheight<=0) or (scellcount<=0) then
         begin
         e:=gecDatacorrupt;
         goto skipend;
         end;
      sdelay:=frcrange(sdelay,0,60*1000);
      sfeather:=frcrange(sfeather,-1,100);//-1=asis, 0=none(sharp), 1..100=feather(Npx/blur)
      slessdata:=frcrange(slessdata,0,5);
      //.sh & sw
      sh:=scellheight;
      cmp1:=scellwidth;
      cmp1:=cmp1*scellcount;
      if (cmp1<=0) or (cmp1>maxint) or (sh<=0) then
         begin
         e:=gecDatacorrupt;
         goto skipend;
         end;
      sw:=scellwidth*scellcount;
      //init
      if zznil(scell,2163) then scell:=misimg(sbits,scellwidth,scellheight);//same level of bits as "s" - 28jan2021
      if zznil(scelldata,2164) then scelldata:=bnew;
      //.resize "s" to fit all cells
      if not missize2(s,sw,sh,true) then
         begin
         e:=gecOutofmemory;
         goto skipend;
         end;
      end;//begin
   end;//case
   end;

//.100 - zipped BMP imagestrip
if xreadingcells and (n=100) then
   begin
   //imagestrip has data
   if (v>=1) and (sx<sw) then
      begin
      scelldata.clear;
      if not scelldata.add3(xdata,xpos,v) then goto skipend;
      if not low__decompress(scelldata,e) then goto skipend;
      if not misfromdata(scell,scelldata,e) then goto skipend;
      if not miscopyareaxx1(0,0,sw,sh,misrect(0,0,sw-1,sh-1),s,scell) then goto skipend;
      //recreate mask if "s" is 32bit
      if (sbits=32) then
         begin
         tr:=-1;
         tg:=-1;
         tb:=-1;
         if (stranscol<>clnone) and (not misfindtranscol82432ex(s,stranscol,tr,tg,tb)) then goto skipend;
         //create a "sharp" 0/1 mask for 32bit image - 28jan2021
         for sy:=0 to (sh-1) do
         begin
         if not misscan32(s,sy,sr32) then goto skipend;
         for sx:=0 to (sw-1) do
         begin
         sc32:=sr32[sx];
         if (tr=sc32.r) and (tg=sc32.g) and (tb=sc32.b) then sc32.a:=0 else sc32.a:=255;
         sr32[sx]:=sc32;
         end;//sx
         end;//sy
         end;
      //inc
      inc(sx,sw);//inc to next cell
      inc(xpos,v);//inc past end of "cell.datastream"
      end;
   end;

//.101 - separate JPG cells
if xreadingcells and (n=101) then
   begin
   //cell has data
   if (v>=1) and (sx<sw) then
      begin
      scelldata.clear;
      if not scelldata.add3(xdata,xpos,v) then goto skipend;
      if not misfromjpg82432(scell,sbackcol,scelldata,str1) then
         begin
         e:=gecDatacorrupt;
         goto skipend;
         end;
      if not miscopyareaxx1(sx,0,scellwidth,scellheight,misrect(0,0,misw(scell)-1,mish(scell)-1),s,scell) then goto skipend;
      //inc
      inc(sx,scellwidth);//inc to next cell
      inc(xpos,v);//inc past end of "cell.datastream"
      end;
   end;

//.9 - stop reading datastream
if (n=9) then break;
end;//with

//check
if (scellwidth<=0) or (scellheight<=0) or (scellcount<=0) then
   begin
   e:=gecDatacorrupt;
   goto skipend;
   end;

//transparent feedback
if mishasai(s) then
   begin
   misai(s).format:='JPGC';//jpeg cells
   misai(s).subformat:=inttostr(stranscol)+'.'+inttostr(sfeather)+'.'+inttostr(slessdata);//23jan2021
   misai(s).transparent:=(stranscol<>clnone);
   misai(s).delay:=sdelay;
   misai(s).count:=scellcount;
   misai(s).cellwidth:=scellwidth;
   misai(s).cellheight:=scellheight;
   misai(s).bpp:=sbits;
   end;

//successful
result:=true;
skipend:
except;end;
try
freeobj(@scell);
freeobj(@scelldata);
bunlockautofree(xdata);
except;end;
end;
//## degtorad2 ##
function degtorad2(deg:extended):extended;//20OCT2009
const
   PieRadian=3.1415926535897932384626433832795;
   v=((2*PieRadian)/360);
begin
try;result:=v*deg;except;end;
end;
//## miscurveAirbrush2 ##
function miscurveAirbrush2(var x:array of longint;xcount,valmin,valmax:longint;xflip,yflip:boolean):boolean;//20jan2021, 29jul2016
var
   dp,dv,valmag,p,v,maxp:longint;
   tmp,deg:extended;
begin
try
//defaults
result:=false;
//range
xcount:=frcrange(xcount,0,high(x)+1);
if (xcount<2) then exit;
if (valmin>valmax) then low__swapint(valmin,valmax);
//init
valmag:=valmax-valmin;
maxp:=frcmin(xcount-1,0);
//set
for p:=0 to maxp do
begin
deg:=90*(p/(1+maxp));//29jul2016
tmp:=round(maxp*sin(degtorad2(deg)));
deg:=90*(tmp/(1+maxp));
v:=round(
 valmag*
 power(cos(degtorad2(deg)),2)//4 or 5 increases the steepness, 1..3 decreases steepness, 3=middle ground and is 98% same as Adobe's aribrush curve
 );
v:=frcrange(v,0,valmag);
//.support X and Y flipping - 20jan2021
if xflip then dp:=p else dp:=maxp-p;
if yflip then dv:=valmax-v else dv:=valmin+v;
x[dp]:=frcrange(dv,valmin,valmax);
end;//p
//successful
result:=true;
except;end;
end;
//## low__comparetext ##
function low__comparetext(a,b:string):boolean;
begin
try;result:=(comparetext(a,b)=0);except;end;
end;
//## low__comparetext ##
function low__comparetext2(a,b:string):longint;
begin
try;result:=comparetext(a,b);except;end;
end;
//## low__comparetext3 ##
function low__comparetext3(a,b:string;var xmatched:boolean):boolean;//28dec2021
begin
try;result:=(comparetext(a,b)=0);xmatched:=result;except;end;
end;
//## low__comparetextcase ##
function low__comparetextcase(a,b:string):boolean;
begin
try;result:=(comparestr(a,b)=0);except;end;
end;
//## low__comparetextcase2 ##
function low__comparetextcase2(a,b:string):longint;
begin
try;result:=comparestr(a,b);except;end;
end;
//## anyformatb ##
function anyformatb(xdata:tstr8):string;
begin
try;anyformat(xdata,result);except;end;
end;
//## anyformat ##
function anyformat(xdata:tstr8;var xformat:string):boolean;//returns EXT of any known format, image, sound, frame, etc - 30jan2021
label
   skipend;
var
   e:string;
   a:tstr8;//pointer only
begin
try
//defaults
result:=false;
xformat:='';

//check
if not block(xdata) then goto skipend;
if (xdata.len<=0) then goto skipend;
a:=xdata;

//images -----------------------------------------------------------------------
//.bmp
if      a.asame3(0,[uuB,uuM],true)                                        then xformat:='BMP'//'BM'
//.wmf
else if a.asame3(0,[215,205,198,154],true)                                then xformat:='WMF'
//.emf
else if a.asame3(0,[1,0,0,0],true)                                        then xformat:='EMF'
//.png
else if a.asame3(0,[137,80,78,71,13,10,26,10],true)                       then xformat:='PNG'//27jan2021
//.pngc
else if a.asame3(0,[uuP,uuN,uuG,ssDash,uuC,uuE,uuL,uuL,uuS,nn1],false)    then xformat:='PNGC'//PNG-CELLS1
//.jpg
else if a.asame3(0,[uuJ,uuF,uuI,uuF],false)                               then xformat:='JPG'//'JFIF'
else if a.asame3(0,[255,216,255],true)                                    then xformat:='JPG'//for ALL jpegs FF,D8,FF = first 3 reliably identical bytes
//.jpgt
else if a.asame3(0,[uuJ,uuP,uuG,uuT],false)                               then xformat:='JPGT'//transparent jpeg
//.jpge
else if a.asame3(0,[uuJ,uuP,uuG,ssDash,uuE,nn1],false)                    then xformat:='JPGE'//JPG-E1 -> enhanced jpeg v1 - 29jan2021
//.jpgc
else if a.asame3(0,[uuJ,uuP,uuG,ssDash,uuC,uuE,uuL,uuL,uuS,nn1],false)    then xformat:='JPGC'//JPG-CELLS1 - 29jan2021
//.ico
else if (a.asame3(0,[0,0,0,0],true) or a.asame3(0,[0,0,1,0],true)) and
        (not a.asame3(4,[0,0],true))                                      then xformat:='ICO'
//.cur
else if a.asame3(0,[0,0,2,0],true) and (not a.asame3(4,[0,0],true))       then xformat:='ICO'
//.ani
else if a.asame3(0,[uuR,uuI,uuF,uuF],false) and
        a.asame3(8,[uuA,uuC,uuO,uuN],false)                               then xformat:='ANI'//RIFF -> ANI (animated cursor)
//.san
else if a.asame3(0,[uuT,uuP,uuF,nn0, 4 ,uuT,uuS,uuA,uuN],true)            then xformat:='SAN'
//.omi
else if a.asame3(0,[uuO,uuM,uuI],false)                                   then xformat:='OMI'
//.gif
else if a.asame3(0,[uuG,uuI,uuF],false)                                   then xformat:='GIF'
//.vbmp
else if a.asame3(0,[uuV,uuB,nn0,nn1],false)                               then xformat:='VBMP'
//.ppm
else if a.asame3(0,[uuP,nn3],false) or a.asame3(0,[uuP,nn6],false)        then xformat:='PPM'//3=text, 6=binary
//.pgm
else if a.asame3(0,[uuP,nn2],false) or a.asame3(0,[uuP,nn5],false)        then xformat:='PGM'//2=text, 5=binary
//.pbm
else if a.asame3(0,[uuP,nn1],false) or a.asame3(0,[uuP,nn4],false)        then xformat:='PBM'//1=text, 4=binary
//.xbm
else if a.asame3(0,[ssHash,uuD,uuE,uuF,uuI,uuN,uuE],false)                then xformat:='XBM'//#DEFINE
//.tep
else if a.asame3(0,[uuT,uuE],false) and ( a.asame3(2,[nn1],true) or
        a.asame3(2,[nn2],true) or a.asame3(2,[nn3],true) or
        a.asame3(2,[nn4],true) or a.asame3(2,[nn5],true) or
        a.asame3(2,[nn6],true) )                                          then xformat:='TEP'
//.tea
else if a.asame3(0,[uuT,uuE,uuA,nn1,ssHash],false)                        then xformat:='TEA'//TEA1#
else if a.asame3(0,[uuT,uuE,uuA,nn2,ssHash],false)                        then xformat:='TEA'//TEA2# - 12apr2021
//.tem
else if a.asame3(0,[uuT,uuE,uuM,nn1,ssHash],false)                        then xformat:='TEM'
//.teh
else if a.asame3(0,[uuT,uuE,uuH,nn1,ssHash],false)                        then xformat:='TEH'
//.teb
else if a.asame3(0,[uuT,uuE,uuB,nn1,ssHash],false)                        then xformat:='TEB'
//.tec
else if a.asame3(0,[uuT,uuE,uuC,nn1,ssHash],false)                        then xformat:='TEC'
//.t24
else if a.asame3(0,[uuA,uuC,uuE,uuG],false)                               then xformat:='T24'
//.anm
else if a.asame3(0,[uuA,uuN,uuM,ssColon],false)                           then xformat:='ANM'
//.aan
else if a.asame3(0,[uuA,uuA,uuN,ssHash],false)                            then xformat:='AAN'
//.aas
else if a.asame3(0,[ssHash,uuI,uuN,uuI,uuT],false)                        then xformat:='AAS'//it's a bit general - 29NOV2010
//.gr8
else if a.asame3(0,[uuG,uuR,nn8,ssColon],false)                           then xformat:='GR8'
//.bw1
else if a.asame3(0,[uuB,uuW,nn1,ssColon],false)                           then xformat:='BW1'//1bit binary blackANDwhite - fast read/write - 14JUL2013
//.lig
else if a.asame3(0,[uuL,uuI,uuG,ssHash],false)                            then xformat:='LIG'//rapid 4bit full color image encoder - 02dec2018
//.b12
else if a.asame3(0,[uuB,nn1,nn2,ssHash],false)                            then xformat:='B12'//12bit RGB - fast read/write - 23nov2018
//.b04
else if a.asame3(0,[uuB,nn0,nn4,ssHash],false)                            then xformat:='B04'//4bit RGB - fast read/write - 28nov2018
//.yuv
else if a.asame3(0,[uuY,uuU,uuV,ssColon],false)                           then xformat:='YUV'//16bit TV format - fast read/write - 10APR2012
//.raw24
else if a.asame3(0,[uuR,uuA,uuW,24],true)                                 then xformat:='RAW24'

//audio ------------------------------------------------------------------------
//.mid
else if a.asame3(0,[uuM,uuT,uuH,uuD],false)                               then xformat:='MID'//MTHD
else if a.asame3(0,[uuR,uuI,uuF,uuF],false) and a.asame3(8,[uuR,uuM,uuI,uuD],false) then xformat:='MID'//RIFF -> RMID
//.wav
else if a.asame3(0,[uuR,uuI,uuF,uuF],false) and a.asame3(8,[uuW,uuA,uuV,uuE],false) then xformat:='WAV'//RIFF -> WAVE
//.mp3
else if a.asame3(0,[uuI,uuD,nn3,3],true) or//ID3+#3
        a.asame3(0,[uuI,uuD,nn3,2],true) or//ID3+#2
        a.asame3(0,[255,251,226,68],true) or//#255#251#226#68
        a.asame3(0,[255,251,178,4],true) or//#255#251#178#4 or #255#251#144#68
        a.asame3(0,[255,251,144,68],true)                                 then xformat:='MP3'
//.wma
else if a.asame3(0,[48,38,178,117],true)                                  then xformat:='WMA'//#48#38#178#117
//.pcs - custom
else if a.asame3(0,[uuP,uuC,uuS,nn1,ssHash],false)                        then xformat:='PCS'//pc speaker sound
//.ssd - custom
else if a.asame3(0,[uuS,uuS,uuD,nn1,ssHash],false)                        then xformat:='SSD'//system sound

//encodings --------------------------------------------------------------------
//.b64
else if a.asame3(0,[uuB,nn6,nn4,ssColon],false)                           then xformat:='B64'//B64:
//.zip
else if a.asame3(0,[120,218],true) or a.asame3(0,[120,1],true) or
        a.asame3(0,[120,94],true)  or a.asame3(0,[120,156],true)          then xformat:='ZIP'
//.ioc
else if a.asame3(0,[uuC,ssExclaim,nn1],false)                             then xformat:='IOC'//compressed data header
//.ior
else if a.asame3(0,[uuC,ssExclaim,nn0],false)                             then xformat:='IOR'//raw data header (not compressed)
//.exe
else if a.asame3(0,[uuM,uuZ,uuP],false)                                   then xformat:='EXE'
//.dll
else if a.asame3(0,[uuM,uuZ,144],true)                                    then xformat:='DLL'
//.lnk
else if a.asame3(0,[uuL,0,0],true)                                        then xformat:='LNK'

//frames -----------------------------------------------------------------------
//sfm
else if a.asame3(0,[uuF,uuP,uuS,ssUnderscore,uuV,uuE,uuR,ssColon,ssSpace,uuV,nn0],false) then xformat:='SFM'//framer plus (v0) -> simple frame
//fps
else if a.asame3(0,[uuF,uuP,uuS,ssUnderscore,uuV,uuE,uuR,ssColon,ssSpace,uuV,nn1],false) then xformat:='FPS'//framer plus (v1) -> enhanced frame with LOGO support etc

//documents --------------------------------------------------------------------
//.bwp
else if a.asame3(0,[uuB,uuW,uuP,nn1],false)                               then xformat:='BWP'
//.bwd
else if a.asame3(0,[uuB,uuW,uuD,nn1],false)                               then xformat:='BWD'
//.rtf
else if a.asame3(0,[ssLCurlyBracket,ssbackslash,uuR,uuT,uuF,nn1,ssBackSlash],false) then xformat:='RTF'//22jun2022

//other ------------------------------------------------------------------------
else if a.asame3(0,[ssLSquarebracket,uuA,uuL,uuA,uuR,uuM,ssRSquarebracket],false) then xformat:='ALARMS'//08mar2022

else
   begin
   //nil
   end;

//successful
result:=(xformat<>'');
skipend:
except;end;
try
bunlockautofree(xdata);
except;end;
end;
//## misformat ##
function misformat(xdata:tstr8;var xformat:string;var xbase64:boolean):boolean;
label
   skipend,redo;
var
   a:tstr8;
   str1,e:string;
   xmustfree,xonce:boolean;
begin
try
//defaults
result:=false;
xformat:='';
xbase64:=false;
block(xdata);//lock
a:=xdata;//a pointer at this stage
xmustfree:=false;
//check
if (blen(a)<=0) then goto skipend;
//init
xonce:=true;
redo:
//get
if anyformat(a,str1) then
   begin
   if (str1='B64') then
      begin
      if xonce then
         begin
         xonce:=false;
         xmustfree:=true;
         xbase64:=true;
         a:=bnew;
         low__fromb641(xdata,a,1,e);
         goto redo;
         end;
      end
   else
      begin
      result:=low__comparetext(str1,'BMP') or low__comparetext(str1,'JPG') or low__comparetext(str1,'PNG') or low__comparetext(str1,'TEA') or (have_ico and (low__comparetext(str1,'GIF') or low__comparetext(str1,'ICO') or low__comparetext(str1,'CUR') or low__comparetext(str1,'ANI')));
      if result then xformat:=str1;
      end;
   end;

skipend:
except;end;
try
if xmustfree then bfree(a);
bunlockautofree(xdata);
except;end;
end;
//## low__draw ##
function low__draw(xdynamicCorners:boolean;xbits,xw,xh:longint;xrows:tstr8;xmask:tmask8;xmaskval:longint;xstyle:char;xclip,xclip2,xarea:trect;xcol,xcol2,xcol3,xval1,xval2,xval3,xrich:longint;xdata,xoptions:tstr8;xroundstyle:longint;xround:boolean):boolean;
begin
try;result:=low__draw2(xdynamicCorners,tbnone,xbits,xw,xh,xrows,xmask,xmaskval,xstyle,xclip,xclip2,xarea,xcol,xcol2,xcol3,xval1,xval2,xval3,0,0,xrich,xdata,xoptions,xroundstyle,xround,false,false,false,false);except;end;
end;
//## low__draw2 ##
function low__draw2(xdynamicCorners:boolean;xtab,xbits,xw,xh:longint;xrows:tstr8;xmask:tmask8;xmaskval:longint;xstyle:char;xclip,xclip2,xarea:trect;xcol,xcol2,xcol3,xval1,xval2,xval3,xval4,xval5,xrich:longint;xdata,xoptions:tstr8;xroundstyle:longint;xround,xbol1,xbol2,xbol3,xbol4:boolean):boolean;
begin
try;result:=low__draw3(xdynamicCorners,false,false,xtab,xbits,xw,xh,xrows,xmask,xmaskval,xstyle,xclip,xclip2,xarea,xcol,xcol2,xcol3,xval1,xval2,xval3,xval4,xval5,xrich,xdata,xoptions,xroundstyle,xround,xbol1,xbol2,xbol3,xbol4);except;end;
end;
//## low__draw3 ##
function low__draw3(xdynamicCorners:boolean;xcolorise,xsyszoom:boolean;xtab,xbits,xw,xh:longint;xrows:tstr8;xmask:tmask8;xmaskval:longint;xstyle:char;xclip,xclip2,xarea:trect;xcol,xcol2,xcol3,xval1,xval2,xval3,xval4,xval5,xrich:longint;xdata,xoptions:tstr8;xroundstyle:longint;xround,xbol1,xbol2,xbol3,xbol4:boolean):boolean;//22may2022, 01mar2022
label
   fredo,skipdone,skipend;
var//Note: dclip=master cliparea and dclip2=sub cliparea within master
   a,atmp:trect;
   xsystem_sparklepos,ax,ay,aw,ah,ah2,xsupport1,xrich2,amin,p,int1,int2,int3,dx,dy:longint;
   lx,lx2,rx,rx2:longint;//corner processing
   lrok,xsupportOK1:boolean;
   sr8,mr8:pcolorrow8;
   sr24:pcolorrow24;
   sr32:pcolorrow32;
   dc24,ac24,xrgb24:tcolor24;
   dc32,ac32:tcolor32;
   bol1,bol2,bol3,bol4,xshade:boolean;
   str1:string;
   xfc:tstr8;
   dypert,dxpert,av,ar,ag,ab:single;
   //.f2 support
   xpos,sremsize,sframesize,dtotalsize,dminsize,dsize,dcolor,dcolor2:longint;
   xonce:boolean;
   //## low__colsplice21 ##
   function low__colsplice21(dpert:extended;xcol,xcol2:longint):longint;
   begin
   if vishadeglow then low__swapint(xcol,xcol2);
   result:=low__colsplice1(dpert,xcol2,xcol);
   end;
   //## scan2432 ##
   function xscan2432(dy:longint):boolean;
   begin//Performance Note: Using "xrows24" and "xrows32" results in a 200% (2x) speed increase for full GUI paints - 13apr2020
   //defaults
   result:=false;
   //get
   case xbits of
   24:begin
      sr24:=xrows.prows24[dy];
      result:=true;
      end;
   32:begin
      sr32:=xrows.prows32[dy];
      result:=true;
      end;
   end;//case
   //.mask
   if (xmaskval>=0) then mr8:=xmask.prows8[dy];

   //fasttimer - ycheck
   inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;
   end;
   //## xsetcol ##
   procedure xsetcol(x:longint);
   begin
   xrgb24:=low__intrgb(x);
   dc24  :=xrgb24;
   dc32.r:=dc24.r;
   dc32.g:=dc24.g;
   dc32.b:=dc24.b;
   dc32.a:=255;
   end;
   //## xsparkleprime ##
   procedure xsparkleprime;//22may2022
   var
      p:longint;
   begin
   for p:=0 to 3 do//predictiable amount so that REPEAT paint REQUESTS to same control will generally generate identical results - 22may2022
   begin
   if (xsystem_sparklepos<high(system_sparklelist)) then inc(xsystem_sparklepos) else xsystem_sparklepos:=0;
   end;//p
   end;
   //## xrich24 ##
   function xrich24:boolean;
   var
      v,b1:longint;
   begin
   result:=true;
//was:   b1:=random(xrich);
   //.sparkle -> using a local var "xsystem_sparklepos" is upto 4x faster than using a global one - 27feb2022
   if (xsystem_sparklepos<high(system_sparklelist)) then inc(xsystem_sparklepos) else xsystem_sparklepos:=0;
   b1:=system_sparklelist[xsystem_sparklepos];
   //.r
   v:=xrgb24.r+b1-xrich2;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   dc24.r:=byte(v);
   //.g
   v:=xrgb24.g+b1-xrich2;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   dc24.g:=byte(v);
   //.b
   v:=xrgb24.b+b1-xrich2;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   dc24.b:=byte(v);
   end;
   //## xrich32 ##
   function xrich32:boolean;
   var
      v,b1:longint;
   begin
   result:=true;
//was:   b1:=random(xrich);
   //.sparkle -> using a local var "xsystem_sparklepos" is upto 4x faster than using a global one - 27feb2022
   if (xsystem_sparklepos<high(system_sparklelist)) then inc(xsystem_sparklepos) else xsystem_sparklepos:=0;
   b1:=system_sparklelist[xsystem_sparklepos];
   //.r
   v:=xrgb24.r+b1-xrich2;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   dc32.r:=byte(v);
   //.g
   v:=xrgb24.g+b1-xrich2;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   dc32.g:=byte(v);
   //.b
   v:=xrgb24.b+b1-xrich2;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   dc32.b:=byte(v);
   end;
   //## xcanshade ##
   function xcanshade:boolean;//detect shade options EVEN when there is not a second color "dcol2" - 11apr2020
   begin
   result:=zzok(xoptions,7017) and ((xoptions.chr1[0]='h') or (xoptions.chr1[0]='g'));
   end;
   //## xsetshade ##
   procedure xsetshade;
   var
      int1,int2,int3:longint;
      xpert,dpert:extended;
      xok:boolean;
      //## xvar ##
      procedure xvar;
      begin
      if not xsupportOK1 then
         begin
         xsupportOK1:=true;
         xsupport1:=0;
         //fixed - 18aug2020
         if zzok(xoptions,7018) then xsupport1:=frcrange(strint(xoptions.str[2,xoptions.count]),-100,100);
         end;
      end;
   begin
   //init
   xok:=zzok(xoptions,7019) and xoptions.notempty;
//   xpert:=frcrange(((dy-a.top)*100) div nozero(1100123,a.bottom-a.top+1),0,100);
   xpert:=frcextrange(((dy-a.top)*100) / nozero(1100123,a.bottom-a.top+1),0,100);

   //get
   //.g0-100 -> gradient -> use "g50" = "c1..c2" (linear) and "g-50" = "c1..c2..c1" (round)
   if xok and (xoptions.chr1[0]='g') then//gradient 50-50 -> round gradient
      begin
      //init
      xvar;
      if (xsupport1>=0) then int1:=xsupport1 else int1:=100+xsupport1;//invert
      //get
      case (xpert<int1) of//was "<=" but at "xpert=0" top-most line was drawn in the bottom-most color by error - 18aug2020
      true:begin
         dpert:=frcextrange(xpert/frcmin(int1,1),0,100);
         xsetcol(low__colsplice21(dpert,xcol2,xcol));
         end;
      false:begin
         dpert:=frcextrange((xpert-int1)/frcmin(100-int1,1),0,100);
         xsetcol(low__colsplice21(dpert,xcol,xcol2));
         end;
      end;//case
      end
   //.h0-100 or "h" -> window head shade + works best with low values like "h12"
   else if xok and (xoptions.chr1[0]='h') then
      begin
      //init
      xvar;
      int3:=low__posn(xsupport1);
      //get
      int1:=low__sc(xcol,low__rgb(255,255,255),int3);//white
      int2:=low__sc(xcol,0,int3);//black
      if (xsupport1<0) then low__swapint(int1,int2);//invert
      xsetcol(low__colsplice21(xpert,int2,int1));//linear gradient
      end
   //.default linear shade
   else xsetcol(low__colsplice21(xpert,xcol2,xcol));//linear gradient
   end;
begin
try
//defaults
result:=true;//ok by default
xfc:=nil;
block(xrows);
block(xdata);//30aug2020
block(xoptions);

//check
if (xw<1) or (xh<1) or zznil(xrows,2170) or ((xbits<>24) and (xbits<>32)) then goto skipend;
//init
//.sparkle -> switch from variable level sparkle shades to a single fixed SYSTEM LEVEL shade of "visparkle" -> upto 4x faster using a single list of sparkle values - 27feb2022
if (xrich>=1) then
   begin
   xrich:=visparkle;
   low__sparklefill(xrich);
   end;
xsystem_sparklepos:=low__sparklestart;
//.roundstyle
if (xroundstyle=corNone) then xround:=false;
//.maskval
if (xmaskval>=0) then
   begin
   if zznil(xmask,2171) or ((xmask.width<xw) or (xmask.height<xh)) then xmaskval:=-1;//off
   end;
//.xclip - fast
if (xclip.right<xclip.left) or (xclip.bottom<xclip.top) or (xclip.right<0) or (xclip.left>=xw) or (xclip.bottom<0) or (xclip.top>=xh) then goto skipend;
if (xclip.left<0)               then xclip.left:=0;
if (xclip.right>=xw)            then xclip.right:=xw-1;
if (xclip.top<0)                then xclip.top:=0;
if (xclip.bottom>=xh)           then xclip.bottom:=xh-1;
//.xclip2 - fast
if (xclip2.right<xclip2.left) or (xclip2.bottom<xclip2.top) or (xclip2.right<0) or (xclip2.left>=xw) or (xclip2.bottom<0) or (xclip2.top>=xh) or (xclip2.right<xclip.left) or (xclip2.left>xclip.right) or (xclip2.bottom<xclip.top) or (xclip2.top>xclip.bottom) then goto skipend;
if (xclip2.left<xclip.left)     then xclip2.left:=xclip.left;
if (xclip2.right>xclip.right)   then xclip2.right:=xclip.right;
if (xclip2.top<xclip.top)       then xclip2.top:=xclip.top;
if (xclip2.bottom>xclip.bottom) then xclip2.bottom:=xclip.bottom;
//.a - retain a copy of original "xarea" for calculations and reference
a:=xarea;
//.colors
if (xcol2=clnone) then xcol2:=xcol;
xshade:=(xcol<>xcol2) or xcanshade;
//init
xsupport1:=0;
xsupportOK1:=false;
xrich:=2*frcrange(xrich,0,20);
xrich2:=frcmin(xrich div 2,1);
lx:=0;
lx2:=0;
rx:=0;
rx2:=0;

//get
//.vertical line ---------------------------------------------------------------
if (xstyle='v') or (xstyle='V') then//round=ok=10mar2021
   begin
   //check - dx=xarea.left, dy=xarea.top, dy2=xarea.bottom
   if (xarea.left<xclip2.left) or (xarea.left>xclip2.right) or (xarea.bottom<xarea.top) or (xarea.bottom<xclip2.top) or (xarea.top>xclip2.bottom) then goto skipend;
   //init
   if (xarea.top<xclip2.top)       then xarea.top:=xclip2.top;
   if (xarea.bottom>xclip2.bottom) then xarea.bottom:=xclip2.bottom;
   amin:=smallest(xclip.bottom-xclip.top+1,xclip.right-xclip.left+1);
   xsetcol(xcol);
   bol1:=(xstyle='v');
   //get
   for dy:=xarea.top to xarea.bottom do
   begin
   //.prime sparkle a tad between rows - counters clipped region "repeat effect" where random looks predicitable - 22may2022
   if (xrich>=1) then xsparkleprime;
   //.corner
   low__cornersolid(xdynamicCorners,xclip,amin,dy,xclip2.left,xclip2.right,xroundstyle,xround,lx,rx);
   //.scan
   if not xscan2432(dy) then
      begin
      result:=false;
      goto skipend;
      end;
   if (xarea.left>=lx) and (xarea.left<=rx) and ((xmaskval<0) or (mr8[xarea.left]=xmaskval)) and (bol1 or (((dy div 2)*2)=dy))then//27feb2021
      begin
      if (xrich>=1) then
         begin
         case xbits of
         24:if xrich24 then sr24[xarea.left]:=dc24;
         32:if xrich32 then sr32[xarea.left]:=dc32;
         end;//case
         end
      else
         begin
         case xbits of
         24:sr24[xarea.left]:=dc24;
         32:sr32[xarea.left]:=dc32;
         end;//case
         end;//rich
      end;//maskval
   end;//dy
   end
//.horizontal line -------------------------------------------------------------
else if (xstyle='h') or (xstyle='H') then//round=ok=10mar2021
   begin
   //check - dx=xarea.left, dx2=xarea.right, dy=xarea.top
   if (xarea.right<xclip2.left) or (xarea.left>xclip2.right) or (xarea.right<xarea.left) or (xarea.top<xclip2.top) or (xarea.top>xclip2.bottom) then goto skipend;
   //init
   if (xarea.left<xclip2.left)       then xarea.left:=xclip2.left;
   if (xarea.right>xclip2.right)     then xarea.right:=xclip2.right;
   amin:=smallest(xclip.bottom-xclip.top+1,xclip.right-xclip.left+1);
   xsetcol(xcol);
   //.prime sparkle a tad between rows - counters clipped region "repeat effect" where random looks predicitable - 22may2022
   if (xrich>=1) then xsparkleprime;
   //get
   //.corner
   low__cornersolid(xdynamicCorners,xclip,amin,xarea.top,xarea.left,xarea.right,xroundstyle,xround,lx,rx);
   if not xscan2432(xarea.top) then
      begin
      result:=false;
      goto skipend;
      end;
   //.fixed with "maskval" - 01aug2021
   if (xrich>=1) then
      begin
      if (xstyle='H') then
         begin
         case xbits of
         24:for dx:=xarea.left to xarea.right do if (dx>=lx) and (dx<=rx) and ((xmaskval<0) or (mr8[dx]=xmaskval)) and xrich24 and (((dx div 2)*2)=dx) then sr24[dx]:=dc24;
         32:for dx:=xarea.left to xarea.right do if (dx>=lx) and (dx<=rx) and ((xmaskval<0) or (mr8[dx]=xmaskval)) and xrich32 and (((dx div 2)*2)=dx) then sr32[dx]:=dc32;
         end;//case
         end
      else
         begin
         case xbits of
         24:for dx:=xarea.left to xarea.right do if (dx>=lx) and (dx<=rx) and ((xmaskval<0) or (mr8[dx]=xmaskval)) and xrich24 then sr24[dx]:=dc24;
         32:for dx:=xarea.left to xarea.right do if (dx>=lx) and (dx<=rx) and ((xmaskval<0) or (mr8[dx]=xmaskval)) and xrich32 then sr32[dx]:=dc32;
         end;//case
         end;
      end
   else
      begin
      if (xstyle='H') then
         begin
         case xbits of
         24:for dx:=xarea.left to xarea.right do if (dx>=lx) and (dx<=rx) and ((xmaskval<0) or (mr8[dx]=xmaskval)) and (((dx div 2)*2)=dx) then sr24[dx]:=dc24;
         32:for dx:=xarea.left to xarea.right do if (dx>=lx) and (dx<=rx) and ((xmaskval<0) or (mr8[dx]=xmaskval)) and (((dx div 2)*2)=dx) then sr32[dx]:=dc32;
         end;//case
         end
      else
         begin
         case xbits of
         24:for dx:=xarea.left to xarea.right do if (dx>=lx) and (dx<=rx) and ((xmaskval<0) or (mr8[dx]=xmaskval)) then sr24[dx]:=dc24;
         32:for dx:=xarea.left to xarea.right do if (dx>=lx) and (dx<=rx) and ((xmaskval<0) or (mr8[dx]=xmaskval)) then sr32[dx]:=dc32;
         end;//case
         end;
      end;//rich
   end
//.solid area ------------------------------------------------------------------
else if (xstyle='s') then//round=ok=10mar2021
   begin
   //check - dx=xarea.left, dx2=xarea.right, dy=xarea.top, dy2=xarea.bottom
   if (xarea.right<xarea.left) or (xarea.bottom<xarea.top) or (xarea.right<xclip2.left) or (xarea.left>xclip2.right) or (xarea.bottom<xclip2.top) or (xarea.top>xclip2.bottom) then goto skipend;
   //init
   if (xarea.left<xclip2.left)       then xarea.left:=xclip2.left;
   if (xarea.right>xclip2.right)     then xarea.right:=xclip2.right;
   if (xarea.top<xclip2.top)         then xarea.top:=xclip2.top;
   if (xarea.bottom>xclip2.bottom)   then xarea.bottom:=xclip2.bottom;
   xsetcol(xcol);
   bol1:=xround and (xcol3<>clnone);//special color outside of round corner area color - optional
   if bol1 then
      begin
      ac24:=low__intrgb(xcol3);
      ac32:=low__intrgb32(xcol3,255);
      end;
//was:   amin:=smallest(xclip.bottom-xclip.top+1,xclip.right-xclip.left+1);
   amin:=smallest(xarea.bottom-xarea.top+1,xarea.right-xarea.left+1);

   //get
   for dy:=xarea.top to xarea.bottom do
   begin
   if not xscan2432(dy) then
      begin
      result:=false;
      goto skipend;
      end;
   //.prime sparkle a tad between rows - counters clipped region "repeat effect" where random looks predicitable - 22may2022
   if (xrich>=1) then xsparkleprime;
   //.color shader
   if xshade then xsetshade;
   //.corner
//was:   low__cornersolid(xclip,amin,dy,xarea.left,xarea.right,xroundstyle,xround,lx,rx);
   lrok:=low__cornersolid(xdynamicCorners,a,amin,dy,xarea.left,xarea.right,xroundstyle,xround,lx,rx);
   //.dx
   case xbits of
   24:begin
      //no mask
      if (xmaskval<0) then
         begin
         if lrok and (lx<=rx) then
            begin
            case (xrich>=1) of
            true: for dx:=lx to rx do if xrich24 then sr24[dx]:=dc24;
            false:for dx:=lx to rx do sr24[dx]:=dc24;
            end;//case
            end;
         //.color outside of round corners
         if bol1 then
            begin
            //.left outside corner
            if (lx>xarea.left) and (lx<=xarea.right) then for dx:=xarea.left to (lx-1) do sr24[dx]:=ac24;
            //.right outside corner
            if (rx>=xarea.left) and (rx<xarea.right) then for dx:=(rx+1) to xarea.right do sr24[dx]:=ac24;
            end;
         end
      //use mask
      else
         begin
         if lrok and (lx<=rx) then
            begin
            case (xrich>=1) of
            true: for dx:=lx to rx do if (mr8[dx]=xmaskval) and xrich24 then sr24[dx]:=dc24;
            false:for dx:=lx to rx do if (mr8[dx]=xmaskval) then sr24[dx]:=dc24;
            end;//case
            end;
         //.color outside of round corners
         if bol1 then
            begin
            //.left outside corner
            if (lx>xarea.left) and (lx<=xarea.right) then for dx:=xarea.left to (lx-1) do if (mr8[dx]=xmaskval) then sr24[dx]:=ac24;
            //.right outside corner
            if (rx>=xarea.left) and (rx<xarea.right) then for dx:=(rx+1) to xarea.right do if (mr8[dx]=xmaskval) then sr24[dx]:=ac24;
            end;
         end;
      end;//begin 24
   32:begin
      //no mask
      if (xmaskval<0) then
         begin
         if lrok and (lx<=rx) then
            begin
            case (xrich>=1) of
            true: for dx:=lx to rx do if xrich32 then sr32[dx]:=dc32;
            false:for dx:=lx to rx do sr32[dx]:=dc32;
            end;//case
            end;
         //.color outside of round corners
         if bol1 then
            begin
            //.left outside corner
            if (lx>xarea.left) and (lx<=xarea.right) then for dx:=xarea.left to (lx-1) do sr32[dx]:=ac32;
            //.right outside corner
            if (rx>=xarea.left) and (rx<xarea.right) then for dx:=(rx+1) to xarea.right do sr32[dx]:=ac32;
            end;
         end
      //use mask
      else
         begin
         if lrok and (lx<=rx) then
            begin
            case (xrich>=1) of
            true: for dx:=lx to rx do if (mr8[dx]=xmaskval) and xrich32 then sr32[dx]:=dc32;
            false:for dx:=lx to rx do if (mr8[dx]=xmaskval) then sr32[dx]:=dc32;
            end;//case
            end;
         //.color outside of round corners
         if bol1 then
            begin
            //.left outside corner
            if (lx>xarea.left) and (lx<=xarea.right) then for dx:=xarea.left to (lx-1) do if (mr8[dx]=xmaskval) then sr32[dx]:=ac32;
            //.right outside corner
            if (rx>=xarea.left) and (rx<xarea.right) then for dx:=(rx+1) to xarea.right do if (mr8[dx]=xmaskval) then sr32[dx]:=ac32;
            end;
         end;
      end;//begin 32
   end;//case
   end;//dy
   end
//.outline area ----------------------------------------------------------------
else if (xstyle='o') then//now supports corner "gap" patching -> no pixels missed - 12apr2020
   begin
   //check - dx=xarea.left, dx2=xarea.right, dy=xarea.top, dy2=xarea.bottom
   if (xarea.right<xarea.left) or (xarea.bottom<xarea.top) or (xarea.right<xclip2.left) or (xarea.left>xclip2.right) or (xarea.bottom<xclip2.top) or (xarea.top>xclip2.bottom) then goto skipend;
   //init
   if (xarea.left<xclip2.left)       then xarea.left:=xclip2.left;
   if (xarea.right>xclip2.right)     then xarea.right:=xclip2.right;
   if (xarea.top<xclip2.top)         then xarea.top:=xclip2.top;
   if (xarea.bottom>xclip2.bottom)   then xarea.bottom:=xclip2.bottom;
   xsetcol(xcol);
   bol1:=xround and (xcol3<>clnone);//special color outside of round corner area color - optional
   if bol1 then
      begin
      ac24:=low__intrgb(xcol3);
      ac32:=low__intrgb32(xcol3,255);
      end;
   amin:=smallest(xarea.bottom-xarea.top+1,xarea.right-xarea.left+1);
   //get
   for dy:=xarea.top to xarea.bottom do
   begin
   if not xscan2432(dy) then
      begin
      result:=false;
      goto skipend;
      end;
   //.prime sparkle a tad between rows - counters clipped region "repeat effect" where random looks predicitable - 22may2022
   if (xrich>=1) then xsparkleprime;
   //.color shader
   if xshade then xsetshade;
   //.corner
   low__cornerhollow(xdynamicCorners,a,amin,dy,xroundstyle,xround,lx,lx2,rx,rx2);
   //.dx
   case xbits of
   24:begin
      //no mask
      if (xmaskval<0) then
         begin
         //top and bottom horizontal lines
         if (dy=a.top) or (dy=a.bottom) then
            begin
            lx:=frcmin(lx,xarea.left);
            rx:=frcmax(rx,xarea.right);
            if (lx<=rx) then
               begin
               case (xrich>=1) of
               true :for dx:=lx to rx do if xrich24 then sr24[dx]:=dc24;
               false:for dx:=lx to rx do sr24[dx]:=dc24;
               end;//case
               end;
            end
         //left and right vertical lines -> 3 modes: draw single, draw double, no draw
         else
            begin
            //.left
            if (lx>=xarea.left) and (lx<=xarea.right) then
               begin
               if (xrich>=1) then xrich24;
               sr24[lx]:=dc24;
               end;
            if (lx2<>lx) and (lx2>=xarea.left) and (lx2<=xarea.right) then
               begin
               if (xrich>=1) then xrich24;
               sr24[lx2]:=dc24;
               end;
            //.right
            if (rx>=xarea.left) and (rx<=xarea.right) then
               begin
               if (xrich>=1) then xrich24;
               sr24[rx]:=dc24;
               end;
            if (rx2<>rx) and (rx2>=xarea.left) and (rx2<=xarea.right) then
               begin
               if (xrich>=1) then xrich24;
               sr24[rx2]:=dc24;
               end;
            end;
         //outside corners
         if bol1 then
            begin
            //.left outside corner
            if (lx>xarea.left) and (lx<=xarea.right) then for dx:=xarea.left to (lx-1) do if ((xrich<=0) or xrich24) then sr24[dx]:=dc24;
            //.right outside corner
            if (rx>=xarea.left) and (rx<xarea.right) then for dx:=(rx+1) to xarea.right do if ((xrich<=0) or xrich24) then sr24[dx]:=dc24;
            end;
         end
      //use mask
      else
         begin
         //top and bottom horizontal lines
         if (dy=a.top) or (dy=a.bottom) then
            begin
            lx:=frcmin(lx,xarea.left);
            rx:=frcmax(rx,xarea.right);
            if (lx<=rx) then
               begin
               case (xrich>=1) of
               true :for dx:=lx to rx do if (mr8[dx]=xmaskval) and xrich24 then sr24[dx]:=dc24;
               false:for dx:=lx to rx do if (mr8[dx]=xmaskval) then sr24[dx]:=dc24;
               end;//case
               end;
            end
         //left and right vertical lines -> 3 modes: draw single, draw double, no draw
         else
            begin
            //.left
            if (lx>=xarea.left) and (lx<=xarea.right) then
               begin
               if (xrich>=1) then xrich24;
               if (mr8[lx]=xmaskval) then sr24[lx]:=dc24;
               end;
            if (lx2<>lx) and (lx2>=xarea.left) and (lx2<=xarea.right) then
               begin
               if (xrich>=1) then xrich24;
               if (mr8[lx2]=xmaskval) then sr24[lx2]:=dc24;
               end;
            //.right
            if (rx>=xarea.left) and (rx<=xarea.right) then
               begin
               if (xrich>=1) then xrich24;
               if (mr8[rx]=xmaskval) then sr24[rx]:=dc24;
               end;
            if (rx2<>rx) and (rx2>=xarea.left) and (rx2<=xarea.right) then
               begin
               if (xrich>=1) then xrich24;
               if (mr8[rx2]=xmaskval) then sr24[rx2]:=dc24;
               end;
            end;
         //outside corners
         if bol1 then
            begin
            //.left outside corner
            if (lx>xarea.left) and (lx<=xarea.right) then for dx:=xarea.left to (lx-1) do if (mr8[dx]=xmaskval) and ((xrich<=0) or xrich24) then sr24[dx]:=dc24;
            //.right outside corner
            if (rx>=xarea.left) and (rx<xarea.right) then for dx:=(rx+1) to xarea.right do if (mr8[dx]=xmaskval) and ((xrich<=0) or xrich24) then sr24[dx]:=dc24;
            end;
         end;
      end;//begin 24
   32:begin
      //no mask
      if (xmaskval<0) then
         begin
         //top and bottom horizontal lines
         if (dy=a.top) or (dy=a.bottom) then
            begin
            lx:=frcmin(lx,xarea.left);
            rx:=frcmax(rx,xarea.right);
            if (lx<=rx) then
               begin
               case (xrich>=1) of
               true :for dx:=lx to rx do if xrich32 then sr32[dx]:=dc32;
               false:for dx:=lx to rx do sr32[dx]:=dc32;
               end;//case
               end;
            end
         //left and right vertical lines -> 3 modes: draw single, draw double, no draw
         else
            begin
            //.left
            if (lx>=xarea.left) and (lx<=xarea.right) then
               begin
               if (xrich>=1) then xrich32;
               sr32[lx]:=dc32;
               end;
            if (lx2<>lx) and (lx2>=xarea.left) and (lx2<=xarea.right) then
               begin
               if (xrich>=1) then xrich32;
               sr32[lx2]:=dc32;
               end;
            //.right
            if (rx>=xarea.left) and (rx<=xarea.right) then
               begin
               if (xrich>=1) then xrich32;
               sr32[rx]:=dc32;
               end;
            if (rx2<>rx) and (rx2>=xarea.left) and (rx2<=xarea.right) then
               begin
               if (xrich>=1) then xrich32;
               sr32[rx2]:=dc32;
               end;
            end;
         //outside corners
         if bol1 then
            begin
            //.left outside corner
            if (lx>xarea.left) and (lx<=xarea.right) then for dx:=xarea.left to (lx-1) do if ((xrich<=0) or xrich32) then sr32[dx]:=dc32;
            //.right outside corner
            if (rx>=xarea.left) and (rx<xarea.right) then for dx:=(rx+1) to xarea.right do if ((xrich<=0) or xrich32) then sr32[dx]:=dc32;
            end;
         end
      //use mask
      else
         begin
         //top and bottom horizontal lines
         if (dy=a.top) or (dy=a.bottom) then
            begin
            lx:=frcmin(lx,xarea.left);
            rx:=frcmax(rx,xarea.right);
            if (lx<=rx) then
               begin
               case (xrich>=1) of
               true :for dx:=lx to rx do if (mr8[dx]=xmaskval) and xrich32 then sr32[dx]:=dc32;
               false:for dx:=lx to rx do if (mr8[dx]=xmaskval) then sr32[dx]:=dc32;
               end;//case
               end;
            end
         //left and right vertical lines -> 3 modes: draw single, draw double, no draw
         else
            begin
            //.left
            if (lx>=xarea.left) and (lx<=xarea.right) then
               begin
               if (xrich>=1) then xrich32;
               if (mr8[lx]=xmaskval) then sr32[lx]:=dc32;
               end;
            if (lx2<>lx) and (lx2>=xarea.left) and (lx2<=xarea.right) then
               begin
               if (xrich>=1) then xrich32;
               if (mr8[lx2]=xmaskval) then sr32[lx2]:=dc32;
               end;
            //.right
            if (rx>=xarea.left) and (rx<=xarea.right) then
               begin
               if (xrich>=1) then xrich32;
               if (mr8[rx]=xmaskval) then sr32[rx]:=dc32;
               end;
            if (rx2<>rx) and (rx2>=xarea.left) and (rx2<=xarea.right) then
               begin
               if (xrich>=1) then xrich32;
               if (mr8[rx2]=xmaskval) then sr32[rx2]:=dc32;
               end;
            end;
         //outside corners
         if bol1 then
            begin
            //.left outside corner
            if (lx>xarea.left) and (lx<=xarea.right) then for dx:=xarea.left to (lx-1) do if (mr8[dx]=xmaskval) and ((xrich<=0) or xrich32) then sr32[dx]:=dc32;
            //.right outside corner
            if (rx>=xarea.left) and (rx<xarea.right) then for dx:=(rx+1) to xarea.right do if (mr8[dx]=xmaskval) and ((xrich<=0) or xrich32) then sr32[dx]:=dc32;
            end;
         end;
      end;//begin 32
   end;//case
   end;//dy
   end
//.outline corners only --------------------------------------------------------
else if (xstyle='r') or (xstyle='0') or (xstyle='1') or (xstyle='2') or (xstyle='3') then//now supports corner "gap" patching -> no pixels missed - 12apr2020
   begin
   //check - dx=xarea.left, dx2=xarea.right, dy=xarea.top, dy2=xarea.bottom
   if (not xround) or (xarea.right<xarea.left) or (xarea.bottom<xarea.top) or (xarea.right<xclip2.left) or (xarea.left>xclip2.right) or (xarea.bottom<xclip2.top) or (xarea.top>xclip2.bottom) then goto skipend;
   bol1:=(xstyle='r') or (xstyle='0');//top-left
   bol2:=(xstyle='r') or (xstyle='1');//top-right
   bol3:=(xstyle='r') or (xstyle='2');//bottom-left
   bol4:=(xstyle='r') or (xstyle='3');//bottom-right
   //init
   if (xarea.left<xclip2.left)       then xarea.left:=xclip2.left;
   if (xarea.right>xclip2.right)     then xarea.right:=xclip2.right;
   if (xarea.top<xclip2.top)         then xarea.top:=xclip2.top;
   if (xarea.bottom>xclip2.bottom)   then xarea.bottom:=xclip2.bottom;
   xsetcol(xcol);
   amin:=smallest(xarea.bottom-xarea.top+1,xarea.right-xarea.left+1);
   int3:=frcmin((1+xarea.bottom-xarea.top) div 2,0);
   //get
   for dy:=xarea.top to xarea.bottom do
   begin
   if not xscan2432(dy) then
      begin
      result:=false;
      goto skipend;
      end;
   //.corner
   low__cornerhollow(xdynamicCorners,a,amin,dy,xroundstyle,xround,lx,lx2,rx,rx2);
   //.color outside of round corners
   if ( ((bol1 or bol2) and (dy<=(xarea.top+int3))) or ((bol3 or bol4) and (dy>=(xarea.bottom-int3))) ) then
      begin
      //.color shader
      if xshade then xsetshade;
      //Note: Now supports optional "Richness" for corner coloring - 01aug2020
      //.color outside of corners
      case xbits of
      24:begin
         //no mask
         if (xmaskval<0) then
            begin
            //.left outside corner
            if (bol1 or bol3) and (lx>xarea.left) and (lx<=xarea.right) then for dx:=xarea.left to (lx-1) do
               begin
               if (xrich>=1) then xrich24;
               sr24[dx]:=dc24;
               end;
            //.right outside corner
            if (bol2 or bol4) and (rx>=xarea.left) and (rx<xarea.right) then for dx:=(rx+1) to xarea.right do
               begin
               if (xrich>=1) then xrich24;
               sr24[dx]:=dc24;
               end;
            end
         //use mask
         else
            begin
            //.left outside corner
            if (bol1 or bol3) and (lx>xarea.left) and (lx<=xarea.right) then for dx:=xarea.left to (lx-1) do if (mr8[dx]=xmaskval) then
               begin
               if (xrich>=1) then xrich24;
               sr24[dx]:=dc24;
               end;
            //.right outside corner
            if (bol2 or bol4) and (rx>=xarea.left) and (rx<xarea.right) then for dx:=(rx+1) to xarea.right do if (mr8[dx]=xmaskval) then
               begin
               if (xrich>=1) then xrich24;
               sr24[dx]:=dc24;
               end;
            end
         end;//24
      32:begin
         //no mask
         if (xmaskval<0) then
            begin
            //.left outside corner
            if (bol1 or bol3) and (lx>xarea.left) and (lx<=xarea.right) then for dx:=xarea.left to (lx-1) do
               begin
               if (xrich>=1) then xrich32;
               sr32[dx]:=dc32;
               end;
            //.right outside corner
            if (bol2 or bol4) and (rx>=xarea.left) and (rx<xarea.right) then for dx:=(rx+1) to xarea.right do
               begin
               if (xrich>=1) then xrich32;
               sr32[dx]:=dc32;
               end;
            end
         //use mask
         else
            begin
            //.left outside corner
            if (bol1 or bol3) and (lx>xarea.left) and (lx<=xarea.right) then for dx:=xarea.left to (lx-1) do if (mr8[dx]=xmaskval) then
               begin
               if (xrich>=1) then xrich32;
               sr32[dx]:=dc32;
               end;
            //.right outside corner
            if (bol2 or bol4) and (rx>=xarea.left) and (rx<xarea.right) then for dx:=(rx+1) to xarea.right do if (mr8[dx]=xmaskval) then
               begin
               if (xrich>=1) then xrich32;
               sr32[dx]:=dc32;
               end;
            end;
         end;//32
      end;//case
      end;
   end;//dy
   end
//.frame area ------------------------------------------------------------------
else if (xstyle='f') then//now supports corner "gap" patching -> no pixels missed - 12apr2020
   begin
   //check - dx=xarea.left, dx2=xarea.right, dy=xarea.top, dy2=xarea.bottom
   //Note: xval1=dsize=1..N
   if (xval1<=0) or (xarea.right<xarea.left) or (xarea.bottom<xarea.top) or (xarea.right<xclip2.left) or (xarea.left>xclip2.right) or (xarea.bottom<xclip2.top) or (xarea.top>xclip2.bottom) then goto skipend;
   //init
   str1:='';
   p:=0;
   //get
fredo:
   atmp.left   :=xarea.left+p;
   atmp.right  :=xarea.right-p;
   atmp.top    :=xarea.top+p;
   atmp.bottom :=xarea.bottom-p;
   if (atmp.left<=atmp.right) and (atmp.top<=atmp.bottom) then
      begin
      //Note: Tecnically this looses at the bottom values but it generates a "soft" frame for small bordersizes of 1-3 - 11mar2020
      if (xval1=1) then int1:=xcol else int1:=low__colsplice(round(((p+1)/frcmin(xval1,1))*100),xcol2,xcol);
      if (xval2<100) then int1:=low__colsplice(xval2,int1,xval3);//dbrightness,int1,dbrightnessDARK - 01mar2022
      //.Switch from "slight corner" to "slight2 corner" on last frame layer -> inner area ends up as a perfect rectangle - 05aug2020
      int2:=xroundstyle;
      if (int2=corToSquare) and ((p+1)=xval1) then int2:=corSlight2;
      low__draw(xdynamicCorners,xbits,xw,xh,xrows,xmask,xmaskval,'o',xclip,xclip2,atmp,int1,clnone,low__aorb(clnone,xcol3,p=0),0,0,0,xrich,nil,xoptions,int2,xround);
      //loop
      inc(p);
      if (p<xval1) then goto fredo;
      end;
   end
//.frame area ------------------------------------------------------------------
else if (xstyle='g') then//now supports code based frames - 23feb2022
   begin
   //check - dx=xarea.left, dx2=xarea.right, dy=xarea.top, dy2=xarea.bottom
   //Note: xval1=dsize=1..N
   if (xval1<=0) or (xarea.right<xarea.left) or (xarea.bottom<xarea.top) or (xarea.right<xclip2.left) or (xarea.left>xclip2.right) or (xarea.bottom<xclip2.top) or (xarea.top>xclip2.bottom) then goto skipend;

   //init
   xpos:=0;
   sframesize:=xval1;
   sremsize  :=xval1;
   dtotalsize:=0;
   xonce:=true;

   //get - framesets
   while true do
   begin
   if low__frameset(xpos,xdata,sremsize,sframesize,xcol,xcol2,dminsize,dsize,dcolor,dcolor2) then
      begin
      for p:=0 to (dsize-1) do
      begin
      atmp.left   :=xarea.left  +dtotalsize;
      atmp.right  :=xarea.right -dtotalsize;
      atmp.top    :=xarea.top   +dtotalsize;
      atmp.bottom :=xarea.bottom-dtotalsize;
      if (atmp.left<=atmp.right) and (atmp.top<=atmp.bottom) then
         begin
         //Note: Tecnically this looses at the bottom values but it generates a "soft" frame for small bordersizes of 1-3 - 11mar2020
         //if (dsize<=1) then int1:=dcolor else
         int1:=low__colsplice(round(((p+1)*100)/frcmin(dsize,1)),dcolor2,dcolor);
         if (xval2<100) then int1:=low__colsplice(xval2,int1,xval3);//dbrightness,int1,dbrightnessDARK - 01mar2022
         //.Switch from "slight corner" to "slight2 corner" on last frame layer -> inner area ends up as a perfect rectangle - 05aug2020
         int2:=xroundstyle;
         if (int2=corToSquare) and (sremsize<=0) and (p=(dsize-1)) then int2:=corSlight2;//switch frame styles to match a square corner - 23feb2022
         low__draw(xdynamicCorners,xbits,xw,xh,xrows,xmask,xmaskval,'o',xclip,xclip2,atmp,int1,clnone,low__aorb(clnone,int1,xonce and (xcol3<>clnone)),0,0,0,xrich,nil,xoptions,int2,xround);
         xonce:=false;                                                                                          //was: xcol3
         end
      else break;
      //inc
      inc(dtotalsize);
      end;//p
      end
   else break;
   end;//while
   end
//.color matrix ----------------------------------------------------------------
else if (xstyle='m') then
   begin
   //check - dx=xarea.left, dx2=xarea.right, dy=xarea.top, dy2=xarea.bottom
   if (xarea.right<xarea.left) or (xarea.bottom<xarea.top) or (xarea.right<xclip2.left) or (xarea.left>xclip2.right) or (xarea.bottom<xclip2.top) or (xarea.top>xclip2.bottom) then goto skipend;
   //init
   //note: "a" is the original unfiltered version of "xarea" - 24apr2020
   if (xarea.left<xclip2.left)       then xarea.left:=xclip2.left;
   if (xarea.right>xclip2.right)     then xarea.right:=xclip2.right;
   if (xarea.top<xclip2.top)         then xarea.top:=xclip2.top;
   if (xarea.bottom>xclip2.bottom)   then xarea.bottom:=xclip2.bottom;
   bol1:=xround and (xcol3<>clnone);//special color outside of round corner area color - optional
   if bol1 then
      begin
      ac24:=low__intrgb(xcol3);
      ac32:=low__intrgb32(xcol3,255);
      end;
   amin:=smallest(xarea.bottom-xarea.top+1,xarea.right-xarea.left+1);
   aw:=a.right-a.left+1;
   ah:=a.bottom-a.top+1;
   //range
   if (aw<=0) or (ah<=0) then goto skipdone;//nothing to do
   ah2:=ah div 2;
   if (ah2<=0) then ah2:=1;
   //get
   for dy:=xarea.top to xarea.bottom do
   begin
   //.other
   if not xscan2432(dy) then
      begin
      result:=false;
      goto skipend;
      end;
   ay:=dy-a.top;
   case (ay<ah2) of
   true:dypert:=-(ah2-ay)/ah2;
   false:dypert:=(ay-ah2)/ah2;
   end;//case
   if (dypert<-1) then dypert:=-1 else if (dypert>1) then dypert:=1;
   //.corner
   low__cornersolid(xdynamicCorners,a,amin,dy,xarea.left,xarea.right,xroundstyle,xround,lx,rx);
   //.dx
   if (lx<=rx) then
      begin
      //.color
      //no mask
      if (xmaskval<0) then
         begin
         for dx:=lx to rx do
         begin
         ax:=dx-a.left;
         dxpert:=((ax+1)/aw);
         if (dxpert<=0.16) then
            begin//red -> yellow
            av:=255*((dxpert-0)/0.16);//0..255
            ar:=255;
            ag:=av;
            ab:=0;
            end
         else if (dxpert<=0.33) then
            begin//yellow -> green
            av:=255*((dxpert-0.16)/0.17);//0..255
            ar:=255-av;
            ag:=255;
            ab:=0;
            end
         else if (dxpert<=0.50) then
            begin//yellow -> green
            av:=255*((dxpert-0.33)/0.17);//0..255
            ar:=0;
            ag:=255;
            ab:=av;
            end
         else if (dxpert<=0.67) then
            begin//yellow -> green
            av:=255*((dxpert-0.50)/0.17);//0..255
            ar:=0;
            ag:=255-av;
            ab:=255;
            end
         else if (dxpert<=0.84) then
            begin//yellow -> green
            av:=255*((dxpert-0.67)/0.17);//0..255
            ar:=av;
            ag:=0;
            ab:=255;
            end
         else if (dxpert<=1) then
            begin//yellow -> green
            av:=255*((dxpert-0.84)/0.16);//0..255
            ar:=255;
            ag:=0;
            ab:=255-av;
            end;
         //.shade
         if (dypert<=0) then
            begin
            ar:=((1+dypert)*ar)+(-dypert*255);
            ag:=((1+dypert)*ag)+(-dypert*255);
            ab:=((1+dypert)*ab)+(-dypert*255);
            end
         else if (dypert>=0) then
            begin
            ar:=(1-dypert)*ar;
            ag:=(1-dypert)*ag;
            ab:=(1-dypert)*ab;
            end;
         //set
         case xbits of
         24:begin
            dc24.r:=byte(round(ar));
            dc24.g:=byte(round(ag));
            dc24.b:=byte(round(ab));
            sr24[dx]:=dc24;
            end;
         32:begin
            dc32.r:=byte(round(ar));
            dc32.g:=byte(round(ag));
            dc32.b:=byte(round(ab));
            dc32.a:=255;
            sr32[dx]:=dc32;
            end;
         end;//case
         end//dx
         end
      //use mask
      else
         begin
         for dx:=lx to rx do if (mr8[dx]=xmaskval) then
         begin
         ax:=dx-a.left;
         dxpert:=((ax+1)/aw);
         if (dxpert<=0.16) then
            begin//red -> yellow
            av:=255*((dxpert-0)/0.16);//0..255
            ar:=255;
            ag:=av;
            ab:=0;
            end
         else if (dxpert<=0.33) then
            begin//yellow -> green
            av:=255*((dxpert-0.16)/0.17);//0..255
            ar:=255-av;
            ag:=255;
            ab:=0;
            end
         else if (dxpert<=0.50) then
            begin//yellow -> green
            av:=255*((dxpert-0.33)/0.17);//0..255
            ar:=0;
            ag:=255;
            ab:=av;
            end
         else if (dxpert<=0.67) then
            begin//yellow -> green
            av:=255*((dxpert-0.50)/0.17);//0..255
            ar:=0;
            ag:=255-av;
            ab:=255;
            end
         else if (dxpert<=0.84) then
            begin//yellow -> green
            av:=255*((dxpert-0.67)/0.17);//0..255
            ar:=av;
            ag:=0;
            ab:=255;
            end
         else if (dxpert<=1) then
            begin//yellow -> green
            av:=255*((dxpert-0.84)/0.16);//0..255
            ar:=255;
            ag:=0;
            ab:=255-av;
            end;
         //.shade
         if (dypert<=0) then
            begin
            ar:=((1+dypert)*ar)+(-dypert*255);
            ag:=((1+dypert)*ag)+(-dypert*255);
            ab:=((1+dypert)*ab)+(-dypert*255);
            end
         else if (dypert>=0) then
            begin
            ar:=(1-dypert)*ar;
            ag:=(1-dypert)*ag;
            ab:=(1-dypert)*ab;
            end;
         //set
         case xbits of
         24:begin
            dc24.r:=byte(round(ar));
            dc24.g:=byte(round(ag));
            dc24.b:=byte(round(ab));
            sr24[dx]:=dc24;
            end;
         32:begin
            dc32.r:=byte(round(ar));
            dc32.g:=byte(round(ag));
            dc32.b:=byte(round(ab));
            dc32.a:=255;
            sr32[dx]:=dc32;
            end;
         end;//case
         end;//dx
         end;
      end;//lx

   //.color outside of round corners
   if bol1 then
      begin
      case xbits of
      24:begin
         //no mask
         if (xmaskval<0) then
            begin
            //.left outside corner
            if (lx>xarea.left) and (lx<=xarea.right) then for dx:=xarea.left to (lx-1) do sr24[dx]:=ac24;
            //.right outside corner
            if (rx>=xarea.left) and (rx<xarea.right) then for dx:=(rx+1) to xarea.right do sr24[dx]:=ac24;
            end
         //use mask
         else
            begin
            //.left outside corner
            if (lx>xarea.left) and (lx<=xarea.right) then for dx:=xarea.left to (lx-1) do if (mr8[dx]=xmaskval) then sr24[dx]:=ac24;
            //.right outside corner
            if (rx>=xarea.left) and (rx<xarea.right) then for dx:=(rx+1) to xarea.right do if (mr8[dx]=xmaskval) then sr24[dx]:=ac24;
            end;
         end;//24
      32:begin
         //no mask
         if (xmaskval<0) then
            begin
            //.left outside corner
            if (lx>xarea.left) and (lx<=xarea.right) then for dx:=xarea.left to (lx-1) do sr32[dx]:=ac32;
            //.right outside corner
            if (rx>=xarea.left) and (rx<xarea.right) then for dx:=(rx+1) to xarea.right do sr32[dx]:=ac32;
            end
         //use mask
         else
            begin
            //.left outside corner
            if (lx>xarea.left) and (lx<=xarea.right) then for dx:=xarea.left to (lx-1) do if (mr8[dx]=xmaskval) then sr32[dx]:=ac32;
            //.right outside corner
            if (rx>=xarea.left) and (rx<xarea.right) then for dx:=(rx+1) to xarea.right do if (mr8[dx]=xmaskval) then sr32[dx]:=ac32;
            end;
         end;//32
      end;//case
      end;//bol1
   end;//dy
   end
//.draw image ------------------------------------------------------------------
else if (xstyle='i') then
   begin
   //check - dx=xarea.left, dx2=xarea.right, dy=xarea.top, dy2=xarea.bottom
   if (xarea.right<xarea.left) or (xarea.bottom<xarea.top) or (xarea.right<xclip2.left) or (xarea.left>xclip2.right) or (xarea.bottom<xclip2.top) or (xarea.top>xclip2.bottom) then goto skipend;
   //get
   case xbits of
   24:low__teadraw2(false,false,xval1,xval2,xcol,xval4,xclip2,xarea,xbits,xw,xh,xrows.prows24,nil,xmask,xmaskval,tepfind2(xval3),xbol1,xbol2,xround,xroundstyle);
   32:low__teadraw2(false,false,xval1,xval2,xcol,xval4,xclip2,xarea,xbits,xw,xh,nil,xrows.prows32,xmask,xmaskval,tepfind2(xval3),xbol1,xbol2,xround,xroundstyle);
   end;
   end
else if (xstyle='j') then//system version -> optional overrides image colors with system based colors
   begin
   //check - dx=xarea.left, dx2=xarea.right, dy=xarea.top, dy2=xarea.bottom
   if (xarea.right<xarea.left) or (xarea.bottom<xarea.top) or (xarea.right<xclip2.left) or (xarea.left>xclip2.right) or (xarea.bottom<xclip2.top) or (xarea.top>xclip2.bottom) then goto skipend;
   //get
   case xbits of
   24:low__teadraw2(xcolorise,true,xval1,xval2,xcol,xval4,xclip2,xarea,xbits,xw,xh,xrows.prows24,nil,xmask,xmaskval,tepfind2(xval3),xbol1,xbol2,xround,xroundstyle);
   32:low__teadraw2(xcolorise,true,xval1,xval2,xcol,xval4,xclip2,xarea,xbits,xw,xh,nil,xrows.prows32,xmask,xmaskval,tepfind2(xval3),xbol1,xbol2,xround,xroundstyle);
   end;
   end
else if (xstyle='a') then
   begin
   //check - dx=xarea.left, dx2=xarea.right, dy=xarea.top, dy2=xarea.bottom
   if (xarea.right<xarea.left) or (xarea.bottom<xarea.top) or (xarea.right<xclip2.left) or (xarea.left>xclip2.right) or (xarea.bottom<xclip2.top) or (xarea.top>xclip2.bottom) then goto skipend;
   //get
   if zzok(xdata,7020) then
      begin
      case xbits of
      24:low__teadraw2(xcolorise,xsyszoom,xval1,xval2,xcol,xval4,xclip2,xarea,xbits,xw,xh,xrows.prows24,nil,xmask,xmaskval,xdata.maplist,xbol1,xbol2,xround,xroundstyle);
      32:low__teadraw2(xcolorise,xsyszoom,xval1,xval2,xcol,xval4,xclip2,xarea,xbits,xw,xh,nil,xrows.prows32,xmask,xmaskval,xdata.maplist,xbol1,xbol2,xround,xroundstyle);
      end;//case
      end;
   end
//.draw text -------------------------------------------------------------------
else if (xstyle='t') then
   begin
   //check - dx=xarea.left, dx2=xarea.right, dy=xarea.top, dy2=xarea.bottom
   if (xarea.right<xarea.left) or (xarea.bottom<xarea.top) or (xarea.right<xclip2.left) or (xarea.left>xclip2.right) or (xarea.bottom<xclip2.top) or (xarea.top>xclip2.bottom) then goto skipend;
   //init
   if (xarea.left<xclip2.left)       then xarea.left:=xclip2.left;
   if (xarea.right>xclip2.right)     then xarea.right:=xclip2.right;
   if (xarea.top<xclip2.top)         then xarea.top:=xclip2.top;
   if (xarea.bottom>xclip2.bottom)   then xarea.bottom:=xclip2.bottom;

   //get - note: xval3=feather: 0=off, 1=mild, 2=strong
   if (xval3>=1) then xfc:=bnew;
   case xbits of
   24:low__fromLGF_drawtext2432TAB(xtab,xdata,xoptions,xval1,xval2,xw,xh,xcol,xclip2,xarea,xrows.prows24,nil,xmask,xmaskval,xfc,xval3,xbol1,xbol2,xbol3,false,xbol4,xround,xroundstyle);//xitalic,xunderline,xstrikeout
   32:low__fromLGF_drawtext2432TAB(xtab,xdata,xoptions,xval1,xval2,xw,xh,xcol,xclip2,xarea,nil,xrows.prows32,xmask,xmaskval,xfc,xval3,xbol1,xbol2,xbol3,false,xbol4,xround,xroundstyle);
   end;
   end;
//successful
skipdone:
low__sparklestop(xsystem_sparklepos);
result:=true;
skipend:
except;end;
try
bfree(xfc);
bunlockautofree(xrows);
bunlockautofree(xdata);//30aug2020
bunlockautofree(xoptions);
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//222222222222222222222222
//## low__cornerMaxwidth ##
function low__cornerMaxwidth:longint;//used by some patch systems to work around corner restrictions such as "statusbar.cellpert.round/square" - 07ul2021
begin
try;result:=3;except;end;
end;
//## low__cornersolid ##
function low__cornersolid(xdynamicCorners:boolean;var a:trect;amin,ay,xmin,xmax,xroundstyle:longint;xround:boolean;var lx,rx:longint):boolean;//29mar2021
var
   ax,ax2:longint;
begin
try
//defaults
result:=true;
ax :=a.left;
ax2:=a.right;
lx :=xmin;
rx :=xmax;

//square corner ----------------------------------------------------------------
if (not xround) or ((amin<3) and xdynamicCorners) or (xmax<xmin) then exit;//check

//rounded corner ---------------------------------------------------------------
//17mar2021
if (xroundstyle=corSlight) or (xroundstyle=corSlight2) or (xroundstyle=corToSquare) then amin:=3//slight corner
else if not xdynamicCorners then amin:=11;//29mar2021

case amin of
3..10:begin
   if (ay=a.top) or (ay=a.bottom) then
      begin
      lx:=ax +1;
      rx:=ax2-1;
      end;
   end;//begin
11..maxint:begin//multi-pixel curved corner
   if (ay=a.top) or (ay=a.bottom) then
      begin
      lx:=ax +3;
      rx:=ax2-3;
      end
   else if (ay=(a.top+1)) or (ay=(a.bottom-1)) then
      begin
      lx:=ax +2;
      rx:=ax2-2;
      end
   else if (ay=(a.top+2)) or (ay=(a.bottom-2)) or (ay=(a.top+3)) or (ay=(a.bottom-3)) or (ay=(a.top+4)) or (ay=(a.bottom-4)) then
      begin
      lx:=ax +1;
      rx:=ax2-1;
      end;
   end;//begin
end;//case
//detect usuability
result:=(lx<=rx);
//enforce range -> must do this else fatal error can occur when a window is dragged offscreen - 29mar2021
lx:=frcrange(lx,xmin,xmax);
rx:=frcrange(rx,xmin,xmax);
except;end;
end;
//## low__cornerhollow ##
procedure low__cornerhollow(xdynamicCorners:boolean;var a:trect;amin,ay,xroundstyle:longint;xround:boolean;var lx,lx2,rx,rx2:longint);//29mar2021, compensates for missed corner pixels -> hollow fits snugly over solid without any missed pixels now - 12apr2020
var
   ax,ax2:longint;
begin
try
//defaults
ax :=a.left;
ax2:=a.right;
lx :=ax;
lx2:=ax;
rx :=ax2;
rx2:=ax2;

//square corner ----------------------------------------------------------------
if (not xround) or ((amin<3) and xdynamicCorners) or (xroundstyle=corNone) then
   begin
   if (ay>a.top) and (ay<a.bottom) then
      begin
      lx:=ax;  lx2:=lx;
      rx:=ax2; rx2:=rx;
      end;
   exit;
   end;

//17mar2021
if (xroundstyle=corSlight) or (xroundstyle=corSlight2) or (xroundstyle=corToSquare) then amin:=3//slight corner
else if not xdynamicCorners then amin:=11;//29mar2021

//rounded corner ---------------------------------------------------------------
case amin of
3..10:begin
   if (ay=a.top) or (ay=a.bottom) then
      begin
      lx:=ax +1; lx2:=lx;
      rx:=ax2-1; rx2:=rx;
      end
   else if (xroundstyle<>corSlight2) and ((ay=(a.top+1)) or (ay=(a.bottom-1))) then
      begin
      lx:=ax +0; lx2:=lx+1;
      rx:=ax2-0; rx2:=rx-1;
      end
   else
      begin
      lx:=ax +0; lx2:=lx;
      rx:=ax2-0; rx2:=rx;
      end;
   end;
11..maxint:begin//multi-pixel curved corner
   if (ay=a.top) or (ay=a.bottom) then
      begin
      lx:=ax +3; lx2:=lx;
      rx:=ax2-3; rx2:=rx;
      end
   else if (ay=(a.top+1)) or (ay=(a.bottom-1)) then
      begin
      lx:=ax +2; lx2:=lx+1;
      rx:=ax2-2; rx2:=rx-1;
      end
   else if (ay=(a.top+2)) or (ay=(a.bottom-2)) then
      begin
      lx:=ax +1; lx2:=lx+1;
      rx:=ax2-1; rx2:=rx-1;
      end
   else if (ay=(a.top+3)) or (ay=(a.bottom-3)) or (ay=(a.top+4)) or (ay=(a.bottom-4)) then
      begin
      lx:=ax +1; lx2:=lx+0;
      rx:=ax2-1; rx2:=rx-0;
      end
   else if (ay=(a.top+5)) or (ay=(a.bottom-5)) then
      begin
      lx:=ax +0; lx2:=lx+1;
      rx:=ax2-0; rx2:=rx-1;
      end
   else
      begin
      lx:=ax +0; lx2:=lx;
      rx:=ax2-0; rx2:=rx;
      end;
   end;
end;//case
except;end;
end;

//-- menu support --------------------------------------------------------------
//## low__menuinit ##
procedure low__menuinit(x:tstr8);
begin
try
if zzok(x,7021) then
   begin
   x.clear;
   x.aadd([llm,lle,uuN,nn2]);//'meN2';
   end;
bautofree(x);
except;end;
end;
//## low__menutitle ##
function low__menutitle(x:tstr8;xtep:longint;xcaption,xhelp:string):boolean;
begin//add menu title
try;result:=low__menuadd(x,xtep,clnone,xcaption,xhelp,'',0,aknone,0,false,true,true,false);except;end;
end;
//## low__menuitem ##
function low__menuitem(x:tstr8;xtep:longint;xcaption,xhelp,xcode2:string;xcode:longint;xenabled:boolean):boolean;
begin//add menu item
try;result:=low__menuadd(x,xtep,clnone,xcaption,xhelp,xcode2,xcode,aknone,0,false,xenabled,false,false);except;end;
end;
//## low__menuitem2 ##
function low__menuitem2(x:tstr8;xtep:longint;xcaption,xhelp,xcode2:string;xcode,xshortcut:longint;xenabled:boolean):boolean;
begin//add menu item
try;result:=low__menuadd(x,xtep,clnone,xcaption,xhelp,xcode2,xcode,xshortcut,0,false,xenabled,false,false);except;end;
end;
//## low__menuitem2b ##
function low__menuitem2b(x:tstr8;xtep:longint;xcaption,xhelp,xcode2:string;xcode,xshortcut:longint;xenabled:boolean;xindentLevel:longint):boolean;//07jun2021
begin//add menu item
try;result:=low__menuadd(x,xtep,clnone,xcaption,xhelp,xcode2,xcode,xshortcut,18*vizoom*frcrange(xindentLevel,0,5),false,xenabled,false,false);except;end;
end;
//## low__menuitem3 ##
function low__menuitem3(x:tstr8;xtep:longint;xcaption,xhelp,xcode2:string;xcode,xshortcut:longint;xflash,xenabled:boolean):boolean;
begin//add menu item
try;result:=low__menuadd(x,xtep,clnone,xcaption,xhelp,xcode2,xcode,xshortcut,0,xflash,xenabled,false,false);except;end;
end;
//## low__menuitem4 ##
function low__menuitem4(x:tstr8;xtep:longint;xcaption,xhelp,xcode2:string;xcode,xshortcut,xindent:longint;xflash,xenabled:boolean):boolean;
begin
try;result:=low__menuadd(x,xtep,clnone,xcaption,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,false,false);except;end;
end;
//## low__menutitlex ##
function low__menutitlex(x:tstr8;xtep,xtepcolor:longint;xcaption,xhelp:string):boolean;
begin//add menu title
try;result:=low__menuadd(x,xtep,xtepcolor,xcaption,xhelp,'',0,aknone,0,false,true,true,false);except;end;
end;
//## low__menuitemx ##
function low__menuitemx(x:tstr8;xtep,xtepcolor:longint;xcaption,xhelp,xcode2:string;xcode:longint;xenabled:boolean):boolean;
begin//add menu item
try;result:=low__menuadd(x,xtep,xtepcolor,xcaption,xhelp,xcode2,xcode,aknone,0,false,xenabled,false,false);except;end;
end;
//## low__menuitemx2 ##
function low__menuitemx2(x:tstr8;xtep,xtepcolor:longint;xcaption,xhelp,xcode2:string;xcode,xshortcut:longint;xenabled:boolean):boolean;
begin//add menu item
try;result:=low__menuadd(x,xtep,xtepcolor,xcaption,xhelp,xcode2,xcode,xshortcut,0,false,xenabled,false,false);except;end;
end;
//## low__menuitemx3 ##
function low__menuitemx3(x:tstr8;xtep,xtepcolor:longint;xcaption,xhelp,xcode2:string;xcode,xshortcut:longint;xflash,xenabled:boolean):boolean;
begin//add menu item
try;result:=low__menuadd(x,xtep,xtepcolor,xcaption,xhelp,xcode2,xcode,xshortcut,0,xflash,xenabled,false,false);except;end;
end;
//## low__menuitemx4 ##
function low__menuitemx4(x:tstr8;xtep,xtepcolor:longint;xcaption,xhelp,xcode2:string;xcode,xshortcut,xindent:longint;xflash,xenabled:boolean):boolean;
begin
try;result:=low__menuadd(x,xtep,xtepcolor,xcaption,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,false,false);except;end;
end;
//## low__menusep ##
function low__menusep(x:tstr8):boolean;
begin//add menu separator (on the tail of previous item)
try;result:=low__menuadd(x,tepNone,clnone,'','','',0,aknone,0,false,false,false,true);except;end;
end;
//## low__menuend ##
function low__menuend(x:tstr8):boolean;
label
   skipend,redo;
var
   xtmp,xindex:tstr8;
   xpos,xlen,xchunksize:longint;
begin
try
//defaults
result:=false;
xindex:=nil;
xtmp:=nil;
block(x);
//check
if zznil(x,2172) or x.empty then goto skipend;
//check
//.menu has already been finalised
if x.asame([109,101,110,50]) then//men2
   begin
   result:=true;
   goto skipend;
   end
//.menu format is unknown
else if not x.asame([109,101,78,50]) then goto skipend;//meN2

//-- Finalise menu -------------------------------------------------------------
//Note: Build and insert menu index
//finalise menu datablock
x.setlen(x.count);

//init
xindex:=bnew;
xlen:=x.count;
//check
if (xlen<4) or (not x.asame([109,101,78,50])) then goto skipend;//meN2
//get
xpos:=5;//skip over main head (temp at this stage)
redo:
if (xpos<=(xlen+3)) then
   begin
   xchunksize:=x.int4[xpos-1];
   if (xchunksize>=1) then
      begin
      xindex.addint4(xpos-4);
      //loop
      inc(xpos,xchunksize);
      goto redo;
      end;
   end;
//.insert index into menu datablock and mark as done with "men2"
xtmp:=bnew;
xtmp.aadd([109,101,110,50]);//men2 -> 0..3
xtmp.addint4(xindex.count div 4);//4..7
xtmp.add(xindex);
xtmp.add2(x,4,x.count-1);
x.clear;
x.add(xtmp);
//successful
result:=true;
skipend:
except;end;
try
freeobj(@xindex);
freeobj(@xtmp);
bunlockautofree(x);
except;end;
end;
//## low__menucount ##
function low__menucount(x:tstr8):longint;//number of items in menu
begin
try
block(x);
result:=0;
if zzok(x,7021) and x.asame([109,101,110,50]) then result:=frcmin(x.int4[4],0);
bunlockautofree(x);
except;end;
end;
//## low__menuget ##
function low__menuget(x:tstr8;xindex:longint;var xtep,xtepcolor:longint;var xcaption,xhelp,xcode2:string;var xcode,xshortcut,xindent:longint;var xflash,xenabled,xtitle,xsep:boolean):boolean;
label
   skipend;
var
   xlen,xpos,xcount:longint;
   xval:tstr8;
   //## xpull ##
   function xpull:boolean;
   var
      int1:longint;
   begin
   //defaults
   result:=false;
   xval.clear;
   //check
   if (xpos<1) or ((xpos+3)>xlen) then exit;
   //get
   int1:=frcmin(x.int4[xpos-1],0);
   inc(xpos,4);
   if (int1>=1) then
      begin
      xval.add2(x,xpos-1,xpos-1+int1-1);
      inc(xpos,int1);
      end;
   //successful
   result:=(int1>=0);
   end;
   //## xpullint4 ##
   function xpullint4(var xval:longint):boolean;
   begin
   //defaults
   result:=false;
   xval:=0;
   //check
   if (xpos<1) or ((xpos+3)>xlen) then exit;
   //get
   xval:=x.int4[xpos-1];
   inc(xpos,4);
   //successful
   result:=true;
   end;
begin
try
//defaults
result:=false;
block(x);
xval:=nil;
xtep:=tepNone;
xtepcolor:=clnone;
xcaption:='';
xhelp:='';
xcode2:='';
xcode:=0;
xshortcut:=aknone;
xindent:=0;
xenabled:=false;
xtitle:=false;
xsep:=false;
xflash:=false;
//check                      //'men2'
if zznil(x,2173) or (x.count<8) or (not x.asame([109,101,110,50])) then goto skipend;
xlen:=x.count;
//init
xval:=bnew;
//range
xcount:=frcmin(x.int4[4],0);
if (xindex<0) or (xindex>=xcount) then goto skipend;
//index slot -> start of menuitem data chunk
xpos:=9+(xindex*4);
if (xpos<1) or ((xpos+3)>xlen) then goto skipend;
xpos:=4+4+(xcount*4)+x.int4[xpos-1];
if (xpos<1) or ((xpos+3)>xlen) then goto skipend;
//.skip over chunksize
inc(xpos,4);
//get
if not xpullint4(xtep) then goto skipend;//06may2020
if not xpullint4(xtepcolor) then goto skipend;//02mar2021
if xpull then xcaption:=xval.text else goto skipend;
if xpull then xhelp:=xval.text else goto skipend;
if xpull then xcode2:=xval.text else goto skipend;
if xpull then
   begin
   xcode:=xval.int4[0];//0..3  to32bit(copy(xval,1,4));//1..4
   xshortcut:=xval.int4[4];//4..7  to32bit(copy(xval,5,4));//5..8
   xindent:=frcmin(xval.int4[8],0);//8..11  frcmin(to32bit(copy(xval,9,4)),0);//9..12
   xflash:=(xval.byt1[12]=1);
   xenabled:=(xval.byt1[13]=1);//(copy(xval,13,1)=#1);//13
   xtitle:=(xval.byt1[14]=1);//(copy(xval,14,1)=#1);//14
   xsep:=(xval.byt1[15]=1);//(copy(xval,15,1)=#1);//15
   end
else goto skipend;
//successful
result:=true;
skipend:
except;end;
try
freeobj(@xval);
bunlockautofree(x);
except;end;
end;
//## low__menuadd ##
function low__menuadd(x:tstr8;xtep,xtepcolor:longint;xcaption,xhelp,xcode2:string;xcode,xshortcut,xindent:longint;xflash,xenabled,xtitle,xsep:boolean):boolean;
label
   skipend;
var
   xval:tstr8;
begin
try
//defaults
result:=false;
xval:=nil;
block(x);
//check
if zznil(x,2174) or (not x.asame([109,101,78,50])) then goto skipend;//meN2
//special overrides
if xsep and (xcaption='') then
   begin
   if (x.count>=1) then x.pbytes[x.count-1]:=1;//adjust the previous item to include a trailing separater - 28mar2020
   result:=true;
   exit;
   end;
//range
xindent:=frcmin(xindent,0);
//get
xval:=bnew;
xval.addint4(xtep);//06may2020
xval.addint4(xtepcolor);//02mar2021
xval.addint4(length(xcaption));xval.addstr(xcaption);
xval.addint4(length(xhelp));xval.addstr(xhelp);
xval.addint4(length(xcode2));xval.addstr(xcode2);
xval.addint4(16);//this covers: xcode+xshortcut+xindent+xenabled+xtitle+xsep below - 01apr2020, 26mar2020
xval.addint4(xcode);
xval.addint4(xshortcut);
xval.addint4(xindent);//07apr2020
xval.addbyt1(low__aorb(0,1,xflash));//25mar2021
xval.addbyt1(low__aorb(0,1,xenabled));
xval.addbyt1(low__aorb(0,1,xtitle));
xval.addbyt1(low__aorb(0,1,xsep));//this trailing var "sep" is automatically modified by menu handler procs -> always have as last in list - 25mar2021
//add
//was: result:=pushb(xdatalen,xdata,from32bit(4+length(xval))+xval);
x.addint4(4+xval.count);
x.add(xval);
skipend:
except;end;
try
freeobj(@xval);
bunlockautofree(x);
except;end;
end;
//## low__menufindbycode2 ##
function low__menufindbycode2(x:tstr8;xfindval:string;var xindex:longint):boolean;
label
   skipend;
var
   xtep,xtepcolor,xcode,xshortcut,xindent,p,xcount:longint;
   xcaption,xhelp,xcode2:string;
   xflash,xenabled,xtitle,xsep:boolean;
begin
try
//defaults
result:=false;
block(x);
xindex:=0;
xcount:=low__menucount(x);
//check
if (xcount<=0) then goto skipend;
//find
for p:=0 to (xcount-1) do if low__menuget(x,p,xtep,xtepcolor,xcaption,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep) and low__comparetext(xfindval,xcode2) then
   begin
   xindex:=p;
   result:=true;
   break;
   end;
skipend:
except;end;
try;bunlockautofree(x);except;end;
end;
//## low__menucode2 ##
function low__menucode2(x:tstr8;xindex:longint):string;
var
   xtep,xtepcolor:longint;
   xcaption,xhelp,xcode2:string;
   xcode,xshortcut,xindent:longint;
   xflash,xenabled,xtitle,xsep:boolean;
begin
try
result:='';
if low__menuget(x,xindex,xtep,xtepcolor,xcaption,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep) then result:=xcode2;
except;end;
end;
//file support -----------------------------------------------------------------
//## faISfolder ##
function faISfolder(x:longint):boolean;//05JUN2013
begin//fast
result:=((x and faDirectory)>0);
end;
//## safename ##
function safename(x:string):string;//07mar2021, 08mar2016
begin
try;result:=safefilename(x,false);except;end;
end;
//## safefilename ##
//Note: was called safename and nn_safename or low__safename
function safefilename(x:string;allowpath:boolean):string;//07mar2021, 08mar2016
var
   minp,p:longint;
   c:char;
   //## isbinary ##
   function isbinary(x:byte):boolean;
   begin
   try
   case x of//31MAR2010
   32..255:result:=false;
   else result:=true;
   end;
   except;end;
   end;
begin
try
//defaults
result:=x;
if (x='') then exit;
//get
if allowpath then
   begin
   //.get
   if (strcopy1(x,1,2)='\\') then minp:=3 else minp:=1;
   //.set
   for p:=(minp-1) to (length(result)-1) do
   begin
   c:=result[p+stroffset];
   if (c='/') then result[p+stroffset]:='\'
   else if isbinary(byte(c)) or (c=';') or (c='*') or (c='?') or (c='"') or (c='<') or (c='>') or (c='|') or (c='$') then result[p+stroffset]:=pcSymSafe;
   //was: else if isbinary(byte(c)) or (c=';') or (c='*') or (c='?') or (c='"') or (c='<') or (c='>') or (c='|') or (c='@') or (c='$') then result[p+stroffset]:=pcSymSafe;
   end;//p
   end
else
   begin
   //.set
   for p:=0 to (length(result)-1) do
   begin
   c:=result[p+stroffset];
   if isbinary(byte(c)) or (c='\') or (c='/') or (c=':') or (c=';') or (c='*') or (c='?') or (c='"') or (c='<') or (c='>') or (c='|') or (c='@') or (c='$') then result[p+stroffset]:=pcSymSafe;
   end;//p
   end;
except;end;
end;
//## issafefilename ##
function issafefilename(x:string):boolean;//07mar2021, 10APR2010
var
   minp,p:longint;
   c:char;
   //## isbinary ##
   function isbinary(x:byte):boolean;
   begin
   try
   case x of//31MAR2010
   32..255:result:=false;
   else result:=true;
   end;
   except;end;
   end;
begin
try
//defaults
result:=true;
//check
if (x='') then exit;
//set
for p:=0 to (length(x)-1) do
begin
c:=x[p+stroffset];
//was: if isbinary(byte(c)) or (c='\') or (c='/') or (c=':') or (c=';') or (c='*') or (c='?') or (c='"') or (c='<') or (c='>') or (c='|') or (c='@') or (c='$') then
if isbinary(byte(c)) or (c='\') or (c='/') or (c=':') or (c=';') or (c='*') or (c='?') or (c='"') or (c='<') or (c='>') or (c='|') or (c='$') then
   begin
   result:=false;
   break;
   end;
end;//p
except;end;
end;
//## hack_dangerous_filepath_allow_mask ##
function hack_dangerous_filepath_allow_mask(x:string):boolean;
begin
try;result:=hack_dangerous_filepath(x,false);except;end;
end;
//## hack_dangerous_filepath_deny_mask ##
function hack_dangerous_filepath_deny_mask(x:string):boolean;
begin
try;result:=hack_dangerous_filepath(x,true);except;end;
end;
//## hack_dangerous_filepath ##
function hack_dangerous_filepath(x:string;xstrict_no_mask:boolean):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
//get
if (x<>'') then
   begin
   for p:=0 to (length(x)-1) do
   begin
   //check 1 - "..\" + "../"
   if (x[p+stroffset]='.') and ((strcopy0(x,p,3)='..\') or (strcopy0(x,p,3)='../')) then
      begin
      result:=true;
      break;
      end
   //check 2 - (..\) "..%5C" + "..%5c" AND (../) "..%2F" + "..%2f"
   else if (x[p+stroffset]='.') and ((strcopy0(x,p,5)='..%5C') or (strcopy0(x,p,5)='..%5c') or (strcopy0(x,p,5)='..%2F') or (strcopy0(x,p,5)='..%2f')) then
      begin
      result:=true;
      break;
      end
   //check 3 - ":" other than "(a-z/@):(\/)" e.g. "C:\" is ok, but "C::" is not - 02sep2016
   else if (p>=2) and (x[p+stroffset]=':') then
      begin
      result:=true;
      break;
      end
   //check 4 - none of these characters are allowed, ever - 02sep2016
   else if (x[p+stroffset]='?') or (x[p+stroffset]='<') or (x[p+stroffset]='>') or (x[p+stroffset]='|') then
      begin
      result:=true;
      break;
      end
   //optional check 5 - disallow file masking "*"
   else if xstrict_no_mask and (x[p+stroffset]='*') then
      begin
      result:=true;
      break;
      end;
   end;//p
   end;
except;end;
end;
//## low__makeportablefilename ##
function low__makeportablefilename(filename:string):string;//11sep2021, 06oct2020, 14APR2011
var// "C:\...\" => exact static filename
   // "c:\...\" => also an exact static filename
   // "?:\...\" => relative dynamic filename (on same disk as EXE and thus will adapt) - 11sep2021, 14APR2011
   edrive,sdrive:string;
begin
try
result:=filename;
//get
if (length(result)>=2) and (strcopy1(result,2,1)=':') and (strcopy1(result,1,1)<>'/') and (strcopy1(result,1,1)<>'\') then
   begin
   edrive:=strcopy1(low__exename+'Z',1,1);//pad with "Z" incase app.exename is empty for some reason - 14APR2011
   sdrive:=strcopy1(result,1,1);
   //get - if on same drive as EXE then it's considered portable so make it "?:\...\"
   if low__comparetext(edrive,sdrive) then result:='?'+strcopy1(result,2,length(result));
   end;
except;end;
end;
//## low__readportablefilename ##
function low__readportablefilename(filename:string):string;//11sep2021
var// "C:\...\" => STATIC, exact static filename
   // "c:\...\" => also an exact static filename
   // "?:\...\" => RELATIVE, dynamic filename (on same disk as EXE and thus will adapt) - 11sep2021, 14APR2011
   edrive:string;
begin
try
result:=filename;
//get
if (length(result)>=2) and (strcopy1(result,2,1)=':') and (strcopy1(result,1,1)<>'/') and (strcopy1(result,1,1)<>'\') then
   begin
   edrive:=strcopy1(low__exename+'Z',1,1);//pad with "Z" incase app.exename is empty for some reason - 14APR2011
   if (strcopy1(result,1,1)='?') then result:=edrive+strcopy1(result,2,length(result));
   end;
except;end;
end;
//## asfolder ##
function asfolder(x:string):string;//enforces trailing "\"
begin
try;if (strcopy1(x,length(x),1)<>'\') then result:=x+'\' else result:=x;except;end;
end;
//## asfolderNIL ##
function asfolderNIL(x:string):string;//enforces trailing "\" AND permits NIL - 03apr2021, 10mar2014
begin
try
if (x='') then result:=''//nil
else if (not low__comparetext(strcopy1(x,2,2),':\')) and (not low__comparetext(strcopy1(x,2,2),':/')) and (strcopy1(x,1,1)<>'/') and (strcopy1(x,1,1)<>'\') then result:=x//straight pass-thru -> this allows for "home" to pass right thru unaffected - 31mar2021
else result:=asfolder(x);//as a folder in the format "?:\.....\" or "?:/...../" or "/..../" or "\...\"
except;end;
end;
//## low__folderaslabel ##
function low__folderaslabel(x:string):string;
var
   p:longint;
begin
try
//defaults
result:='';
//remove trailing slash
if (strcopy1(x,length(x),1)='/') or (strcopy1(x,length(x),1)='\') then strdel1(x,length(x),1);
//read down to next slash                                 
if (x<>'') then for p:=length(x) downto 1 do if (strbyte1(x,p)=92) or (strbyte1(x,p)=47) then
   begin
   x:=strcopy1(x,p+1,length(x));
   break;
   end;
except;end;
try;result:=low__udv(x,'?');except;end;
end;
//## low__isfile ##
function low__isfile(x:string):boolean;
begin
try;result:=(strcopy1(x,length(x),1)<>'\') and (strcopy1(x,length(x),1)<>'/');except;end;
end;
//## low__local ##
function low__local(x:string):boolean;
begin
try;result:=(strcopy1(x,1,1)<>'@');except;end;
end;
//## low__canshowfolder ##
function low__canshowfolder(x:string):boolean;
begin
try;result:=(x<>'') and (not low__nn(x)) and (not low__dk(x));except;end;
end;
//## low__nn ##
function low__nn(x:string):boolean;//14apr2021
begin
try;result:=(strcopy1(x,1,1)='@');except;end;
end;
//## low__dk ##
function low__dk(x:string):boolean;//14apr2021
begin
try;result:=(strcopy1(x,1,1)=sysdisk_char);except;end;
end;
//## tep__delall20 ##
procedure tep__delall20(xownerid:longint);
var
   int1,xpos,xstep,xlen,p:longint;
begin
try
//check
if zznil(syslist_tep20,2176) or (xownerid<=0) then exit;//ownerid must be 1..N
//init
xpos:=0;
xlen:=syslist_tep20.len;
xstep:=8+(teaMaxsize20x20+100);//ownerid.4 + tea.datalen.4 + tea.data.N + plus.overallow.by.100bytes
//get
while true do
begin
//check
if ((xpos+xstep)>xlen) then break;
//decide
int1:=syslist_tep20.int4[xpos];
if (int1=xownerid) then syslist_tep20.int4[xpos]:=0;//mark as "not owned" or "0" - 06apr2021
//inc
inc(xpos,xstep);
end;
except;end;
end;
//## tep__addone20 ##
function tep__addone20(xownerid:longint;xdata:tstr8;var xtep:longint):boolean;
label
   redo,skipend;
var
   atransparent,asyscolors,xonce:boolean;
   int1,p,xlenlimit,xdatalen,xpos,xstep,xlen,aw,ah,aSOD,aversion,aval1,aval2:longint;
begin
try
//defaults
result:=false;
xtep:=tepNone;
xonce:=true;
//init
if (xownerid<=0) or zznil(xdata,2177) then exit;
xdatalen:=xdata.len;
if (xdatalen<=0) or (xdatalen>(teaMaxsize20x20+100)) then exit;
if (not low__teainfo2(xdata,false,aw,ah,aSOD,aversion,aval1,aval2,atransparent,asyscolors)) or (aw<=0) or (aw>20) or (ah<=0) or (ah>20) then exit;//ensure image is atleast 1w x 1h and no more than 20w x 20h
if zznil(syslist_tep20,2178) then syslist_tep20:=bnew;
xpos:=0;
xlen:=syslist_tep20.len;
xstep:=8+(teaMaxsize20x20+100);//ownerid + tea.data
xlenlimit:=(tepSysstop20-tepSysstart20+1)*xstep;

//find 1st unused item "xownerid=0"
redo:
while true do
begin
//check
if ((xpos+xstep)>xlen) then break;
//decide
if (syslist_tep20.int4[xpos]=0) then
   begin
   xtep:=tepSysstart20+(xpos div xstep);
   if (xtep>tepSysstop20) then goto skipend;//exceeds allowed limit
   syslist_tep20.int4[xpos]:=xownerid; inc(xpos,4);
   syslist_tep20.int4[xpos]:=xdatalen; inc(xpos,4);
   for p:=0 to (xdatalen-1) do syslist_tep20.byt1[xpos+p]:=xdata.pbytes[p];
   result:=true;
   break;
   end;
//inc
inc(xpos,xstep);
end;

//expand the list and try again - 06apr2021
if (not result) and xonce and (xlen<xlenlimit) then
   begin
   xonce:=false;
   int1:=xlen+(1000*xstep);
   syslist_tep20.setlen(int1);
   syslist_tep20.fill(xlen,int1-1,0);
   xpos:=xlen;
   xlen:=syslist_tep20.len;
   goto redo;
   end;

skipend:
except;end;
try;if not result then xtep:=tepNone;except;end;
end;
//## tep__find20 ##
function tep__find20(xindex:longint;var xdata:tlistptr):boolean;
var//xindex=tepSysstart20..N
   int1,int2,xpos,xlen,xstep:longint;
begin
try
//defaults
result:=false;
xdata.count:=0;
xdata.bytes:=nil;
//get
if (xindex>=tepSysstart20) and zzok(syslist_tep20,7022) then
   begin
   xlen:=syslist_tep20.len;
   xstep:=8+teaMaxsize20x20+100;//ownerid + tea.data + overallow by 100bytes
   xpos:=(xindex-tepSysstart20)*xstep;
   if (xpos>=0) and ((xpos+xstep)<=xlen) then
      begin
      int1:=syslist_tep20.int4[xpos]; inc(xpos,4);//ownerid = 0 = not in use
      int2:=syslist_tep20.int4[xpos]; inc(xpos,4);//datalen
      if (int1>=1) and (int2>=1) then
         begin
         xdata.count:=int2;
         xdata.bytes:=syslist_tep20.scanline(xpos);
         result:=true;
         end;
      end;
   end;
except;end;
end;
//## low__reloadfastvars ##
procedure low__reloadfastvars;
begin
try
sysfast_root        :=low__platroot;
sysfast_settings    :=low__platfolder('settings');
sysfast_schemes     :=low__platfolder('schemes');
sysfast_startmenu   :=winstartmenu;
sysfast_desktop     :=windesktop;
sysfast_programs    :=winprograms;
sysfast_blaiz       :=low__platfolder('');
except;end;
end;
//## low__getfolderimg ##
function low__getfolderimg(xfolder:string;xdata:tstr8):boolean;//14apr2021
var
   xfn,e:string;
begin
try
result:=false;
if block(xdata) then
   begin
   xdata.clear;
   xfolder:=asfoldernil(xfolder);
   if (xfolder<>'') then xfn:=xfolder+'.be.tea' else xfn:='';
   if (xfn<>'') then result:=low__fromfile(xfn,xdata,e);
   if not result then xdata.clear;
   end;
except;end;
try;bunlockautofree(xdata);except;end;
end;
//## low__setfolderimg ##
function low__setfolderimg(xfolder:string;xdata:tstr8):boolean;//14apr2021
var
   xfn,e:string;
begin
try
result:=false;
block(xdata);
xfolder:=asfoldernil(xfolder);
if (xfolder<>'') then xfn:=xfolder+'.be.tea' else xfn:='';
if (xfn<>'') then
   begin
   if zznil(xdata,2179) or (xdata.len<=0) then result:=low__remfile(xfn) else result:=low__tofile(xfn,xdata,e);
   end;
except;end;
try;bunlockautofree(xdata);except;end;
end;
//## low__setfolderimg2 ##
function low__setfolderimg2(xfolder:string;xdata:array of byte):boolean;//14apr2021
var
   a:tstr8;
begin
try
result:=false;
a:=nil;
a:=bnew;
a.aadd(xdata);
result:=low__setfolderimg(xfolder,a);
except;end;
try;bfree(a);except;end;
end;
//## low__foldertep ##
function low__foldertep(xfolder:string):longint;
begin
try;result:=low__foldertep2(0,xfolder);except;end;
end;
//## low__foldertep2 ##
function low__foldertep2(xownerid:longint;xfolder:string):longint;
var//Note: xownerid=0=built-in images only, 1..N=use built-in images, but override if folder has a custom image (.be.tea) - 06apr2021
   a:tstr8;
   int1,xlen:longint;
   e,n:string;
begin
try
//defaults
result:=tepFolder20;
a:=nil;
//init
xfolder:=asfoldernil(xfolder);
xlen:=length(xfolder);
//get
//.root folder
if (xlen=1) and ((strcopy1(xfolder,1,1)='/') or (strcopy1(xfolder,1,1)='\')) then result:=tepDisk20
//.disk drive
else if (xlen=3) then
   begin
   n:=low__drivetype(xfolder);
   if (n='cd') then result:=tepCD20
   else if (n='removable') or (n='floppy') or (n='network') or (n='nn') then result:=tepRemovable20
   else result:=tepDisk20;
   end
//.special folder
else if      low__comparetext(xfolder,sysfast_root) then result:=tepOpen20
else if low__comparetext(xfolder,sysfast_settings)  then result:=tepSettings20
else if low__comparetext(xfolder,sysfast_schemes)   then result:=tepSchemes20
else if low__comparetext(xfolder,sysfast_startmenu) then result:=tepStartmenu20
else if low__comparetext(xfolder,sysfast_desktop)   then result:=tepDesktop20
else if low__comparetext(xfolder,sysfast_programs)  then result:=tepPrograms20
else if low__comparetext(xfolder,sysfast_blaiz)     then result:=tepBE20

//.folder
else result:=tepFolder20;

//customise
if (xlen>=3) and (xownerid>=1) then
   begin
   a:=bnew;
   if low__fromfile(xfolder+'.be.tea',a,e) and tep__addone20(xownerid,a,int1) then result:=int1;
   end;
except;end;
try;if (a<>nil) then bfree(a);except;end;
end;
//## low__driveexists ##
function low__driveexists(x:string):boolean;//true=drive has content - 17may2021, 16feb2016, 25feb2015, 17AUG2010
var
   xdrive:string;
{$ifdef D3}
   orgerr,notused,volflags,serialno:dword;
   buf:array[0..max_path] of char;
   buf2:array[0..max_path] of char;
{$endif}
begin
try
//defaults
result:=false;
//check
if (x<>'') then xdrive:=x[stroffset]+':\' else exit;
//hack check
if hack_dangerous_filepath_deny_mask(xdrive) then exit;//17may2021
//check drive is in range
if not (  (xdrive[1+stroffset]=':') and ((xdrive[2+stroffset]='\') or (xdrive[2+stroffset]='/')) and ( (xdrive[0+stroffset]='!') or (xdrive[0+stroffset]='@') or ((xdrive[0+stroffset]>='a') and (xdrive[0+stroffset]<='z')) or ((xdrive[0+stroffset]>='A') and (xdrive[0+stroffset]<='Z')) )  ) then exit;
//get
if      (xdrive='@:\') then result:=false//no support for Name Network at this stage - nn.stable - 15mar2020
else if (xdrive='!:\') then result:=sysdisk_inuse//no support for this either - resources drive - 13apr2015
else
   begin
{$ifdef D3}
   try
   //fully qualified for maximum stability - 17may2021
   orgerr:=seterrormode(SEM_FAILCRITICALERRORS);//prevents the display of a prompt window asking for a FLOPPY or CD-DISK to be inserted as stated my MS - 04apr2021
   fillchar(buf,sizeof(buf),0);
   fillchar(buf2,sizeof(buf2),0);
   buf[0]:=#$00;
   buf2[0]:=#$00;
   result:=boolean(getvolumeinformation(pchar(xdrive),buf,sizeof(buf),@serialno,notused,volflags,buf2,sizeof(buf2)));
   except;end;
   seterrormode(orgerr);
{$endif}

{$ifdef D10}
result:=true;//D10: No support yet
{$endif}
   end;
except;end;
end;
//## low__drivetype ##
function low__drivetype(x:string):string;//15apr2021, 05apr2021
type
   tdrivetype2=(dtUnknown,dtNoDrive,dtFloppy,dtFixed,dtNetwork,dtCDROM,dtRAM);
var
   xdrive:string;
begin
try
//defaults
result:='';
//init
xdrive:=low__uppercase(strcopy1(x,1,1));
//get
if (xdrive<>'') then
   begin
   if      (xdrive='@')          then result:='nn'//name network
   else if (xdrive=sysdisk_char) then result:='sys'//built-in system disk
   else
      begin
      case tdrivetype2(getdrivetype(pchar(xdrive+':\'))) of
      dtFloppy:if (xdrive<='B') then result:='floppy' else result:='removable';
      dtFixed   :result:='fixed';
      dtNetwork :result:='network';
      dtCDROM   :result:='cd';
      dtRAM     :result:='ram';
      else       result:='fixed';
      end;//case
      end;//if
   end;
except;end;
end;
//## low__drivelabel ##
function low__drivelabel(x:string;xfancy:boolean):string;//17may2021, 05apr2021
var//Note: Incorrectly returns UPPERCASE labels for removable disks - 30DEC2010
   xdrive,xlabel:string;
   p:longint;
   orgerr,notused,volflags,serialno:dword;
   buf:array[0..max_path] of char;
   buf2:array[0..max_path] of char;
begin
try
//defaults
result:='';
//get
if (x<>'') then
   begin
   //init
   xdrive:=strcopy1(x,1,1)+':';
   xlabel:='';
   //label
   if low__driveexists(x) then
      begin
      //.built-in system disk "!:\"
      if low__comparetext(strcopy1(x,1,1),sysdisk_char) then xlabel:=sysdisk_label
      //.standard disk drives "A-Z:\"
      else if ((x[0+stroffset]>='a') and (x[0+stroffset]<='z')) or ((x[0+stroffset]>='A') and (x[0+stroffset]<='Z')) then
         begin
         try
         //fully qualified for maximum stability - 17may2021
         orgerr:=seterrormode(SEM_FAILCRITICALERRORS);//prevents the display of a prompt window asking for a FLOPPY or CD-DISK to be inserted as stated my MS - 04apr2021
         fillchar(buf,sizeof(buf),0);
         fillchar(buf2,sizeof(buf2),0);
         buf[0]:=#$00;
         buf2[0]:=#$00;
         if boolean(getvolumeinformation(pchar(strcopy1(x,1,1)+':\'),buf,sizeof(buf),@serialno,notused,volflags,buf2,sizeof(buf2))) then setstring(xlabel,buf,strlen(buf));
         except;end;
         seterrormode(orgerr);
         end;
      end;
   //clean -> make more compatible with "Wine 5+" - 16apr2021
   if (xlabel<>'') then
      begin
      for p:=1 to length(xlabel) do if (strcopy1(xlabel,p,1)='?') or (strcopy1(xlabel,p,1)=#0) then
         begin
         xlabel:=strcopy1(xlabel,1,p-1);
         break;
         end;
      end;
   //set
   if xfancy then result:=xlabel+low__insstr(#32+'(',xlabel<>'')+xdrive+low__insstr(')',xlabel<>'') else result:=xlabel;
   end;
except;end;
end;
//## low__extractfileext ##
function low__extractfileext(x:string):string;//12apr2021
var
   p:longint;
begin
try
//defaults
result:='';
//get
if (x<>'') then
   begin
   for p:=length(x) downto 1 do
   begin
   if (strcopy1(x,p,1)='/') or (strcopy1(x,p,1)='\') then break
   else if (strcopy1(x,p,1)='.') then
      begin
      result:=strcopy1(x,p+1,length(x));
      break
      end;
   end;//p
   end;
except;end;
end;
//## low__extractfileext2 ##
function low__extractfileext2(x,xdefext:string;xuppercase:boolean):string;//12apr2021
begin
try
result:=low__udv(low__extractfileext(x),xdefext);
if xuppercase then result:=low__uppercase(result);
except;end;
end;
//## low__extractfileext3 ##
function low__extractfileext3(x,xdefext:string):string;//lowercase version - 15feb2022
begin
try;result:=low__lowercase(low__udv(low__extractfileext(x),xdefext));except;end;
end;
//## low__extractfilepath ##
function low__extractfilepath(x:string):string;//04apr2021
var
   p:longint;
begin
try
//defaults
result:='';
//get
if (x<>'') then
   begin
   for p:=length(x) downto 1 do if (strcopy1(x,p,1)='/') or (strcopy1(x,p,1)='\') then
      begin
      result:=strcopy1(x,1,p);
      break;
      end;
   end;
except;end;
end;
//## low__extractfilename ##
function low__extractfilename(x:string):string;//05apr2021
var
   p:longint;
begin
try
//defaults
result:=x;//allow default passthru -> this allows for instances with ONLY a filename present e.g. "aaaa.bcs"
//get
if (x<>'') then
   begin
   for p:=length(x) downto 1 do if (strcopy1(x,p,1)='/') or (strcopy1(x,p,1)='\') then
      begin
      result:=strcopy1(x,p+1,length(x));
      break;
      end;
   end;
except;end;
end;
//## low__renamefile ##
function low__renamefile(s,d:string):boolean;//local only, soft check - 27nov2016
begin
try
//defaults
result:=false;
if (s='') or (d='') then exit;
//hack check
if hack_dangerous_filepath_deny_mask(s) then exit;
if hack_dangerous_filepath_deny_mask(d) then exit;
//collision check
if low__comparetext(s,d) then
   begin
   result:=true;
   exit;
   end;
//get - Delphi renamefile
if low__fileexists(s) and (not low__fileexists(d)) then result:=sysutils.renamefile(s,d);
except;end;
end;
//## low__shortfile ##
function low__shortfile(xlongfilename:string):string;//translate long filenames to short filename, using MS api, for "MCI playback of filenames with 125+c" - 23FEB2008
var//Note: works only for existing filenames - short names accessed from disk system
  z:string;
  zlen:integer;
begin
try
//defaults
result:=xlongfilename;
//get
setlength(z,max_path);
zlen:=getshortpathname(pchar(xlongfilename),pchar(z),max_path-1);
if (zlen>=1) then
   begin
   setlength(z,zlen);
   result:=z;
   end;
except;end;
end;
//## low__makerelative ##
function low__makerelative(xfilename,xauthoritiveFilenameORfolder:string):string;//20mar2022
var
   str1,xroot,v:string;
   p:longint;
   xonce:boolean;
begin
try
{
Example:
r:='c:\temp\f\1\2\z.m3u';
s:='c:\temp\a\b\c.mid';
d:=low__makerelative(s,r);
d:="..\..\..\temp\a\b\c.mid"
//debug code for testing:
showbasic('-- make relative --'+rcode+
'r: '+r+'<<'+rcode+
's: '+s+'<<'+rcode+
'd: '+d+'<<'+rcode+
}//yyyy

//defaults
result:=xfilename;
xroot:=low__extractfilepath(xauthoritiveFilenameORfolder);
//check
if (strcopy1(xroot,2,2)<>':\') and (strcopy1(xroot,2,2)<>':/') then exit;//must be a local drive
if not low__comparetext(strcopy1(result,1,3),strcopy1(xroot,1,3)) then exit;//must be on same drive
//get
if low__comparetext(xroot,strcopy1(result,1,length(xroot))) then strdel1(result,1,length(xroot))
else
   begin//xfilename is on same drive BUT in another folder structure from the xroot e.g. "xfilename=d:\temp\music\1.mid" and "xroot=d:\temp2\mymusic\" so "result=..\..\temp\music\1.mid"
   //get -> count down through root's subfolders till we match that of the xfilename
   str1:='';
   xonce:=true;
   for p:=length(xroot) downto 1 do
   begin
   if (xroot[p-1+stroffset]='\') or (xroot[p-1+stroffset]='/') then
      begin
      if not xonce then str1:=str1+'..\';
      if low__comparetext(strcopy1(xroot,1,p),strcopy1(result,1,p)) then
         begin
         result:=str1+strcopy1(result,p+1,length(result));
         break;
         end;
      if xonce then xonce:=false;
      end;
   end;
   end;
except;end;
end;
//## low__readrelative ##
function low__readrelative(xfilename,xauthoritiveFilenameORfolder:string):string;//fixed 31may2022, 20mar2022
var
   xroot:string;
   xonce:boolean;
   xcount,xcount2,p:longint;
begin
try
//defaults
result:=xfilename;
//check
xroot:=low__extractfilepath(xauthoritiveFilenameORfolder);
if (strcopy1(xroot,2,2)<>':\') and (strcopy1(xroot,2,2)<>':/') then exit;//must be a local drive
//special check
if (strcopy1(xfilename,1,3)<>'..\') then//critical fix - 31may2022
   begin
   if (strcopy1(xfilename,2,2)<>':\') and (strcopy1(xfilename,2,2)<>':/') then result:=xroot+xfilename;
   exit;
   end;
//count
xcount:=0;
xcount2:=0;
for p:=1 to length(result) do
begin
if (p>=3) and ((result[p-1+stroffset]='\') or (result[p-1+stroffset]='/')) and ( (strcopy1(result,p-2,3)='..\') or (strcopy1(result,p-2,3)='../') ) then inc(xcount);
end;//p
//get
if (xcount>=1) then
   begin
   xonce:=true;
   for p:=length(xroot) downto 1 do
   begin
   if (xroot[p-1+stroffset]='\') or (xroot[p-1+stroffset]='/') then
      begin
      if not xonce then
         begin
         inc(xcount2);
         if (xcount=xcount2) then
            begin
            result:=strcopy1(xroot,1,p)+strcopy1(result,xcount*3+1,length(result));
            break;
            end;
         end;
      if xonce then xonce:=false;
      end;
   end;//p
   end;
except;end;
end;
//## low__fileexists ##
function low__fileexists(x:string):boolean;//04apr2021, 15mar2020, 19may2019
begin//soft check via low__driveexists
try
//dk support
if dk_havescope(x) then
   begin
   result:=dk_fileexists(x);
   exit;
   end;
//local file
result:=(x<>'') and low__local(x) and low__driveexists(x) and fileexists(x);
except;end;
end;
//## low__filesize ##
function low__filesize(x:string):longint;//19dec2021
var
   a:tfilestream;
begin
try
//defaults
result:=-1;
//check
if (x='') or (x[0+stroffset]='@') then exit;
//hack check
if hack_dangerous_filepath_deny_mask(x) then exit;
//check
if not low__fileexists(x) then exit;
//get
a:=nil;
a:=createfilestream(x,fmOpenRead+fmShareDenyNone);
if (a<>nil) and (a.handle<>0) then result:=a.size;//fixed - 27sep2022
except;end;
try;freeobj(@a);except;end;
end;
//## low__filedateb ##
function low__filedateb(x:string):tdatetime;//27jan2022
begin
try;low__filedate(x,result);except;end;
end;
//## low__filedate ##
function low__filedate(x:string;var xdate:tdatetime):boolean;//27jan2022
label
   skipend;
var
   a:tfilestream;
   b:tbyhandlefileinformation;
   int1:longint;
begin
try
//defaults
result:=false;
xdate:=0;
a:=nil;

//check
if (x='') or (x[0+stroffset]='@') then goto skipend;

//hack check
if hack_dangerous_filepath_deny_mask(x) then goto skipend;

//dk support -> built-in system disk
if dk_havescope(x) then
   begin
   if dk_find(x,false,int1) and zzok(sysdisk_data[int1],7023) then
      begin
      xdate:=sysdisk_date[int1];
      result:=true;//ok
      end;
   goto skipend;
   end;

//get
if not low__fileexists(x) then goto skipend;
//.open
a:=createfilestream(x,fmOpenRead+fmShareDenyNone);
if (a<>nil) and (a.handle<>0) and getfileinformationbyhandle(a.handle,b) then
   begin
   xdate:=low__fromfiletime(b.ftLastWriteTime);
   result:=true;//ok
   end;

skipend:
except;end;
try;freeobj(@a);except;end;
end;
//## low__remfile ##
function low__remfile(x:string):boolean;
begin
try
//defaults
result:=false;
//hack check
if hack_dangerous_filepath_deny_mask(x) then exit;

//dk support
if dk_havescope(x) then
   begin
   result:=dk_remfile(x);
   exit;
   end;

//ok - local file
result:=true;
if not low__fileexists(x) then exit;
//error
result:=false;
try;low__filesetattr(x,0);except;end;
try;deletefile(pchar(x));except;end;
//return result
result:=not low__fileexists(x);
except;end;
end;
//## low__filesetattr ##
procedure low__filesetattr(x:string;xval:longint);
begin
try
{$ifdef D3}
if dk_havescope(x) then exit;
filesetattr(x,xval);
{$endif}
{$ifdef D10}
//D10: No support yet
{$endif}
except;end;
end;
//## low__copyfile ##
function low__copyfile(sf,df:string;var e:string):boolean;
label//Warning: Only good for SMALL files - 29aug2021
   skipend;
var
   xdata:tstr8;
begin
try
//defaults
result:=false;
xdata:=nil;
e:=gecTaskfailed;
//check
if low__comparetext(sf,df) then
   begin
   result:=true;
   goto skipend;
   end;
//check
if not low__fileexists(sf) then
   begin
   e:=gecFilenotfound;
   goto skipend;
   end;
//get
xdata:=bnew;
if not low__fromfile(sf,xdata,e) then goto skipend;
if not low__tofile(df,xdata,e) then goto skipend;
//successful
result:=true;
skipend:
except;end;
try;bfree(xdata);except;end;
end;
//## low__tofilestr ##
function low__tofilestr(x,xdata:string;var e:string):boolean;//fast and basic low-level
var
   a:tstr8;
begin
try
//defaults
result:=false;
a:=nil;
a:=bnew;
//get
a.text:=xdata;
result:=low__tofile(x,a,e);
except;end;
try;bfree(a);except;end;
end;
//## low__tofile ##
function low__tofile(x:string;xdata:tstr8;var e:string):boolean;//27sep2022, fast and basic low-level
label
   skipend;
const
   amax=32767;
var
   a:array[0..amax] of byte;
   ylen,p,ap,cc:longint;
   b:tfilestream;
   ref64b:comp;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
b:=nil;
//check
if zznil(xdata,2180) then exit;
block(xdata);
if (x='') or (x[0+stroffset]='@') then
   begin
   e:=gecBadfilename;
   goto skipend;
   end;
//hack check
if hack_dangerous_filepath_deny_mask(x) then
   begin
   e:=gecTaskfailed;
   goto skipend;
   end;

//dk support
if dk_havescope(x) then
   begin
   result:=dk_tofile(x,xdata,e);
   goto skipend;
   end;

//init
ylen:=xdata.count;
//get
//.delete
e:=gecFileInUse;
if not low__remfile(x) then goto skipend;
//.folder
if not low__makefolder(low__extractfilepath(x)) then goto skipend;//13aug2019
//.open
e:=gecFileInUse;
b:=createfilestream(x,fmCreate);
if (b=nil) or (b.handle=0) then goto skipend;//fixed - 27sep2022
//.size
e:=gecOutOfDiskSpace;
b.size:=yLen;
b.position:=0;
p:=1;
ap:=0;
ref64b:=ms64;
cc:=0;
sysstatus(ref64b,sysstatus_tofile,'Saving'+#9+low__percentage64str(1,1,true));
//.write
if (ylen>=1) then
   begin
   for p:=1 to ylen do
   begin
   //.fill
   a[ap]:=xdata.pbytes[p-1];
   //.store
   if (ap>=amax) or (p=yLEN) then
      begin
      if ((ap+1)<>b.write(a,(ap+1))) then goto skipend;
      ap:=-1;
      app__fasttimer;
      end;
   //.inc
   inc(ap);
   //.system status - 04oct2022
   inc(cc);
   if (cc>=50) then
      begin
      if sysstatus(ref64b,sysstatus_tofile,'Saving'+#9+low__percentage64str(p,ylen,true)) then
         begin
         e:=gecTaskcancelled;
         goto skipend;
         end;
      cc:=0;
      end;
   end;//p
   end;
//successful
result:=true;
skipend:
except;end;
try
freeobj(@b);
if not result then low__remfile(x);
bunlockautofree(xdata);//16aug2020
except;end;
end;
//## low__tofileappend ##
function low__tofileappend(x:string;xdata:tstr8;var xpersistenthandler:tfilestream;var e:string):boolean;//20jun2021 - fast and basic low-level
begin
try;result:=low__tofileappend2(x,maxint,xdata,xpersistenthandler,e);except;end;
end;
//## low__tofileappend2 ##
function low__tofileappend2(x:string;xpos:longint;xdata:tstr8;var xpersistenthandler:tfilestream;var e:string):boolean;//20jun2021 - fast and basic low-level
label
   skipend;
const
   amax=32767;
var
   a:array[0..amax] of byte;
   xsize,ylen,p,ap:longint;
   b:tfilestream;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
b:=nil;
//check
if zznil(xdata,2180) then exit;
block(xdata);
if (x='') or (x[0+stroffset]='@') then
   begin
   e:=gecBadfilename;
   goto skipend;
   end;
//hack check
if hack_dangerous_filepath_deny_mask(x) then
   begin
   e:=gecTaskfailed;
   goto skipend;
   end;
//stop -> autoclose
if (xpersistenthandler<>nil) and (xdata.len<=0) then
   begin
   result:=true;
   freeobj(@xpersistenthandler);
   goto skipend;
   end;
//dk support
if dk_havescope(x) then//not supported yet
   begin
//   result:=dk_tofile(x,xdata,e);
   result:=false;
   goto skipend;
   end;

//init
ylen:=xdata.count;
//get
//.delete
e:=gecFileInUse;
if (xpersistenthandler=nil) then
   begin
   if not low__remfile(x) then goto skipend;
   //.folder
   if not low__makefolder(low__extractfilepath(x)) then goto skipend;//13aug2019
   //.open
   e:=gecFileInUse;
   xpersistenthandler:=createfilestream(x,fmCreate);
   end;
//.size
e:=gecOutOfDiskSpace;
b:=xpersistenthandler;
if (b=nil) or (b.handle=0) then
   begin
   e:=gecFileinuse;
   goto skipend;//fixed - 27sep2022
   end;
xpos:=frcrange(xpos,0,b.size);
b.size:=frcmin(xpos+ylen,b.size);
b.position:=xpos;
//.process
p:=1;
ap:=0;
//.write
if (ylen>=1) then
   begin
   for p:=1 to ylen do
   begin
   //.fill
   a[ap]:=xdata.pbytes[p-1];
   //.store
   if (ap>=amax) or (p=yLEN) then
      begin
      if ((ap+1)<>b.write(a,(ap+1))) then goto skipend;
      ap:=-1;
      app__fasttimer;
      end;
   //.inc
   inc(ap);
   end;//p
   end;
//successful
result:=true;
skipend:
except;end;
try
if not result then
   begin
   freeobj(@xpersistenthandler);
   low__remfile(x);
   end;
bunlockautofree(xdata);//16aug2020
except;end;
end;
//## low__tofileappend3 ##
function low__tofileappend3(x:string;xpos:longint;xdata:tstr8;var e:string):boolean;//19feb2022
var//Easier to use but is NOT persistent -> file must be opened and closed each time more data is appended
   a:tfilestream;
begin
try
//defaults
result:=false;
a:=nil;
//get
case low__fileexists(x) of
true:begin
   a:=createfilestream(x,fmOpenReadWrite+fmShareDenyWrite);
   result:=low__tofileappend2(x,xpos,xdata,a,e);
   end;
false:result:=low__tofileappend2(x,xpos,xdata,a,e);
end;//case
except;end;
try;freeobj(@a);except;end;
end;
//## low__fromfile ##
function low__fromfile(x:string;xdata:tstr8;var e:string):boolean;
var
   _filesize,_from:longint;
begin
try;_from:=0;result:=low__fromfileb(x,xdata,e,_filesize,_from,maxint);except;end;
end;
//## low__fromfilestrb ##
function low__fromfilestrb(x:string;var e:string):string;//30mar2022
begin
try;low__fromfilestr(x,result,e);except;end;
end;
//## low__fromfilestr ##
function low__fromfilestr(x:string;var xdata,e:string):boolean;
var
   a:tstr8;
begin
try
//defaults
result:=false;
xdata:='';
a:=nil;
//get
a:=bnew;
result:=low__fromfile(x,a,e);
if result then xdata:=a.text;
except;end;
try;bfree(a);except;end;
end;
//## low__drivelist ##
function low__drivelist:tdrivelist;
var
   xdrivelist:set of 0..25;
   p:longint;
begin
try
//defaults
for p:=0 to high(tdrivelist) do result[p]:=false;
//get
longint(xdrivelist):=getlogicaldrives;
for p:=0 to 25 do if (p in xdrivelist) then result[p]:=true;
except;end;
end;
//## low__safedate ##
function low__safedate(x:tdatetime):tdatetime;
begin
try;result:=x;if (result<-693593) then result:=-693593 else if (result>9000000) then result:=9000000;except;end;
end;
//## low__decodedate2 ##
procedure low__decodedate2(x:tdatetime;var y,m,d:word);//safe range
begin
try;decodedate(low__safedate(x),y,m,d);except;end;
end;
//## low__decodetime2 ##
procedure low__decodetime2(x:tdatetime;var h,min,s,ms:word);//safe range
begin
try;decodetime(low__safedate(x),h,min,s,ms);except;end;
end;
//## low__encodedate2 ##
function low__encodedate2(y,m,d:word):tdatetime;
begin
try;result:=encodedate(y,m,d);except;end;
end;
//## low__encodetime2 ##
function low__encodetime2(h,min,s,ms:word):tdatetime;
begin
try;result:=encodetime(h,min,s,ms);except;end;
end;
//## low__dayofweek1 ##
function low__dayofweek1(x:tdatetime):longint;
begin
try;result:=frcrange(dayofweek(x),1,7);except;end;
end;
//## low__dayofweek0 ##
function low__dayofweek0(x:tdatetime):longint;
begin
try;result:=frcrange(dayofweek(x)-1,0,6);except;end;
end;
//## low__dayofweekstr ##
function low__dayofweekstr(x:tdatetime;xfullname:boolean):string;
begin
try;result:=low__weekday1(low__dayofweek1(x),xfullname);except;end;
end;
//## low__month1 ##
function low__month1(x:longint;xfullname:boolean):string;//08mar2022
begin
try;result:=low__month0(x-1,xfullname);except;end;
end;
//## low__month0 ##
function low__month0(x:longint;xfullname:boolean):string;//08mar2022
begin//note: x=1..12
try
//range
x:=frcrange(x,0,11);
case xfullname of
true:result:=system_month[x+1];
false:result:=system_month_abrv[x+1];
end;
except;end;
end;
//## low__weekday1 ##
function low__weekday1(x:longint;xfullname:boolean):string;//08mar2022
begin//note: x=1..7
try;result:=low__weekday0(x-1,xfullname);except;end;
end;
//## low__weekday0 ##
function low__weekday0(x:longint;xfullname:boolean):string;//08mar2022
begin
try
//range
x:=frcrange(x,0,11);
case xfullname of
true:result:=system_dayOfweek[x+1];
false:result:=system_dayOfweek_abrv[x+1];//0..11 -> 1..12
end;
except;end;
end;
//## low__datestr ##
function low__datestr(xdate:tdatetime;xformat:longint;xfullname:boolean):string;//09mar2022
var
   y,m,d:word;
begin
try
result:='';
low__decodedate2(xdate,y,m,d);
result:=low__date1(y,m,d,xformat,xfullname);
except;end;
end;
//## low__date1 ##
function low__date1(xyear,xmonth1,xday1:longint;xformat:longint;xfullname:boolean):string;
begin
try;result:=low__date0(xyear,xmonth1-1,xday1-1,xformat,xfullname);except;end;
end;
//## low__date0 ##
function low__date0(xyear,xmonth,xday:longint;xformat:longint;xfullname:boolean):string;
var
   xmonthstr,xth:string;
begin
try
//defaults
result:='';
//range
xday:=1+frcrange(xday,0,30);
xmonth:=1+frcrange(xmonth,0,11);
xmonthstr:=low__month1(xmonth,xfullname);
//get
case xday of
1,21,31:xth:='st';
2,22:xth:='nd';
3,23:xth:='rd';
else xth:='th';
end;
//set
case frcrange(xformat,0,3) of
1:result:=low__digpad11(xday,1)+xth+#32+xmonthstr+low__insstr(#32+low__digpad11(xyear,4),xyear>=0);
2:result:=xmonthstr+#32+low__digpad11(xday,1)+low__insstr(', '+low__digpad11(xyear,4),xyear>=0);
3:result:=xmonthstr+#32+low__digpad11(xday,1)+xth+low__insstr(', '+low__digpad11(xyear,4),xyear>=0);
else result:=low__digpad11(xday,1)+#32+xmonthstr+low__insstr(#32+low__digpad11(xyear,4),xyear>=0);
end;
except;end;
end;
//## low__time0 ##
function low__time0(xhour,xminute:longint;xsep,xsep2:string;xuppercase,xshow24:boolean):string;
var
   dPM:boolean;
   xampm:string;
begin
try
//defaults
result:='';
//range
xhour:=frcrange(xhour,0,23);
xminute:=frcrange(xminute,0,59);
xsep:=low__udv(xsep,':');
xsep2:=low__udv(xsep2,#32);
//get
case xshow24 of
true:result:=low__digpad11(xhour,2)+xsep+low__digpad11(xminute,2);
false:begin
   //get
   dPM:=(xhour>=12);
   case xhour of
   13..23:dec(xhour,12);
   24:xhour:=12;//never used - 28feb2022
   0:xhour:=12;//"0:00" -> "12:00am"
   end;
   xampm:=low__aorbstr('am','pm',dPM);
   if xuppercase then xampm:=low__uppercase(xampm);
   //set
   result:=low__digpad11(xhour,1)+xsep+low__digpad11(xminute,2)+xsep2+xampm;
   end;
end;//case
except;end;
end;
//## low__hour0 ##
function low__hour0(xhour:longint;xsep:string;xuppercase,xshowAMPM,xshow24:boolean):string;
var
   dPM:boolean;
   xampm:string;
begin
try
//defaults
result:='';
//range
xhour:=frcrange(xhour,0,23);
xsep:=low__udv(xsep,#32);
//get
case xshow24 of
true:result:=low__digpad11(xhour,2);
false:begin
   //get
   dPM:=(xhour>=12);
   case xhour of
   13..23:dec(xhour,12);
   24:xhour:=12;//never used - 28feb2022
   0:xhour:=12;//"0:00" -> "12:00am"
   end;
   if xshowAMPM then
      begin
      xampm:=low__aorbstr('am','pm',dPM);
      if xuppercase then xampm:=low__uppercase(xampm);
      end
   else xampm:='';
   //set
   result:=low__digpad11(xhour,1)+low__insstr(xsep+xampm,xshowAMPM);
   end;
end;//case
except;end;
end;
//## low__fromfileb ##
function low__fromfileb(x:string;xdata:tstr8;var e:string;var _filesize,_from:longint;_size:longint):boolean;//20-OCT-2006
label//Speed: ~5.9Mb/s = 137% faster, 03-OCT-2004
     skipend;
const
   amax=32767;
var
   a:array[0..amax] of byte;
   int1,i,p,ac,cc:longint;
   b:tfilestream;
   ref64b:comp;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
b:=nil;
_filesize:=0;
//check
if zznil(xdata,2181) then exit;
block(xdata);
if (x='') or (x[0+stroffset]='@') then
   begin
   e:=gecBadfilename;
   goto skipend;
   end;
//hack check
if hack_dangerous_filepath_deny_mask(x) then
   begin
   e:=gecTaskfailed;
   goto skipend;
   end;

//init
xdata.clear;

//dk support -> built-in system disk
if dk_havescope(x) then
   begin
   //find
   if not dk_find(x,false,int1) then
      begin
      e:=gecFilenotfound;
      goto skipend;
      end;
   //get
   if zzok(sysdisk_data[int1],7023) then
      begin
      _filesize:=sysdisk_data[int1].len;
      if not xdata.add3(sysdisk_data[int1],_from,_size) then
         begin
         e:=gecTaskfailed;
         goto skipend;
         end;
      end;
   //succesful
   result:=true;
   goto skipend;
   end;

//get
//.check
e:=gecFileNotFound;
if not low__fileexists(x) then goto skipend;
//.open
e:=gecFileInUse;
b:=createfilestream(x,fmOpenRead+fmShareDenyNone);
if (b=nil) or (b.handle=0) then goto skipend;//fixed - 27sep2022
_filesize:=b.size;
//._from
if (_from<0) then _from:=0
else if (_from>=b.size) then
   begin
   result:=true;
   goto skipend;
   end;
b.position:=_from;
//.size
if (_size=0) then//0=read NO data
   begin
   result:=true;
   goto skipend;
   end
else if (_size<0) then _size:=b.size//-X..-1=read ALL data
else if (_size>b.size) then _size:=b.size;//1..X=read SPECIFIED data
e:=gecOutOfMemory;
xdata.setlen(_size);
i:=0;
ref64b:=ms64;
cc:=0;
sysstatus(ref64b,sysstatus_fromfile,'Loading'+#9+low__percentage64str(1,1,true));
//.write
while true do
begin
//.get
ac:=b.read(a,amax+1);
//.check
if (ac=0) then break;
//.fill
for p:=0 to frcmax(ac-1,_size-i-1) do//tested and passed - 17may2021
begin
inc(i);
xdata.pbytes[i-1]:=a[p];
end;//p
//.system status - 04oct2022
inc(cc);
if (cc>=50) then
   begin
   if sysstatus(ref64b,sysstatus_fromfile,'Loading'+#9+low__percentage64str(frcmin(b.position-_from,0),_size,true)) then
      begin
      e:=gecTaskcancelled;
      goto skipend;
      end;
   cc:=0;
   end;
//.quit
if (i>=_size) then break;

app__fasttimer;
end;//loop
//successful
inc(_from,i);
if (b.size=_size) and (_from=0) then result:=(i=_size)
else
   begin
   if (i<>_size) then xdata.setlen(i);
   result:=(i>=1);
   end;
skipend:
except;end;
try
if (not result) and (xdata<>nil) then xdata.clear;
freeobj(@b);
bunlockautofree(xdata);//16aug2020
except;end;
end;
//## low__fromfiletime ##
function low__fromfiletime(x:tfiletime):tdatetime;
var
   a:longint;
   c:tfiletime;
begin
try
//defaults
result:=now;
//get
filetimetolocalfiletime(x,c);
if filetimetodosdatetime(c,longrec(a).hi,longrec(a).lo) then result:=filedatetodatetime(a) else result:=now;
except;end;
end;
//## low__folderexists ##
function low__folderexists(x:string):boolean;//15mar2020, 14dec2016
begin//soft check via low__driveexists
try;result:=(x<>'') and low__local(x) and low__driveexists(x) and directoryexists(x);except;end;
end;
//## low__makefolder ##
function low__makefolder(x:string):boolean;//15mar2020, 19may2019
begin//soft check via low__driveexists
try
result:=false;
//check
if (x='') then exit else x:=asfolder(x);
//get
if low__local(x) and low__driveexists(x) then
   begin
   result:=low__folderexists(x);
   if not result then
      begin
      forcedirectories(x);
      result:=low__folderexists(x);
      end;
   end;
except;end;
end;
//.file list support -----------------------------------------------------------
//## low__navinfo ##
function low__navinfo(x:tstr8;var xnavcount,xfoldercount,xfilecount,xtotalcount:longint):boolean;
label
   skipend;
var
   cmp1,cmp2:comp;
   xtep:longint;
   str1,str2:string;
begin
try
//defaults
result:=false;
xnavcount    :=0;
xfoldercount :=0;
xfilecount   :=0;
xtotalcount  :=0;
//get
result:=low__nav(x,'info',0,xnavcount,xtep,xfoldercount,xfilecount,xtotalcount,cmp1,cmp2,str1,str2);
except;end;
try
if not result then
   begin
   xnavcount    :=0;
   xfoldercount :=0;
   xfilecount   :=0;
   xtotalcount  :=0;
   end;
except;end;
end;
//## low__navcan ##
function low__navcan(x:tstr8;var xsortname,xsortsize,xsortdate,xsorttype:boolean):boolean;
label
   skipend;
var
   xtep,int1,int2,int3,int4:longint;
   cmp1,cmp2:comp;
   str1,str2:string;
begin
try
//defaults
result:=false;
xsortname    :=false;
xsortsize    :=false;
xsortdate    :=false;
xsorttype    :=false;;
//get
result:=low__nav(x,'can',0,int1,xtep,int2,int3,int4,cmp1,cmp2,str1,str2);
if result then
   begin
   xsortname    :=(int1=1);
   xsortsize    :=(int2=1);
   xsortdate    :=(int3=1);
   xsorttype    :=(int4=1);
   end;
except;end;
end;
//## low__navinit ##
function low__navinit(x:tstr8):boolean;
var
   xtep,int1,int2,int3,int4:longint;
   cmp1,cmp2:comp;
   str1,str2:string;
begin
try;result:=low__nav(x,'init',0,int1,xtep,int2,int3,int4,cmp1,cmp2,str1,str2);except;end;
end;
//## low__navadd ##
function low__navadd(x:tstr8;xstyle,xtep:longint;xsize:comp;xname,xlabel:string):boolean;
begin
try;result:=low__navadd2(x,xstyle,xtep,xsize,2000,1,1,0,0,0,xname,xlabel);except;end;
end;
//## low__navadd2 ##
function low__navadd2(x:tstr8;xstyle,xtep:longint;xsize:comp;xyear,xmonth,xday,xhr,xmin,xsec:longint;xname,xlabel:string):boolean;
var
   a:tcmp8;
   int1,int2,int3:longint;
begin
try
//defaults
result:=false;
//range
xyear:=frcrange(xyear,0,50000);
xmonth:=frcrange(xmonth,1,12);
xday:=frcrange(xday,1,31);
xhr:=frcrange(xhr,0,23);
xmin:=frcrange(xmin,0,59);
xsec:=frcrange(xsec,0,59);
//encode time
a.ints[0]:= xsec + (xmin*60) + (xhr*3600);
//encode date
a.ints[1]:=xmonth + (xday*13) + (xyear*416);
//get
result:=low__nav(x,'add',0,xstyle,xtep,int1,int2,int3,xsize,a.val,xname,xlabel);
except;end;
end;
//## low__navsort ##
function low__navsort(x:tstr8;xsortstyle:longint):boolean;
var
   xtep,int2,int3,int4:longint;
   cmp1,cmp2:comp;
   str1,str2:string;
begin
try;result:=low__nav(x,'sort',0,xsortstyle,xtep,int2,int3,int4,cmp1,cmp2,str1,str2);except;end;
end;
//## low__navend ##
function low__navend(x:tstr8;xsortstyle:longint):boolean;
var
   xtep,int2,int3,int4:longint;
   cmp1,cmp2:comp;
   str1,str2:string;
begin
try;result:=low__nav(x,'end',0,xsortstyle,xtep,int2,int3,int4,cmp1,cmp2,str1,str2);except;end;
end;
//## low__navget ##
function low__navget(x:tstr8;xindex:longint;var xstyle,xtep:longint;var xsize:comp;var xname,xlabel:string):boolean;
var
   xyear,xmonth,xday,xhr,xmin,xsec:longint;
begin
try;result:=low__navget2(x,xindex,xstyle,xtep,xsize,xyear,xmonth,xday,xhr,xmin,xsec,xname,xlabel);except;end;
end;
//## low__navget2 ##
function low__navget2(x:tstr8;xindex:longint;var xstyle,xtep:longint;var xsize:comp;var xyear,xmonth,xday,xhr,xmin,xsec:longint;var xname,xlabel:string):boolean;
var
   int1,int2,int3,int4:longint;
   a:tcmp8;
begin
try
//defaults
result:=false;
xname:='';
xlabel:='';
xstyle:=0;
xtep:=tepNone;
xsize:=0;
xyear:=2000;
xmonth:=1;
xday:=1;
xhr:=0;
xmin:=0;
xsec:=0;
int2:=0;
int3:=0;
int4:=0;
//get
result:=low__nav(x,'get', xindex,xstyle,xtep,int2,int3,int4,xsize,a.val,xname,xlabel);
if result then
   begin
   //decode time
   int1:=a.ints[0];
   //.hr
   xhr:=frcrange(int1 div 3600,0,23);
   dec(int1,xhr*3600);
   //.min
   xmin:=frcrange(int1 div 60,0,59);
   dec(int1,xmin*60);
   //.sec
   xsec:=frcrange(int1,0,59);

   //decode date
   int1:=a.ints[1];
   //.year
   xyear:=frcrange(int1 div 416,0,50000);
   dec(int1,xyear*416);
   //.day
   xday:=frcrange(int1 div 13,1,31);
   dec(int1,xday*13);
   //.month
   xmonth:=frcrange(int1,1,12);
   end;
except;end;
end;
//## low__navlist ##
function low__navlist(x:tstr8;xsortstyle:longint;xfolder,xmasklist,xemasklist:string;xnav,xfolders,xfiles:boolean):boolean;//04oct2020
begin
try;result:=low__navlist2(0,x,xsortstyle,xfolder,xmasklist,xemasklist,xnav,xfolders,xfiles);except;end;
end;
//## low__navlist2 ##
function low__navlist2(xownerid:longint;x:tstr8;xsortstyle:longint;xfolder,xmasklist,xemasklist:string;xnav,xfolders,xfiles:boolean):boolean;//04oct2020
begin
try;result:=low__navlist3(xownerid,x,xsortstyle,xfolder,xmasklist,xemasklist,xnav,xfolders,xfiles,mincomp,maxcomp,'');except;end;
end;
//## low__navlist3 ##
function low__navlist3(xownerid:longint;x:tstr8;xsortstyle:longint;xfolder,xmasklist,xemasklist:string;xnav,xfolders,xfiles:boolean;xminsize,xmaxsize:comp;xminmax_emasklist:string):boolean;//04oct2020
label
   skipend;
const
   xallfiles='*';
var
   lp,p,i,xyear,xmonth,xday,xhr,xmin,xsec:longint;
   xsize:comp;
   xrec:tsearchrec;
   str1,str2:string;
   systime:tsystemtime;
   bol1,xfindopen:boolean;
   //.dk support
   xoutname,xoutnameonly:string;
   xoutfolder,xoutfile:boolean;
   xoutdate:tdatetime;
   xpos,xoutsize:longint;
   xoutreadonly:boolean;
   //## xrootnav ##
   procedure xrootnav;
   label
      skipend;
   var
      a:tdrivelist;
      p:longint;
      v:string;
      //## xadd ##
      function xadd(xtep:longint;n,nlabel:string):boolean;
      begin
      result:=low__navadd2(x,nltSysfolder,xtep,0,0,0,0,0,0,0,n,nlabel);
      end;
      //## xaddfolder ##
      function xaddfolder(n,nlabel:string):boolean;
      var
         xtep:longint;
      begin
      xtep:=low__foldertep2(xownerid,n);
      result:=low__navadd2(x,nltSysfolder,xtep,0,0,0,0,0,0,0,n,nlabel);
      end;
   begin
   //disk drives
   low__navadd2(x,nltTitle,tepNone,0,0,0,0,0,0,0,'Drives','');
   a:=low__drivelist;
   for p:=0 to high(a) do if a[p] and (not xaddfolder(char(65+p)+':\',low__drivelabel(char(65+p),true))) then goto skipend;
   if sysdisk_inuse then xaddfolder(sysdisk_char+':\',low__drivelabel(sysdisk_char,true));//04apr2021
   //system folders
   low__navadd2(x,nltTitle,tepNone,0,0,0,0,0,0,0,'Special Folders','');
   xaddfolder(low__platroot,'');
   xaddfolder(low__platfolder(''),'');
   xaddfolder(low__platfolder('Schemes'),'');
   xaddfolder(low__platfolder('Settings'),'');
   xaddfolder(windesktop,'');
   xaddfolder(winstartmenu,'');
   xaddfolder(winprograms,'');
   xaddfolder(low__plattemp,'Portable Temp');//17may2022
   xaddfolder(wintemp,'Temp');
   xaddfolder(wincommontemp,'Common Temp');//05apr2021
   skipend:
   end;
   //## xfindsize ##
   function xfindsize:boolean;//pass-thru
   var
      int1:longint;
   begin
   result:=true;
   int1:=xrec.size;
   if (int1<0) then int1:=maxint;
   xsize:=int1;
   end;
   //## xfinddate2 ##
   procedure xfinddate2(a:tdatetime);
   var
      y,m,d,h,min,s,ms:word;
   begin
   low__decodedate2(a,y,m,d);
   low__decodetime2(a,h,min,s,ms);
   //set
   xyear   :=y;
   xmonth  :=m;
   xday    :=d;
   xhr     :=h;
   xmin    :=min;
   xsec    :=s;
   end;
   //## xfinddate ##
   procedure xfinddate;
   begin
   xfinddate2(low__fromfiletime(xrec.finddata.ftLastWriteTime));
   end;
begin
try
//defaults
result:=false;
xfindopen:=false;
fillchar(xrec,sizeof(xrec),#0);//28sep2020
block(x);
//check
if zznil(x,2183) then goto skipend;
//init
if not low__navinit(x) then goto skipend;
if (not xfolders) and (not xfiles) then goto skipend;
if (xmasklist='') then xmasklist:=xallfiles;
low__reloadfastvars;
if (xownerid>=1) then tep__delall20(xownerid);//delete any previous images done by us - 06apr2021
if (xfolder='') then
   begin
   xrootnav;
   result:=true;
   goto skipend;
   end
else xfolder:=asfolder(xfolder);//28sep2020

//hack check
if hack_dangerous_filepath_allow_mask(xfolder) then goto skipend;
//get
//.top title -> leave empty -> host can fill it with information in realtime - 04oct2020
if xnav and xfolders and xfiles then
   begin
   low__navadd2(x,nltTitle,tepNone,0,0,0,0,0,0,0,'','');
   end;

//.add nav ---------------------------------------------------------------------
if xnav then
   begin
   //.home
   if not low__navadd2(x,nltNav,tepNone,0,0,0,0,0,0,0,'','') then goto skipend;//"Home"
   //.nav sets
   bol1:=true;
   lp:=1;
   for p:=1 to length(xfolder) do if (xfolder[p-1+stroffset]='\') or (xfolder[p-1+stroffset]='/') then
      begin
      str1:=strcopy1(xfolder,1,p);
      if bol1 then
         begin
         bol1:=false;
         str2:=low__drivelabel(str1,true);//show drive label for first item in nav list
         end
      else str2:='';
      if (str1<>'') and (not low__navadd2(x,nltNav,low__foldertep2(xownerid,str1),0,0,0,0,0,0,0,str1,str2)) then goto skipend;
      lp:=p+1;
      end;
   end;

//.dk support
if dk_havescope(xfolder) then
   begin
   //get
   xpos:=0;
   while true do
   begin
   if dk_findnext(xpos,xfolder,xfolders,xfiles,xoutname,xoutnameonly,xoutfolder,xoutfile,xoutdate,xoutsize,xoutreadonly) then
      begin
      //folder
      if xfolders and xoutfolder then
         begin
         xfinddate2(xoutdate);
         if not low__navadd2(x,nltFolder,low__foldertep2(xownerid,xoutname),xoutsize,xyear,xmonth,xday,xhr,xmin,xsec,xoutnameonly,'') then goto skipend;
         end
      //file
      else if xfiles and xoutfile and (((xoutsize>=xminsize) and (xoutsize<=xmaxsize)) or low__matchmasklistb(xoutnameonly,xminmax_emasklist)) and ( low__matchmasklistb(xoutnameonly,xmasklist) and ((xemasklist='') or (not low__matchmasklistb(xoutnameonly,xemasklist))) ) then
         begin
         xfinddate2(xoutdate);
         if not low__navadd2(x,nltFile,tepext(xoutnameonly),xoutsize,xyear,xmonth,xday,xhr,xmin,xsec,xoutnameonly,'') then goto skipend;
         end;
      end
   else break;//stop
   end;//loop
   //successful
   result:=true;
   goto skipend;
   end;

//.open
case xfolders of
true: i:=findfirst(xfolder+xallfiles,faReadOnly or faHidden or faSysFile or faDirectory or faArchive or faAnyFile,xrec);
false:i:=findfirst(xfolder+xallfiles,faReadOnly or faHidden or faSysFile or faArchive or faAnyFile,xrec);
end;//end of case
xfindopen:=(i=0);
while i=0 do
begin
//.skip system folders
if (xrec.name='.') or (xrec.name='..') then
   begin
   //nil
   end
//.add folder ------------------------------------------------------------------
else if faISfolder(xrec.attr) then
   begin
   if xfolders then
      begin
      //init
      xfindsize;
      xfinddate;
      //get
      if not low__navadd2(x,nltFolder,low__foldertep2(xownerid,asfoldernil(xfolder+xrec.name)),xsize,xyear,xmonth,xday,xhr,xmin,xsec,xrec.name,'') then goto skipend;
      end;
   end
//.add file --------------------------------------------------------------------
else
   begin
   if xfiles and xfindsize and (((xsize>=xminsize) and (xsize<=xmaxsize)) or low__matchmasklistb(xrec.name,xminmax_emasklist)) and ( low__matchmasklistb(xrec.name,xmasklist) and ((xemasklist='') or (not low__matchmasklistb(xrec.name,xemasklist))) ) then
      begin
      //init
      xfindsize;
      xfinddate;
      //get
      if not low__navadd2(x,nltFile,tepext(xrec.name),xsize,xyear,xmonth,xday,xhr,xmin,xsec,xrec.name,'') then goto skipend;
      end;
   end;
//.inc
i:=findnext(xrec);
end;//while
//successful
result:=true;
skipend:
except;end;
try;if xfindopen then findclose(xrec);except;end;
try
low__navend(x,xsortstyle);//finalise
bunlockautofree(x);
except;end;
end;
//## low__nav ##
function low__nav(x:tstr8;xcmd:string;xindex:longint;var xstyle,xtep,xval1,xval2,xval3:longint;var xsize,xdate:comp;var xname,xlabel:string):boolean;//04apr2021, 25mar2021, 20feb2021
label
   redo, skipend,skipdone;
const
   xmorespace    =500000;
   xhdrlen       =24;
   xdatasetsize  =25;//min.size - 06apr2021
   //counters
   xnavpos       =8;
   xfolderpos    =12;
   xfilepos      =16;
   xsortpos      =20;
var
   xnamelen,xlabellen,v1,v2,v3,di,p,int1,int2,int3,int4,int5,xcount:longint;
   xonce:boolean;
   //## xlen ##
   function xlen:longint;
   begin
   if zzok(x,7024) then result:=x.int4[4] else result:=0;
   if (result>x.datalen) then result:=x.datalen;
   end;
   //## xsetlen ##
   procedure xsetlen(xval:longint);
   begin
   if zzok(x,7025) then x.int4[4]:=frcmin(xval,xhdrlen);
   end;
   //## xinfo ##
   procedure xinfo(var xnavcount,xfoldercount,xfilecount,xtotalcount:longint);
   begin
   xnavcount:=frcmin(x.int4[xnavpos],0);//nav.count
   xfoldercount:=frcmin(x.int4[xfolderpos],0);//folder.count
   xfilecount:=frcmin(x.int4[xfilepos],0);//file.count
   xtotalcount:=xnavcount+xfoldercount+xfilecount;//total.count
   end;
   //## xsort ##
   function xsort(xsortstyle:longint):boolean;
   label
      skipend;
   var
      v1,v2,v3,xcount,int1,int2,int3,di,xfastlen:longint;
      a:tstr8;
      alist:pdllongint;
      //## xfindstyle ##
      function xfindstyle(xpos:longint;var xstyle:longint):boolean;
      var
         dlen:longint;
      begin
      //defaults
      result:=false;
      xstyle:=nltNav;
      //check dataset size
      if (xpos<0) or ((xpos+4)>xfastlen) then exit;
      dlen:=frcmin(x.int4[xpos],0);
      if (dlen<xdatasetsize) or ((xpos+dlen)>xfastlen) then exit;
      //read dataset
      inc(xpos,4);
      xstyle:=frcrange(x.byt1[xpos],0,nltMax);
      //successful
      result:=true;
      end;
      //## xfindvals ##
      function xfindvals(xpos:longint;var xstyle,xtep:longint;var xsize,xdate:comp;var xname,xlabel:string):boolean;
      var
         xnamelen,xlabellen,nlen,dlen:longint;
      begin
      //defaults
      result:=false;
      xstyle:=nltNav;
      xtep:=tepNone;
      xsize:=0;
      xdate:=0;
      xname:='';
      xlabel:='';
      //check dataset size
      if (xpos<0) or ((xpos+4)>xfastlen) then exit;
      dlen:=frcmin(x.int4[xpos],0);
      if (dlen<xdatasetsize) or ((xpos+dlen)>xfastlen) then exit;
      //read dataset
      inc(xpos,4);
      xstyle:=frcrange(x.byt1[xpos],0,nltMax); inc(xpos,1);
      xtep  :=x.int4[xpos]; inc(xpos,4);//06apr2021
      xsize :=x.cmp8[xpos]; inc(xpos,8);
      xdate :=x.cmp8[xpos]; inc(xpos,8);
      //namelen+name+label - 04apr2021
      nlen:=dlen-xdatasetsize;
      if (nlen>=1) then
         begin
         //namelen
         xnamelen:=frcmin(x.int4[xpos],0);
         inc(xpos,4);
         //name
         if (xnamelen>=1) then
            begin
            xname:=x.str[xpos,xnamelen];//zero-based
            inc(xpos,xnamelen);
            end;
         //label
         xlabellen:=nlen-4-xnamelen;
         if (xlabellen>=1) then
            begin
            xlabel:=x.str[xpos,xlabellen];//zero-based
            inc(xpos,xlabellen);
            end;
         end;
      //successful
      result:=true;
      end;
      //## xrev ##
      procedure xrev(s:tstr8);//25mar2021
      var
         d:tstr8;
         slist,dlist:pdllongint;
         xstyle,scount,p:Longint;
      begin
      try
      //defaults
      d:=nil;
      scount:=0;
      //check
      if (xcount<=0) or zznil(s,2185) then exit;
      //init
      d:=bnewlen(xcount*4);
      dlist:=d.pints4;
      slist:=s.pints4;
      //fill
      for p:=0 to (xcount-1) do dlist[p]:=slist[p];
      //write back to "s"
      //.nav - always at top -> never sort this
      for p:=0 to (xcount-1) do if xfindstyle(dlist[p],xstyle) and ((xstyle=nltNav) or (xstyle=nltSysfolder) or (xstyle=nltTitle)) then//nltTitle=25mar2021
         begin
         if (scount>=xcount) then break;
         slist[scount]:=dlist[p];
         inc(scount);
         end;
      //.all other items
      for p:=(xcount-1) downto 0 do if xfindstyle(dlist[p],xstyle) and (xstyle<>nltNav) and (xstyle<>nltSysFolder) and (xstyle<>nltTitle) then//nltTitle=25mar2021
         begin
         if (scount>=xcount) then break;
         slist[scount]:=dlist[p];
         inc(scount);
         end;
      except;end;
      try;bfree(d);except;end;
      end;
      //## xdatestr ##
      function xdatestr(v:comp):string;
      var
         a:tcmp8;
         p,int1,xhr,xmin,xsec,xyear,xmonth,xday:longint;
         str1:string;
      begin
      try
      //defaults
      result:='';
      //init
      a.val:=v;
      //decode time
      int1:=a.ints[0];
      //.hr
      xhr:=frcrange(int1 div 3600,0,23);
      dec(int1,xhr*3600);
      //.min
      xmin:=frcrange(int1 div 60,0,59);
      dec(int1,xmin*60);
      //.sec
      xsec:=frcrange(int1,0,59);

      //decode date
      int1:=a.ints[1];
      //.year
      xyear:=frcrange(int1 div 416,0,50000);
      dec(int1,xyear*416);
      //.day
      xday:=frcrange(int1 div 13,1,31);
      dec(int1,xday*13);
      //.month
      xmonth:=frcrange(int1,1,12);

      //get -> yyyyMMddHHmmSS - 01oct2020
      result:=low__digpad11(xyear,4)+low__digpad11(xmonth,2)+low__digpad11(xday,2)+low__digpad11(xhr,2)+low__digpad11(xmin,2)+low__digpad11(xsec,2);
      except;end;
      end;
      //## xsortname ##
      procedure xsortname(s:tstr8;ssortstyle:longint);
      label
         skipend;
      var
         a,d:tstr8;
         c:tdynamicstring;
         alist,slist,dlist:pdllongint;
         xstyle,xtep,acount,scount,p:longint;
         xsize,xdate:comp;
         xval:string;
         bol1,srev:boolean;
      begin
      try
      //defaults
      a:=nil;
      d:=nil;
      c:=nil;
      scount:=0;
      //check
      if (xcount<=0) or zznil(s,2186) then exit;
      //init
      srev:=(ssortstyle=nlAsisD) or (ssortstyle=nlNameD) or (ssortstyle=nlSizeD) or (ssortstyle=nlDateD) or (ssortstyle=nlTypeD);
      //.asis
      if (ssortstyle=nlAsis) or (ssortstyle=nlAsisD) then
         begin
         if srev then xrev(s);
         goto skipend;
         end;
      a:=bnewlen(xcount*4);
      d:=bnewlen(xcount*4);
      alist:=a.pints4;
      dlist:=d.pints4;
      slist:=s.pints4;
      c:=tdynamicstring.create;
      //fill
      for p:=0 to (xcount-1) do dlist[p]:=slist[p];

      //nav - always at top -> never sort this
      for p:=0 to (xcount-1) do if xfindstyle(dlist[p],xstyle) and ((xstyle=nltNav) or (xstyle=nltSysfolder) or (xstyle=nltTitle)) then
         begin
         if (scount>=xcount) then break;
         slist[scount]:=dlist[p];
         inc(scount);
         end;

      //folders
      c.clear;
      acount:=0;
      for p:=0 to (xcount-1) do if xfindvals(dlist[p],xstyle,xtep,xsize,xdate,xname,xlabel) and (xstyle=nltFolder) then
         begin
         if (acount>=xcount) then break;
         alist[acount]:=dlist[p];
         c.value[acount]:=low__lowercase(xname);
         inc(acount);
         end;
      //.sort
      if (acount>=1) then
         begin
         c.sort(true);
         if (ssortstyle=nlName) or (ssortstyle=nlNameD) then bol1:=srev else bol1:=false;
         //.write back
         for p:=0 to (acount-1) do
         begin
         if (scount>=xcount) then break;
         case bol1 of
         false:slist[scount]:=alist[c.sindex(p)];
         true:slist[scount]:=alist[c.sindex(acount-1-p)];
         end;
         inc(scount);
         end;//p
         end;

      //files
      c.clear;
      acount:=0;
      for p:=0 to (xcount-1) do if xfindvals(dlist[p],xstyle,xtep,xsize,xdate,xname,xlabel) and (xstyle=nltFile) then
         begin
         case ssortstyle of
         nlName,nlNameD:xval:=low__lowercase(xname);
         nlSize,nlSizeD:xval:=low__digpad20(xsize,20)+'|'+low__lowercase(xname);
         nlDate,nlDateD:xval:=xdatestr(xdate)+'|'+low__lowercase(xname);
         nlType,nlTypeD:xval:=readfileext(xname,true)+'|'+low__lowercase(xname);
         end;
         if (acount>=xcount) then break;
         alist[acount]:=dlist[p];
         c.value[acount]:=xval;
         inc(acount);
         end;
      //.sort
      if (acount>=1) then
         begin
         c.sort(true);
         //.write back
         for p:=0 to (acount-1) do
         begin
         if (scount>=xcount) then break;
         case srev of
         false:slist[scount]:=alist[c.sindex(p)];
         true:slist[scount]:=alist[c.sindex(acount-1-p)];
         end;
         inc(scount);
         end;//p
         end;
      skipend:
      except;end;
      try
      bfree(a);
      bfree(d);
      freeobj(@c);
      except;end;
      end;
   begin
   try
   //defaults
   result:=false;
   a:=nil;
   //init
   xinfo(v1,v2,v3,xcount);//totalcount => number of items in EACH sort.list
   a:=bnewlen(xcount*4);//pre-size list for ultra-fast access
   alist:=a.pints4;
   xfastlen:=xlen;

   //get -> "nlAsis" is default sortstyle - 01oct2020
   int2:=xhdrlen;
   //note: int1 is set to "xlen" by calling proc - 26apr2021
   di:=0;
   while true do
   begin
   if ((int2+4)<=int1) then
      begin
      int3:=x.int4[int2];//read dataset.size
      if (int3<xdatasetsize) then break;//dataset.size is always 25..N bytes
      if (di<xcount) then alist[di]:=int2 else break;
      inc(di);
      inc(int2,int3);
      end
   else break;
   end;//while
   //sort
   xsortname(a,xsortstyle);

   //store
   x.int4[xsortpos]:=int2;
   x.owr(a,int2);
   xsetlen(int2+(xcount*4));//set datasize to actual size of data now - 25sep2020
   //successful
   result:=true;
   skipend:
   except;end;
   try;bfree(a);except;end;
   end;
begin
try
//defaults
result:=false;
block(x);
xonce:=true;
//check
if zznil(x,2187) then goto skipend;
//init
xcmd:=low__lowercase(xcmd);
if (xcmd='init') then
   begin
   x.clear;
   x.aadd([70,108,116,49]);//"Flt1" - 0..3 -> note uppercase "F" denotes structure is in edit mode -> there are no quick lookup sort.lists present yet -> 25sep2020
   x.addint4(xhdrlen);//overall data size - 4..7 -> used for building data structure - 25sep2020
   x.addint4(0);//nav.count - 8..11
   x.addint4(0);//folder.count - 12..15
   x.addint4(0);//file.count - 16..19
   x.addint4(0);//sortlist.pos - 20..23
   goto skipdone;
   end;
//check
if (x.len<xhdrlen) then goto skipend;
//get
if      (xcmd='end') then
   begin
   //already finished -> "flt1"
   if x.asame([102,108,116,49]) then goto skipdone;
   //need to finish -> "Flt1" -> "flt1"
   if not x.asame([70,108,116,49]) then goto skipend;
   //init
   int1:=xlen;
   if (int1<xhdrlen) then goto skipend;
   if (int1<>x.len) then x.setlen(int1);//finalise size -> safe to append data now
   //finish
   xsetlen(x.len);//set datasize to actual size of data now - 25sep2020
   x.pbytes[0]:=llf;//change "F" to "f" -> marks structure as finished -> can "get" now - 25sep2020
   //sort
   int1:=xlen;//26apr2021
   xsort(xstyle);//fixed 20feb2021
   end
else if (xcmd='sort') then
   begin
   int1:=xlen;//26apr2021
   xsort(xstyle)//fixed 20feb2021
   end
else if (xcmd='info') then xinfo(xstyle,xval1,xval2,xval3)
else if (xcmd='add') then
   begin
   //init
   xnamelen:=length(xname);
   xlabellen:=length(xlabel);
   int1:=xlen;
   int2:=4+xnamelen+xlabellen;
   x.minlen(int1+xdatasetsize+int2+xmorespace);
   //range
   xstyle:=frcrange(xstyle,0,nltMax);//0=nav, 1=folder, 2=file, 3=full folder (full path -> special folder, system folder etc)
   xsize:=frcmin64(xsize,0);
   //get
   x.int4[int1]:=xdatasetsize+int2;
   inc(int1,4);//dataset.size -> 22+name.len
   x.byt1[int1]:=xstyle;  inc(int1,1);
   x.int4[int1]:=xtep;    inc(int1,4);//06apr2021
   x.cmp8[int1]:=xsize;   inc(int1,8);
   x.cmp8[int1]:=xdate;   inc(int1,8);
   //.name+label - 04apr2021
   if (int2>=1) then
      begin
      //.namelen
      x.int4[int1]:=xnamelen;
      inc(int1,4);
      //.name
      for p:=0 to (xnamelen-1) do x.pbytes[int1+p]:=byte(xname[p+stroffset]);//zero-base string copy 0 25sep2020
      inc(int1,xnamelen);
      //.label
      for p:=0 to (xlabellen-1) do x.pbytes[int1+p]:=byte(xlabel[p+stroffset]);//zero-base string copy 0 25sep2020
      inc(int1,xlabellen);
      end;
   //set
   xsetlen(int1);
   //inc counters
   case xstyle of
   nltNav,nltTitle:         x.int4[xnavpos]   :=x.int4[xnavpos]+1;
   nltFolder,nltSysFolder:  x.int4[xfolderpos]:=x.int4[xfolderpos]+1;
   nltFile:                 x.int4[xfilepos]  :=x.int4[xfilepos]+1;
   end;//case
   end
else if (xcmd='get') then
   begin
   //check
   if not x.asame([102,108,116,49]) then goto skipend;//must be "flt1" -> init->add's->end
   //init
   int1:=frcmax(xlen,x.len);
   xstyle:=nltNav;
   xval1:=0;
   xval2:=0;
   xval3:=0;
   xsize:=0;
   xdate:=0;
   xname:='';
   xlabel:='';
   xinfo(v1,v2,v3,xcount);//totalcount => number of items in EACH sort.list

   //check
   if (xindex<0) or (xindex>=xcount) then goto skipend;
   //use sortlist
   int2:=x.int4[xsortpos];
   if (int2<=0) then goto skipend;
   //.inc to sort.list postion requested by "xindex"
   inc(int2,(xindex*4));//ascending order

   //dataset.pos
   if (int2>=0) and ((int2+4)<=int1) then int3:=x.int4[int2] else goto skipend;

   //check dataset size
   if (int3<0) or ((int3+4)>int1) then goto skipend;
   int4:=frcmin(x.int4[int3],0);
   if (int4<xdatasetsize) or ((int3+int4)>int1) then goto skipend;

   //read dataset
   inc(int3,4);
   xstyle:=frcrange(x.byt1[int3],0,nltMax); inc(int3,1);//28sep2020
   xtep  :=x.int4[int3]; inc(int3,4);//06apr2021
   xsize :=x.cmp8[int3]; inc(int3,8);
   xdate :=x.cmp8[int3]; inc(int3,8);
   int5:=int4-xdatasetsize;
   //.xnamelen+xname+xlabel - 04apr2021
   if (int5>=1) then
      begin
      //namelen
      xnamelen:=frcmin(x.int4[int3],0);
      inc(int3,4);
      //name
      if (xnamelen>=1) then
         begin
         xname:=x.str[int3,xnamelen];//zero-based
         inc(int3,xnamelen);
         end;
      //label
      xlabellen:=int5-4-xnamelen;
      if (xlabellen>=1) then
         begin
         xlabel:=x.str[int3,xlabellen];//zero-based
         inc(int3,xlabellen);
         end;
      end;//int5
   end
else goto skipend;

//successful
skipdone:
result:=true;
skipend:
except;end;
try
if not result then
   begin
   xstyle:=0;
   xtep:=tepNone;//06apr2021
   xval1:=0;
   xval2:=0;
   xval3:=0;
   xsize:=0;
   xdate:=0;
   xname:='';
   end;
except;end;
try
bunlockautofree(x);
except;end;
end;
//## low__filelist ##
function low__filelist(xoutlist:tdynamicstring;xfullfilenames:boolean;xfolder,xmasklist,xemasklist:string):boolean;//06oct2022
begin
try;result:=low__filelist2(xoutlist,xfullfilenames,xfolder,xmasklist,xemasklist,0,0,maxcur,'');except;end;
end;
//## low__filelist ##
function low__filelist2(xoutlist:tdynamicstring;xfullfilenames:boolean;xfolder,xmasklist,xemasklist:string;xtotalsizelimit,xminsize,xmaxsize:comp;xminmax_emasklist:string):boolean;//06oct2022
label
   skipend;
const
   xfiles=true;
   xfolders=false;
   xallfiles='*';
var
   i:longint;
   xtotalsize,xsize:comp;
   xrec:tsearchrec;
   dfolder:string;
   xfindopen:boolean;
   //.dk support
   xoutname,xoutnameonly:string;
   xoutfolder,xoutfile:boolean;
   xoutdate:tdatetime;
   xpos,xoutsize:longint;
   xoutreadonly:boolean;
   //## xfindsize ##
   function xfindsize:boolean;//pass-thru
   var
      int1:longint;
   begin
   result:=true;
   int1:=xrec.size;
   if (int1<0) then int1:=maxint;
   xsize:=int1;
   end;
begin
try
//defaults
result:=false;
xfindopen:=false;
fillchar(xrec,sizeof(xrec),#0);//28sep2020
xtotalsize:=0;
//check
if zznil(xoutlist,2183) then goto skipend;
//init
if (xmasklist='') then xmasklist:=xallfiles;
if (xfolder='') then
   begin
   result:=true;
   goto skipend;
   end
else xfolder:=asfolder(xfolder);//28sep2020
//.xtotalsizelimit
if (xtotalsizelimit<0) then xtotalsizelimit:=0;
//.dfolder
dfolder:=low__insstr(xfolder,xfullfilenames);

//hack check
if hack_dangerous_filepath_allow_mask(xfolder) then goto skipend;
//get

//.dk support
if dk_havescope(xfolder) then
   begin
   //get
   xpos:=0;
   while true do
   begin
   if dk_findnext(xpos,xfolder,xfolders,xfiles,xoutname,xoutnameonly,xoutfolder,xoutfile,xoutdate,xoutsize,xoutreadonly) then
      begin
      //file
      if xoutfile and (((xoutsize>=xminsize) and (xoutsize<=xmaxsize)) or low__matchmasklistb(xoutnameonly,xminmax_emasklist)) and ( low__matchmasklistb(xoutnameonly,xmasklist) and ((xemasklist='') or (not low__matchmasklistb(xoutnameonly,xemasklist))) ) then
         begin
         //.at limit -> stop
         xtotalsize:=low__add64(xtotalsize,xoutsize);
         if (xtotalsizelimit>=1) and (xtotalsize>xtotalsizelimit) then
            begin
            result:=true;
            goto skipend;
            end;
         //.add
         xoutlist.value[xoutlist.count]:=dfolder+xoutnameonly
         end;
      end
   else break;//stop
   end;//loop
   //successful
   result:=true;
   goto skipend;
   end;

//.open
case xfolders of
true: i:=findfirst(xfolder+xallfiles,faReadOnly or faHidden or faSysFile or faDirectory or faArchive or faAnyFile,xrec);
false:i:=findfirst(xfolder+xallfiles,faReadOnly or faHidden or faSysFile or faArchive or faAnyFile,xrec);
end;//end of case
xfindopen:=(i=0);
while i=0 do
begin
//.skip system folders
if (xrec.name='.') or (xrec.name='..') then
   begin
   //nil
   end
//.add folder ------------------------------------------------------------------
else if faISfolder(xrec.attr) then
   begin
   //nil
   end
//.add file --------------------------------------------------------------------
else
   begin
   if xfiles and xfindsize and (((xsize>=xminsize) and (xsize<=xmaxsize)) or low__matchmasklistb(xrec.name,xminmax_emasklist)) and ( low__matchmasklistb(xrec.name,xmasklist) and ((xemasklist='') or (not low__matchmasklistb(xrec.name,xemasklist))) ) then
      begin
      //init
      xfindsize;
      //get
      //.at limit -> stop
      xtotalsize:=low__add64(xtotalsize,xsize);
      if (xtotalsizelimit>=1) and (xtotalsize>xtotalsizelimit) then
         begin
         result:=true;
         goto skipend;
         end;
      //.add
      xoutlist.value[xoutlist.count]:=dfolder+xrec.name;
      end;
   end;
//.inc
i:=findnext(xrec);
end;//while
//successful
result:=true;
skipend:
except;end;
try;if xfindopen then findclose(xrec);except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//666666666666666666666666
//## low__tob64 ##
function low__tob64(s,d:tstr8;linelength:longint;var e:string):boolean;//to base64
begin
try;result:=low__tob641(s,d,1,linelength,e);except;end;
end;
//## low__tob641 ##
function low__tob641(s,d:tstr8;xpos1,linelength:longint;var e:string):boolean;//to base64
label//Speed: 2,997Kb in 3320ms (~0.902Mb/sec) @ 200Mhz
   skipend;
var
   sptr:tstr8;
   smustfree:boolean;
   a,b:tint4;
   ll,slen,dlen,p,i:longint;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
smustfree:=false;
sptr:=s;
block(s);
block(d);
//check
if zznil(s,2188) or zznil(d,2189) then goto skipend;
//init
if (blen(s)<=0) then
   begin
   result:=true;
   goto skipend;
   end;
//.detect in-out same conflict - 21aug2020
if (s=d) then
   begin
   smustfree:=true;
   sptr:=bnew;
   sptr.add(s);
   s.clear;
   end;
d.clear;//07oct2020
dlen:=0;
slen:=blen(sptr);
ll:=0;
p:=1;
if (linelength<0) then linelength:=0;
//get
d.minlen(4096+6);
repeat
//.get
a.val:=0;
a.bytes[2]:=sptr.pbytes[p-1];
if ((p+1)<=slen) then a.bytes[1]:=sptr.pbytes[p+1-1] else a.bytes[1]:=0;
if ((p+0)<=slen) then a.bytes[0]:=sptr.pbytes[p+2-1] else a.bytes[0]:=0;
//.soup (3 -> 4)
b.bytes[0]:=(a.val div 262144);
dec(a.val,b.bytes[0]*262144);
b.bytes[1]:=(a.val div 4096);
dec(a.val,b.bytes[1]*4096);
if ((p+1)<=slen) then
   begin
   b.bytes[2]:=a.val div 64;
   dec(a.val,b.bytes[2]*64);
   end
else b.bytes[2]:=64;
if ((p+2)<=slen) then b.bytes[3]:=a.val else b.bytes[3]:=64;
//.encode
for i:=0 to 3 do b.bytes[i]:=base64[b.bytes[i]];
//.dlen
if ((dlen+6)>=d.len) then d.minlen(dlen+100000);//100K buffer
inc(dlen,4);
d.pbytes[dlen-3-1]:=b.bytes[0];
d.pbytes[dlen-2-1]:=b.bytes[1];
d.pbytes[dlen-1-1]:=b.bytes[2];
d.pbytes[dlen-1]  :=b.bytes[3];
//.line
if (linelength<>0) then
   begin
   inc(ll,4);
   if (ll>=linelength) then
      begin
      inc(dlen,2);
      d.pbytes[dlen-1-1]:=13;
      d.pbytes[dlen-1]:=10;
      ll:=0;
      end;//if
   end;//if
//.inc
inc(p,3);
until (p>slen);
//.finalise
if (dlen>=1) then d.setlen(dlen);
//successful
result:=true;
skipend:
except;end;
try
if (not result) and zzok(d,7027) then d.clear;
if smustfree then bfree(sptr);
bunlockautofree(s);
bunlockautofree(d);
except;end;
end;
//## low__tob64b ##
function low__tob64b(s:tstr8;linelength:longint):tstr8;//28jan2021
var
   e:string;
begin
try;result:=bnew;low__tob641(s,result,1,linelength,e);except;end;
try;result.oautofree:=true;except;end;
end;
//## low__fromb64 ##
function low__fromb64(s,d:tstr8;var e:string):boolean;//from base64
begin
try;result:=low__fromb641(s,d,1,e);except;end;
end;
//## low__fromb641 ##
function low__fromb641(s,d:tstr8;xpos1:longint;var e:string):boolean;//from base64
label//Speed: 4,101Kb in 3150ms (~1.301Mb/sec) @ 200Mhz
   skipend;
var
   sptr:tstr8;
   smustfree:boolean;
   b,a:tint4;
   slen,dlen,c,p,i:longint;
   v:byte;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
smustfree:=false;
sptr:=s;
block(s);
block(d);
//check
if zznil(s,2190) or zznil(d,2191) then goto skipend;
//init
if (blen(s)<=0) then
   begin
   result:=true;
   goto skipend;
   end;
//.detect in-out same conflict - 21aug2020
if (s=d) then
   begin
   smustfree:=true;
   sptr:=bnew;
   sptr.add(s);
   s.clear;
   end;
d.clear;
dlen:=0;
slen:=blen(sptr);
p:=frcmin(xpos1,1);
if (p>slen) then
   begin
   result:=true;
   goto skipend;
   end;
//get
repeat
a.val:=0;
c:=0;
repeat
//.store
v:=byte(base64r[sptr.pbytes[p-1]]-48);
if (v>=0) and (v<=63) then
   begin
   //.set
   case c of
   0:inc(a.val,v*262144);
   1:inc(a.val,v*4096);
   2:inc(a.val,v*64);
   3:begin
     inc(a.val,v);
     inc(c);
     inc(p);
     break;
     end;//begin
   end;//case
   //.inc
   inc(c,1);
   end
else if (v=64) then
   begin
   p:=slen;
   break;//=
   end;//if
//.inc
inc(p);
until (p>slen);
//.split (4 -> 3)
b.bytes[0]:=a.val div 65536;
dec(a.val,b.bytes[0]*65536);
b.bytes[1]:=a.val div 256;
dec(a.val,b.bytes[1]*256);
b.bytes[2]:=a.val;
//.set
case c of
4:begin
  inc(dlen,3);
  if ((dlen+3)>d.len) then d.minlen(dlen+100000);
  d.pbytes[dlen-2-1]:=b.bytes[0];
  d.pbytes[dlen-1-1]:=b.bytes[1];
  d.pbytes[dlen+0-1]:=b.bytes[2];
  end;//begin
3:begin//finishing #1
  inc(dlen,2);
  if ((dlen+2)>d.len) then d.minlen(dlen+100);
  d.pbytes[dlen-1-1]:=b.bytes[0];
  d.pbytes[dlen+0-1]:=b.bytes[1];
  end;//begin
1..2:begin//finishing #2
  inc(dlen,1);
  if ((dlen+1)>d.len) then d.minlen(dlen+100);
  d.pbytes[dlen+0-1]:=b.bytes[0];
  end;//begin
end;//end of case
until (p>=slen);
//.finalise
if (dlen>=1) then d.setlen(dlen);
//successful
result:=true;
skipend:
except;end;
try
if (not result) and zzok(d,7027) then d.clear;
if smustfree then bfree(sptr);
bunlockautofree(s);
bunlockautofree(d);
except;end;
end;
//## low__fromb64b ##
function low__fromb64b(s:tstr8):tstr8;//28jan2021
var
   e:string;
begin
try;result:=bnew;low__fromb641(s,result,1,e);except;end;
try;result.oautofree:=true;except;end;
end;

//system support ---------------------------------------------------------------
//## system_paintallnowSLOW ##
procedure system_paintallnowSLOW;
begin
try;system_mustpaintSLOW:=2;low__iroll(system_mustidSLOW,1);except;end;
end;
//## system_paintallnow ##
procedure system_paintallnow;
begin
try;system_mustpaint:=2;low__iroll(system_mustid,1);except;end;
end;
//## system_paintnow ##
procedure system_paintnow;
begin
try
if (system_mustpaint<1) then
   begin
   system_mustpaint:=1;
   low__iroll(system_mustid,1);
   end;
except;end;
end;
//## system_alignallnow ##
procedure system_alignallnow;
begin
try;system_mustalign:=2;low__iroll(system_mustid,1);except;end;
end;
//## system_alignnow ##
procedure system_alignnow;
begin
try
if (system_mustalign<1) then
   begin
   system_mustalign:=1;
   low__iroll(system_mustid,1);
   end;
except;end;
end;
//## system_sizenow ##
procedure system_sizenow;
begin
try
system_mustalign:=2;//full
system_mustpaint:=2;//full
low__iroll(system_mustid,1);
except;end;
end;
//## dbRGBA ##
procedure dbRGBA(x:longint);//26jun2021
var
   a:tint4;
begin
try
a.val:=x;
showbasic(
'R: '+inttostr(a.r)+rcode+
'G: '+inttostr(a.g)+rcode+
'B: '+inttostr(a.b)+rcode+
'A: '+inttostr(a.a)+rcode+
'');
except;end;
end;
//## dbimage ##
procedure dbimage(s:tobject;szoom:longint;susealpha:boolean);//strictly debug purposes only - 21dec2021, 07jun2021
var//Note: Now supports 32bit images with alpha masking - 07jun2021
   x:tform;
   b:tbmp;
   c:tbasicimage;
   sptr:tobject;
   e:string;
begin
try
//defaults
x:=nil;
b:=nil;
c:=nil;
sptr:=s;
szoom:=frcrange(szoom,1,50);
//check
if zznil(s,2192) then
   begin
   showbasic('no image');
   exit;
   end;
//init
if (s is tstr8) then//handle data streams natively - 21dec2021
   begin
   c:=misimg32(1,1);
   misfromdata(c,s as tstr8,e);
   sptr:=c;
   end;
b:=misbmp(32,misw(sptr)*szoom,mish(sptr)*szoom);//07jun2021
x:=tform.create(nil);
x.vertscrollbar.visible:=false;
x.horzscrollbar.visible:=false;
x.borderstyle:=bsNone;
x.bordericons:=[];
x.clientwidth:=misw(b);
x.clientheight:=mish(b);
x.left:=frcmin((screen.width-x.width) div 2,0);//14may2022
x.top:=10;
x.show;
app__processallmessages;
b.lock;
miscls(b,0);
miscopyareaxx8(rect(0,0,maxint,maxint),0,0,misw(b),mish(b),misarea(sptr),b,sptr,nil,nil,nil,nil,nil,nil,0,0,false,255,0,clnone,0,0,0,nil,nil,nil,nil,nil,nil,nil,susealpha);
x.canvas.draw(0,0,b.core);
b.unlock;
showbasic('dbimage');
except;end;
try
freeobj(@b);
freeobj(@x);
freeobj(@c);
except;end;
end;
//## dbimage2 ##
procedure dbimage2(s,s2:tobject;szoom:longint);//strictly debug purposes only
var
   x:tform;
   b:tbmp;
begin
try
//defaults
x:=nil;
b:=nil;
szoom:=frcrange(szoom,1,50);
//check
if zznil(s,2192) then
   begin
   showbasic('no image');
   exit;
   end;
//init
b:=misbmp(24,misw(s)*szoom,mish(s)*szoom);
x:=tform.create(nil);
x.vertscrollbar.visible:=false;
x.horzscrollbar.visible:=false;
x.borderstyle:=bsNone;
x.bordericons:=[];
x.clientwidth:=misw(b);
x.clientheight:=mish(b);
x.left:=(screen.width-x.width) div 2;
x.top:=10;
x.show;
app__processallmessages;
b.lock;
//.s
miscopyareaxx(rect(0,0,maxint,maxint),0,0,misw(b),mish(b),misarea(s),b,s,255,0,clnone,0);
//.s2
miscopyareaxx(rect(0,0,maxint,maxint),0,0,misw(b),mish(b),misarea(s),b,s2,150,1,mispixel24VAL(s2,0,0),0);
x.canvas.draw(0,0,b.core);
b.unlock;
showbasic('dbimage2');
except;end;
try
freeobj(@b);
freeobj(@x);
except;end;
end;
//## dbstatus ##
procedure dbstatus(p:longint;x:string);
const
   fixh=20;
   fixw=500;
   fixblank='                               ';
begin
try
//check
if not system_debug then exit;

//range
p:=frcrange(p,0,high(debug_form));
//set

{$ifdef D3}
if (debug_info[p]<>x) then
   begin
   debug_info[p]:=x;
   if system_debugFASTSTAT then system_paintallnow else system_paintallnowSLOW;
   end;
{$endif}

{$ifdef D10}
if (debug_info[p]<>x) then
   begin
   debug_info[p]:=x;
   if system_debugFASTSTAT then system_paintallnow else system_paintallnowSLOW;
   end;
{$endif}
except;end;
end;
//## dbstart ##
procedure dbstart;
begin
try
debug_msstart:=ms64;
debug_msstop:=debug_msstart;
if (debug_msstartave=0) then debug_msstartave:=ms64;
except;end;
end;
//## dbstop ##
procedure dbstop;
var
   cmp1:comp;
begin
try
debug_msstop:=ms64;
debug_mstimetotal:=debug_mstimetotal+(debug_msstop-debug_msstart);
debug_mstimecount:=debug_mstimecount+1;
//.avefast
debug_mstimetotal2:=debug_mstimetotal2+(debug_msstop-debug_msstart);
debug_mstimecount2:=debug_mstimecount2+1;
if ((ms64-debug_msstartave)>=1000) then
   begin
   cmp1:=debug_mstimecount2;
   if (cmp1<1) then cmp1:=1;
   debug_mstimeavefast:=debug_mstimetotal2/cmp1;
   //reset
   debug_mstimetotal2:=0;
   debug_mstimecount2:=0;
   debug_msstartave:=0;
   end;
except;end;
end;
//## dbtime ##
function dbtime:string;
begin
try;result:=low__thousands64(debug_msstop-debug_msstart)+' ms';except;end;
end;
//## dbtimeave ##
function dbtimeave:string;
var
   cmp1:comp;
begin
try
cmp1:=debug_mstimecount;
if (cmp1<1) then cmp1:=1;
result:=low__thousands64(debug_mstimetotal/cmp1)+' ms';
except;end;
end;
//## dbtimeavefast ##
function dbtimeavefast:string;
begin
try;result:=low__thousands64(debug_mstimeavefast)+' ms';except;end;
end;
//## dbshow ##
procedure dbshow(xlabel:string);//show label + dbtime
begin
try;showbasic(xlabel+'<<'+dbtime);except;end;
end;
//## showerror ##
procedure showerror(e:string);//01jan2020
begin
{$ifdef D3}
try
low__closelock;
messagebox(application.handle,pchar(e),'Error!',$00000000+$10);
except;end;
try;low__closeunlock;except;end;
{$endif}
end;
//## showbasic ##
procedure showbasic(x:string);
begin
{$ifdef D3}
try
low__closelock;
messagebox(application.handle,pchar(x),'Information',$00000000+$40);
except;end;
try;low__closeunlock;except;end;
{$endif}
end;
//## showa ##
procedure showa(x:longint);
begin
try;showbasic('a'+inttostr(x));except;end;
end;
//## showb ##
procedure showb(x:longint);
begin
try;showbasic('b'+inttostr(x));except;end;
end;
//## showc ##
procedure showc(x:longint);
begin
try;showbasic('c'+inttostr(x));except;end;
end;
//## showa1 ##
procedure showa1;
begin
showa(1);
end;
//## showa2 ##
procedure showa2;
begin
showa(2);
end;
//## showa3 ##
procedure showa3;
begin
showa(3);
end;
//## showa4 ##
procedure showa4;
begin
showa(4);
end;
//## showa5 ##
procedure showa5;
begin
showa(5);
end;
//## showa6 ##
procedure showa6;
begin
showa(6);
end;
//## showa7 ##
procedure showa7;
begin
showa(7);
end;
//## showa8 ##
procedure showa8;
begin
showa(8);
end;
//## showa9 ##
procedure showa9;
begin
showa(9);
end;
//## showb1 ##
procedure showb1;
begin
showb(1);
end;
//## showb2 ##
procedure showb2;
begin
showb(2);
end;
//## showb3 ##
procedure showb3;
begin
showb(3);
end;
//## showb4 ##
procedure showb4;
begin
showb(4);
end;
//## showc1 ##
procedure showc1;
begin
showc(1);
end;
//## showc2 ##
procedure showc2;
begin
showc(2);
end;
//## showc3 ##
procedure showc3;
begin
showc(3);
end;
//## showc4 ##
procedure showc4;
begin
showc(4);
end;
//## showerror8 ##
procedure showerror8(e:tstr8);//19aug2020
begin//Do not check "e" for risk of cyclic error
{$ifdef D3}
try
low__closelock;
block(e);
try;if (e<>nil) and (not e.empty) then messagebox(application.handle,pchar(e.text),'Error!',$00000000+$10);except;end;
bunlockautofree(e);
except;end;
try;low__closeunlock;except;end;
{$endif}
end;
//## showbasic8 ##
procedure showbasic8(x:tstr8);//19aug2020
begin//Do no check "x" for risk of cyclic error
{$ifdef D3}
try
low__closelock;
block(x);
try;if (x<>nil) and (not x.empty) then messagebox(application.handle,pchar(x.text),'Information',$00000000+$40);except;end;
bunlockautofree(x);
except;end;
try;low__closeunlock;except;end;
{$endif}
end;
//## findfolder ##
function findfolder(x:longint;var y:string):boolean;//17-JAN-2007
var
   i:IMalloc;
   a:pitemidlist;
   b:pchar;
   tmpfolder:string;
begin
try
//defaults
result:=false;
y:='';
a:=nil;
//process
if (SHGetMalloc(i)=NOERROR) then
   begin
   if (shgetspecialfolderlocation(0,x,a)=0) then
      begin
      //.size
      b:=pchar(low__nullstr(max_path,#0));
      //.get
      if shgetpathfromidlist(a,b) then
         begin
         y:=asfolder(string(b));
         result:=(length(y)>=3);
         end;//end of if
      end;//end of if
   end;//end of if
except;end;
try;if (a<>nil) then i.free(a);except;end;
try
//-- Linux and robust Windows Support --
//Note: return a path regardless whether we are Windows or Linux, and wether it's supported
//      or not.
if not result then
   begin
   //fallback to "c:\windows\temp\"
   tmpfolder:=wintemp;
   if (tmpfolder='') then tmpfolder:='C:\WINDOWS\TEMP\';
   y:='';
   //get
   case x of
   CSIDL_DESKTOP:                y:=tmpfolder;
   CSIDL_COMMON_DESKTOPDIRECTORY:y:=tmpfolder;
   CSIDL_FAVORITES:              y:=tmpfolder;
   CSIDL_STARTMENU:              y:=tmpfolder;
   CSIDL_COMMON_STARTMENU:       y:=tmpfolder;
   CSIDL_PROGRAMS:               y:=tmpfolder;
   CSIDL_COMMON_PROGRAMS:        y:=tmpfolder;
   CSIDL_STARTUP:                y:=tmpfolder;
   CSIDL_COMMON_STARTUP:         y:=tmpfolder;
   CSIDL_RECENT:                 y:=tmpfolder;
   CSIDL_FONTS:                  y:=tmpfolder;
   CSIDL_APPDATA:                y:=tmpfolder;
   end;//end of case
   //set
   result:=(length(y)>=3);
   end;//end of if
except;end;
end;
//## appdata ##
function appdata:string;//out of date
begin
try;findfolder(CSIDL_APPDATA,result);except;end;
end;
//## windrive ##
function windrive:string;//14DEC2010
begin
try;result:=strcopy1(winroot,1,3);except;end;
end;
//## winroot ##
function winroot:string;//11DEC2010
var
  a:pchar;
begin
try
//process
//.size
a:=pchar(low__nullstr(max_path,#0));
//.get
getwindowsdirectorya(a,MAX_PATH);
result:=asfolder(string(a));
except;end;
try;if (length(result)<3) then result:='C:\WINDOWS\';except;end;
end;
//## winsystem ##
function winsystem:string;//11DEC2010
var
  a:pchar;
begin
try
//process
//.size
a:=pchar(low__nullstr(max_path,#0));
//.get
getsystemdirectorya(a,MAX_PATH);
result:=asfolder(string(a));
except;end;
try;if (length(result)<3) then result:=winroot+'SYSTEM32\';except;end;
end;
//## wintemp ##
function wintemp:string;//11DEC2010
var
  a:pchar;
begin
try
//defaults
result:='';
//size
a:=pchar(low__nullstr(max_path,#0));
//get
gettemppatha(max_path,a);
//set
result:=asfolder(string(a));
except;end;
try
//range
if (length(result)<3) then result:='C:\WINDOWS\TEMP\';//11DEC2010
if not directoryexists(result) then forcedirectories(result);
except;end;
end;
//## wincommontemp ##
function wincommontemp:string;//27NOV2010
var
   a:array[0..1023] of char;
   s,d:string;
begin
try
//defaults
result:='C:\WINDOWS\TEMP\';
//get
s:='%windir%';
expandenvironmentstrings(pchar(s),a,sizeof(a));
d:=fromnullstr(@a,sizeof(a));
if not low__comparetext(s,d) then result:=asfolder(d)+'TEMP\';
//set
result:=asfolder(result);
//create folder
low__makefolder(result);
//check
if not directoryexists(result) then result:=wintemp;//fallback to "wintemp"
except;end;
end;
//## windesktop ##
function windesktop:string;//17MAY2013
begin
try;findfolder(csidl_desktop,result);except;end;
end;
//## winstartup ##
function winstartup:string;
begin
try;findfolder(CSIDL_STARTUP,result);except;end;
end;
//## winprograms ##
function winprograms:string;//start button > programs > - 11NOV2010
begin
try;findfolder(CSIDL_PROGRAMS,result);except;end;
end;
//## winstartmenu ##
function winstartmenu:string;
begin
try;findfolder(CSIDL_STARTMENU,result);except;end;
end;
//-- Idle Trackers -------------------------------------------------------------
//## low__inputidle ##
function low__inputidle:comp;
var
   a:comp;
begin
try
//defaults
result:=0;
//get
a:=syskeytime;
if (sysclicktime>a) then a:=sysclicktime;
if (syswheeltime>a) then a:=syswheeltime;
if (sysmovetime>a) then a:=sysmovetime;
if (sysdowntime>a) then a:=sysdowntime;//mousedown
//.global mouse move
low__moveidle_global;
if (sysmovetime_global>a) then a:=sysmovetime_global;
//set
result:=frcmin64(ms64-a,0);
except;end;
end;
//## low__inputidle_nomove ##
function low__inputidle_nomove:comp;
var
   a:comp;
begin
try
result:=0;
a:=syskeytime;
if (sysclicktime>a) then a:=sysclicktime;
if (syswheeltime>a) then a:=syswheeltime;
if (sysdowntime>a) then a:=sysdowntime;//mousedown
result:=frcmin64(ms64-a,0);
except;end;
end;
//## low__inputidle_nomove_nodown ##
function low__inputidle_nomove_nodown:comp;
var
   a:comp;
begin
try
result:=0;
a:=syskeytime;
if (sysclicktime>a) then a:=sysclicktime;
if (syswheeltime>a) then a:=syswheeltime;
result:=frcmin64(ms64-a,0);
except;end;
end;
//## low__canecopaint ##
function low__canecopaint(var xtime64:comp):boolean;
var
   v:comp;
begin
try
//defaults
result:=not viecomode;
//get
if not result then
   begin
   //init
   v:=low__inputidle;
   //get
   if (v<=30000) then result:=true
   else if (ms64>=xtime64) then
      begin
      result:=true;
      if     (v<=600000) then xtime64:=ms64+500  //30s..10m = 2fps
      else                    xtime64:=ms64+1000;//10m+      = 1fps
      end;
   end;
except;end;
end;
//## low__keyidle ##
function low__keyidle:comp;
begin
try;result:=frcmin64(ms64-syskeytime,0);except;end;
end;
//## low__clickidle ##
function low__clickidle:comp;
begin
try;result:=frcmin64(ms64-sysclicktime,0);except;end;
end;
//## low__moveidle ##
function low__moveidle:comp;
begin
try;result:=frcmin64(ms64-sysmovetime,0);except;end;
end;
//## low__moveidle_global ##
function low__moveidle_global:comp;
var
   a:tpoint;
begin
try
a:=low__getcursorposb;
if (a.x<>sysmovetime_globalx) or (a.y<>sysmovetime_globaly) then sysmovetime_global:=ms64;
sysmovetime_globalx:=a.x;
sysmovetime_globaly:=a.y;
result:=frcmin64(ms64-sysmovetime_global,0);
except;end;
end;
//## low__downidle ##
function low__downidle:comp;
begin
try;result:=frcmin64(ms64-sysdowntime,0);except;end;
end;
//## low__wheelidle ##
function low__wheelidle:comp;
begin
try;result:=frcmin64(ms64-syswheeltime,0);except;end;
end;
//.reset trackers
//## low__resetkeytime ##
procedure low__resetkeytime;
begin
try;syskeytime:=ms64;except;end;
end;
//## low__resetclicktime ##
procedure low__resetclicktime;
begin
try;sysclicktime:=ms64;except;end;
end;
//## low__resetmovetime ##
procedure low__resetmovetime;
begin
try;sysmovetime:=ms64;except;end;
end;
//## low__resetdowntime ##
procedure low__resetdowntime;
begin
try;sysdowntime:=ms64;except;end;
end;
//## low__resetwheeltime ##
procedure low__resetwheeltime;
begin
try;syswheeltime:=ms64;except;end;
end;
//## low__newpstring
procedure low__newpstring(var z:pstring);//29NOV2011
begin
satinc(satPstring,1);
system.new(z);
end;
//## low__despstring ##
procedure low__despstring(var z:pstring);//29NOV2011
begin
system.dispose(z);
satinc(satPstring,-1);
end;
//## low__getmem ##
function low__getmem(var p:pointer;size,xid:longint):boolean;//27apr2021, 29apr2020
begin
try
result:=false;
if system_debug and (p<>nil) then ppcheck(p,xid);
system.getmem(p,size);
if (size<=0) then p:=nil;
if system_debug and (p<>nil) then ppadd(p);//debug mode only - 29apr2021
systrack_ptrbytes:=systrack_ptrbytes+size;
result:=true;
except;end;
end;
//## low__reallocmem ##
function low__reallocmem(var p:pointer;oldsize,newsize,xid:longint):boolean;//27apr2021, 29apr2020
var
   wasp:pointer;
   xok:boolean;
begin
try
//defaults
result:=false;
xok:=false;
//range
if (newsize<0) then newsize:=0;
//debug: check pointer exists in out list -> if not a FATAL ERROR will occur - 29apr2021
if system_debug then
   begin
   wasp:=p;
   if (p<>nil) then ppcheck(p,xid);
   end;
//get
try
system.reallocmem(p,newsize);//does set to nil but we are covering it just incase - 27apr2021
xok:=true;
except;end;
//reset -> Delphi's proc fails to reset "p" to nil - 29apr2021
if (newsize<=0) or (not xok) then p:=nil;
//debug: add pointer
if system_debug then
   begin
   //add
   if (p<>nil) then ppadd(p);
   //del
   if (wasp<>nil) and (wasp<>p) then ppdel(wasp);
   end;
//memory
systrack_ptrbytes:=systrack_ptrbytes+newsize;
systrack_ptrbytes:=systrack_ptrbytes-oldsize;
//successful
result:=xok;
except;end;
end;
//## low__reallocmemCLEAR ##
function low__reallocmemCLEAR(var p:pointer;oldsize,newsize,xid:longint):boolean;//29apr2021, 29NOV2011
label
   skipend;
var
   a:pdlbyte;
   i:longint;
begin
try
//defaults
result:=false;
//range
if (oldsize<0) then oldsize:=0;
if (newsize<0) then newsize:=0;
//get
if not low__reallocmem(p,oldsize,newsize,xid) then goto skipend;
//clear
if (p<>nil) and (newsize>oldsize) then//fixed 29apr2021
   begin
   a:=pdlbyte(p);
   for i:=oldsize to (newsize-1) do a[i]:=0;
   end;
//successful
result:=true;
skipend:
except;end;
end;
//## low__freemem ##
function low__freemem(var x:pointer;oldsize,xid:longint):boolean;//27apr2021, 29apr2020
var
   wasx:pointer;
begin
try
result:=false;
if ppok(x,xid) then//27apr2021
   begin
   wasx:=x;
   system.freemem(x);//does not set "x" to "nil" when freeing - 28apr2021
   x:=nil;//27apr2021
   if system_debug then ppdel(wasx);
   systrack_ptrbytes:=systrack_ptrbytes-oldsize;
   end;
result:=true;
except;end;
end;

//string support ---------------------------------------------------------------
//## strcopy0 ##
function strcopy0(x:string;xpos,xlen:longint):string;//0based always -> forward compatible with D10 - 02may2020
begin
try
result:='';
if (xlen<1) then exit;
if (xpos<0) then xpos:=0;
result:=copy(x,xpos+stroffset,xlen);
except;end;
end;
//## strcopy0x ##
function strcopy0x(var x:string;xpos,xlen:longint):string;//0based always -> forward compatible with D10 - 02may2020
begin
try
result:='';
if (xlen<1) then exit;
if (xpos<0) then xpos:=0;
result:=copy(x,xpos+stroffset,xlen);
except;end;
end;
//## strlastMatch ##
function strlastMatch(var x:string;xvaluetomatch:string):boolean;//07jan2022
begin
try;result:=(length(xvaluetomatch)<=length(x)) and low__comparetext(strcopy1x(x,length(x)-length(xvaluetomatch)+1,length(xvaluetomatch)),xvaluetomatch);except;end;
end;
//## strlastx ##
function strlastx(var x:string):string;//returns last char of string or nil if string is empty
begin
try;result:=strcopy1x(x,length(x),1);except;end;
end;
//## strlast ##
function strlast(x:string):string;//returns last char of string or nil if string is empty
begin
try;result:=strlastx(x);except;end;
end;
//## strcopy1 ##
function strcopy1(x:string;xpos,xlen:longint):string;//1based always -> backward compatible with D3 - 02may2020
begin
try
result:='';
if (xlen<1) then exit;
if (xpos<1) then xpos:=1;
result:=copy(x,xpos-1+stroffset,xlen);
except;end;
end;
//## strcopy1x ##
function strcopy1x(var x:string;xpos,xlen:longint):string;//1based always -> backward compatible with D3 - 02may2020
begin
try
result:='';
if (xlen<1) then exit;
if (xpos<1) then xpos:=1;
result:=copy(x,xpos-1+stroffset,xlen);
except;end;
end;
//## strdel0 ##
function strdel0(var x:string;xpos,xlen:longint):boolean;//0based
begin
try
result:=true;
if (xlen<1) then exit;
if (xpos<0) then xpos:=0;
delete(x,xpos+stroffset,xlen);
except;end;
end;
//## strdel1 ##
function strdel1(var x:string;xpos,xlen:longint):boolean;//1based
begin
try
result:=true;
if (xlen<1) then exit;
if (xpos<1) then xpos:=1;
delete(x,xpos-1+stroffset,xlen);
except;end;
end;
//## strbyte0 ##
function strbyte0(x:string;xpos:longint):byte;//1based always -> backward compatible with D3 - 02may2020
var
   xlen:longint;
begin
try
result:=0;
if (xpos<0) then xpos:=0;
xlen:=length(x);
if (xlen>=1) and (xpos<xlen) then result:=byte(x[xpos+stroffset]);
except;end;
end;
//## strbyte1 ##
function strbyte1(x:string;xpos:longint):byte;//1based always -> backward compatible with D3 - 02may2020
var
   xlen:longint;
begin
try
result:=0;
if (xpos<1) then xpos:=1;
xlen:=length(x);
if (xlen>=1) and (xpos<=xlen) then result:=byte(x[xpos-1+stroffset]);
except;end;
end;
//## strbyte1x ##
function strbyte1x(var x:string;xpos:longint):byte;//1based always -> backward compatible with D3 - 02may2020
var
   xlen:longint;
begin
try
result:=0;
if (xpos<1) then xpos:=1;
xlen:=length(x);
if (xlen>=1) and (xpos<=xlen) then result:=byte(x[xpos-1+stroffset]);
except;end;
end;
//## low__lowercase ##
function low__lowercase(x:string):string;
begin
try;result:=lowercase(x);except;end;
end;
//## low__uppercase ##
function low__uppercase(x:string):string;
begin
try;result:=uppercase(x);except;end;
end;
//## low__aswin95 ##
function low__aswin95(x:string):string;//31mar2021, 21-AUG-2004
var
   p,xlen:longint;
   z:string;
begin
try
//init
xlen:=length(x);
//check
if (xlen<=0) then
   begin
   result:='';
   exit;
   end;
//get
if (x[0+stroffset]='&') then p:=1 else p:=0;//fixed - 31mar2021
result:=low__lowercase(x);
if (p<=(xLen-1+stroffset)) then
   begin
   z:=low__uppercase(x[p+stroffset]);
   result[p+stroffset]:=z[0+stroffset];
   end;
except;end;
end;
{was:
//## low__asname ##
function low__asname(x:string):string;//31mar2021, 10JUN2007
var//Note: "/=47" and "\=92" support added 10JUN2007
   int1,xlen,lp,p:longint;
   str1:string;
begin
try
//defaults
result:=x;
//init
xlen:=length(x);
//check
if (xlen<=0) then exit;
//get
lp:=1;
for p:=1 to xlen do
begin
case byte(x[p-1+stroffset]) of
34,39,10,9,95,32,45,126,47,92:begin
   str1:=low__aswin95(strcopy1(x,lp,p-lp))+strcopy1(x,p,1);//exclude the sep char from the "low__aswin95()" process
   if (str1<>'') then for int1:=1 to length(str1) do result[(lp-1)+stroffset+(int1-1)]:=str1[int1-1+stroffset];
   lp:=p+1;
   end;
else
   begin
   if (p>=xlen) then
      begin
      str1:=low__aswin95(strcopy1(x,lp,p-lp));
      if (str1<>'') then for int1:=1 to length(str1) do result[(lp-1)+stroffset+(int1-1)]:=str1[int1-1+stroffset];
      end;
   end;
end;//case
end;//p
except;end;
end;
{}
//## low__asname ##
function low__asname(x:string):string;//02mar2022
var
   lc,v,xlen,p:longint;
   //## xAB09 ##
   function xAB09(x:longint):boolean;
   begin
   result:=false;
   case x of
   48..57,65..90,97..122:result:=true;
   end;//case
   end;
begin
try
//defaults
result:=x;
xlen:=length(x);
if (xlen<=0) then exit;
//get
lc:=32;
for p:=1 to xlen do
begin
v:=strbyte1x(result,p);
if xAB09(v) then
   begin
   case xAB09(lc) of
   true:begin
      if(v>=65) and (v<=90) then
         begin
         inc(v,32);
         result[p-1+stroffset]:=char(v);
         end;
      end;
   false:begin
      if(v>=97) and (v<=122) then
         begin
         dec(v,32);
         result[p-1+stroffset]:=char(v);
         end;
      end;
   end;//case
   end;
lc:=v;
end;//p
except;end;
end;
//## bn ##
function bn(x:boolean):byte;
begin
try;if x then result:=1 else result:=0;except;end;
end;
//## bnc ##
function bnc(x:boolean):char;
begin
try;if x then result:='1' else result:='0';except;end;
end;
//## nb ##
function nb(x:byte):boolean;
begin
try;result:=(x=1);except;end;
end;
//## nbs ##
function nbs(x:string):boolean;
begin
try;result:=(x='1');except;end;
end;
//## swapcharsb ##
function swapcharsb(x:string;a,b:char):string;
begin
try;result:=x;swapchars(result,a,b);except;end;
end;
//## swapchars ##
procedure swapchars(var x:string;a,b:char);//20JAN2011
var
   p:longint;
begin
try
//check
if (x='') then exit;
//get
for p:=0 to (length(x)-1) do if (x[p+stroffset]=a) then x[p+stroffset]:=b;
except;end;
end;
//## fromnullstr ##
function fromnullstr(a:pointer;asize:longint):string;
var
   p:longint;
   b:pdlBYTE;
begin
try
//prepare
setlength(result,asize);
b:=a;
//process
for p:=0 to (asize-1) do
    begin
    result[p+stroffset]:=chr(b[p]);
    if (b[p]=0) then
       begin
       setlength(result,p);
       break;
       end;
    end;
except;end;
end;
//## low__nullstr ##
function low__nullstr(x:longint;y:char):string;
var//speed: 8-9Mb/sec, tested at 9Mb=1,000ms @ 200Mhz
   p:longint;
begin
try;setlength(result,x);for p:=(length(result)-1) downto 0 do result[p+stroffset]:=y;except;end;
end;
//## low__lastext ##
function low__lastext(x:string):string;//returns last extension - 03mar2021
begin
try;result:=low__lastext2(x,false);except;end;
end;
//## low__lastext2 ##
function low__lastext2(x:string;xifnodotusex:boolean):string;//returns last extension - 03mar2021
var
   p:longint;
   c:char;
begin
try
//defaults
if xifnodotusex then result:=x else result:='';
//get
if (x<>'') then
   begin
   for p:=(length(x)-1) downto 0 do
   begin
   c:=x[p+stroffset];
   if (c='.') then
      begin
      result:=strcopy0(x,p+1,length(x));
      break;
      end
   else if (c='/') or (c='\') or (c=':') or (c='|') then break;
   end;//p
   end;
except;end;
end;
//## remlastext ##
function remlastext(x:string):string;//remove last extension
var
   p:longint;
begin
try
result:=x;
if (x<>'') then
   begin
   for p:=(length(x)-1) downto 0 do if (x[p+stroffset]='.') then
   begin
   result:=strcopy0(x,0,p);
   break;
   end;//p
   end;
except;end;
end;
//## readfileext ##
function readfileext(x:string;fu:boolean):string;{Date: 24-DEC-2004, Superceeds "ExtractFileExt"}
var//supports: "c:\windows\abc.RTF" and also "http://www.blaiz.net/abc/docs/index.RTF?abc=com"
   a,b:string;
begin
try
if scandownto(x,'.','/','\',a,result) then
   begin
   if scandownto(result,'?',#0,#0,a,b) then result:=a;
   if fu then result:=low__uppercase(result);
   end
else result:='';
except;end;
end;
//## lowercase__readfileext ##
function lowercase__readfileext(x:string):string;//30jan2022
begin
try;result:=low__lowercase(readfileext(x,false));except;end;
end;
//## scandownto ##
function scandownto(x:string;y,stopA,stopB:char;var a,b:string):boolean;
var
   xlen,p:longint;
   _stopA,_stopB:boolean;
begin
try
//defaults
result:=false;
a:='';
b:='';
_stopA:=(stopA<>#0);
_stopB:=(stopB<>#0);
//init
xlen:=length(x);
//check
if (xlen<=0) then exit;
//get
for p:=(xlen-1) downto 0 do
begin
if (_stopA and (x[p+stroffset]=stopA)) then break
else if (_stopB and (x[p+stroffset]=stopB)) then break
else if (x[p+stroffset]=y) then
   begin
   a:=strcopy0(x,0,p);
   b:=strcopy0(x,p+1,xlen);
   result:=true;
   break;
   end;
end;//p
except;end;
end;
//## floattostrex2 ##
function floattostrex2(x:extended):string;//19DEC2007
begin
try;result:=floattostrex(x,18);except;end;
end;
//## floattostrex ##
function floattostrex(x:extended;dig:byte):string;//07NOV20210
var//0=integer part only, 1-18=include partial content if present
   p:longint;
   a,b,c:string;
begin
try
//defaults
result:='0';
//get
a:=floattostrf(x,ffFixed,18,18);
b:='';
c:='';
if (a<>'') then
   begin
   for p:=0 to (length(a)-1) do if (a[p+stroffset]='.') then
   begin
   if (dig>=1) then b:=strcopy0(a,p+1,dig);
   a:=strcopy0(a,0,p);
   break;
   end;
   end;
//scan
if (b<>'') then
   begin
   for p:=(length(b)-1) downto 0 do if (b[p+stroffset]<>'0') then
   begin
   c:=strcopy0(b,0,p+1);//strip off excess zeros - 07NOV2010
   break;
   end;
   end;
//set
result:=a+low__insstr('.'+c,c<>'');
except;end;
end;
//## strtofloatex ##
function strtofloatex(x:string):extended;//triggers less errors (x=nil now covered)
begin
try;result:=0;if (x<>'') then result:=strtofloat(x);except;end;
end;
//## low__remcharb ##
function low__remcharb(x:string;c:char):string;//26apr2019
begin
try;result:=x;low__remchar(result,c);except;end;
end;
//## low__remchar ##
function low__remchar(var x:string;c:char):boolean;//26apr2019
var
   xlen,i,p:longint;
begin
try
//defaults
result:=false;
xlen:=length(x);
i:=0;
//get
if (xlen>=1) then
   begin
   for p:=0 to (xlen-1) do
   begin
   if (x[p+stroffset]=c) then inc(i)
   else if (i<>0) then x[p-i+stroffset]:=x[p+stroffset];
   end;//p
   end;
//shrink
if (i<>0) then setlength(x,xlen-i);
except;end;
end;
//## low__rembinary ##
function low__rembinary(var x:string):boolean;//07apr2020
var
   xlen,i,p:longint;
begin
try
//defaults
result:=false;
xlen:=length(x);
i:=0;
//get
if (xlen>=1) then
   begin
   for p:=0 to (xlen-1) do
   begin
   if (x[p+stroffset]<#32) then inc(i)
   else if (i<>0) then x[p-i+stroffset]:=x[p+stroffset];
   end;//p
   end;
//shrink
if (i<>0) then setlength(x,xlen-i);
except;end;
end;
//## low__rembinaryb ##
function low__rembinaryb(x:string):string;//07apr2020
begin
try;result:=x;low__rembinary(result);except;end;
end;
//## strint_filtered ##
function strint_filtered(x:string):longint;//removes "comma,space" automatically
var
   a:string;
begin
try
result:=0;
a:=x;
low__remchar(a,',');
low__remchar(a,#32);
result:=strint(a);
except;end;
end;
//## strint_filtered64 ##
function strint_filtered64(x:string):comp;//removes "comma,space" automatically
var
   a:string;
begin
try
a:=x;
low__remchar(a,',');
low__remchar(a,#32);
result:=strint64(a);
except;end;
end;
//## low__netencode_str ##
procedure low__netencode_str(var x:string);
begin
try;low__netencode_strslash(x,false);except;end;
end;
//## low__netencode_strslash ##
procedure low__netencode_strslash(var x:string;leaveslash:boolean);//12-jun-2006
var
   v,xlen,p:longint;
begin
try
//defaults
xlen:=length(x);
//check
if (xlen=0) then exit;
//process
p:=1;
repeat
v:=strbyte1(x,p);
case v of
42,45..46,48..57,64..90,95,97..122:{don't encode these |*|-|.|0..9|@..z|_|a..z|};
32:x[p]:='+';{special case: <space> -> <+>}
else{encode using ibm encoding ("%"+"0..f"+"0..f")}
if not ((x[p]='/') and leaveslash) then
   begin
   x:=strcopy1(x,1,p-1)+'%'+low__hex(v)+strcopy1(x,p+1,xlen);
   xlen:=xlen+2;{always "%xy" = 3-1 = enlarged by 2c's}
   //.inc
   inc(p,2);
   end;//if
end;//case
//.inc
inc(p);
until (p>xlen);
except;end;
end;
//## low__hexchar ##
function low__hexchar(x:byte):char;
begin
try
//range
if (x>15) then x:=15;
//get
case x of
0..9   :result:=chr(48+x);
10..15 :result:=chr(55+x);
else    result:='?';
end;//case
except;end;
end;
//## low__hex ##
function low__hex(x:byte):string;
var
   a,b:byte;
begin
try
a:=x div 16;
b:=x-(a*16);
result:=low__hexchar(a)+low__hexchar(b);
except;end;
end;
//## low__swapstrs ##
function low__swapstrs(var x:string;a,b:string):boolean;
label
   redo;
var
   lenb,lena,maxp,p:longint;
begin
try{Extremely Fast Praser/StrSwaper - 5KBx6 times = 1-7ms => 46 times faster than SwapStrs => 325ms}
//no
result:=false;
//init
maxp:=length(x);
lena:=length(a);
lenb:=length(b);
p:=0;
//get
redo:
inc(p);
if (p>maxp) then exit;
if (x[p-1+stroffset]=a[stroffset]) and (strcopy1(x,p,lena)=a) then
   begin
   x:=strcopy1(x,1,p-1)+b+strcopy1(x,p+lena,maxp);
   p:=p+lenb-1;
   maxp:=maxp-lena+lenb;
   //yes
   result:=true;
   end;//loop
goto redo;
except;end;
end;
//## firstline ##
function low__firstline(var _data:string):string;//08oct2018
var//Now supports #10, #13 and #13#10 combinations
   ok:boolean;
   p:longint;
   v:byte;
begin
try
//defaults
result:='';
ok:=false;
//get
for p:=1 to length(_data) do
begin
v:=strbyte1(_data,p);
if (v=10) or (v=13) then//fixed 08oct2018
   begin
   ok:=true;
   result:=strcopy1(_data,1,p-1);
   break;
   end;
end;
if not ok then result:=_data;
except;end;
end;
//## low__checkfilebadchars ##
procedure low__checkfilebadchars(xfilename:string);
label
   skipend2,skipend;
var
   x:tstr8;
   xlinecount,lv,i,v,p,xlen,xbadcount:longint;
   xreclist,str1,xfirst,e:string;
   xreccount:longint;
begin
try
//init
e:='';
xreclist:='';
xfirst:='';
x:=nil;
x:=bnew;
xreccount:=-1;//off
xbadcount:=0;
xlinecount:=0;
if low__fromfile(xfilename,x,e) then e:='';
xlen:=x.len;
if (xlen<=0) then goto skipend;
//get
lv:=0;
for p:=0 to (xlen-1) do
begin
v:=x.pbytes[p];

//.return code checker
if (v=10) then inc(xlinecount);
if (v=10) and (lv=10) then
   begin
   showbasic('Error at line '+low__64(xlinecount)+' - incorrect return code (10+10) instead of (13+10)!!!!');
   goto skipend2;
   end;
lv:=v;

{
if (v=124) and (xreccount<0) then xreccount:=0;//start recording
if (xreccount>=0) then
   begin
   inc(xreccount);
   if (xreccount<=400) then xreclist:=xreclist+inttostr(v)+' ';
   end;
{}
{
case v of
0..8,11..12,14..31,127..255:begin
   inc(xbadcount);
   if (xbadcount=1) then
      begin
      str1:='';
      for i:=(p-1) downto (p-250) do str1:=char(x.pbytes[i])+str1;
      xfirst:='Text before bad character: >>'+str1+'<<';
      end;
   end;
end;
{}//xxxxx
end;//p
skipend:
//prompt
if (e<>'') then showbasic(e)
else if (xbadcount<=0) then
   begin
   showbasic(
   'Code is clean.'+rcode+
   'No bad characters detected.'+rcode+
   'Scanned '+low__64(xlen)+'c in '+xfilename+rcode+
   rcode+
   'Reclist>>'+xreclist+'<<'+rcode
   );
   end
else
   begin
   showbasic(
   'Warning: '+low__64(xbadcount)+' bad characters detected within code.'+rcode+
   rcode+
   xfirst+rcode+
   rcode+
   'Scanned '+low__64(xlen)+'c in '+xfilename+rcode+
   rcode+
   'Reclist>>'+xreclist+'<<'+rcode
   );
   end;
skipend2:
except;end;
try;bfree(x);except;end;
end;
//## findtext ##
function low__findtext(var _pos:longint;var _data:string;_find:string):boolean;
begin
try;result:=low__findtextL(_pos,length(_data),_data,_find);except;end;
end;
//## low__findtextL ##
function low__findtextL(var _pos:longint;_len:longint;var _data:string;_find:string):boolean;//22apr2014
var//optimised for speed: 70,000 lines in ~270ms
   a,b,d,f:byte;
   p2,p,fLEN:longint;
begin
try
//defaults
result:=false;
fLEN:=length(_find);
//check
if (_len=0) or (fLEN=0) or (fLEN>_LEN) then exit;
if (_pos<1) or (_pos>_len) then exit;//range check - 22apr2014
//.d
d:=ord(_find[1]);
if (d>=97) and (d<=122) then d:=d-32;//uppercase
//process
for p:=_pos to (_LEN-fLEN+1) do
begin
//.get
f:=ord(_data[p]);
if (f>=97) and (f<=122) then f:=f-32;//uppercase
//.compare
if (f=d) then
   begin
   //fLEN=1
   if (fLEN=1) then
      begin
      result:=true;
      _pos:=p;
      exit;
      end;
   //fLEN=2..n
   for p2:=2 to fLEN do
   begin
   a:=ord(_find[p2]);if (a>=97) and (a<=122) then a:=a-32;//uppercase
   b:=ord(_data[p+p2-1]);if (b>=97) and (b<=122) then b:=b-32;//uppercase
   if (a<>b) then break
   else if (p2=fLEN) then
        begin
        result:=true;
        _pos:=p;
        exit;
        end;//end of if
   end;//end of loop
   end;//end of if
end;//end of loop
except;end;
end;
//## readline ##
function low__readline(var _pos,_start,_length:longint;var _data:string):boolean;
var
   _winrc:boolean;
begin
try;result:=low__readlinec(_pos,_start,_length,_data,length(_data),_winrc);except;end;
end;
//## readlineb ##
function low__readlineb(var _pos,_start,_length:longint;var _data:string;var _winrc:boolean):boolean;
begin
try;result:=low__readlinec(_pos,_start,_length,_data,length(_data),_winrc);except;end;
end;
//## readlinec ##
function low__readlinec(var _pos,_start,_length:longint;var _data:string;_datalen:longint;var _winrc:boolean):boolean;//16may2022
var//Supports: Unix return codes "#10" and Windows/DOS return codes "#13+#10"
   lv,v:byte;
   p,LEN:longint;
begin
try
//defaults
result:=false;
_winrc:=false;
//check
if (_pos<1) then exit;
//init
LEN:=frcrange(_datalen,0,length(_data));//limit range to safe range - 29dec2018
if (len=0) then exit;
_start:=_pos;
_length:=0;
lv:=0;
//get
for p:=_pos to LEN do
begin
//.get
v:=ord(_data[p-1+stroffset]);

//.set
if ((v=10) or (p=LEN)) then
   begin
   //.length
   _length:=p-_start;
   if (lv=13) then
      begin
      _length:=_length-1;
      _winrc:=true;
      end
   else if (p=LEN) and (v<>10) then _length:=_length+1;
   //.pos
   _pos:=p+1;
   //.successful
   result:=true;
   break;
   end;//end of if
//.lv
lv:=v;
end;
except;end;
end;
//## strint ##
function strint(x:string):longint;//skip over pluses "+" - 22jan2022, skip over commas - 05jun2021, date: 16aug2020, 25mar2016 v1.00.50 / 10DEC2009, v1.00.045
var //Similar speed to "strtoint" - no erros are produced though
    //Fixed "integer out of range" error, for data sets that fall outside of range
   n,xlen,z,y:longint;
   tmp:currency;
begin
try
//defaults
result:=0;
tmp:=0;
if (x='') then exit;
//init
xlen:=length(x);
n:=1;
//get
z:=1;
while true do
begin
y:=byte(x[z-1+stroffset]);
if (y=45) then n:=-1
else if (y=43) then
   begin
   //do nothing as "+" does nothing - 22jan2022
   end
else if (y=ssComma) then//05jun2021
   begin
   //nil
   end
else
    begin
    if (y<48) or (y>57) then break;
    tmp:=tmp*10+y-48;
    end;
inc(z);
if (z>xlen) then break;
//.range limit => prevent error "EInvalidOP - Invalid floating point operation" - 25mar2016
if (tmp>maxint) then
   begin
   tmp:=maxint;
   break;
   end;
end;//loop
//n
tmp:=frccurrange(tmp*n,minint,maxint);
result:=round(tmp);
except;end;
end;
//## extstr ##
function extstr(x:extended):string;//17sep2018
begin
try;result:=floattostrex2(x);except;end;
end;
//## curstr ##
function curstr(x:currency):string;//27nov2017
begin
try;result:=floattostrex2(x);except;end;
end;
//## strcur ##
function strcur(x:string):currency;//v1.00.070 - 07NOV2010
label
   skipone;
var //similar speed to "strtoint" - no errors are produced though
   n,xlen,z,y:longint;
   dotdiv:currency;
   dotok:boolean;
begin
try
//default
result:=0;
if (x='') then exit;
//init
xlen:=length(x);
n:=1;
dotok:=false;
dotdiv:=10;
//get
z:=1;
while true do
begin
y:=byte(x[z-1+stroffset]);
if (y=45) then n:=-1
else if (y=ssComma) then//05jun2021
   begin
   //nil
   end
else
    begin
    //decide
    if (not dotok) and (y=46) then
       begin
       dotok:=true;//decimal point - 07NOV2010
       goto skipone;
       end
    else if (y<48) or (y>57) then break;
    //set - 07NOV2010
    case dotok of
    false:result:=result*10+y-48;
    true:begin//5 digit max - (x/100,000)
       if (dotdiv<>0) then result:=result+((y-48)/nozero_cur(1200001,dotdiv));
       dotdiv:=dotdiv*10;
       if (dotdiv>=1000000) then break;
       end;
    end;//case
    end;
skipone:
inc(z);
if (z>xlen) then break;
end;//loop
//n
result:=result*n;
except;end;
end;
//## curstrex ##
function curstrex(x:currency;sep:string):string;//01aug2017, 07SEP2007
var
   xlen,i,p:longint;
   decbit,z2,Z,Y:String;
begin
try
//defaults
result:='0';
decbit:='';
//init
z2:='';
if (x<0) then
   begin
   x:=-x;
   z2:='-';
   end;
//.dec point fix - 01aug2017
y:=floattostrex2(x);
if (y<>'') then for p:=0 to (length(y)-1) do if (y[p+stroffset]='.') then
   begin
   decbit:=strcopy0(y,p,length(y));
   y:=strcopy0(y,0,p);
   break;
   end;
//get
z:='';
xlen:=length(y);
i:=0;
if (xlen>=1) then
   begin
   for p:=(xlen-1) downto 0 do
   begin
   inc(i);
   if (i>=3) and (p>0) then
      begin
      z:=sep+strcopy0(y,p,3)+z;
      i:=0;
      end;
   end;//p
   end;
if (i<>0) then z:=strcopy0(y,0,i)+z;
//return result
result:=z2+z+decbit;
except;end;
end;
//## curcomma ##
function curcomma(x:currency):string;{same as "Thousands" but for "double"}
begin
try;result:=curstrex(x,',');except;end;
end;
//## strdec ##
function strdec(x:string;y:byte;xcomma:boolean):string;
var
   a,b:string;
   aLen,p:longint;
begin
try
//range
if (y<0)  then y:=0;
if (y>10) then y:=10;
//init
a:=x;
alen:=length(a);
b:='';
//get
if (alen>=1) then
   begin
   for p:=0 to (alen-1) do if (a[p+stroffset]='.') then
      begin
      b:=strcopy0(a,p+1,alen);
      a:=strcopy0(a,0,p);
      break;
      end;//p
   end;
//xcomma - thousands
if xcomma then a:=curcomma(strtofloatex(a));
//set
if (y<=0) then result:=a else result:=a+'.'+strcopy0(b+'0000000000',0,y);
except;end;
end;
//## curdec ##
function curdec(x:currency;y:byte;xcomma:boolean):string;
begin
try;result:=strdec(floattostrex2(x),y,xcomma);except;end;
end;
//## strint64 ##
function strint64(x:string):comp;//v1.00.035 - 05jun2021, v1.00.033 - 28jan2017
var
   n,digcount,xlen,z,y:longint;
begin
try
//defaults
result:=0;
if (x='') then exit;
//init
xlen:=length(x);
digcount:=0;//comp 64bit allows for 18 digit WHOLE numbers (- and +) - 28jan2017
n:=1;
//get
z:=0;
while true do
begin
y:=byte(x[z+stroffset]);
if (y=45) then n:=-n
else if (y=ssComma) then//05jun2021
   begin
   //nil
   end
else
    begin
    if (y<48) or (y>57) then break;
    result:=result*10+(y-48);
    inc(digcount);
    end;
inc(z);
//.range limit to 18 digits => prevent error "EInvalidOP - Invalid floating point operation" - 27jan2017
if (z>=xlen) or (digcount>=18) then break;
end;//end of while
//sign
result:=n*result;
except;end;
end;
//## intstr64 ##
function intstr64(x:comp):string;//30jan2017
var
   p:longint;
begin
try
//defaults
result:='0';
//get
result:=floattostrf(x,ffFixed,18,18);
if (result<>'') then
   begin
   for p:=0 to (length(result)-1) do if (result[p+stroffset]='.') then
      begin
      result:=strcopy0(result,0,p);
      break;
      end;//p
   end;
except;end;
end;
//## int32 ##
function int32(x:comp):longint;
begin//Note: Clip a 64bit integer to a 32bit integer range
try
if (x>maxint) then x:=maxint;
if (x<minint) then x:=minint;
result:=round(x);
except;end;
end;
//## int32RANGE ##
function int32RANGE(x,xmin,xmax:comp):longint;
begin//Note: Clip a 64bit integer to a 32bit integer range
try
//range
if (x<xmin) then x:=xmin;
if (x>xmax) then x:=xmax;
//32bit range
if (x>maxint) then x:=maxint;
if (x<minint) then x:=minint;
//get
result:=round(x);
except;end;
end;
//## safeinc ##
procedure safeinc(var x:longint);//16jun2014
begin
try;if (x<maxint) then inc(x);except;end;
end;
//## cround ##
function cround(x:extended):currency;//19DEC2007
begin//Note: extended maintains high-level "x/y" values, which if were transfered
try  //within currency would be slightly rounded causing distortion/errors
result:=0;
result:=strtocurr(floattostrex(x,0));//remove partial content
except;end;
end;

//-- System Timer Support - ----------------------------------------------------
//uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//fffffffffffffffffffffffff

//## fasttimer_ystep ##
procedure fasttimer_ystep(xby:longint);
begin
if sysfasttiminginuse then
   begin
   if (xby<1) then xby:=1 else if (xby>50000) then xby:=50000;//prevent longint overflow
   inc(sysfasttimer_ycount,xby);
   if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then
      begin
      sysfasttimer_ycount:=0;
      app__fasttimer;
      end;
   end;
end;
//## fasttimer_ycheck ##
procedure fasttimer_ycheck;
begin
if sysfasttiminginuse and (sysfasttimer_ycount>=sysfasttimer_ytrigger) then
   begin
   sysfasttimer_ycount:=0;
   app__fasttimer;
   end;
end;
//## fasttimer_xstep ##
procedure fasttimer_xstep(xby:longint);
begin
if sysfasttiminginuse then
   begin
   if (xby<1) then xby:=1 else if (xby>500000) then xby:=500000;//prevent longint overflow
   inc(sysfasttimer_xcount,xby);
   if (sysfasttimer_xcount>=sysfasttimer_xtrigger) then
      begin
      sysfasttimer_xcount:=0;
      app__fasttimer;
      end;
   end;
end;
//## fasttimer_xcheck ##
procedure fasttimer_xcheck;
begin
if sysfasttiminginuse and (sysfasttimer_xcount>=sysfasttimer_xtrigger) then
   begin
   sysfasttimer_xcount:=0;
   app__fasttimer;
   end;
end;
//## low__timerflush ##
procedure low__timerflush;
var
   p:longint;
begin
try
for p:=0 to high(systimer_event) do if assigned(systimer_event[p]) then
   begin
   systimer_owner[p]:=nil;
   systimer_event[p]:=nil;
   systimer_delay[p]:=0;//off
   end;//p
except;end;
end;
//## low__timerfound ##
function low__timerfound(xowner:tobject;x:tnotifyevent):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
//check
if not assigned(x) then exit;
//find
for p:=0 to high(systimer_event) do if (xowner=systimer_owner[p]) and (@x=@systimer_event[p]) then
   begin
   result:=true;
   break;
   end;
except;end;
end;
//## low__timerset ##
function low__timerset(xowner:tobject;x:tnotifyevent;xdelay:comp):boolean;
var//Note: accepts "xowner=nil" but beware this timer will not be unique if more than one instance the object etc is used
   pnew,p:longint;
begin
try
//defaults
result:=false;
pnew:=-1;
//check
if not assigned(x) then exit;
//existing
for p:=0 to high(systimer_event) do
begin
if (xowner=systimer_owner[p]) and (@x=@systimer_event[p]) then
   begin
   systimer_delay[p]:=xdelay;
   if (low__sub64(systimer_ref64[p],ms64)>xdelay) then systimer_ref64[p]:=ms64;//fast reset incase last was a long delay - 05may2021
   result:=true;
   break;
   end
else if (pnew<0) and (not assigned(systimer_event[p])) and (not systimer_busy[p]) then pnew:=p;
end;//p
//new
if (not result) and (pnew>=0) then
   begin
   systimer_owner[pnew]:=xowner;//required as "tnotifyevents" on an object are NOT unique between instances of the same object - 19feb2021
   systimer_event[pnew]:=x;
   systimer_delay[pnew]:=xdelay;
   systimer_ref64[pnew]:=ms64;//fast reset incase last was a long delay
   satinc(satTimer,1);
   result:=true;
   end;
except;end;
end;
//## low__timerdelay ##
function low__timerdelay(xowner:tobject;x:tnotifyevent;xnewdelay:comp):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
//check
if not assigned(x) then exit;
//find
for p:=0 to high(systimer_event) do if (xowner=systimer_owner[p]) and (@x=@systimer_event[p]) then
   begin
   systimer_delay[p]:=xnewdelay;
   if (low__sub64(systimer_ref64[p],ms64)>xnewdelay) then systimer_ref64[p]:=ms64;//fast reset incase last was a long delay - 05may2021
   result:=true;
   break;
   end;
except;end;
end;
//## low__timerfinddelay ##
function low__timerfinddelay(xowner:tobject;x:tnotifyevent;var xdelay:comp):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
xdelay:=0;
//check
if not assigned(x) then exit;
//find
for p:=0 to high(systimer_event) do if (xowner=systimer_owner[p]) and (@x=@systimer_event[p]) then
   begin
   xdelay:=systimer_delay[p];
   result:=true;
   break;
   end;
except;end;
end;
//## low__timerdel ##
function low__timerdel(xowner:tobject;x:tnotifyevent):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
//check
if not assigned(x) then exit;
//get
for p:=0 to high(systimer_event) do if (xowner=systimer_owner[p]) and (@x=@systimer_event[p]) then//works even when the timer is currently locked mid-way through firing the "_event()" proc - 19feb2021
   begin
   systimer_owner[p]:=nil;
   systimer_event[p]:=nil;
   systimer_delay[p]:=0;//off
   result:=true;
   satinc(satTimer,-1);
   break;
   end;//p
except;end;
end;

{$ifdef tbt}
//## low__encrypt ##
function low__encrypt(s:tstr8;xpass:string;xpower:longint;xencrypt:boolean;var e:string):boolean;
var
   d:tstr8;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
d:=nil;
//init
d:=bnew;
//get
if low__encrypt2(s,d,xpass,xpower,xencrypt,e) then
   begin
   e:=gecOutOfMemory;
   s.clear;
   result:=s.add(d);
   end
else s.clear;//13jun2022
except;end;
try;bfree(d);except;end;
end;
//## low__encrypt2 ##
function low__encrypt2(s,d:tstr8;xpass:string;xpower:longint;xencrypt:boolean;var e:string):boolean;
var
   a:ttbt;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
a:=nil;
//range
if (xpower<2) then xpower:=1000;//max power
xpower:=frcrange(xpower,2,1000);
//check
if low__true2(block(s),block(d)) then
   begin
   a:=ttbt.create;
   a.password:=xpass;
   a.power:=xpower;
   if xencrypt then
      begin
      if (xpower=1000) then result:=a.encode(s,d,e) else result:=a.encode4(s,d,e);
      end
   else result:=a.decode(s,d,e);
   end;
except;end;
try
freeobj(@a);
bunlockautofree(s);
bunlockautofree(d);
except;end;
end;
//## ttbt ######################################################################
//## create ##
constructor ttbt.create;
var
   p:integer;
begin
//self
inherited create;
//controls

//defaults
obreath:=true;//02mar2015
ipower:=1000;//8,000 bits(max), range 2..1000
ipassword:='';
ikey:='';
ikeyrandom:='';
ikeymodified:=true;
end;
//## destroy ##
destructor ttbt.destroy;
begin
try
//controls

//self
inherited destroy;
except;end;
end;
//## setpassword ##
procedure ttbt.setpassword(x:string);
begin
try;if low__setstr(ipassword,x) then ikeymodified:=true;except;end;
end;
//## setpower ##
procedure ttbt.setpower(x:integer);
begin
try;if low__setint(ipower,frcrange(x,2,1000)) then ikeymodified:=true;except;end;
end;
//## keyinit ##
function ttbt.keyinit:boolean;
label
   skipend;
const
   klimit=1000;
var
   maxp,p:longint;
   k,x,j:tstr8;
   v:byte;
begin
try
//defaults
result:=false;
k:=nil;
x:=nil;
j:=nil;
//check
if not ikeymodified then
   begin
   result:=true;
   exit;
   end;//end of if
//init
k:=bnew;
x:=bnew;
j:=bnew;


//PASSWORD KEY
//.password
x.text:=strcopy1(ipassword,1,klimit);
if (x.len<2) then x.text:=strcopy1(x.text+'O3ksiaAlkasdr',1,klimit);//13jun2022
//.fill
repeat
//..get
if not frs(x,j,tbtFeedback) then goto skipend;
//..set
k.add(x);//was: k:=k+x;
x.replace:=k;//was: x:=k;
until (k.len>=klimit);
//.trim to "klimit"
if (k.len>klimit) then k.setlen(klimit);//was: k:=copy(k,1,klimit);
//.finalise
if not frs(k,j,tbtFeedback) then goto skipend;
//.set
ikey:=k.text;

//RANDOM KEY
//.setup
x.clear;
k.clear;
j.clear;
maxp:=frcrange(ipower,2,klimit);
//.random
for p:=1 to maxp do
begin
v:=random(256);
if (v=5) then v:=13+random(65)
else if (v=79) then v:=random(19)+100
else if (v=201) then v:=9+random(200);
x.addbyt1(v);//was: x:=x+chr(v);
end;//p
//.fill
repeat
//..get
if not frs(x,j,tbtFeedback) then goto skipend;
//..set
k.add(x);//was: k:=k+x;
x.replace:=k;//was: x:=k;
until (k.len>=klimit);
//.trim to "klimit"
if (k.len>klimit) then k.setlen(klimit);//was: k:=copy(k,1,klimit);
//.finalise
if not frs(k,j,tbtFeedback) then goto skipend;
//.set
ikeyrandom:=k.text;
//successful
ikeymodified:=false;
result:=true;
skipend:
except;end;
try
bfree(k);
bfree(x);
bfree(j);
except;end;
end;
//## frs ##
function ttbt.frs(s,d:tstr8;m:byte):boolean;//feedback randomisation of string - 16sep2017, 16nov2016
label
   skipend;
var//New and improved: OLD ~20Mb/sec, NEW ~33Mb/sec => 65% faster
   slen,dlen,o1,r1,r2,r3,x1,x2,x3,y1,y2,y3,p:longint;
begin
try
//defaults
result:=false;
if not low__true2(block(s),block(d)) then goto skipend;
//init
slen:=s.len;
dlen:=d.len;
//check
if (slen<2) then goto skipend;
//init
o1:=s.pbytes[0];//13jun2022
//get
for p:=1 to slen do
begin
//..r1-r3
//was: r1:=sref[p];
//was: if (p<slen) then r2:=sref[p+1] else r2:=o1;
//was:if (p>1) then r3:=sref[p-1] else r3:=0;
r1:=s.pbytes[p-1];
if (p<slen) then r2:=s.pbytes[p] else r2:=o1;
if (p>1) then r3:=s.pbytes[p-2] else r3:=0;
//..y1-y3
y1:=r1 div 16;
y2:=r2 div 16;
y3:=r3 div 16;
//..x1-x3
x1:=r1-y1*16;
x2:=r2-y2*15;//* - throws random rounding
x3:=r3-y3*16;
//..set
//was: sref[p]:=((x1+x3)+(y2*16)+3) mod 256;//s[p]
//was: if (p<slen) then sref[p+1]:=(x2+(x1*4+x3*2)) mod 256;//s[p+1]
s.pbytes[p-1]:=((x1+x3)+(y2*16)+3) mod 256;//s[p]
if (p<slen) then s.pbytes[p]:=(x2+((x1*4)+(x3*2))) mod 256;//s[p+1]
end;//p
//mode
if (m<>tbtFeedback) and (dlen>=1) and (dlen<=slen) then
   begin
   //.Was This:
   //if (m=tbtEncode)      then for p:=1 to dlen do dref[p]:=(sref[p]+dref[p]) mod 256
   //else if (m=tbtDecode) then for p:=1 to dlen do dref[p]:=(dref[p]-sref[p]) mod 256;

   //.But Now Is: -> Note the new "byte(...)" boundary that protects against "negative values"
   // and therefore prevents exceptions from happening - 16sep2017
   //was: if (m=tbtEncode)      then for p:=1 to dlen do dref[p]:=byte((sref[p]+dref[p]) mod 256)
   //was: else if (m=tbtDecode) then for p:=1 to dlen do dref[p]:=byte((dref[p]-sref[p]) mod 256);
   if (m=tbtEncode)      then for p:=1 to dlen do d.pbytes[p-1]:=byte((s.pbytes[p-1]+d.pbytes[p-1]) mod 256)
   else if (m=tbtDecode) then for p:=1 to dlen do d.pbytes[p-1]:=byte((d.pbytes[p-1]-s.pbytes[p-1]) mod 256);
   end;
//successful
result:=true;
skipend:
except;end;
try
bunlockautofree(s);
bunlockautofree(d);
except;end;
end;
//## keyid ##
function ttbt.keyid(x:tstr8;var id:integer):boolean;
var
   xlen,tmp,p:integer;
   v:byte;
begin
try
//defaults
result:=false;
id:=0;
tmp:=0;
//check
if not block(x) then exit;
//setup
xlen:=x.len;
tmp:=xlen;
//get
for p:=1 to xlen do
begin
//was: v:=byte(x[p]);
v:=x.pbytes[p-1];
inc(tmp,v);
//"even" values:
if (((p div 2)*2)=p) then
   begin
   if (v<100) then inc(tmp,3)
   else if (v>200) then inc(tmp,357);
   end
else
   begin
   if (v<51) then inc(tmp,71)
   else if (v=93) then inc(tmp,191)
   else if (v=101) then inc(tmp,191)
   else if (v=104) then inc(tmp,191)
   else if (v>130) then inc(tmp,191);
   end;
end;//p
//successful
result:=true;
id:=tmp;
except;end;
try;bunlockautofree(x);except;end;
end;
//## encode ##
function ttbt.encode(s,d:tstr8;var e:string):boolean;
label
   skipend;
const
   klimit=1000;
var
   i4:tint4;
   cc,sLEN,cs,rc,p:integer;
   tmp,h,j,k,kr:tstr8;
   ref64,ref64b:comp;
begin
try
//defaults
result:=false;
tmp:=nil;
h:=nil;
j:=nil;
k:=nil;
kr:=nil;
//check
if not low__true2(block(s),block(d)) then goto skipend;
//init
d.clear;
cs:=0;
sLEN:=s.len;
tmp:=bnew;
h:=bnew;
j:=bnew;
k:=bnew;
kr:=bnew;
//init
e:=gecUnexpectedError;
if not keyinit then exit;
k.text:=ikey;
kr.text:=ikeyrandom;
//.offset checksum using keyID (password key)
if not keyid(k,cs) then exit;
rc:=2+random(21);//2..22 (old system was 0..15)
e:=gecOutOfMemory;
ref64:=ms64;
ref64b:=ms64;
//get
//.create header key "encrypt random key (1..12)"
tmp.replace:=kr;
for p:=1 to ((rc div 2)+1) do if not frs(k,tmp,tbtEncode) then goto skipend;
//.feedback randomise "kr"
for p:=1 to rc do if not frs(kr,j,tbtFeedback) then goto skipend;
//.header                    //pos=6,7,8,9=checksum
//was: pushb(dLEN,d,'TBT3'+char(rc)+#0#0#0#0+from32bit(sLEN)+tmp);
d.sadd('TBT3');
d.aadd([rc,0,0,0,0]);
d.addint4(sLEN);
d.add(tmp);
tmp.clear;
//.encrypt
sysstatus(ref64b,sysstatus_encrypt,'Encrypting'+#9+low__percentage64str(1,1,true));//100%
cc:=0;
p:=1;
while true do
begin
//.get
tmp.clear;
tmp.add31(s,p,klimit);//was: tmp:=copy(s,p,klimit);
//.set
if (tmp.len<=0) then break
else
   begin
   //.cs
   inc(cs,tmp.pbytes[0]);//was: inc(cs,byte(tmp[1]));
   //.encode
   if not frs(kr,tmp,tbtEncode) then goto skipend;
   //.store
   d.add(tmp);//was: pushb(dLEN,d,tmp);
   //.breath - 02mar2015
   inc(cc);
   if (cc>=50) then
      begin
      if obreath and (ms64>ref64) then
         begin
         app__processmessages;
         ref64:=ms64+200;
         end;
      //.system status - 04oct2022
      if sysstatus(ref64b,sysstatus_encrypt,'Encrypting'+#9+low__percentage64str(p,sLEN,true)) then
         begin
         e:=gecTaskcancelled;
         goto skipend;
         end;
      cc:=0;
      end;
   end;
//inc
inc(p,klimit);
end;//loop
//.insert check sum value into header
i4.val:=cs;
//d[6]:=i4.chars[0];
//d[7]:=i4.chars[1];
//d[8]:=i4.chars[2];
//d[9]:=i4.chars[3];
d.pbytes[6-1]:=i4.bytes[0];
d.pbytes[7-1]:=i4.bytes[1];
d.pbytes[8-1]:=i4.bytes[2];
d.pbytes[9-1]:=i4.bytes[3];
//successful
result:=true;
skipend:
except;end;
try
bfree(tmp);
bfree(h);
bfree(j);
bfree(k);
bfree(kr);
bunlockautofree(s);
bunlockautofree(d);
except;end;
end;
//## encode4 ##
function ttbt.encode4(s,d:tstr8;var e:string):boolean;
begin
try
result:=false;
if low__true2(block(s),block(d)) then
   begin
   d.clear;
   if encodeLITE4(s,e) then
      begin
      e:=gecOutOfMemory;
      result:=d.add(s);
      end;
   end;
except;end;
try
bunlockautofree(s);
bunlockautofree(d);
except;end;
end;
//## encodeLITE4 ##
function ttbt.encodeLITE4(s:tstr8;e:string):boolean;
label
   skipend;
var
   i4:tint4;
   pw2,cc,sLEN,dLEN,cs,rc,p:integer;
   dHDR,tmp,h,j,k,kr:tstr8;
   pw:twrd2;
   int1:longint;
   ref64,ref64b:comp;
begin
try
//defaults
result:=false;
dHDR:=nil;
tmp:=nil;
h:=nil;
j:=nil;
k:=nil;
kr:=nil;
//check
if not block(s) then exit;
//init
dHDR:=bnew;
tmp:=bnew;
h:=bnew;
j:=bnew;
k:=bnew;
kr:=bnew;
cs:=0;
slen:=s.len;
dlen:=0;
//init
e:=gecUnexpectedError;
if not keyinit then exit;
pw2:=ipower;
pw.val:=pw2;
k.text:=strcopy1(ikey,1,pw2);
kr.text:=strcopy1(ikeyrandom,1,pw2);
//.offset checksum using keyID (password key)
if not keyid(k,cs) then exit;
rc:=2+random(21);//2..22 (old system was 0..15)
e:=gecOutOfMemory;
//get
//.create header key "encrypt random key (1..12)"
tmp.replace:=kr;
for p:=1 to ((rc div 2)+1) do if not frs(k,tmp,tbtEncode) then goto skipend;
//.feedback randomise "kr"
for p:=1 to rc do if not frs(kr,j,tbtFeedback) then goto skipend;
//.header                    //pos=6,7,8,9=checksum      //length of key (power)
//was: dHDR:='TBT4'+char(rc)+#0#0#0#0+from32bit(sLEN)+pw.chars[0]+pw.chars[1]+tmp;//02JAN2012
dHDR.sadd('TBT4');
dHDR.aadd([rc,0,0,0,0]);
dHDR.addint4(sLEN);
dHDR.aadd([pw.bytes[0],pw.bytes[1]]);
dHDR.add(tmp);//02JAN2012
tmp.clear;
//.encrypt
ref64:=ms64;
ref64b:=ms64;
cc:=0;
p:=1;
//get
sysstatus(ref64b,sysstatus_encrypt,'Encrypting'+#9+low__percentage64str(1,1,true));//100%
while true do
begin
//.get
tmp.clear;
tmp.add31(s,p,pw2);//was: tmp:=copy(s,p,pw2);
//.set
if (tmp.len<=0) then break
else
   begin
   //.cs
   inc(cs,tmp.pbytes[0]);//was: inc(cs,byte(tmp[1]));
   //.encode
   if not frs(kr,tmp,tbtEncode) then goto skipend;
   //.store -> faster than using "push" - 16nov2016
   //was: dref:=pdlbyte1(pchar(tmp));
   //was: for int1:=length(tmp) downto 1 do sref[dlen+int1]:=dref[int1];
   //was: inc(dlen,length(tmp));
   for int1:=tmp.len downto 1 do s.pbytes[dlen+int1-1]:=tmp.pbytes[int1-1];
   inc(dlen,tmp.len);
   //.breath - 02mar2015
   inc(cc);
   if (cc>=50) then
      begin
      if obreath and (ms64>ref64) then
         begin
         app__processmessages;
         ref64:=ms64+100;
         end;
      //.system status - 04oct2022
      if sysstatus(ref64b,sysstatus_encrypt,'Encrypting'+#9+low__percentage64str(p,sLEN,true)) then
         begin
         e:=gecTaskcancelled;
         goto skipend;
         end;
      cc:=0;
      end;
   end;
//inc
inc(p,pw2);
end;//loop
//.finalise
if (dlen<>slen) then s.setlen(dlen);
//.insert check sum value into header
i4.val:=cs;
//dHDR[6]:=i4.chars[0];
//dHDR[7]:=i4.chars[1];
//dHDR[8]:=i4.chars[2];
//dHDR[9]:=i4.chars[3];
dHDR.pbytes[6-1]:=i4.bytes[0];
dHDR.pbytes[7-1]:=i4.bytes[1];
dHDR.pbytes[8-1]:=i4.bytes[2];
dHDR.pbytes[9-1]:=i4.bytes[3];
//.insert header before "s"
if not s.ins(dHDR,0) then goto skipend;
//successful
result:=true;
skipend:
except;end;
try
bfree(dHDR);
bfree(tmp);
bfree(h);
bfree(j);
bfree(k);
bfree(kr);
bunlockautofree(s);
except;end;
end;
//## decode ##
function ttbt.decode(s,d:tstr8;var e:string):boolean;
begin
try
result:=false;
if low__true2(block(s),block(d)) then
   begin
   d.clear;
   if decodeLITE(s,e) then
      begin
      e:=gecOutOfMemory;
      result:=d.add(s);
      end;
   end;
except;end;
try
bunlockautofree(s);
bunlockautofree(d);
except;end;
end;
//## decodeLITE ##
function ttbt.decodeLITE(s:tstr8;var e:string):boolean;//uses minimal RAM - 02JAN2012
label
   skipend;
const
   klimit=1000;
var
   i4:tint4;
   int1,startpos,klen,v,cc,slen,dlen,cl,cs,rc,p:longint;
   tmp,h,j,k,kr:tstr8;
   v3,v4:boolean;
   pw:twrd2;
   ref64,ref64b:comp;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
tmp:=nil;
h:=nil;
j:=nil;
k:=nil;
kr:=nil;
//check
if not block(s) then exit;
//init
v3:=false;
v4:=false;
cs:=0;
dlen:=0;
slen:=s.len;
startpos:=1;
klen:=0;
if not keyinit then goto skipend;
tmp:=bnew;
h:=bnew;
j:=bnew;
k:=bnew;
kr:=bnew;
//get
//.header
e:=gecDataCorrupt;
if      s.asame3(0,[uuT,uuB,uuT,nn4],false) and (sLEN>=15)   then v4:=true
else if s.asame3(0,[uuT,uuB,uuT,nn3],false) and (sLEN>=1013) then v3:=true
else
   begin
   e:=gecUnknownFormat;
   goto skipend;
   end;
//.read
//was: rc:=byte(s[5]);
//was: cs:=to32bit(copy(s,6,4));
//was: cl:=to32bit(copy(s,10,4));
rc:=s.pbytes[5-1];
cs:=s.int4[6-1];
cl:=s.int4[10-1];
if (cs<0) or (cl<0) then goto skipend;
//.version
if v3 then
   begin
   //get
   if ((cl+1013)>sLEN) then goto skipend;
   kr.clear;
   kr.add31(s,14,klimit);//was: kr:=copy(s,14,klimit);
   klen:=kr.len;
   startpos:=1014;
   //check
   if (klen<>klimit) then goto skipend;
   end
else if v4 then
   begin
   //get
   pw.bytes[0]:=s.pbytes[14-1];//was: pw.chars[0]:=s[14];
   pw.bytes[1]:=s.pbytes[15-1];//was: pw.chars[1]:=s[15];
   if (pw.val<2) or (pw.val>1000) then goto skipend;//enforce range of 2..1000 (upto 8000bit)
   if ((cl+pw.val+15)>sLEN) then goto skipend;
   kr.clear;
   kr.add31(s,16,pw.val);//was: kr:=copy(s,16,pw.val);
   klen:=kr.len;
   startpos:=15+klen+1;
   //check
   if (klen<>pw.val) then goto skipend;
   end;
//.keyid
k.text:=strcopy1(ikey,1,klen);
if not keyid(k,v) then exit;
//..cs
e:=gecAccessDenied;
dec(cs,v);
if (cs<0) then goto skipend;
//.recover header key "decrypt random key"
for p:=1 to ((rc div 2)+1) do if not frs(k,kr,tbtDecode) then goto skipend;
//.feedback randomise "kr"
for p:=1 to rc do if not frs(kr,j,tbtFeedback) then goto skipend;
//.decrypt
ref64:=ms64;
ref64b:=ms64;
cc:=0;
p:=startpos;
sysstatus(ref64b,sysstatus_encrypt,'Decrypting'+#9+low__percentage64str(1,1,true));//100%
//get
while true do
begin
//.get
tmp.clear;
tmp.add31(s,p,klen);//was: tmp:=copy(s,p,klen);
//.set
if (tmp.len<=0) then break
else
   begin
   //.decode
   if not frs(kr,tmp,tbtDecode) then goto skipend;
   //.store -> faster than using "push" - 16nov2016
   //was: dref:=pdlbyte1(pchar(tmp));
   //was: for int1:=length(tmp) downto 1 do sref[dlen+int1]:=dref[int1];
   //was: inc(dlen,length(tmp));
   for int1:=tmp.len downto 1 do s.pbytes[dlen+int1-1]:=tmp.pbytes[int1-1];
   inc(dlen,tmp.len);
   //.cs
   dec(cs,tmp.pbytes[0]);
   if (cs<0) then
      begin
      e:=gecAccessDenied;
      goto skipend;
      end;
   //.stop
   if (dlen>=cl) then break;
   //.breath - 02mar2015
   inc(cc);
   if (cc>=50) then
      begin
      if obreath and (ms64>ref64) then
         begin
         app__processmessages;
         ref64:=ms64+100;
         end;//end of if
      //.system status - 04oct2022
      if sysstatus(ref64b,sysstatus_encrypt,'Decrypting'+#9+low__percentage64str(p,sLEN,true)) then
         begin
         e:=gecTaskcancelled;
         goto skipend;
         end;
      cc:=0;
      end;
   end;
//inc
inc(p,klen);
end;//loop
//.finalise
if (slen<>dlen) then s.setlen(dlen);//was: setlength(s,dlen);
//.check
if (cs<>0) then goto skipend;
//.size/finalise
if (s.len>cl) then s.setlen(cl);//was: setlength(s,cl);
//successful
result:=(s.len=cl);
skipend:
except;end;
try
bfree(tmp);
bfree(h);
bfree(j);
bfree(k);
bfree(kr);
bunlockautofree(s);
except;end;
end;
{$else}
//## low__encrypt ##
function low__encrypt(s:tstr8;xpass:string;xpower:longint;xencrypt:boolean;var e:string):boolean;
begin
try
result:=false;
e:=gecTaskfailed;
bautofree(s);
except;end;
end;
//## low__encrypt2 ##
function low__encrypt2(s,d:tstr8;xpass:string;xpower:longint;xencrypt:boolean;var e:string):boolean;
begin
try
result:=false;
e:=gecTaskfailed;
bautofree(s);
bautofree(d);
except;end;
end;

{$endif}

//GIF
//## thashtable ################################################################
{$ifdef gif}
//## gif_decompress ##
procedure gif_decompress(x:tstr8);//28jul2021, 11SEP2007
var
   p:integer;
   z:tstr8;
begin
try
//init
z:=nil;
p:=1;
if block(x) then x.clear else exit;
//get
z:=bnew;
gif_decompressex(p,x,z,0,0,false);
//set
x.add(z);
except;end;
try
bunlockautofree(x);
bfree(z);
except;end;
end;
//## gif_decompressex ##
procedure gif_decompressex(var xlenpos1:integer;x,imgdata:tstr8;_width,_height:integer;interlaced:boolean);//11SEP2007
label
   skipend;
const
  GIFCodeBits=12;// Max number of bits per GIF token code
  GIFCodeMax=(1 SHL GIFCodeBits)-1;//Max GIF token code,12 bits=4095
  StackSize=(2 SHL GIFCodeBits);//Size of decompression stack
  TableSize=(1 SHL GIFCodeBits);//Size of decompression table
var
   tmprow,xlen:longint;
   table0:array[0..TableSize-1] of longint;
   table1:array[0..TableSize-1] of longint;
   firstcode,oldcode:integer;
   buf:array[0..257] of BYTE;
   v,xpos,ypos,pass:integer;
   stack:array[0..StackSize-1] of longint;
   Source:^integer;
   BitsPerCode:integer;//number of CodeTableBits/code
   InitialBitsPerCode:BYTE;
   MaxCode,MaxCodeSize,ClearCode,EOFCode,step,i,StartBit,LastBit,LastByte:longint;
   get_done,return_clear,ZeroBlock:boolean;
   ClearValue:BYTE;

//## read ##
function read(a:pointer;len:integer):longint;
var
   b:pdlByte;
   i:longint;
begin
try
//defaults
result:=0;
//init
b:=a;
//process
for i:=1 to len do if (xlenpos1<=xlen) then
   begin
   b[result]:=x.bytes1[xlenpos1];
   inc(result);
   inc(xlenpos1);
   end
else break;
except;end;
end;
//## nextCode ##
function nextCode(BitsPerCode: longint): longint;
const
   masks:array[0..15] of integer=($0000,$0001,$0003,$0007,$000f,$001f,$003f,$007f,$00ff,$01ff,$03ff,$07ff,$0fff,$1fff,$3fff,$7fff);
var
   p2,StartIndex,EndIndex,ret,EndBit:integer;
   count:BYTE;
begin
try
//defaults
result:=-1;
//check
if return_clear then
   begin
   return_clear:=false;
   result:=ClearCode;
   exit;
   end;//end of if
//get
EndBit:=StartBit+BitsPerCode;
if (EndBit>=LastBit) then
   begin
   if get_done then
      begin
      if (StartBit>=LastBit) then result:=-1;
      exit;
      end;//end of if
   buf[0]:=buf[LastByte-2];
   buf[1]:=buf[LastByte-1];
   //.count
   if (xlenpos1>xlen) then
      begin
      result:=-1;
      exit;
      end
   else
      begin
      count:=byte(x.bytes1[xlenpos1]);
      inc(xlenpos1);
      end;//end of if
   //.check
   if (count=0) then
      begin
      ZeroBlock:=True;
      get_done:=TRUE;
      end
   else
      begin
      //handle premature end of file
      if ((1+xlen-xlenpos1)<count) then
         begin
         //Not enough data left - Just read as much as we can get
         Count:=xlen-xlenpos1+1;
         end;//end of if
      if (Count<>0) and (read(@buf[2],count)<>count) then exit;//out of data
      end;//end of if
   LastByte:=2+count;
   StartBit:=(StartBit-LastBit)+16;
   LastBit:=LastByte*8;
   EndBit:=StartBit+BitsPerCode;
   end;//end of if
//set
EndIndex:=EndBit div 8;
StartIndex:=StartBit div 8;
//check
if (startindex>high(buf)) then exit;//out of range
if (StartIndex=EndIndex) then ret:=buf[StartIndex]
else if ((StartIndex+1)=EndIndex) then ret:=buf[StartIndex] or (buf[StartIndex+1] shl 8)
else ret:=buf[StartIndex] or (buf[StartIndex+1] shl 8) or (buf[StartIndex+2] shl 16);
ret:=(ret shr (StartBit and $0007)) and masks[BitsPerCode];
inc(StartBit,BitsPerCode);
result:=ret;
except;end;
end;
//## NextLZW ##
function NextLZW:longint;
var
   code,incode,i:longint;
   b:byte;
begin
try
//defaults
result:=-1;
//scan
code:=nextCode(BitsPerCode);
while (code>=0) do
begin
if (code=ClearCode) then
   begin
   //check
   if (clearcode>tablesize) then exit;//out of range
   for i:=0 to (ClearCode-1) do
   begin
   table0[i]:=0;
   table1[i]:=i;
   end;//loop

   for i:=ClearCode to (TableSize-1) do
   begin
   table0[i]:=0;
   table1[i]:=0;
   end;//end of loop
   BitsPerCode:=InitialBitsPerCode+1;
   MaxCodeSize:=2*ClearCode;
   MaxCode:=ClearCode+2;
   Source:=@stack;

   repeat
   firstcode:=nextCode(BitsPerCode);
   oldcode:=firstcode;
   until (firstcode<>ClearCode);
   Result := firstcode;
   exit;
   end;//if
//.eof
if (code=EOFCode) then
   begin
   Result:=-2;
   if ZeroBlock then exit;
   //eat blank data (all 0's)
   //--ignore
   exit;
   end;//if

incode:=code;
if (code>=MaxCode) then
   begin
   Source^:=firstcode;
   Inc(Source);
   code:=oldcode;
   end;//if
//check
if (Code>TableSize) then exit;//out of range

 while (code>=ClearCode) do
 begin
 Source^:=table1[code];
 Inc(Source);
 //check
 if (code=table0[code]) then exit;//error
 code:=table0[code];
 //check
 if (Code>TableSize) then exit;
 end;//loop

firstcode:=table1[code];
Source^:=firstcode;
Inc(Source);
code:=MaxCode;
if (code<=GIFCodeMax) then
   begin
   table0[code]:=oldcode;
   table1[code]:=firstcode;
   Inc(MaxCode);
   if ((MaxCode>=MaxCodeSize) and (MaxCodeSize<=GIFCodeMax)) then
      begin
      MaxCodeSize:=MaxCodeSize*2;
      Inc(BitsPerCode);
      end;//end of if
   end;//if
oldcode:=incode;
if (longInt(Source)>longInt(@stack)) then
   begin
   Dec(Source);
   Result:=Source^;
   exit;
   end
end;//loop
Result:=code;
except;end;
end;
//## readLZW ##
function readLZW:longint;
begin
try
if (longInt(Source)>longInt(@stack)) then
   begin
   Dec(Source);
   Result:=Source^;
   end
else Result:=NextLZW;
except;end;
end;

//START
begin
try
//check
if not low__true2(block(x),block(imgdata)) then goto skipend;

//init
xlen:=x.len;
imgdata.clear;
if (xlenpos1<1) or (xlenpos1>xlen) then goto skipend;
//get
if (xlenpos1>xlen) then goto skipend;
InitialBitsPerCode:=x.bytes1[xlenpos1];
inc(xlenpos1);
imgdata.setlen(_width*_height);//was: setlength(imgdata,_width*_height);
//Initialize the Compression routines
BitsPerCode:=InitialBitsPerCode+1;
ClearCode:=1 shl InitialBitsPerCode;
EOFCode:=ClearCode+1;
MaxCodeSize:=2*ClearCode;
MaxCode:=ClearCode+2;
StartBit:=0;
LastBit:=0;
LastByte:=2;
ZeroBlock:=false;
get_done:=false;
return_clear:=true;
Source:=@stack;
try
if interlaced then
   begin
   ypos:=0;
   pass:=0;
   step:=8;
   for i:=0 to (_Height-1) do
   begin
   tmprow:=_width*ypos;
    for xpos:=0 to (_width-1) do
    begin
    v:=readLZW;
    if (v<0) then exit;
    imgdata.bytes1[1+tmprow+xpos]:=byte(v);
    end;//end of loop
   //inc
   Inc(ypos,step);
   if (ypos>=_height) then
      begin
      repeat
      if (pass>0) then step:=step div 2;
      Inc(pass);
      ypos := step DIV 2;
      until (ypos < _height);
      end;//if
   end;//loop
   end
else
   begin
   if (_width>=1) and (_height>=1) then
      begin
      for ypos:=0 to ((_height*_width)-1) do
      begin
      v:=readLZW;
      if (v<0) then exit;
      imgdata.bytes1[1+ypos]:=byte(v);
      end;//end of loop
      end
   else
      begin//decompress raw data string (width and height are not used
      tmprow:=1;
      while true do
      begin
      v:=readLZW;
      if (v<0) then exit;//done
      imgdata.bytes1[tmprow]:=byte(v);
      inc(tmprow);
      end;//loop
      end;//if
   end;//if
except;end;
//too much data
if (readLZW>=0) then
   begin
   //ignore
   end;//if
skipend:
except;end;
try
bunlockautofree(x);
bunlockautofree(imgdata);
except;end;
end;
//## gif_compress ##
function gif_compress(x:tstr8;var e:string):boolean;//12SEP2007
var
   z:tstr8;
begin
try
//defaults
result:=false;
z:=nil;
if not block(x) then exit;
z:=bnew;
//get
if gif_compressex(x,z,e) then
   begin
   x.clear;
   x.add(z);
   result:=true;
   end;
except;end;
try
bfree(z);
bunlockautofree(x);
except;end;
end;
//## gif_compressex ##
function gif_compressex(x,imgdata:tstr8;e:string):boolean;//12SEP2007
label
   skipend;
const
   EndBlockByte=$00;			// End of block marker
var
   h:thashtable;
   buf:tstr8;
   NewCode,Prefix,FreeEntry:smallint;
   NewKey:longint;
   Color:byte;
   ClearFlag:boolean;
   MaxCode,EOFCode,BaseCode,ClearCode:smallint;
   maxcolor,xlen,xpos,BitsPerCode,OutputBits,OutputBucket:longint;
   BitsPerPixel,InitialBitsPerCode:byte;

//## MaxCodesFromBits ##
function MaxCodesFromBits(bits:integer):smallint;
begin
try;result:=(smallint(1) shl bits)-1;except;end;
end;
//## writechar ##
procedure writechar(x:byte);//15SEP2007
begin//"x=nil" => flush
try
//get
buf.addbyt1(x);
//set
if (buf.len>=255) then
   begin
   //was:pushb(imglen,imgdata,char(length(buf))+buf);
   imgdata.addbyt1(buf.len);
   imgdata.add(buf);
   buf.clear;
   end;
except;end;
end;
//## writecharfinish ##
procedure writecharfinish;
begin//"x=nil" => flush
try
if (buf.len>=1) then
   begin
   //was:pushb(imglen,imgdata,char(length(buf))+buf);
   imgdata.addbyt1(buf.len);
   imgdata.add(buf);
   buf.clear;
   end;
except;end;
end;
//## output ##
procedure output(value:integer);
const
  BitBucketMask: array[0..16] of longInt =
    ($0000,
     $0001, $0003, $0007, $000F,
     $001F, $003F, $007F, $00FF,
     $01FF, $03FF, $07FF, $0FFF,
     $1FFF, $3FFF, $7FFF, $FFFF);
begin
try
//get
if (OutputBits > 0) then OutputBucket := (OutputBucket AND BitBucketMask[OutputBits]) OR (longInt(Value) SHL OutputBits)
else OutputBucket := Value;
inc(OutputBits, BitsPerCode);
//set
while (OutputBits >= 8) do
begin
writechar(OutputBucket and $FF);//was: writechar(char(OutputBucket and $FF));
OutputBucket:=OutputBucket shr 8;
dec(OutputBits,8);
end;//end of loop
//check
if (Value = EOFCode) then
   begin
   // At EOF, write the rest of the buffer.
   while (OutputBits > 0) do
   begin
   writechar(OutputBucket and $FF);//was: writechar(char(OutputBucket and $FF));
   OutputBucket := OutputBucket shr 8;
   dec(OutputBits, 8);
   end;//end of loop
   end;//end of if
// If the next entry is going to be too big for the code size,
// then increase it, if possible.
if (FreeEntry > MaxCode) or (ClearFlag) then
   begin
   if (ClearFlag) then
      begin
      BitsPerCode := InitialBitsPerCode;
      MaxCode := MaxCodesFromBits(BitsPerCode);
      ClearFlag := False;
      end
   else
      begin
      inc(BitsPerCode);
      if (BitsPerCode=GIFCodeBits) then MaxCode:=GIFTableMaxMaxCode
      else MaxCode:=MaxCodesFromBits(BitsPerCode);
      end;//end of if
   end;//end of if
except;end;
end;

begin
try
//defaults
result:=false;
h:=nil;
buf:=nil;
//check
if not low__true2(block(x),block(imgdata)) then goto skipend;
imgdata.clear;
e:=gecUnexpectedError;
//init
xlen:=x.len;
xpos:=1;
if (xlen<=2) then goto skipend;
h:=thashtable.create;
buf:=bnew;
maxcolor:=256;
BitsPerPixel:=8;//bits per pixel - fixed at 8, don't go below 2
InitialBitsPerCode:=BitsPerPixel+1;
BitsPerCode:=InitialBitsPerCode;
MaxCode:=MaxCodesFromBits(BitsPerCode);
ClearCode:=(1 SHL (InitialBitsPerCode-1));
EOFCode:=ClearCode+1;
BaseCode:=EOFCode+1;
//.clear bit bucket
OutputBucket:=0;
OutputBits:=0;
imgdata.addbyt1(BitsPerPixel);//was: pushb(imglen,imgdata,char(BitsPerPixel));

//clear - hash table and sync decoder
clearflag:=true;
output(clearcode);
h.clear;
freeentry:=clearcode+2;
//get
prefix:=smallint(x.bytes1[xpos]);//was: x[xpos]);
if (Prefix>=MaxColor) then
   begin
   e:=gecIndexOutOfRange;
   goto skipend;
   end;
while true do
begin
//.inc
inc(xpos);
if (xpos>xlen) then break;
//.get
color:=x.bytes1[xpos];//was: x[xpos];
if (color>=maxcolor) then
   begin
   e:=gecIndexOutOfRange;
   goto skipend;
   end;//end of if
//append postfix to prefix and lookup in table...
NewKey := (longint(Prefix) SHL 8) OR Color;
NewCode := h.lookup(NewKey);
if (NewCode >= 0) then
   begin
   // ...if found, get next pixel
   prefix:=newcode;
   //skip to next item
   continue;
   end;//end of if
// ...if not found, output and start over
output(prefix);
prefix:=smallint(color);
if (FreeEntry < GIFTableMaxFill) then
   begin
   h.insert(NewKey, FreeEntry);
   inc(FreeEntry);
   end
else
   begin
   //clear
   clearflag:=true;
   output(clearcode);
   h.clear;
   freeentry:=clearcode+2;
   end;//end of if
end;//loop
output(prefix);
skipend:
//finalise - 15SEP2007
output(EOFCode);
writecharfinish;
imgdata.addbyt1(EndBlockByte);//was: //writechar('');pushb(imglen,imgdata,char(EndBlockByte));pushb(imglen,imgdata,'');
//successful
result:=true;
except;end;
try
freeobj(@h);
bfree(buf);
bunlockautofree(x);
bunlockautofree(imgdata);
except;end;
end;
//## hashkey ##
function hashkey(key:longint):smallint;
begin
try
result:=smallint(((Key SHR (GIFCodeBits-8)) XOR Key) MOD HashSize);
except;end;
end;
//## nexthashkey ##
function nexthashkey(hkey:smallint):smallint;
var
  disp:smallint;
begin
try
//defaults
result:=0;
//secondary hash (after G. Knott)
disp:=HashSize-HKey;
if (HKey=0) then disp:=1;
//disp := 13;		// disp should be prime relative to HashSize, but
			// it doesn't seem to matter here...
dec(HKey,disp);
if (HKey<0) then inc(HKey,HashSize);
Result:=HKey;
except;end;
end;
//## create ##
constructor thashtable.create;
begin//longInt($FFFFFFFF) = -1, 'TGIFImage implementation assumes $FFFFFFFF = -1');
inherited create;
getmem(hashtable,sizeof(thasharray));
clear;
end;
//## destroy ##
destructor thashtable.destroy;
begin
try
freemem(hashtable);
inherited destroy;
except;end;
end;
//## clear ##
procedure thashtable.clear;
begin
try;fillchar(hashtable^,sizeof(thasharray),$FF);except;end;
end;
//## insert  ##
procedure thashtable.insert(key:longint;code:smallint);
var
   hkey:smallint;
begin
try
//Create hash key from prefix string
hkey:=hashkey(key);
//Scan for empty slot
//while (HashTable[HKey] SHR GIFCodeBits <> HashEmpty) do { Unoptimized }
while (hashtable[hkey] and (hashempty shl gifcodebits)<>(hashempty shl gifcodebits)) do hkey:=nexthashkey(hkey);
//Fill slot with key/value pair
hashtable[hkey]:=(key shl gifcodebits) or (code and gifcodemask);
except;end;
end;
//## lookup ##
function thashtable.lookup(key:longInt):smallint;
var
// Search for key in hash table.
// Returns value if found or -1 if not
  hkey:smallint;
  htkey:longInt;
begin
try
// Create hash key from prefix string
HKey := HashKey(Key);
// Scan table for key
// HTKey := HashTable[HKey] SHR GIFCodeBits; { Unoptimized }
Key := Key SHL GIFCodeBits; { Optimized }
HTKey := HashTable[HKey] AND (HashEmpty SHL GIFCodeBits); { Optimized }
// while (HTKey <> HashEmpty) do { Unoptimized }
while (HTKey <> HashEmpty SHL GIFCodeBits) do { Optimized }
begin
if (Key = HTKey) then
   begin
   // Extract and return value
   Result := HashTable[HKey] AND GIFCodeMask;
   exit;
   end;
// Try next slot
HKey := NextHashKey(HKey);
// HTKey := HashTable[HKey] SHR GIFCodeBits; { Unoptimized }
HTKey := HashTable[HKey] AND (HashEmpty SHL GIFCodeBits); { Optimized }
end;//end of loop
// Found empty slot - key doesn't exist
Result := -1;
except;end;
end;
//## low__fromgif ##
function low__fromgif(x:tbmp;y:tstr8;var e:string):boolean;//28jul2021, 20JAN2012, 22SEP2009
begin
try;result:=low__fromgif1(x,y,false,e);except;end;
end;
//## low__fromgif ##
function low__fromgif1(x:tbmp;y:tstr8;xuse32:boolean;var e:string):boolean;//28jul2021, 20JAN2012, 22SEP2009
var
   xcellcount,xcellwidth,xcellheight,xdelay,xbpp:longint;
   xtransparent:boolean;
begin
try;result:=low__fromgif3(x,y,xcellcount,xcellwidth,xcellheight,xdelay,xbpp,xuse32,xtransparent,e);except;end;
end;
//## low__fromgif2 ##
function low__fromgif2(x:tbmp;y:tstr8;var xcellcount,xcellwidth,xcellheight,xdelay,xbpp:longint;var xtransparent:boolean;var e:string):boolean;//28jul2021, 20JAN2012, 22SEP2009
begin
try;result:=low__fromgif3(x,y,xcellcount,xcellwidth,xcellheight,xdelay,xbpp,false,xtransparent,e);except;end;
end;
//## low__fromgif3 ##
function low__fromgif3(x:tbmp;y:tstr8;var xcellcount,xcellwidth,xcellheight,xdelay,xbpp:longint;xuse32:boolean;var xtransparent:boolean;var e:string):boolean;//28jul2021, 20JAN2012, 22SEP2009
label//Important Note: WHITE is only ever used for transparent pixels, all other colors are allowed
   skipone,skipend;
const
   //main flags
   pfGlobalColorTable	= $80;		{ set if global color table follows L.S.D. }
   pfColorResolution	= $70;		{ Color resolution - 3 bits }
   pfSort		= $08;		{ set if global color table is sorted - 1 bit }
   pfColorTableSize	= $07;		{ size of global color table - 3 bits }
   //local - image des
   idLocalColorTable	= $80;    { set if a local color table follows }
   idInterlaced		= $40;    { set if image is interlaced }
   idSort		= $20;    { set if color table is sorted }
   idReserved		= $0C;    { reserved - must be set to $00 }
   idColorTableSize	= $07;    { size of color table as above }
type
   pgifpal=^tgifpal;
   tgifpal=record
    c:array[0..255] of tcolor24;
    count:integer;
    init:boolean;
    end;
var
   imgdata,tmp:tstr8;
   xbits,imglimit,imgcount,nx,ny,offx,len,dy,dx,trans,delay,loops,i,p,tmp2,ylen,pos1:longint;
   xmustunlock,alltrans,ok,wait,v87a,v89a:boolean;
   lastdispose,dispose,bgcolor,ci,v2,v:byte;
   s:tgifscreen;
   lp,gp:tgifpal;//global color palette
   pal:pgifpal;//pointer to current palette for image to use
   id:tgifimgdes;
   sr8:pcolorrow8;
   sr24:pcolorrow24;
   sr32:pcolorrow32;
   sc8,zc8:tcolor8;
   sc32,zc32:tcolor32;
   yc24,zc24,tc24:tcolor24;
   lastrect:trect;
   //## palinit ##
   procedure palinit(var x:tgifpal);
   var
      p:integer;
      r,g,b:byte;
   begin
   try
   //check
   if x.init then exit else x.init:=true;
   //swap
   for p:=0 to high(x.c) do
   begin
   //get
   r:=x.c[p].r;
   g:=x.c[p].g;
   b:=x.c[p].b;
   //set - swap r/b elements
   x.c[p].r:=b;
   x.c[p].g:=g;
   x.c[p].b:=r;
   end;//end of loop
   except;end;
   end;
//START
begin//Note: xe=points to an animation structure for storing timing/framecount information, and is optional
try
//defaults
result:=false;
e:=gecUnexpectedError;
xcellcount:=1;
xcellwidth:=1;
xcellheight:=1;
xtransparent:=false;
xdelay:=100;
xbpp:=8;
tmp:=nil;
imgdata:=nil;
//.check y
if not block(y) then goto skipend;
//.bits
xbits:=misb(x);
if (xbits<>8) and (xbits<>24) and (xbits<>32) then goto skipend;
//WARNING: x must be locked to read pixles BUT also must be unlocked to resize -> so we need to switch between the two - 28jul2021
xmustunlock:=not x.locked;
if xmustunlock then x.lock;

//INIT
ylen:=y.len;
if (ylen<6) then exit;
imgcount:=0;
imglimit:=0;
alltrans:=false;
offx:=0;
pos1:=1;
loops:=0;
delay:=0;
pal:=@gp;
dispose:=0;
lastdispose:=0;
//.static transparent color of "WHITE"
tc24.r:=255;
tc24.g:=255;
tc24.b:=255;
//.control items
bgcolor:=0;
trans:=-1;//not in use
wait:=false;
//GET
//header sig (GIF)
if not y.asame3(pos1-1,[uuG,uuI,uuF],false) then//GIF
   begin
   e:=gecUnknownFormat;
   goto skipend;
   end;//end of if
inc(pos1,3);
e:=gecDataCorrupt;
//version
v87a:=y.asame3(pos1-1,[nn8,nn7,llA],false);
v89a:=y.asame3(pos1-1,[nn8,nn9,llA],false);
inc(pos1,3);
if (not v87a) and (not v89a) then goto skipend;

//screen info
if ((pos1+sizeof(s)-1)>ylen) then goto skipend;
if not y.writeto1(@s,sizeof(s),pos1,sizeof(s)) then goto skipend;//was: tostrucb(@s,sizeof(s),copy(y,pos,sizeof(s)));
inc(pos1,sizeof(s));
//.range
s.w:=frcmin(s.w,1);
s.h:=frcmin(s.h,1);
imglimit:=maxint;//yyyyyyyyyyyyy [disabled for huge images on 22SEP2009] 21000 div s.w;//safe number of frames (tbitmap.width=22000+ crashes)
//.global color palette - always empty, since we may have to use it even when we shouldn't be
fillchar(gp,sizeof(gp),0);
if ((s.pf and pfGlobalColorTable)=pfGlobalColorTable) then
   begin
   //get
   gp.count:=2 shl (s.pf and pfColorTableSize);
   if (gp.count<2) or (gp.count>256) then
      begin
      e:=gecIndexOutOfRange;
      goto skipend;
      end;//end of if
   //set
   tmp2:=gp.count*sizeof(tcolor24);
   if ((pos1+tmp2-1)>ylen) then goto skipend;
   y.writeto1(@gp.c,tmp2,pos1,tmp2);//was: tostrucb(@gp.c,tmp2,copy(y,pos,tmp2));
   inc(pos1,tmp2);
   end;//end of if
//init
palinit(gp);
//IMAGES
if (pos1>ylen) then goto skipend;
tmp:=bnew;
imgdata:=bnew;
repeat
v:=y.bytes1[pos1];
//scan
if (v=59) then break//terminator
else if (v<>0) then
   begin
   //init
   inc(pos1);
   if (pos1<=ylen) then v2:=y.bytes1[pos1] else v2:=0;
   //blocks
   if (v=33) then
      begin
      //get - multi-length sub-parts (ie. text blocks etc)
      inc(pos1);
      tmp.clear;
      while true do
      begin
      if (pos1<=ylen) then
         begin
         tmp2:=y.bytes1[pos1];
         tmp.add31(y,pos1+1,tmp2);//was: tmp:=tmp+copy(y,pos+1,tmp2);
         if (tmp2=0) then break else inc(pos1,1+tmp2);
         end
      else break;
      end;//end of loop
      if (tmp.len=0) then goto skipone;
      //set
      case v2 of
      249:begin//control - for image handling
         if (tmp.len<4) then goto skipone;
         tmp2:=tmp.bytes1[1];//was: byte(tmp[1]);
         //.defaults
         bgcolor:=0;
         trans:=-1;//not in use
         wait:=false;
         dispose:=0;
         //.dispose mode
         dispose:=byte(frcrange((tmp2 shl 27) shr 29,0,7));
         //.wait
         if (((tmp2 shl 30) shr 31)>=1) then wait:=true;
         //.bgcolor
         bgcolor:=tmp.bytes1[4];
         //.transparent
         if (((tmp2 shl 31) shr 31)>=1) then trans:=bgcolor;
         //.delay
         inc(delay,frcmin(tmp.sml2[2-1],0));//was: inc(delay,frcmin(to16bit(copy(tmp,2,2),true),0));
         end;//end of begin
      255:begin//loop
         loops:=tmp.sml2[tmp.len-1-1];//was: loops:=to16bit(copy(tmp,length(tmp)-1,2),true);
         end;//end of begin
      254:begin//comment
         //ignore
         end;//end of begin
      1:begin//plain text - displayed on image
         //ignore
         end;//end of begin
      end;//end of case
      end
   else if (v=44) then//image
      begin
      //get
      dec(pos1);
      y.writeto1(@id,sizeof(id),pos1,sizeof(id));//was: tostrucb(@id,sizeof(id),copy(y,pos,sizeof(id)));
      inc(pos1,sizeof(id));
      //range
      id.dx:=frcrange(id.dx,0,s.w);
      id.dy:=frcrange(id.dy,0,s.h);
      id.w:=frcrange(id.w,1,s.w);
      id.h:=frcrange(id.h,1,s.h);
      fillchar(lp,sizeof(lp),0);
      //local palette
      if ((id.pf and idLocalColorTable)=idLocalColorTable) then
         begin
         //get
         lp.count:=2 shl (id.pf and idColorTableSize);
         if (lp.count<2) or (lp.count>256) then
            begin
            e:=gecIndexOutOfRange;
            goto skipend;
            end;//end of if
         //set
         tmp2:=lp.count*sizeof(tcolor24);
         if ((pos1+tmp2-1)>ylen) then goto skipend;
         y.writeto1(@lp.c,tmp2,pos1,tmp2);//was: tostrucb(@lp.c,tmp2,copy(y,pos,tmp2));
         inc(pos1,tmp2);
         //init
         palinit(lp);
         end;//end of if
      if (lp.count=0) then pal:=@gp else pal:=@lp;
      //decompress image
      gif_decompressex(pos1,y,imgdata,id.w,id.h,((id.pf and idInterlaced)<>0));
      //transparency check - if transparent color index is not used, then turn it off!
      ok:=false;
      if (trans>=0) then
         begin
         //check
         v:=byte(trans);
         for p:=1 to imgdata.len do if (v=imgdata.bytes1[p]) then
            begin
            ok:=true;
            break;
            end;//end of if
         if not ok then trans:=-1;
         //image is transparent - therefore entire image is transparent
         if (imgcount=0) and (trans>=0) then alltrans:=true;
         end;//end of if
      //size
      inc(imgcount);
      if ((imgcount*s.w)>x.width) or (x.height<>s.h) then
         begin//size ahead by 5 cells
         //WARNING: Image width is adjusted as we go, so we must USE a BITMAP that retains image rows when resizing - 28jul2021
         x.unlock;
         try
         x.width:=frcmax(((x.width div nozero(1100133,s.w))+5),imglimit)*s.w;
         if (x.height<>s.h) then x.height:=s.h;
         except;end;
         x.lock;
         end;//if
      //cls
      if (imgcount<=1) then
         begin
         if (trans>=0) then zc24:=tc24 else zc24:=low__nonwhite24(pal.c[bgcolor]);
         for dy:=0 to (s.h-1) do
         begin
         if not misscan82432(x,dy,sr8,sr24,sr32) then goto skipend;
         //.32
         if (xbits=32) then
            begin
            if xuse32 and (trans>=0) then
               begin
               sc32.r:=0;
               sc32.g:=0;
               sc32.b:=0;
               sc32.a:=0;
               end
            else
               begin
               sc32.r:=zc24.r;
               sc32.g:=zc24.g;
               sc32.b:=zc24.b;
               sc32.a:=255;
               end;
            for dx:=0 to (s.w-1) do sr32[offx+dx]:=sc32;
            end
         //.24
         else if (xbits=24) then
            begin
            for dx:=0 to (s.w-1) do sr24[offx+dx]:=zc24;
            end
         //.8
         else if (xbits=8) then
            begin
            sc8:=low__greyscale2(zc24);
            for dx:=0 to (s.w-1) do sr8[offx+dx]:=sc8;
            end;
         end;//dy
         end
      else
         begin
         //init
         if (trans>=0) then zc24:=tc24 else zc24:=low__nonwhite24(pal.c[bgcolor]);
         if (xbits=32) and xuse32 and (trans>=0) then
            begin
            zc32.r:=0;
            zc32.g:=0;
            zc32.b:=0;
            zc32.a:=0;
            end
         else
            begin
            zc32.r:=zc24.r;
            zc32.g:=zc24.g;
            zc32.b:=zc24.b;
            zc32.a:=255;
            end;

{
         zc32.r:=zc24.r;
         zc32.g:=zc24.g;
         zc32.b:=zc24.b;
         zc32.a:=255;
{}//xxxxxxx
         zc8:=low__greyscale2(zc24);
         //get
         for dy:=0 to (s.h-1) do
         begin
         if not misscan82432(x,dy,sr8,sr24,sr32) then goto skipend;
         //.32
         if (xbits=32) then
            begin
            for dx:=0 to (s.w-1) do
            begin
            case lastdispose of
            0,1:begin//graphic left in place
               sc32:=sr32[offx-s.w+dx];
               sr32[offx+dx]:=sc32;
               end;
            2:begin//restore background color - area used by image
               if (dy>=lastrect.top) and (dy<=lastrect.bottom) and (dx>=lastrect.left) and (dx<=lastrect.right) then sr32[offx+dx]:=zc32
               else
                  begin
                  sc32:=sr32[offx-s.w+dx];
                  sr32[offx+dx]:=sc32;
                  end;
               end;
            3:begin//restore to previous image - area used by image
               sc32:=sr32[offx-s.w+dx];
               sr32[offx+dx]:=sc32;
               end;
            end;//case
            end;//dx
            end//32
         //.24
         else if (xbits=24) then
            begin
            for dx:=0 to (s.w-1) do
            begin
            case lastdispose of
            0,1:begin//graphic left in place
               yc24:=sr24[offx-s.w+dx];
               sr24[offx+dx]:=yc24;
               end;
            2:begin//restore background color - area used by image
               if (dy>=lastrect.top) and (dy<=lastrect.bottom) and (dx>=lastrect.left) and (dx<=lastrect.right) then sr24[offx+dx]:=zc24
               else
                  begin
                  yc24:=sr24[offx-s.w+dx];
                  sr24[offx+dx]:=yc24;
                  end;
               end;
            3:begin//restore to previous image - area used by image
               yc24:=sr24[offx-s.w+dx];
               sr24[offx+dx]:=yc24;
               end;
            end;//case
            end;//dx
            end//24
         //.8
         else if (xbits=8) then
            begin
            for dx:=0 to (s.w-1) do
            begin
            case lastdispose of
            0,1:begin//graphic left in place
               sc8:=sr8[offx-s.w+dx];
               sr8[offx+dx]:=sc8;
               end;
            2:begin//restore background color - area used by image
               if (dy>=lastrect.top) and (dy<=lastrect.bottom) and (dx>=lastrect.left) and (dx<=lastrect.right) then sr8[offx+dx]:=zc8
               else
                  begin
                  sc8:=sr8[offx-s.w+dx];
                  sr8[offx+dx]:=sc8;
                  end;
               end;
            3:begin//restore to previous image - area used by image
               sc8:=sr8[offx-s.w+dx];
               sr8[offx+dx]:=sc8;
               end;
            end;//case
            end;//dx
            end;//8
         end;//dy
         end;//if
      //draw
      p:=1;
      len:=imgdata.len;
      for dy:=0 to (id.h-1) do
      begin
      ny:=dy+id.dy;
      if (ny>=0) and (ny<s.h) then
         begin
         if not misscan82432(x,ny,sr8,sr24,sr32) then goto skipend;
         //.32
         if (xbits=32) then
            begin
            for dx:=0 to (id.w-1) do
            begin
            nx:=dx+id.dx;
            if (nx>=0) and (nx<s.w) then
               begin
               ci:=imgdata.bytes1[p];
               if (trans=-1) then
                  begin
                  yc24:=pal.c[ci];//important: must maintain original image data if not transparent - special white/offwhite image cases, any rounding down will cause white+offwhite=>all offwhite which will cause entire area of both colors to be transparent if the "transparent" option is then used - 17SEP2007
                  sc32.r:=yc24.r;
                  sc32.g:=yc24.g;
                  sc32.b:=yc24.b;
                  sc32.a:=255;
                  sr32[offx+nx]:=sc32;
                  end
               else if (ci<>trans) then
                  begin
                  yc24:=low__nonwhite24(pal.c[ci]);
                  sc32.r:=yc24.r;
                  sc32.g:=yc24.g;
                  sc32.b:=yc24.b;
                  sc32.a:=255;
                  sr32[offx+nx]:=sc32;
                  end;
               end;//if
            //inc
            inc(p);
            //quit
            if (p>len) then break;
            end;//dx
            end//32
         //.24
         else if (xbits=24) then
            begin
            for dx:=0 to (id.w-1) do
            begin
            nx:=dx+id.dx;
            if (nx>=0) and (nx<s.w) then
               begin
               ci:=imgdata.bytes1[p];
               if (trans=-1) then sr24[offx+nx]:=pal.c[ci]//important: must maintain original image data if not transparent - special white/offwhite image cases, any rounding down will cause white+offwhite=>all offwhite which will cause entire area of both colors to be transparent if the "transparent" option is then used - 17SEP2007
               else if (ci<>trans) then sr24[offx+nx]:=low__nonwhite24(pal.c[ci]);
               end;//if
            //inc
            inc(p);
            //quit
            if (p>len) then break;
            end;//dx
            end//24
         //.8
         else if (xbits=8) then
            begin
            for dx:=0 to (id.w-1) do
            begin
            nx:=dx+id.dx;
            if (nx>=0) and (nx<s.w) then
               begin
               ci:=imgdata.bytes1[p];
               if (trans=-1) then
                  begin
                  sc8:=low__greyscale2(pal.c[ci]);//important: must maintain original image data if not transparent - special white/offwhite image cases, any rounding down will cause white+offwhite=>all offwhite which will cause entire area of both colors to be transparent if the "transparent" option is then used - 17SEP2007
                  sr8[offx+nx]:=sc8;
                  end
               else if (ci<>trans) then
                  begin
                  sc8:=low__greyscale2b(low__nonwhite24(pal.c[ci]));
                  sr8[offx+nx]:=sc8;
                  end;
               end;//if
            //inc
            inc(p);
            //quit
            if (p>len) then break;
            end;//dx
            end;//8
         end;//ny

      if (p>len) then break;
      end;//end of loop
      //enforce top-left corner transparency (only if entire animation is transparent)
      if alltrans and (trans>=0) then
         begin
         if not misscan82432(x,0,sr8,sr24,sr32) then goto skipend;
         //.32
         if (xbits=32) then
            begin
            if not xuse32 then
               begin
               sc32.r:=tc24.r;
               sc32.g:=tc24.g;
               sc32.b:=tc24.b;
               sc32.a:=255;
               sr32[offx]:=sc32;
               end;
            end
         //.24
         else if (xbits=24) then sr24[offx]:=tc24
         //.8
         else if (xbits=8) then
            begin
            sc8:=low__greyscale2b(tc24);
            sr32[offx]:=sc32;
            end;
         end;//if
      //inc
      inc(offx,s.w);
      dec(pos1);
      //last
      lastdispose:=dispose;
      lastrect:=rect(id.dx,id.dy,frcmax(id.dx+id.w-1,s.w-1),frcmax(id.dy+id.h-1,s.h-1));
      //frame limit
      if (imgcount>=imglimit) then break;//safe number of frames
      end
   else if (v=59) then break//terminator
   else break;//unknown
   end;//end of if
skipone:
//inc
inc(pos1);
until (pos1>ylen);
//trim
if (imgcount<>0) and (x<>nil) then
   begin
   x.unlock;
   try;x.width:=(imgcount*s.w);except;end;
   x.lock;
   end;
//animation information --------------------------------------------------------
//range - max. number of frames-per-second=50 (20ms)...[delay=0=>20ms or 50fps]
if (imgcount>=1) then
   begin
   delay:=frcmin((delay div nozero(1100134,imgcount))*10,0);//ave. units => ave. ms
   //.default is 100ms
   if (delay<=0) then delay:=100;
   end;//end of if
//set
xdelay:=frcmin(delay,1);//28jul2021
xcellcount:=frcmin(imgcount,1);
xcellwidth:=frcmin(s.w,1);
xcellheight:=frcmin(s.h,1);
xtransparent:=alltrans;;
xdelay:=frcmin(delay,1);
case gp.count of
2:xbpp:=2;
3..16:xbpp:=4;
17..256:xbpp:=8;
end;//case
//.store a copy onboard "tbitmapenhanced" - 28jul2021
misai(x).delay:=xdelay;
misai(x).count:=xcellcount;
misai(x).cellwidth:=xcellwidth;
misai(x).cellheight:=xcellheight;
misai(x).transparent:=xtransparent;
misai(x).bpp:=xbpp;
//successful
result:=true;
skipend:
except;end;
try
if (x<>nil) and xmustunlock then x.unlock;
bfree(tmp);
bfree(imgdata);
bunlockautofree(y);
except;end;
end;
//## togif ##
function low__togif(x:tobject;y:tstr8;var e:string):boolean;//11SEP2007
begin
try;result:=low__togif2(x,clnone,y,e);except;end;
end;
//## low__togif2 ##
function low__togif2(x:tobject;xtranscol:longint;y:tstr8;var e:string):boolean;//11SEP2007
begin
try;result:=low__togif3(x,xtranscol,true,false,y,e);except;end;
end;
//## low__togif3 ##
function low__togif3(x:tobject;xtranscol:longint;xlocalpalettes,xuse32:boolean;y:tstr8;var e:string):boolean;////14may2022 - now supports 32bit mask channel for transparency, 22sep2021 (now supports localpalettes - each cell of an animation has it's own separate color palette), 11SEP2007
label//writes v89a GIF's
   skipend;
const
   //main flags
   pfGlobalColorTable	= $80;		{ set if global color table follows L.S.D. }
   pfColorResolution	= $70;		{ Color resolution - 3 bits }
   pfSort		= $08;		{ set if global color table is sorted - 1 bit }
   pfColorTableSize	= $07;		{ size of global color table - 3 bits }
   //local - image des
   idLocalColorTable	= $80;    { set if a local color table follows }
   idInterlaced		= $40;    { set if image is interlaced }
   idSort		= $20;    { set if color table is sorted }
   idReserved		= $0C;    { reserved - must be set to $00 }
   idColorTableSize	= $07;    { size of color table as above }
var
   z:tstr8;
   e2:string;
   xhasai,xtransparent:boolean;
   xdelay,xbits,xw,xh,palcount,dpalcount,ccount,cw,ch,nx,ny,offx,len,dy,dx,delay,loops,i,p,p2,tmp2,pos:longint;
   flags:byte;
   s:tgifscreen;
   pal:array[0..255] of tcolor24;
   lpal:array[0..255] of tcolor24;
   id:tgifimgdes;
   sr8:pcolorrow8;
   sr24:pcolorrow24;
   sr32:pcolorrow32;
   sc8:tcolor8;
   yc,zc,tc:tcolor24;
   sc32:tcolor32;
   lastrect:trect;
   trans:boolean;
   //## palfind ##
   function palfind(var z:tcolor24):byte;
   var
      p:integer;
   begin
   try
   //defaults
   result:=frcmax(1,palcount-1);//avoid "item.0" if we can as it is reserved for transparent pixels - 23JAN2012
   //scan
   if xlocalpalettes then
      begin
      for p:=0 to (palcount-1) do if (lpal[p].r=z.r) and (lpal[p].g=z.g) and (lpal[p].b=z.b) then
         begin
         result:=byte(p);
         break;
         end;
      end
   else
      begin
      for p:=0 to (palcount-1) do if (pal[p].r=z.r) and (pal[p].g=z.g) and (pal[p].b=z.b) then
         begin
         result:=byte(p);
         break;
         end;
      end;
   except;end;
   end;
   //## low__transwhite ##
   function low__transwhite(x:tobject;var e:string):boolean;//prepare a multi-cell imagestrip, ensuring all [0,0] pixel corners are "black" if transparent and all black must be [1,1,1] or higher
   label
      skipend;
   var//Note: White is reserved for transparent information
      xhasai:boolean;
      xbits,xw,xh,ccount,cw,ch,delay,p,dy,dx,offx:longint;
      sc8:tcolor8;
      zc,tc,white,offwhite:tcolor24;
      white32,offwhite32:tcolor32;
      sc32:tcolor32;
      sr8:pcolorrow8;
      sr24:pcolorrow24;
      sr32:pcolorrow32;
   begin
   try
   //defaults
   result:=false;
   e:=gecUnexpectedError;
   ccount:=1;
   //check
   if not miscells(x,xbits,xw,xh,ccount,cw,ch,delay,xhasai,xtransparent) then goto skipend;
   if (xbits<>8) and (xbits<>24) and (xbits<>32) then goto skipend;
   if (xtranscol<>clnone) then xtransparent:=true;//09sep2021
   //init
   //.white
   white.r:=255;
   white.g:=255;
   white.b:=255;
   //.white32
   white32.r:=255;
   white32.g:=255;
   white32.b:=255;
   white32.a:=255;
   //.offwhite
   offwhite.r:=254;
   offwhite.g:=254;
   offwhite.b:=254;
   //.offwhite32
   offwhite32.r:=254;
   offwhite32.g:=254;
   offwhite32.b:=254;
   offwhite32.a:=255;
   //get
   e:=gecOutOfMemory;
   for p:=1 to ccount do
   begin
   offx:=(p-1)*cw;
   //y
   for dy:=0 to (ch-1) do
   begin
   if not misscan82432(x,dy,sr8,sr24,sr32) then goto skipend;
   if (dy=0) and (not xuse32) then
      begin
      if (xtranscol=clTopLeft) then tc:=mispixel24(x,dy,offx)
      else if (xtranscol<>clnone) then tc:=low__intrgb(xtranscol)
      else tc:=mispixel24(x,dy,offx);//was: tc:=r[offx]; - 09sep2021
      //transparent color is already WHITE, so there is nothing to do
      if (tc.r=white.r) and (tc.g=white.g) and (tc.b=white.b) then break;
      end;//end of if
   //get
   //.8
   if (xbits=8) then
      begin
      for dx:=0 to (cw-1) do
      begin
      sc8:=sr8[offx+dx];
      //.swap pixel to transparent color (as defined by 0,0 pixel of cell)
      if (sc8=tc.r) then sc8:=white.r
      //.pixel is white, but not transparent - swap to offwhite (non-transparent white)
      else if (sc8=white.r) then sc8:=offwhite.r;
      //.set
      sr8[offx+dx]:=sc8;
      end;//dx
      end//8
   //.24
   else if (xbits=24) then
      begin
      for dx:=0 to (cw-1) do
      begin
      zc:=sr24[offx+dx];
      //.swap pixel to transparent color (as defined by 0,0 pixel of cell)
      if (zc.r=tc.r) and (zc.g=tc.g) and (zc.b=tc.b) then zc:=white
      //.pixel is white, but not transparent - swap to offwhite (non-transparent white)
      else if (zc.r=white.r) and (zc.g=white.g) and (zc.b=white.b) then zc:=offwhite;
      //.set
      sr24[offx+dx]:=zc;
      end;//dx
      end//24
   //.32
   else if (xbits=32) then
      begin
      if xuse32 then//14may2022
         begin
         for dx:=0 to (cw-1) do
         begin
         sc32:=sr32[offx+dx];
         //.swap pixel to transparent color (as defined by 0,0 pixel of cell)
         if (sc32.a=0) then sc32:=white32
         //.pixel is white, but not transparent - swap to offwhite (non-transparent white)
         else if (sc32.r=white.r) and (sc32.g=white.g) and (sc32.b=white.b) then sc32:=offwhite32;
         //.set
         sr32[offx+dx]:=sc32;
         end;//dx
         end
      else
         begin
         for dx:=0 to (cw-1) do
         begin
         sc32:=sr32[offx+dx];
         //.swap pixel to transparent color (as defined by 0,0 pixel of cell)
         if (sc32.r=tc.r) and (sc32.g=tc.g) and (sc32.b=tc.b) then sc32:=white32
         //.pixel is white, but not transparent - swap to offwhite (non-transparent white)
         else if (sc32.r=white.r) and (sc32.g=white.g) and (sc32.b=white.b) then sc32:=offwhite32;
         //.set
         sr32[offx+dx]:=sc32;
         end;//dx
         end;
      end;//32
   end;//end of loop - y
   end;//end of loop - p (all cells)

   //successful
   result:=true;
   skipend:
   except;end;
   end;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
z:=nil;

//lock
if not block(y) then exit;
//check
if not miscells(x,xbits,xw,xh,ccount,cw,ch,xdelay,xhasai,xtransparent) then goto skipend;
if xuse32 and (xbits<>32) then xuse32:=false;//14may2022
if (xbits<>8) and (xbits<>24) and (xbits<>32) then goto skipend;
if (xtranscol<>clnone) or (xuse32 and (xbits=32)) then xtransparent:=true;//14may2022, 09sep2021
//.turn off local palletes for static images and single cell animations - 22sep2021
if xlocalpalettes and (ccount<=1) then xlocalpalettes:=false;

//init
y.clear;
z:=bnew;
flags:=0;
delay:=0;
trans:=false;
palcount:=0;
dpalcount:=0;
fillchar(pal,sizeof(pal),0);//23JAN2012
if xhasai or xtransparent then
   begin
   delay:=frcmin(xdelay div 10,2);//20ms or larger (50fps)
   if xtransparent then
      begin
      inc(flags);//1=transparent
      trans:=true;
      end;
   inc(flags,8);//remove-by background
   end;

//init
if (xw<=0) or (xh<=0) or (ccount<=0) then exit;
//INIT
//.enforces transparent color as "WHITE", do this even if the image is not transparent - keep consistent
if trans and (not low__transwhite(x,e)) then goto skipend;

//.build palette - 09sep2021, 22JAN2012
case xlocalpalettes of
true:begin
   //.count colors only -> do not reduce
   if not mislimitcolors82432ex(x,0,cw,low__rgb(255,255,255),high(pal)+1,true,false,pal,palcount,e) then goto skipend;
   palcount:=256;//localpalettes assumes FULL palette consumption (e.g. global palette is NOT used, but included) - 22sep2021
   end;
false:if not mislimitcolors82432(x,low__rgb(255,255,255),high(pal)+1,true,pal,palcount,e) then goto skipend;
end;//case

case palcount of
0..2:dpalcount:=2;
3..16:dpalcount:=16;
else dpalcount:=256;
end;

//HEADER
y.aadd([uuG,uuI,uuF,nn8,nn9,lla]);//was: pushb(ylen,y,'GIF89a');
//screen info
fillchar(s,sizeof(s),0);
s.w:=cw;
s.h:=ch;
//.palette size - 22JAN2012
case dpalcount of
2:s.pf:=176;
16:s.pf:=179;
else s.pf:=183;//183=256PAL,NOT-SORTED [247=SORTED]
end;

//was: pushb(ylen,y,fromstruc(@s,sizeof(s)));
y.addwrd2(s.w);
y.addwrd2(s.h);
y.addbyt1(s.pf);
y.addbyt1(s.bgi);
y.addbyt1(s.ar);

//global palette - fixed at 2, 16 or 256 colors - 23JAN2012
//was: for p:=0 to (dpalcount-1) do pushb(ylen,y,char(pal[p].r)+char(pal[p].g)+char(pal[p].b));
for p:=0 to (dpalcount-1) do
begin
y.addbyt1(pal[p].r);
y.addbyt1(pal[p].g);
y.addbyt1(pal[p].b);
end;//p


//LOOP       //unknown code block [78..3..1]                       //0=loop forever
//was: if (ccount>=2) then pushb(ylen,y,#33#255#11#78#69#84#83#67#65#80#69#50#46#48#3#1+from16bit(0,true)+#0);
if (ccount>=2) then
   begin
   y.aadd([33,255,11,78,69,84,83,67,65,80,69,50,46,48,3,1]);
   y.addsmi2(0);
   y.addbyt1(0);
   end;


//IMAGES
for p:=1 to ccount do
begin
//img-control [ext,imgctrl,4bytes]+[trans=v1,wait=v2,(dispose=v0..3used, v4..7 resv)
//dispose modes(0=nothing=>0, 1=leave-as-is=>4, 2=background=>8, 3=previous-image=>12
//.value=transparent1 and/or background8 = 1,8 or 9
                      //flags + delay + transparent-color-index (fixed at ZERO for us)+#0terminator
//was: pushb(ylen,y,#33#249#4+char(flags)+from16bit(delay,true)+#0#0);
y.aadd([33,249,4]);
y.addbyt1(flags);
y.addsmi2(delay);
y.aadd([0,0]);


//img-des - Note: pf=0 (no local color table, not interlaced, not sorted)
fillchar(id,sizeof(id),0);
id.sep:=44;
id.w:=cw;
id.h:=ch;
//was: pushb(ylen,y,fromstruc(@id,sizeof(id)));
y.addbyt1(id.sep);
y.addwrd2(id.dx);
y.addwrd2(id.dy);
y.addwrd2(id.w);
y.addwrd2(id.h);
//if xlocalpalettes then id.pf:=idLocalColorTable;//+idColorTableSize;//only for local palette support - 22sep2021


offx:=(p-1)*s.w;

//.build local palette
if xlocalpalettes then
   begin
   //.create local palette - 22sep2021
   //Note: palcount=actual number of colors in palette -> this is NOT store in the GIF as it can differ / internal reference only - 22sep2021
   if not mislimitcolors82432ex(x,offx,cw,low__rgb(255,255,255),high(pal)+1,true,true,lpal,palcount,e) then goto skipend;

   case palcount of
   0..2:dpalcount:=2;
   3..16:dpalcount:=16;
   else dpalcount:=256;
   end;

   case dpalcount of
   2:inc(id.pf,176);
   16:inc(id.pf,179);
   else inc(id.pf,183);//183=256PAL,NOT-SORTED [247=SORTED]
   end;

   y.addbyt1(id.pf);//bit fields

   //.store local palette - 22sep2021
   for p2:=0 to (dpalcount-1) do
   begin
   y.addbyt1(lpal[p2].r);
   y.addbyt1(lpal[p2].g);
   y.addbyt1(lpal[p2].b);
   end;//p
   end
else y.addbyt1(id.pf);//bit fields

//IMAGE DATA
z.setlen(cw*ch);//was: setlength(z,cw*ch);
i:=1;
for dy:=0 to (ch-1) do
begin
if not misscan82432(x,dy,sr8,sr24,sr32) then goto skipend;
//.8
if (xbits=8) then
   begin
   for dx:=0 to (cw-1) do
   begin
   sc8:=sr8[dx+offx];
   zc.r:=sc8;
   zc.g:=sc8;
   zc.b:=sc8;
   z.pbytes[i-1]:=palfind(zc);//r-b elements are reversed in pal items
   inc(i);
   end;//dx
   end
//.24
else if (xbits=24) then
   begin
   for dx:=0 to (cw-1) do
   begin
   zc:=sr24[dx+offx];
   z.pbytes[i-1]:=palfind(zc);//r-b elements are reversed in pal items
   inc(i);
   end;//dx
   end
//.32
else if (xbits=32) then
   begin
   for dx:=0 to (cw-1) do
   begin
   sc32:=sr32[dx+offx];
   zc.r:=sc32.r;
   zc.g:=sc32.g;
   zc.b:=sc32.b;
   z.pbytes[i-1]:=palfind(zc);//r-b elements are reversed in pal items
   inc(i);
   end;//dx
   end;
end;//dy

//compressed image data
if not gif_compress(z,e2) then
   begin
   e:=e2;
   goto skipend;
   end;//end of if
y.add(z);//was: pushb(ylen,y,z);
z.clear;
end;//p

//terminator
y.aadd([0,59]);//was: pushb(ylen,y,#0#59);

//successful
result:=true;
skipend:
except;end;
try
bfree(z);
bunlockautofree(y);
except;end;
end;

{$else}

//## low__fromgif ##
function low__fromgif(x:tbmp;y:tstr8;var e:string):boolean;//28jul2021, 20JAN2012, 22SEP2009
var
   xcellcount,xcellwidth,xcellheight,xdelay,xbpp:longint;
   xtransparent:boolean;
begin
try;result:=low__fromgif2(x,y,xcellcount,xcellwidth,xcellheight,xdelay,xbpp,xtransparent,e);except;end;
end;
//## low__fromgif ##
function low__fromgif1(x:tbmp;y:tstr8;xuse32:boolean;var e:string):boolean;//28jul2021, 20JAN2012, 22SEP2009
var
   xcellcount,xcellwidth,xcellheight,xdelay,xbpp:longint;
   xtransparent:boolean;
begin
try;result:=low__fromgif3(x,y,xcellcount,xcellwidth,xcellheight,xdelay,xbpp,xuse32,xtransparent,e);except;end;
end;
//## low__fromgif2 ##
function low__fromgif2(x:tbmp;y:tstr8;var xcellcount,xcellwidth,xcellheight,xdelay,xbpp:longint;var xtransparent:boolean;var e:string):boolean;//28jul2021, 20JAN2012, 22SEP2009
begin
try;result:=low__fromgif3(x,y,xcellcount,xcellwidth,xcellheight,xdelay,xbpp,false,xtransparent,e);except;end;
end;
//## low__fromgif3 ##
function low__fromgif3(x:tbmp;y:tstr8;var xcellcount,xcellwidth,xcellheight,xdelay,xbpp:longint;xuse32:boolean;var xtransparent:boolean;var e:string):boolean;//28jul2021, 20JAN2012, 22SEP2009
begin
try
result:=false;
e:=gecUnexpectederror;
xcellcount:=1;
xcellwidth:=1;
xcellheight:=1;
xdelay:=500;
xbpp:=8;
xtransparent:=false;
except;end;
end;
//## low__togif ##
function low__togif(x:tobject;y:tstr8;var e:string):boolean;//11SEP2007
begin
try;result:=low__togif2(x,clnone,y,e);except;end;
end;
//## low__togif2 ##
function low__togif2(x:tobject;xtranscol:longint;y:tstr8;var e:string):boolean;//permit transparent color override - 09sep2021, 11SEP2007
begin
try;result:=low__togif3(x,xtranscol,true,false,y,e);except;end;
end;
//## low__togif3 ##
function low__togif3(x:tobject;xtranscol:longint;xlocalpalettes,xuse32:boolean;y:tstr8;var e:string):boolean;//14may2022 - now supports 32bit mask channel for transparency, 22sep2021 (now supports localpalettes - each cell of an animation has it's own separate color palette), 11SEP2007
begin
try
result:=false;
e:=gecUnknownformat;
except;end;
try;bautofree(y);except;end;
end;

{$endif}
//-- GIF end -------------------------------------------------------------------


//-- Range Support -------------------------------------------------------------
//## low__newtempname ##
function low__newtempname(dpre,dext:string):string;//temp filenames - 25jun2022
begin
try;result:=low__plattemp+low__newnameid(dpre,dext);except;end;
end;
//## low__newnameid ##
function low__newnameid(dpre,dext:string):string;//for use with temp filenames etc - 25jun2022
begin
try
result:=dpre+low__insstr('-',dpre<>'')+low__digpad11(system_instanceid,10)+'-'+low__digpad11(sysnewnameid,10)+low__insstr('.',dext<>'')+dext;
low__iroll(sysnewnameid,1);
except;end;
end;
//## low__newid ##
function low__newid:longint;
begin//Range: 0..N
try;low__iroll(sysnewid,1);result:=sysnewid;except;end;
end;
//## low__newid1 ##
function low__newid1:longint;
begin//Range: 1..N
try
low__iroll(sysnewid1,1);
if (sysnewid1<1) then sysnewid1:=1;
result:=sysnewid1;
except;end;
end;
//## frcmin ##
function frcmin(x,min:longint):longint;//14-SEP-2004
begin
try;result:=x;if (result<min) then result:=min;except;end;
end;
//## frcmin64 ##
function frcmin64(x,min:comp):comp;//24jan2016
begin
try;result:=x;if (result<min) then result:=min;except;end;
end;
//## frccurmin ##
function frccurmin(x,min:currency):currency;
begin
try;result:=x;if (result<min) then result:=min;except;end;
end;
//## smallest ##
function smallest(a,b:longint):longint;
begin
try;result:=a;if (result>b) then result:=b;except;end;
end;
//## largest ##
function largest(a,b:longint):longint;
begin
try;result:=a;if (result<b) then result:=b;except;end;
end;
//## largestrect ##
function largestrect(a,b:trect):trect;//12nov2017
begin
try
result:=a;
if (b.left<result.left) then result.left:=b.left;
if (b.top<result.top) then result.top:=b.top;
if (b.right>result.right) then result.right:=b.right;
if (b.bottom>result.bottom) then result.bottom:=b.bottom;
except;end;
end;
//## low__xyinarea ##
function low__xyinarea(sx,sy:longint;xarea:trect):boolean;
begin
try;result:=(xarea.left<=xarea.right) and (xarea.top<=xarea.bottom) and (sx>=xarea.left) and (sx<=xarea.right) and (sy>=xarea.top) and (sy<=xarea.bottom);except;end;
end;
//## low__ptinarea ##
function low__ptinarea(x:tpoint;xarea:trect):boolean;
begin
try;result:=(xarea.left<=xarea.right) and (xarea.top<=xarea.bottom) and (x.x>=xarea.left) and (x.x<=xarea.right) and (x.y>=xarea.top) and (x.y<=xarea.bottom);except;end;
end;
//## low__areaequal ##
function low__areaequal(a,b:trect):boolean;
begin
try;result:=(a.left=b.left) and (a.top=b.top) and (a.right=b.right) and (a.bottom=b.bottom);except;end;
end;
//## smallest64 ##
function smallest64(a,b:comp):comp;
begin
try;result:=a;if (result>b) then result:=b;except;end;
end;
//## largest64 ##
function largest64(a,b:comp):comp;
begin
try;result:=a;if (result<b) then result:=b;except;end;
end;
//## largestcur ##
function largestcur(a,b:currency):currency;//20jan2016
begin
try;result:=a;if (result<b) then result:=b;except;end;
end;
//## csmallestex ##
function csmallestex(a:array of currency):currency;//22JAN2008
var
   p:longint;
begin
try
result:=maxcur;
for p:=low(a) to high(a) do if (a[p]<result) then result:=a[p];
except;end;
end;
//## clargestex ##
function clargestex(a:array of currency):currency;//22JAN2008
var
   p:longint;
begin
try
result:=mincur;
for p:=low(a) to high(a) do if (a[p]>result) then result:=a[p];
except;end;
end;
//## frcmax ##
function frcmax(x,max:longint):longint;//14-SEP-2004
begin
try;result:=x;if (result>max) then result:=max;except;end;
end;
//## frcmax64 ##
function frcmax64(x,max:comp):comp;//24jan2016
begin
try;result:=x;if (result>max) then result:=max;except;end;
end;
//## restrict64 ##
function restrict64(x:comp):comp;//24jan2016
begin
try
result:=x;
if (result>max64) then result:=max64;
if (result<min64) then result:=min64;
except;end;
end;
//## restrict32 ##
function restrict32(x:comp):longint;//limit32 - 24jan2016
begin
try
if (x>maxint) then x:=maxint;
if (x<minint) then x:=minint;
result:=round(x);
except;end;
end;
//## low__sum32 ##
function low__sum32(x:array of longint):longint;
var//Add N longint's (32bit) numbers together and limit to longint range minint..maxint - 08may2020
   v:comp;
   p:longint;
begin
try
//defaults
result:=x[low(x)];
//get
if (low(x)<>high(x)) then
   begin
   v:=0;
   for p:=low(x) to high(x) do
   begin
   v:=v+x[p];
   if (v<minint) then v:=minint;
   if (v>maxint) then v:=maxint;
   end;//p
   //set
   result:=round(v);
   end;
except;end;
end;
//## frccurmax ##
function frccurmax(x,max:currency):currency;
begin
try;result:=x;if (result>max) then result:=max;except;end;
end;
//## frcrange ##
function frcrange(x,min,max:longint):longint;//13-SEP-2004
begin
try
result:=x;
if (result<min) then result:=min;
if (result>max) then result:=max;
except;end;
end;
//## frcrange2 ##
function frcrange2(var x:longint;xmin,xmax:longint):boolean;//29apr2020
begin
try;result:=true;if (x<xmin) then x:=xmin else if (x>xmax) then x:=xmax;except;end;
end;
//## frcrange64 ##
function frcrange64(x,min,max:comp):comp;//24jan2016
begin
try
result:=x;
if (result<min) then result:=min;
if (result>max) then result:=max;
except;end;
end;
//## frcrangeex ##
function frcrangeex(x,min,max,defvalue:longint):longint;//14-JAN-2007
begin
try
if (x=0) then x:=defvalue;
result:=frcrange(x,min,max);
except;end;
end;
//## frccurrange ##
function frccurrange(x,min,max:currency):currency;//date: 02-APR-2004
begin
try
result:=x;
if (result<min) then result:=min;
if (result>max) then result:=max;
except;end;
end;
//## frcextmin ##
function frcextmin(x,min:extended):extended;//07NOV20210
begin
try;result:=x;if (result<min) then result:=min;except;end;
end;
//## frcextrange ##
function frcextrange(x,min,max:extended):extended;//06JUN2007
begin
try
result:=x;
if (result<min) then result:=min;
if (result>max) then result:=max;
except;end;
end;
//## low__intr ##
function low__intr(x:longint):longint;//reverse longint
var
   s,d:tint4;
begin
try
result:=0;
s.val:=x;
d.bytes[0]:=s.bytes[3];//swap round
d.bytes[1]:=s.bytes[2];
d.bytes[2]:=s.bytes[1];
d.bytes[3]:=s.bytes[0];
result:=d.val;
except;end;
end;
//## low__wrdr ##
function low__wrdr(x:word):word;//reverse word
var
   s,d:twrd2;
begin
try
result:=0;
s.val:=x;
d.bytes[0]:=s.bytes[1];//swap round
d.bytes[1]:=s.bytes[0];
result:=d.val;
except;end;
end;
//## low__posn ##
function low__posn(x:longint):longint;
begin
try;result:=x;if (result<0) then result:=-result;except;end;
end;
//## low__iroll ##
procedure low__iroll(var x:longint;by:longint);//continuous incrementer with safe auto. reset
begin//if (x>capacity) reset to 0
try;x:=x+by;except;x:=0;end;
try;if (x<0) then x:=0;except;end;//required when compiler "range checking" is turned OFF - 25jun2022
end;
//## croll ##
procedure low__croll(var x:currency;by:currency);//continuous incrementer with safe auto. reset
begin//if (x>capacity) reset to 0
try;x:=x+by;except;x:=0;end;
try;if (x<0) then x:=0;except;end;//required when compiler "range checking" is turned OFF - 25jun2022
end;
//## roll64 ##
procedure low__roll64(var x:comp;by:comp);//continuous incrementer with safe auto. reset to user specified value - 05feb2016
begin//if (x>capacity) reset to 0
try
x:=x+by;
//.don't allow "x" to exceed upper limit of whole number range
if (x>max64) then x:=0
else if (x<0) then x:=0;//06sep2016
except;x:=0;end;
try;if (x<0) then x:=0;except;end;//required when compiler "range checking" is turned OFF - 25jun2022
end;
//## low__nrw ##
function low__nrw(x,y,r:longint):boolean;//number within range
begin
try;result:=(x>=(y-r)) and (x<=(y+r));except;end;
end;
//## low__udv ##
function low__udv(v,dv:string):string;//use default value
begin
try;result:=v;if (result='') then result:=dv;except;end;
end;
//## low__true1 ##
function low__true1(v1:boolean):boolean;
begin
result:=v1;
end;
//## low__true2 ##
function low__true2(v1,v2:boolean):boolean;
begin
result:=v1 and v2;
end;
//## low__true3 ##
function low__true3(v1,v2,v3:boolean):boolean;
begin
result:=v1 and v2 and v3;
end;
//## low__true4 ##
function low__true4(v1,v2,v3,v4:boolean):boolean;
begin
result:=v1 and v2 and v3 and v4;
end;
//## low__true5 ##
function low__true5(v1,v2,v3,v4,v5:boolean):boolean;
begin
result:=v1 and v2 and v3 and v4 and v5;
end;
//## low__or2 ##
function low__or2(v1,v2:boolean):boolean;
begin
result:=v1 or v2;
end;
//## low__or3 ##
function low__or3(v1,v2,v3:boolean):boolean;
begin
result:=v1 or v2 or v3;
end;
//## low__fireevent ##
function low__fireevent(xsender:tobject;x:tnotifyevent):boolean;
begin
try
result:=false;
if assigned(x) then
   begin
   x(xsender);
   result:=true;
   end;
except;end;
end;
//## swapbol ##
procedure low__swapbol(var x,y:boolean);//05oct2018
var
   z:boolean;
begin
try;z:=x;x:=y;y:=z;except;end;
end;
//## swapbyt ##
procedure low__swapbyt(var x,y:byte);//22JAN2011
var
   z:byte;
begin
try;z:=x;x:=y;y:=z;except;end;
end;
//## swapint ##
procedure low__swapint(var x,y:longint);
var
   z:longint;
begin
try;z:=x;x:=y;y:=z;except;end;
end;
//## swapcomp ##
procedure low__swapcomp(var x,y:comp);//07apr2016
var
   z:comp;
begin
try;z:=x;x:=y;y:=z;except;end;
end;
//## swapcur ##
procedure low__swapcur(var x,y:currency);
var
   z:currency;
begin
try;z:=x;x:=y;y:=z;except;end;
end;
//## swapext ##
procedure low__swapext(var x,y:extended);//06JUN2007
var
   z:extended;
begin
try;z:=x;x:=y;y:=z;except;end;
end;
//## low__setobj ##
function low__setobj(var xdata:tobject;xnewvalue:tobject):boolean;//15mar2021
begin
try
result:=false;
if (xnewvalue<>xdata) then
   begin
   xdata:=xnewvalue;
   result:=true;
   end;
except;end;
end;
//## low__setbc ##
function low__setbc(var xdata:tbasiccontrol;xnewvalue:tbasiccontrol):boolean;//15mar2021
begin
try
result:=false;
if (xnewvalue<>xdata) then
   begin
   xdata:=xnewvalue;
   result:=true;
   end;
except;end;
end;
//## low__setstr ##
function low__setstr(var xdata:string;xnewvalue:string):boolean;
begin
try
result:=false;
if (xnewvalue<>xdata) then
   begin
   xdata:=xnewvalue;
   result:=true;
   end;
except;end;
end;
//## low__setcmp ##
function low__setcmp(var xdata:comp;xnewvalue:comp):boolean;//10mar2021
begin
try
result:=false;
if (xnewvalue<>xdata) then
   begin
   xdata:=xnewvalue;
   result:=true;
   end;
except;end;
end;
//## low__setint ##
function low__setint(var xdata:longint;xnewvalue:longint):boolean;
begin
try
result:=false;
if (xnewvalue<>xdata) then
   begin
   xdata:=xnewvalue;
   result:=true;
   end;
except;end;
end;
//## low__setbol ##
function low__setbol(var xdata:boolean;xnewvalue:boolean):boolean;
begin
try
result:=false;
if (xnewvalue<>xdata) then
   begin
   xdata:=xnewvalue;
   result:=true;
   end;
except;end;
end;
//## low__color ##
function low__color(xname:string):longint;
const
   xlc=220;
begin
try
//defaults
result:=0;
xname:=low__lowercase(xname);
//get
if      (xname='yellow') then result:=low__rgb(255,255,190)
else if (xname='green')  then result:=low__rgb(xlc,255,xlc)
else if (xname='blue')   then result:=low__rgb(xlc,255,255)//was: low__rgb(230,255,255)
else if (xname='red')    then result:=low__rgb(255,xlc,xlc)
else if (xname='pink')   then result:=low__rgb(255,226,235)
else if (xname='orange') then result:=low__rgb(255,231,190)
else if (xname='grey')   then result:=low__rgb(230,230,230)
else if (xname='purple') then result:=low__rgb(245,230,250)
else if (xname='white')  then result:=low__rgb(255,255,250)//sligh yellowish tint
else                          result:=low__rgb(230,230,230);
except;end;
end;
//## rgbint ##
function low__rgbint(x:tcolor24):longint;
var
   a:tint4;
begin
try
//get
a.r:=x.r;
a.g:=x.g;
a.b:=x.b;
a.a:=0;
//set
result:=a.val;
except;end;
end;
//## rgbaint ##
function low__rgbaint(x:tcolor32):longint;
var
   a:tint4;
begin
try
//get
a.r:=x.r;
a.g:=x.g;
a.b:=x.b;
a.a:=x.a;
//set
result:=a.val;
except;end;
end;
//## low__greyscale ##
procedure low__greyscale(var x:tcolor24);
begin
if (x.g>x.r) then x.r:=x.g;
if (x.b>x.r) then x.r:=x.b;
x.g:=x.r;
x.b:=x.r;
end;
//## low__greyscale2 ##
function low__greyscale2(var x:tcolor24):byte;
begin
result:=x.r;
if (x.g>result) then result:=x.g;
if (x.b>result) then result:=x.b;
end;
//## low__greyscale2b ##
function low__greyscale2b(x:tcolor24):byte;
begin
result:=x.r;
if (x.g>result) then result:=x.g;
if (x.b>result) then result:=x.b;
end;
//## low__greyscale3 ##
function low__greyscale3(x:longint):longint;
var
   a:tint4;
begin
result:=0;
a.val:=x;
if (a.g>a.r) then a.r:=a.g;
if (a.b>a.r) then a.r:=a.b;
a.g:=a.r;
a.b:=a.r;
result:=a.val;
end;
//## low__greyscale4 ##
function low__greyscale4(x:longint):longint;
var
   a:tint4;
begin
result:=0;
a.val:=x;
result:=(a.r+a.g+a.b) div 3;
end;
//## low__focus3 ##
function low__focus3(x:longint):longint;
const
   fv=30;
var
   a:tint4;
   v:longint;
begin
//defaults
result:=0;
a.val:=x;
//.r
v:=a.r+fv;
if (v<100) then v:=100;
if (v>255) then v:=255;
a.r:=byte(v);
//.g
v:=a.g+fv;
if (v<100) then v:=100;
if (v>255) then v:=255;
a.g:=byte(v);
//.b
v:=a.b+fv;
if (v<100) then v:=100;
if (v>255) then v:=255;
a.b:=byte(v);
//set
result:=a.val;
end;
//## low__rgbtohex ##
function low__rgbtohex(xrgb:longint):string;//ultra-fast int->hex color converter - 15aug2019
var
   a:tint4;
   v,v2:longint;
   c2,c3,c4,c5,c6,c7:char;
begin
try
//defaults
result:='';
//get
a.val:=xrgb;
//.23
v :=a.bytes[0] div 16;
v2:=a.bytes[0]-(v*16);
if (v <=9) then c2:=char(48+v ) else c2:=char(55+v );
if (v2<=9) then c3:=char(48+v2) else c3:=char(55+v2);
//.45
v :=a.bytes[1] div 16;
v2:=a.bytes[1]-(v*16);
if (v <=9) then c4:=char(48+v ) else c4:=char(55+v );
if (v2<=9) then c5:=char(48+v2) else c5:=char(55+v2);
//.67
v :=a.bytes[2] div 16;
v2:=a.bytes[2]-(v*16);
if (v <=9) then c6:=char(48+v ) else c6:=char(55+v );
if (v2<=9) then c7:=char(48+v2) else c7:=char(55+v2);
//set
result:='#'+c2+c3+c4+c5+c6+c7;
except;end;
end;
//## low__hextorgb ##
function low__hextorgb(sx:string;xdef:longint):longint;//12jan2022, 27feb2021
label
   skipend;
var
   r,g,b:longint;
   x:string;
   //## xval ##
   function xval(x:byte):longint;
   begin
   case x of
   48..57: result:=x-48;
   65..70: result:=x-55;
   97..102:result:=x-87;
   else    result:=0;
   end;//case
   end;
begin
try
//defaults
result:=xdef;
//check
if (sx='') then exit;
//init
x:=low__lowercase(sx);
r:=0;
g:=0;
b:=0;
//get
if (x='red') then
   begin
   r:=255;
   g:=0;
   b:=0;
   end
else if (x='green') then
   begin
   r:=0;
   g:=255;
   b:=0;
   end
else if (x='blue') then
   begin
   r:=0;
   g:=0;
   b:=255;
   end
else if (x='black') then
   begin
   r:=0;
   g:=0;
   b:=0;
   end
else if (x='white') then
   begin
   r:=255;
   g:=255;
   b:=255;
   end
else if (x='yellow') then
   begin
   r:=255;
   g:=255;
   b:=0;
   end
else if (x='orange') then
   begin
   r:=255;
   g:=128;
   b:=0;
   end
else if (x='none') then
   begin
   result:=clnone;
   goto skipend;
   end
else if (strcopy1(x,1,1)='#') and (length(x)>=4) and (length(x)<7) then//e.g. "#ae9"
   begin
   r:=xval(strbyte1(x,2))*17;//fixed - 12jan2022
   g:=xval(strbyte1(x,3))*17;
   b:=xval(strbyte1(x,4))*17;
   end
else if (strcopy1(x,1,1)='#') and (length(x)>=7) then//e.g. "#aaee99"
   begin
   r:=(xval(strbyte1(x,2))*16)+xval(strbyte1(x,3));
   g:=(xval(strbyte1(x,4))*16)+xval(strbyte1(x,5));
   b:=(xval(strbyte1(x,6))*16)+xval(strbyte1(x,7));
   end
else goto skipend;
//set
result:=low__rgb(r,g,b);
skipend:
except;end;
end;
//## low__rgbatohex ##
function low__rgbatohex(xrgba:longint;xhash:boolean):string;//ultra-fast int->hex color converter - 22jul2021
var
   a:tint4;
   v,v2:longint;
   c2,c3,c4,c5,c6,c7,c8,c9:char;
begin
try
//defaults
result:='';
//get
a.val:=xrgba;
//.23
v :=a.r div 16;
v2:=a.r-(v*16);
if (v <=9) then c2:=char(48+v ) else c2:=char(55+v );
if (v2<=9) then c3:=char(48+v2) else c3:=char(55+v2);
//.45
v :=a.g div 16;
v2:=a.g-(v*16);
if (v <=9) then c4:=char(48+v ) else c4:=char(55+v );
if (v2<=9) then c5:=char(48+v2) else c5:=char(55+v2);
//.67
v :=a.b div 16;
v2:=a.b-(v*16);
if (v <=9) then c6:=char(48+v ) else c6:=char(55+v );
if (v2<=9) then c7:=char(48+v2) else c7:=char(55+v2);
//.89
v :=a.a div 16;
v2:=a.a-(v*16);
if (v <=9) then c8:=char(48+v ) else c8:=char(55+v );
if (v2<=9) then c9:=char(48+v2) else c9:=char(55+v2);
//set
case xhash of
true:result:='#'+c2+c3+c4+c5+c6+c7+c8+c9;
false:result:=c2+c3+c4+c5+c6+c7+c8+c9;
end;
except;end;
end;
//## low__hextorgba ##
function low__hextorgba(sx:string;xdef:longint):longint;//27feb2021
label
   skipend;
var
   r,g,b,a,xlen:longint;
   x:string;
   //## xval ##
   function xval(x:byte):longint;
   begin
   case x of
   48..57: result:=x-48;
   65..70: result:=x-55;
   97..102:result:=x-87;
   else    result:=0;
   end;//case
   end;
begin
try
//defaults
result:=xdef;
//check
if (sx='') then exit;
//init
x:=low__lowercase(sx);
xlen:=length(x);
r:=0;
g:=0;
b:=0;
a:=0;
//get
if (strcopy1(x,1,1)='#') and (xlen>=5) and (xlen<9) then//e.g. "#ae93"
   begin
   r:=xval(strbyte1(x,2)*17);
   g:=xval(strbyte1(x,3)*17);
   b:=xval(strbyte1(x,4)*17);
   a:=xval(strbyte1(x,5)*17);
   end
else if (strcopy1(x,1,1)='#') and (xlen>=9) then//e.g. "#aaee9933"
   begin
   r:=(xval(strbyte1(x,2))*16)+xval(strbyte1(x,3));
   g:=(xval(strbyte1(x,4))*16)+xval(strbyte1(x,5));
   b:=(xval(strbyte1(x,6))*16)+xval(strbyte1(x,7));
   a:=(xval(strbyte1(x,8))*16)+xval(strbyte1(x,9));
   end
else if (xlen>=4) and (xlen<8) then//e.g. "ae93"
   begin
   r:=xval(strbyte1(x,1)*17);
   g:=xval(strbyte1(x,2)*17);
   b:=xval(strbyte1(x,3)*17);
   a:=xval(strbyte1(x,4)*17);
   end
else if (xlen>=8) then//e.g. "aaee9933"
   begin
   r:=(xval(strbyte1(x,1))*16)+xval(strbyte1(x,2));
   g:=(xval(strbyte1(x,3))*16)+xval(strbyte1(x,4));
   b:=(xval(strbyte1(x,5))*16)+xval(strbyte1(x,6));
   a:=(xval(strbyte1(x,7))*16)+xval(strbyte1(x,8));
   end
else goto skipend;
//set
result:=low__rgba(r,g,b,a);
skipend:
except;end;
end;
//## low__vifontscale ##
function low__vifontscale(xwidth:longint):longint;//use to scale width of columns and height of other items according to current "viFontheight" setting based on a default value of "16"
begin
try;result:=round((vifontheight/14)*xwidth);except;end;
end;
//## low__cv ##
function low__cv(col,bgcolor,by:longint):boolean;//color visible
var
   c,b:tint4;
   //## xccv ##
   function xccv(x,y:byte;by:longint):boolean;
   begin
   if (by<0) then by:=30;
   result:=(low__posn(x-y)>=by);
   end;
begin
try
result:=false;
c.val:=col;
b.val:=bgcolor;
result:=xccv(c.bytes[0],b.bytes[0],by) or xccv(c.bytes[1],b.bytes[1],by) or xccv(c.bytes[2],b.bytes[2],by);
except;end;
end;
//## low__ecv ##
function low__ecv(col,bgcolor,by:longint):longint;//ensure color visible
begin
try
result:=col;
if not low__cv(result,bgcolor,by) then result:=low__invert2b(result,true);
except;end;
end;
//## low__brightness ##
function low__brightness(x:longint;var xout:longint):boolean;
var
   a:tint4;
begin
try
result:=true;
xout:=0;
a.val:=x;
if (a.r>xout) then xout:=a.r;
if (a.g>xout) then xout:=a.g;
if (a.b>xout) then xout:=a.b;
except;end;
end;
//## low__brightnessb ##
function low__brightnessb(x:longint):longint;
begin
try;low__brightness(x,result);except;end;
end;
//## low__brightness2 ##
function low__brightness2(x:longint;var xout:longint):boolean;//27mar2021
var
   a:tint4;
begin
try
result:=true;
xout:=0;
a.val:=x;
xout:=(a.r+a.g+a.b) div 3;
except;end;
end;
//## low__brightness2b ##
function low__brightness2b(x:longint):longint;
begin
try;low__brightness2(x,result);except;end;
end;
//## low__invert ##
function low__invert(x:longint;var xout:longint):boolean;
begin
try;result:=true;low__invert2(x,false,xout);except;end;
end;
//## low__invert2 ##
function low__invert2(x:longint;xgreycorrection:boolean;var xout:longint):boolean;
var
   a:tint4;
   b:longint;
begin
try
//defaults
result:=true;
xout:=x;
//get
if xgreycorrection and low__brightness(x,b) and (b>=100) and (b<=156) then
   begin
   xout:=low__rgb(255,255,255);
   exit;
   end;
//invert
a.val:=x;
a.r:=255-a.r;
a.g:=255-a.g;
a.b:=255-a.b;
xout:=a.val;
except;end;
end;
//## low__invertb ##
function low__invertb(x:longint):longint;
begin
try;low__invert2(x,false,result);except;end;
end;
//## low__invert2b ##
function low__invert2b(x:longint;xgreycorrection:boolean):longint;
begin
try;low__invert2(x,xgreycorrection,result);except;end;
end;
//## low__maplist ##
function low__maplist(const x:array of byte):tlistptr;
begin
try
//defaults
result.count:=0;
result.bytes:=nil;
//get
if (low(x)=0) then
   begin
   result.count:=high(x)+1;
   result.bytes:=@x;
   end;
except;end;
end;
//## low__maplist2 ##
function low__maplist2(x:tstr8):tlistptr;//07apr2021
begin
try
//defaults
result.count:=0;
result.bytes:=nil;
//get
if block(x) and (not x.oautofree) then result:=x.maplist;
except;end;
try;bunlockautofree(x);except;end;
end;
//## low__compareint ##
function low__compareint(x,xval:longint):boolean;
begin
try
result:=(x=xval);
if not result then
   begin
   if (x>=97) and (x<=122)       then dec(x,32);//a-z -> A-Z
   if (xval>=97) and (xval<=122) then dec(xval,32);//a-z -> A-Z
   result:=(x=xval);
   end;
except;end;
end;
//## low__strASarray__debugonly ##
function low__strASarray__debugonly(xdata:string):string;
var//WARNING: Not to be used in a program -> for strict debug and data
   //         management use only -> will not work in D10 - 19aug2020
   xlen,p:longint;
begin
try
//defaults
result:='';
//check
xlen:=length(xdata);
if (xlen<=0) then exit;
//get
for p:=1 to xlen do
begin
result:=result+inttostr(byte(xdata[p-1+stroffset]));
if (p<xlen) then result:=result+',';
end;
result:='['+result+']';
except;end;
end;
//## low__year ##
function low__year(xmin:longint):longint;
var
   y,m,d:word;
begin
try
result:=xmin;
low__decodedate2(now,y,m,d);
if (y>xmin) then result:=y;
except;end;
end;
//## low__yearstr ##
function low__yearstr(xmin:longint):string;
begin
try;result:=inttostr(low__year(xmin));except;end;
end;
//## low__leapyear ##
function low__leapyear(xyear:longint):boolean;
begin//Note: leap years are: 2024, 2028 and 2032 - when Feb has 29 days instead of the usual 28 days
try;result:=(xyear=((xyear div 4)*4));except;end;
end;
//## low__monthdaycount0 ##
function low__monthdaycount0(xmonth,xyear:longint):longint;
begin//xmonth=0..11 => Jan..Dec
try
//defaults
result:=31;
//get
case xmonth of
0,2,4,6,7,9,11 :result:=31;//Jan31, Mar31, May31, Jul31, Aug31, Oct31, Dec31
3,5,8,10       :result:=30;//Apr30, Jun30, Sep30, Nov30
1              :result:=low__aorb(28,29,low__leapyear(xyear));//Feb28 but Feb29 on a leap year - 09mar2022
end;
except;end;
end;
//## low__monthdayfilter ##
function low__monthdayfilter0(xdayOfmonth,xmonth,xyear:longint):longint;
begin//Note: xdayOfmonth=0..30, xmonth=0..11, xyear=0..N, actual year - e.g. 2022 is really 2022
try;result:=frcrange(xdayOfmonth,0,low__monthdaycount0(xmonth,xyear)-1);except;end;
end;
//## low__scaledown ##
procedure low__scaledown(maxw,maxh,sw,sh:longint;var dw,dh:longint);//29jul2016
begin
try
//range
sw:=frcmin(sw,1);
sh:=frcmin(sh,1);
dw:=sw;
dh:=sh;
//get
if (sw>maxw) then
   begin
   sh:=frcmin(round(sh*(maxw/sw)),1);//29jul2016
   sw:=maxw;
   end;
if (sh>maxh) then
   begin
   sw:=frcmin(round(sw*(maxh/sh)),1);//29jul2016
   sh:=maxh;
   end;
//set
dw:=sw;
dh:=sh;
except;end;
end;
//## low__scale ##
procedure low__scale(maxw,maxh,sw,sh:integer;var dw,dh:integer);
var
   r1,r2:extended;
begin
try
//range
sw:=frcmin(sw,1);
sh:=frcmin(sh,1);
dw:=sw;
dh:=sh;
//get
r1:=maxw/sw;
if (r1<=0) then r1:=1;
r2:=maxh/sh;
if (r2<=0) then r2:=1;
if (r2<r1) then r1:=r2;
//set
dw:=round(sw*r1);
dh:=round(sh*r1);
except;end;
end;
//## low__orderint ##
procedure low__orderint(var x,y:longint);
begin
try;if (x>y) then low__swapint(x,y);except;end;
end;
//## low__insint ##
function low__insint(x:longint;y:boolean):longint;
begin
try;if y then result:=x else result:=0;except;end;
end;
//## low__touchlarge ##
function low__touchlarge:longint;
begin
result:=(vizoom*64);
end;
//## low__touchnormal ##
function low__touchnormal:longint;
begin
result:=(vizoom*32);
end;
//## low__touchsmall ##
function low__touchsmall:longint;
begin
//was: result:=(vizoom*24);//27mar2022
result:=(26*vizoom);//27mar2022
end;
//## low__winzoom ##
procedure low__winzoom(var dw,dh:longint);//20mar2021
var
   xrat:single;
   xzoom:longint;
begin
try
//init
xzoom:=vizoom;
xrat:=vifontwidthratio;
if vitouch then xrat:=(xrat*1.2);//27mar2022
if (xrat<1) then xrat:=1;
//get
dw:=frcmin(largest(round(dw*xrat),round(dw*xzoom)),dw);
dh:=frcmin(largest(round(dh*xrat),round(dh*xzoom)),dh);
except;end;
end;
//## low__winzoom2 ##
procedure low__winzoom2(var dw,dh:longint;xminw,xminh:longint);//20mar2021
var
   xrat:single;
   xzoom:longint;
begin
try
//init
xzoom:=vizoom;
xrat:=vifontwidthratio;
if (xrat<1) then xrat:=1;
//get
xminw:=frcmin(largest(round(xminw*xrat),round(xminw*xzoom)),xminw);
xminh:=frcmin(largest(round(xminh*xrat),round(xminh*xzoom)) ,xminh);
dw:=frcmin(largest(round(dw*xrat),round(dw*xzoom)),xminw);
dh:=frcmin(largest(round(dh*xrat),round(dh*xzoom)),xminh);
except;end;
end;
//## low__findext ##
function low__findext(s:string;var xoutlabel,xoutext,xoutmask:string):boolean;
//Note: s is "txt" or "bat" or "bmp" or "tea" etc
   //## xcap ##
   procedure xcap(x:string);
   var
      lp,p:longint;
      str1,d,dl,dm:string;
      c:char;
   begin
   //init
   d:=s+fesepX;//usually a plus sign "+"
   lp:=1;
   //get
   for p:=1 to length(d) do
   begin
   c:=d[p-1+stroffset];
   if (c=fesepX) then
      begin
      str1:=strcopy1(d,lp,p-lp);
      if (str1<>'') then
         begin
         dl:=dl+low__insstr(fesep,dl<>'')+str1;
         dm:=dm+low__insstr(fesep,dm<>'')+low__insstr('*.',str1<>'*')+str1;
         end;
      lp:=p+1;
      end;
   end;//p
   //set
   xoutlabel:=x+' ('+dl+')';
   xoutext:=s;//leave exactly as is (maintain original format even if it's "txt+bwd+bwp") - 03mar2021
   xoutmask:=dm;
   result:=true;
   end;
begin
try
//defaults
result:=false;
xoutlabel:='';
xoutext:='';
xoutmask:='';
//init
s:=low__lowercase(low__lastext2(s,true));
//get
if      (s=feany) then xcap('All Files')
else if (s=fec2p) then xcap('Claude 2 Product')
else if (s=fec2v) then xcap('Claude 2 Values')
else if (s=feini) then xcap('INI Document')
else if (s=fetxt) then xcap('Text Document')
else if (s=febwd) then xcap('Blaiz Writer Document')//26sep2022
else if (s=febwp) then xcap('Blaiz Word Processor Document')
else if (s=fesfef) then xcap('Small File Encrypter File')//27sep2022
else if (s=fexml) then xcap('XML (Pad) Document')
else if (s=fehtml) then xcap('HTML Document')
else if (s=febat) then xcap('Batch File')
else if (s=febmp) then xcap('Bitmap Picture')
else if (s=fegif) then xcap('GIF Picture')
else if (s=fejpg) then xcap('JPEG Picture')
else if (s=fejif) then xcap('JIF Picture')
else if (s=fejpeg) then xcap('JPEG Picture')
else if (s=fepng) then xcap('Portable Network Graphic Picture')
else if (s=feico) then xcap('Icon')//15feb2022
else if (s=fecur) then xcap('Static Cursor')//22may2022, 29aug2021
else if (s=feani) then xcap('Animated Cursor')//29aug2021
else if (s=fetep) then xcap('Text Picture')
else if (s=fetea) then xcap(protect_text(16771257,'TEA Picture'))
else if (s=febvid) then xcap('Basic Video')//20jun2021
else if (s=feAU22) then xcap('Raw Audio - 22,050 Hz')//17jul2021
else if (s=feAU44) then xcap('Raw Audio - 44,100 Hz')//17jul2021
else if (s=feAU48) then xcap('Raw Audio - 48,000 Hz')//17jul2021
else if (s=fevmp) then xcap('Video Magic Project')//06jul2021
else if (s=fevmt) then xcap('Video Magic Track')//06jul2021
else if (s=feabr) then xcap('Abra Cadabra Project')//01aug2021
else if (s=feaccp) then xcap('Animated Cursor Creator Project')//07feb2022
else if (s=femjpeg) then xcap('Motion JPEG Video')//20jun2021
else if (s=fealarms) then xcap('Alarms List')//12nov2022, 08mar2022
else if (s=feReminders) then xcap('Reminders List')//09mar2022
else if (s=feM3U) then xcap('Playlist')//20mar2022
else if (s=feFootnote) then xcap('Footnote')//21mar2022
else if (s=feCursorScript) then xcap('Cursor Script')//17may2022
else if (s=feallfiles) then xcap('All Files')
else if (s=fealldocs) then xcap('All Documents')
else if (s=feallimgs) then xcap('All Images')
else if (s=feallcurs) then xcap('All Cursors')
else if (s=feallcurs2) then xcap('All Cursors')//22may2022
else if (s=fealljpgs) then xcap('All JPEG Pictures')//03sep2021
else if (s=febcs) then xcap(protect_text(16771558,'Blaiz Color Scheme'));
except;end;
end;
//## low__forceext ##
function low__forceext(xfilename,xforceext:string):string;
begin
try;result:=low__forceext2(xfilename,xforceext,true);except;end;
end;
//## low__forceext2 ##
function low__forceext2(xfilename,xforceext:string;xappend:boolean):string;
var
   p,lp:longint;
   str1,d,xext,xoutlabel,xoutext,xoutmask:string;
   xforcedone:boolean;
   c:char;
   //## xforce ##
   procedure xforce;
   label
      skipend;
   var
      lp,p:longint;
      dext,str1,d,dl,dm:string;
      c:char;
   begin
   try
   //init
   d:=xoutext+fesepX;//usually a plus sign "+"
   dext:='';
   lp:=1;
   //get
   for p:=1 to length(d) do
   begin
   c:=d[p-1+stroffset];
   if (c=fesepX) then
      begin
      str1:=strcopy1(d,lp,p-lp);
      if (dext='') then dext:=str1;//take first instance as fallback
      if (str1=xext) or (str1=feany) then
         begin
         xforcedone:=true;
         goto skipend;//filename.ext matches one of the extensions in the list -> do nothing
         end;
      lp:=p+1;
      end;
   end;//p
   //force first ext we came across
   if (dext<>'') then
      begin
      if xappend then result:=result+low__insstr('.',strcopy1(result,length(result),1)<>'.')+dext
      else            result:=strcopy1(result,1,length(result)+low__insint(-1,xext<>'')-length(xext))+'.'+dext;
      //successful
      xforcedone:=true;
      end;
   skipend:
   except;end;
   end;
begin
try
//defaults
result:=xfilename;
xforcedone:=false;
//check
if (xforceext=feany) then exit;
//init
xext:=low__lowercase(low__lastext(xfilename));//allows "nil"
//get
d:=xforceext+fesep;
lp:=1;
for p:=1 to length(d) do
begin
c:=d[p-1+stroffset];
if (c=fesep) or (c=fesepX) then//";" or "+"
   begin
   str1:=strcopy1(d,lp,p-lp);
   if low__findext(str1,xoutlabel,xoutext,xoutmask) then
      begin
      xforce;
      if xforcedone then break;//done
      end;
   lp:=p+1;
   end;
end;//p
except;end;
end;
//## remdupb ##
function low__remdup(x:string):string;//remove duplicates
begin
try;result:=low__remdup2(x,false,false);except;end;
end;
//## low__remdup2 ##
function low__remdup2(x:string;xremblanklines,xsort:boolean):string;//remove duplicates
var
   s,a:tdynamicstring;
   p,acount:longint;
   xline:string;
   //## xhave ##
   function xhave:boolean;
   var
      p:longint;
   begin
   result:=false;
   if (acount<=0) then exit;
   for p:=0 to (acount-1) do if low__comparetext(a.items[p]^,xline) then
      begin
      result:=true;
      break;
      end;//p
   end;
begin
try
//defaults
result:='';
s:=nil;
a:=nil;
acount:=0;
//init
a:=tdynamicstring.create;
s:=tdynamicstring.create;
s.text:=x;
//get
if (s.count>=1) then
   begin
   for p:=0 to (s.count-1) do
   begin
   xline:=s.items[p]^;
   if ((xline<>'') or (not xremblanklines)) and (not xhave) then
      begin
      a.value[acount]:=xline;
      inc(acount);
      end;
   end;//p
   end;
//set
if (a.count>=1) then
   begin
   case xsort of
   false:result:=a.text;
   true:begin
      a.sort(true);
      result:=a.stext;
      end;
   end;//case
   end;
except;end;
try
freeobj(@a);
freeobj(@s);
except;end;
end;
//## low__exename ##
function low__exename:string;
begin
try;result:=paramstr(0);except;end;//w32 and a32
end;
//## low__ownname ##
function low__ownname:string;
begin
try;result:=remlastext(low__extractfilename(paramstr(0)));except;end;//c:\xxxx\abc.exe -> "abc" - 09aug2021
end;
//## low__paramstr1 ##
function low__paramstr1:string;
begin
try;result:=paramstr(1);except;end;
end;
//## low__insstr ##
function low__insstr(x:string;y:boolean):string;
begin
try;if y then result:=x else result:='';except;end;
end;
//## low__repeatstr ##
function low__repeatstr(x:string;xcount:longint):string;//15nov2022
var
   a:tstr8;
   p:longint;
begin
try
//defaults
result:=x;
a:=nil;
//get
if (xcount>=2) and (x<>'') then
   begin
   a:=bnew;
   for p:=1 to xcount do a.sadd(x);
   result:=a.text;
   end;
except;end;
try;bfree(a);except;end;
end;
//## low__swapvals0 ##
function low__swapvals0(x,v0:string):string;
begin
try;result:=low__swapvals01234(x,v0,'','','','');except;end;
end;
//## low__swapvals01 ##
function low__swapvals01(x,v0,v1:string):string;
begin
try;result:=low__swapvals01234(x,v0,v1,'','','');except;end;
end;
//## low__swapvals012 ##
function low__swapvals012(x,v0,v1,v2:string):string;
begin
try;result:=low__swapvals01234(x,v0,v1,v2,'','');except;end;
end;
//## low__swapvals0123 ##
function low__swapvals0123(x,v0,v1,v2,v3:string):string;
begin
try;result:=low__swapvals01234(x,v0,v1,v2,v3,'');except;end;
end;
//## low__swapvals01234 ##
function low__swapvals01234(x,v0,v1,v2,v3,v4:string):string;
label
   redo;
var
   a:tstr8;
   xcount,v,p,xlen:longint;
   //## xadd ##
   procedure xadd(x:string);
   begin
   if (x<>'') then a.sins(x,p+1);
   end;
begin
try
//defaults
result:='';
a:=nil;
//get
a:=bnew;
a.text:=x;
xlen:=a.len;
xcount:=0;
p:=0;
redo:
//.scan
if (a.pbytes[p]=37) and ((p+2)<xlen) and (a.pbytes[p+2]=37) then//expects "%1%" format val names - 27jun2022
   begin
   v:=a.pbytes[p+1]-nn0;
   if (v>=0) and (v<=9) then
      begin
      inc(xcount);//limit cyclic loops
      a.del3(p,3);
      dec(p);
      case v of
      0:xadd(v0);
      1:xadd(v1);
      2:xadd(v2);
      3:xadd(v3);
      4:xadd(v4);
      end;
      end;
   end;
//.inc
inc(p);
if (p>=0) and (p<xlen) and (xcount<=200) then goto redo;

//set
result:=a.text;
except;end;
try;bfree(a);except;end;
end;
//## low__trimdec ##
function low__trimdec(x:string):string;//01aug2021
begin//auto trim ".0" or  ".10" or  ".100"
try
result:=x;
if (strcopy1(result,length(result)-1,2)='.0') then result:=strcopy1(result,1,length(result)-2)
else if (strcopy1(result,length(result)-2,3)='.10') then result:=strcopy1(result,1,length(result)-1)
else if (strcopy1(result,length(result)-3,4)='.100') then result:=strcopy1(result,1,length(result)-2);
except;end;
end;
//## low__urlok ##
function low__urlok(xurl:string;xmailto:boolean):boolean;//19apr2021
   //## xmatch ##
   function xmatch(n:string):boolean;
   begin
   result:=(n<>'') and low__comparetext(strcopy1(xurl,1,length(n)),n);
   end;
begin
try;result:=xmatch('http://') or xmatch('https://') or xmatch('ftp://') or xmatch('ftps://') or (xmailto and xmatch('mailto:'));except;end;
end;
//## low__limitlines ##
function low__limitlines(x:string;xlimit:longint):string;//14apr2021
var
   s,d:tdynamicstring;
   p:longint;
begin
try
//defaults
result:='';
s:=nil;
d:=nil;
//init
xlimit:=frcmin(xlimit,0);
//get
s:=tdynamicstring.create;
d:=tdynamicstring.create;
s.text:=x;
if (s.count>=1) and (xlimit>=1) then
   begin
   for p:=(frcmax(s.count,xlimit)-1) downto 0 do d.value[p]:=s.value[p];
   result:=d.text;
   end;
except;end;
try
freeobj(@s);
freeobj(@d);
except;end;
end;
//## low__findchar ##
function low__findchar(var x:string;c:char):longint;//27feb2021, 14SEP2007
var
   p:longint;
   cv:byte;
begin
try
//defaults
result:=0;//not found
cv:=byte(c);
//get
for p:=1 to length(x) do if (strbyte1(x,p)=cv) then
   begin
   result:=p;
   break;
   end;//end of if
except;end;
end;
//## low__havechar ##
function low__havechar(var x:string;c:char):boolean;//27feb2021, 02FEB2008
var
   p:longint;
   cv:byte;
begin
try
//defaults
result:=false;
cv:=byte(c);
//get
for p:=1 to length(x) do if (strbyte1(x,p)=cv) then
   begin
   result:=true;
   break;
   end;//end of if
except;end;
end;
//## low__havecharb ##
function low__havecharb(x:string;c:char):boolean;//09mar2021
begin
try;result:=low__havechar(x,c);except;end;
end;
//## low__comparearray ##
function low__comparearray(a,b:array of byte):boolean;//27jan2021
var
   ai,bi,va,vb,p:longint;
begin
try
//defaults
result:=false;
//get
if (sizeof(a)=sizeof(b)) then
   begin
   //init
   result:=true;
   ai:=low(a);
   bi:=low(b);
   //get
   for p:=1 to sizeof(a) do
   begin
   va:=a[ai];
   vb:=b[bi];
   if (va>=97) and (va<=122) then dec(va,32);
   if (vb>=97) and (vb<=122) then dec(vb,32);
   if (va<>vb) then
      begin
      result:=false;
      break;
      end;
   //inc
   inc(ai);
   inc(bi);
   end;//p
   end;
except;end;
end;
//## aorb ##
function low__aorb(a,b:longint;xuseb:boolean):longint;
begin
try;if xuseb then result:=b else result:=a;except;end;
end;
//## low__aorbcur ##
function low__aorbcur(a,b:currency;xuseb:boolean):currency;//07oct2022
begin
try;if xuseb then result:=b else result:=a;except;end;
end;
//## low__yes ##
function low__yes(x:boolean):string;//16sep2022
begin
try;result:=low__aorbstr('No','Yes',x);except;end;
end;
//## low__aorbstr ##
function low__aorbstr(a,b:string;xuseb:boolean):string;
begin
try;if xuseb then result:=b else result:=a;except;end;
end;
//## low__aorbchar ##
function low__aorbchar(a,b:char;xuseb:boolean):char;
begin
try;if xuseb then result:=b else result:=a;except;end;
end;
//## low__aorbbol ##
function low__aorbbol(a,b:boolean;xuseb:boolean):boolean;
begin
try;if xuseb then result:=b else result:=a;except;end;
end;
//## initcrc32 ##
procedure low__initcrc32;
const//Note: 0xedb88320L="-306674912"
   seed=$edb88320;
var
   c,k,n:longint;
begin
try
//check
if sys_initcrc32 then exit;
//get
for n:=0 to 255 do
begin
c:=n;
for k:=0 to 7 do if boolean(c and 1) then c:=seed xor (c shr 1) else c:=c shr 1;
sys_crc32[n]:=c;
end;//end of loop
except;end;
try;sys_initcrc32:=true;except;end;
end;
//## crc32inc ##
procedure low__crc32inc(var _crc32:longint;x:byte);//23may2020, 31-DEC-2006
var
   c:longint;
begin
try
//check
if not sys_initcrc32 then low__initcrc32;
//get
c:=_crc32 xor $ffffffff;
c:=sys_crc32[(c xor byte(x)) and $ff] xor (c shr 8);
_crc32:=c xor $ffffffff;
except;end;
end;
//## low__crc32 ##
procedure low__crc32(var _crc32:longint;x:tstr8;s,f:longint);//31-DEC-2006, updated 27-MAR-2007
label
   skipend;
var//Industry standard CRC-32 (PASSED, Sunday 31-DEC-2006)
   c,p,xlen:longint;
begin
try
//defaults
_crc32:=0;
//check
if (not block(x)) or (x.count<=0) then goto skipend else xlen:=x.count;
//init
if not sys_initcrc32 then low__initcrc32;
//range
s:=frcrange(s,1,xlen);
f:=frcrange(f,s,xlen);
//get
for p:=s to f do low__crc32inc(_crc32,x.bytes1[p]);
skipend:
except;end;
try;bunlockautofree(x);except;end;
end;
//## crc32c ##
function low__crc32c(x:tstr8;s,f:longint):longint;
begin
try
result:=0;
if block(x) then low__crc32(result,x,s,f);
except;end;
try;bunlockautofree(x);except;end;
end;
//## crc32b ##
function low__crc32b(x:tstr8):longint;
begin
try
result:=0;
if block(x) then low__crc32(result,x,1,x.count);
except;end;
try;bunlockautofree(x);except;end;
end;
//## crc32nonzero ##
function low__crc32nonzero(x:tstr8):longint;//02SEP2010
begin
try
//defaults
result:=0;//only zero if "z=''" else non-zero, always
//get
if block(x) and (x.count>=1) then
   begin
   result:=low__crc32b(x);
   if (result=0) then result:=1;
   end;
except;end;
try;bunlockautofree(x);except;end;
end;
//## crc32seedable ##
function low__crc32seedable(x:tstr8;xseed:longint):longint;//14jan2018
label
   skipend;
var
   xref:array[0..255] of longint;
   k,n,c:longint;
begin
try
//defaults
result:=0;//only zero if "z=''" else non-zero, always
//check
if zznil(x,2196) or (x.count<=0) then goto skipend;
if (xseed=0) then xseed:=$edb88320;//industry standard seed value
//init
for n:=0 to 255 do
begin
c:=n;
for k:=0 to 7 do if boolean(c and 1) then c:=xseed xor (c shr 1) else c:=c shr 1;
xref[n]:=c;
end;//n
//get
for n:=1 to x.count do
begin
c:=result xor $ffffffff;
c:=xref[(c xor x.bytes1[n]) and $ff] xor (c shr 8);
result:=c xor $ffffffff;
end;//n
skipend:
except;end;
try;bautofree(x);except;end;
end;
//## nozero ##
function nozero(xdebugID,x:longint):longint;
begin
try
//defaults
result:=1;//fail safe value
//check
if (xdebugID<1000000) then showerror('Invalid no zero location value '+inttostr(xdebugID));//value MUST BE 1 million or above - this is strictly a made-up threshold to make it standout from code and code values - 26jul2016
//get
if (x=0) then
   begin
   //in program debug
   if programactivedebugger then showerror('No zero (int) error at location '+inttostr(xdebugID));
   //other
   exit;
   end
else result:=x;//acceptable value (non-zero)
except;end;
end;
//## nozero_byt ##
function nozero_byt(xdebugID:longint;x:byte):byte;
begin
try
//defaults
result:=1;//fail safe value
//check
if (xdebugID<1000000) then showerror('Invalid no zero location value '+inttostr(xdebugID));//value MUST BE 1 million or above - this is strictly a made-up threshold to make it standout from code and code values - 26jul2016
//get
if (x=0) then
   begin
   //in program debug
   if programactivedebugger then showerror('No zero (byte) error at location '+inttostr(xdebugID));
   //other
   exit;
   end
else result:=x;//acceptable value (non-zero)
except;end;
end;
//## nozero_dbl ##
function nozero_dbl(xdebugID:longint;x:double):double;
begin
try
//defaults
result:=1;//fail safe value
//check
if (xdebugID<1000000) then showerror('Invalid no zero location value '+inttostr(xdebugID));//value MUST BE 1 million or above - this is strictly a made-up threshold to make it standout from code and code values - 26jul2016
//get
if (x=0) then
   begin
   //in program debug
   if programactivedebugger then showerror('No zero (double) error at location '+inttostr(xdebugID));
   //other
   exit;
   end
else result:=x;//acceptable value (non-zero)
except;end;
end;
//## nozero_ext ##
function nozero_ext(xdebugID:longint;x:extended):extended;
begin
try
//defaults
result:=1;//fail safe value
//check
if (xdebugID<1000000) then showerror('Invalid no zero location value '+inttostr(xdebugID));//value MUST BE 1 million or above - this is strictly a made-up threshold to make it standout from code and code values - 26jul2016
//get
if (x=0) then
   begin
   //in program debug
   if programactivedebugger then showerror('No zero (extended) error at location '+inttostr(xdebugID));
   //other
   exit;
   end
else result:=x;//acceptable value (non-zero)
except;end;
end;
//## nozero_cur ##
function nozero_cur(xdebugID:longint;x:currency):currency;
begin
try
//defaults
result:=1;//fail safe value
//check
if (xdebugID<1000000) then showerror('Invalid no zero location value '+inttostr(xdebugID));//value MUST BE 1 million or above - this is strictly a made-up threshold to make it standout from code and code values - 26jul2016
//get
if (x=0) then
   begin
   //in program debug
   if programactivedebugger then showerror('No zero (currency) error at location '+inttostr(xdebugID));
   //other
   exit;
   end
else result:=x;//acceptable value (non-zero)
except;end;
end;
//## nozero_sig ##
function nozero_sig(xdebugID:longint;x:single):single;
begin
try
//defaults
result:=1;//fail safe value
//check
if (xdebugID<1000000) then showerror('Invalid no zero location value '+inttostr(xdebugID));//value MUST BE 1 million or above - this is strictly a made-up threshold to make it standout from code and code values - 26jul2016
//get
if (x=0) then
   begin
   //in program debug
   if programactivedebugger then showerror('No zero (single) error at location '+inttostr(xdebugID));
   //other
   exit;
   end
else result:=x;//acceptable value (non-zero)
except;end;
end;
//## nozero_rel ##
function nozero_rel(xdebugID:longint;x:real):real;
begin
try
//defaults
result:=1;//fail safe value
//check
if (xdebugID<1000000) then showerror('Invalid no zero location value '+inttostr(xdebugID));//value MUST BE 1 million or above - this is strictly a made-up threshold to make it standout from code and code values - 26jul2016
//get
if (x=0) then
   begin
   //in program debug
   if programactivedebugger then showerror('No zero (real) error at location '+inttostr(xdebugID));
   //other
   exit;
   end
else result:=x;//acceptable value (non-zero)
except;end;
end;
//## nozero_cmp ##
function nozero_cmp(xdebugID:longint;x:comp):comp;
begin
try
//defaults
result:=1;//fail safe value
//check
if (xdebugID<1000000) then showerror('Invalid no zero location value '+inttostr(xdebugID));//value MUST BE 1 million or above - this is strictly a made-up threshold to make it standout from code and code values - 26jul2016
//get
if (x=0) then
   begin
   //in program debug
   if programactivedebugger then showerror('No zero (comp) error at location '+inttostr(xdebugID));
   //other
   exit;
   end
else result:=x;//acceptable value (non-zero)
except;end;
end;
//-- Color Support -------------------------------------------------------------
//## low__rgb ##
function low__rgb(r,g,b:byte):longint;
var
   x:tint4;
begin
try
x.r:=r;
x.g:=g;
x.b:=b;
x.a:=0;
result:=x.val;
except;end;
end;
//## low__rgb24 ##
function low__rgb24(r,g,b:byte):tcolor24;
begin
try
result.r:=r;
result.g:=g;
result.b:=b;
except;end;
end;
//## low__rgba ##
function low__rgba(r,g,b,a:byte):longint;
var
   x:tint4;
begin
try
x.r:=r;
x.g:=g;
x.b:=b;
x.a:=a;
result:=x.val;
except;end;
end;
//## low__rgb32to24 ##
function low__rgb32to24(var x:tcolor32):tcolor24;//21jun2022
begin
result.r:=x.r;
result.g:=x.g;
result.b:=x.b;
end;
//## low__rgb24to32 ##
function low__rgb24to32(var x:tcolor24;xa:byte):tcolor32;//21jun2022
begin
result.r:=x.r;
result.g:=x.g;
result.b:=x.b;
result.a:=xa;
end;
//## low__colbright ##
function low__colbright(x:longint):longint;
var
   a:tint4;
begin
try
result:=0;
a.val:=x;
if (a.r>result) then result:=a.r;
if (a.g>result) then result:=a.g;
if (a.b>result) then result:=a.b;
except;end;
end;
//## low__colsplice ##
function low__colsplice(x,c1,c2:longint):longint;
var
   a,b:tint4;
   P1,P2:longint;
begin
try
{Error}
Result:=0;
{P1 & P2}
x:=frcrange(x,0,100);
P1:=(X*100) Div 100;
P2:=100-P1;
{Color}
a.val:=c1;
b.val:=c2;
a.R:=(a.R*P1+b.R*P2) Div 100;
a.G:=(a.G*P1+b.G*P2) Div 100;
a.B:=(a.B*P1+b.B*P2) Div 100;
{Return Result}
Result:=a.val;
except;end;
end;
//## low__colsplice1 ##
function low__colsplice1(xpert:extended;s,d:longint):longint;//13nov2022
begin//xpert range is 0..1 (0=0% and 0.5=50% and 1=100%)
try;result:=low__rgbint(low__rgbsplice24(xpert,low__intrgb(s),low__intrgb(d)));except;end;
end;
//## low__compare24 ##
function low__compare24(s,d:tcolor24):boolean;
begin
result:=(s.r=d.r) and (s.g=d.g) and (s.b=d.b);
end;
//## low__rgbsplice24 ##
function low__rgbsplice24(xpert:extended;s,d:tcolor24):tcolor24;//17may2022
var//xpert range is 0..1 (0=0% and 0.5=50% and 1=100%)
   p2:extended;
   v:longint;
begin
try
//defaults
result:=s;
//init
if (xpert<0) then xpert:=0 else if (xpert>1) then xpert:=1;
p2:=1-xpert;
//r
v:=round((d.r*xpert)+(s.r*p2));
if (v<0) then v:=0 else if (v>255) then v:=255;
result.r:=v;
//g
v:=round((d.g*xpert)+(s.g*p2));
if (v<0) then v:=0 else if (v>255) then v:=255;
result.g:=v;
//b
v:=round((d.b*xpert)+(s.b*p2));
if (v<0) then v:=0 else if (v>255) then v:=255;
result.b:=v;
except;end;
end;
//## low__sc ##
function low__sc(sc,dc,pert:longint):longint;//shift color
begin
try;result:=low__colsplice(frcrange(pert,0,100),dc,sc);except;end;
end;
//## low__sc1 ##
function low__sc1(xpert:extended;sc,dc:longint):longint;//shift color
begin
try;result:=low__colsplice1(xpert,sc,dc);except;end;
end;
//## dc ##
function low__dc(x,y:longint):longint;//differential color
label
     redo;
var
   once:boolean;
   ox,a:tint4;
   by,z:longint;
begin
try
//prepare
once:=true;
ox.val:=x;
//y check
if (y=0) then
   begin
   result:=ox.val;
   exit;
   end;//end of if
//check for "black"
//.y
//yyyyyyyyyyyyyyyyyif (colbright(ox.val)<100) then y:=100;
//.by
by:=y;
if (by<0) then by:=-by;
by:=by div 2;
//a.val
a.val:=ox.val;
//process
redo:
//.r
z:=(a.r+y);if (z<0) then z:=0 else if (z>255) then z:=255;a.r:=z;
//.g
z:=(a.g+y);if (z<0) then z:=0 else if (z>255) then z:=255;a.g:=z;
//.b
z:=(a.b+y);if (z<0) then z:=0 else if (z>255) then z:=255;a.b:=z;
//check
if once and (low__nrw(low__colbright(a.val),low__colbright(ox.val),by) or (low__nrw(a.r,ox.r,by) and low__nrw(a.g,ox.g,by) and low__nrw(a.b,ox.b,by))) then
   begin
   a.val:=ox.val;
   y:=-y;
   once:=false;
   goto redo;
   end;//end of if
//return result
result:=a.val;
except;end;
end;
//## low__int3toRGB ##
procedure low__int3toRGB(x:longint;var r,g,b:byte);
begin
//range
x:=frcrange(x,0,16777215);
//get
//.b
b:=byte(frcrange(x div (256*256),0,255));
dec(x,b*256*256);
//.g
g:=byte(frcrange(x div 256,0,255));
dec(x,g*256);
//.r
r:=byte(frcrange(x,0,255));
end;
//## low__intrgb ##
function low__intrgb(x:longint):tcolor24;
var
   a:tint4;
begin
try
//get
a.val:=x;
//set
result.r:=a.r;
result.g:=a.g;
result.b:=a.b;
except;end;
end;
//## low__intrgb32 ##
function low__intrgb32(x:longint;aval:byte):tcolor32;
var
   a:tint4;
begin
try
//get
a.val:=x;
//set
result.r:=a.r;
result.g:=a.g;
result.b:=a.b;
result.a:=aval;
except;end;
end;
//## low__intrgba32 ##
function low__intrgba32(x:longint):tcolor32;
var
   a:tint4;
begin
try
//get
a.val:=x;
//set
result.r:=a.r;
result.g:=a.g;
result.b:=a.b;
result.a:=a.b;
except;end;
end;
//## low__blendcolor32 ##
procedure low__blendcolor32(var f,b:tcolor32);//7,703ms -> 6,047ms -> 5,782ms -> 5,234 -> 3,781ms -> 3,875ms
var//Note: Blends two 32bit colors together at high-speed. Output color
   //      is written into "b" wiping previous contents - 01jul2021
   //Works perfectly - 01jul2021
   ba,v:longint;
   ff,bb:double;
begin
if (f.a>=255) then
   begin
   b.r:=f.r;
   b.g:=f.g;
   b.b:=f.b;
   b.a:=f.a;
   exit;
   end
else if (f.a<=0) then exit;
ba:=b.a;
b.a:=255-round((255-f.a)*(255-ba)*0.0039215);//slightly faster than using a "div 255" - 01jul2021
if (b.a<=0) then
   begin
   b.r:=0;
   b.g:=0;
   b.b:=0;
   b.a:=0;
   exit;
   end;
ff:=f.a/b.a;
bb:=ba*(255-f.a)/(b.a*255);
//.r
v:=round( (f.r*ff) + (b.r*bb) );
if (v>255) then b.r:=255 else b.r:=v;
//.g
v:=round( (f.g*ff) + (b.g*bb) );
if (v>255) then b.g:=255 else b.g:=v;
//.b
v:=round( (f.b*ff) + (b.b*bb) );
if (v>255) then b.b:=255 else b.b:=v;
end;
//## low__iseven ##
function low__iseven(x:longint):boolean;
begin//no error handling for maximum speed - 28mar2020
result:=(x=((x div 2)*2));
end;
//## low__msb16 ##
procedure low__msb16(var s:word);//most significant bit first - 22JAN2011
var//bit work, 16bit, swapper, swap
   a,b:twrd2;
begin
try
a.val:=s;
b.bytes[0]:=a.bytes[1];
b.bytes[1]:=a.bytes[0];
s:=b.val;
except;end;
end;
//## low__msb32 ##
procedure low__msb32(var s:longint);//most significant bit first - 22JAN2011
var//bit work, 32bit, swap, swapper,
   a,b:tint4;
begin
try
a.val:=s;
b.bytes[0]:=a.bytes[3];
b.bytes[1]:=a.bytes[2];
b.bytes[2]:=a.bytes[1];
b.bytes[3]:=a.bytes[0];
s:=b.val;
except;end;
end;
//## low__thousands64 ##
function low__thousands64(x:comp):string;//handles full 64bit whole number range of min64..max64 - 24jan2016
begin
try;result:=low__64(x);except;end;
end;
//## low__64 ##
function low__64(x:comp):string;//handles full 64bit whole number range of min64..max64 - 24jan2016
begin
try;result:=low__64ex(x,true);except;end;
end;
//## low__64ex ##
function low__64ex(x:comp;xsep:boolean):string;//handles full 64bit whole number range of min64..max64 - 24jan2016
const
   sep=',';
var
   i,xlen,p:longint;
   z2,z,y:string;
begin
try
//defaults
result:='0';
//range
x:=restrict64(x);
//get
z2:='';
if (x<0) then
   begin
   x:=-x;
   z2:='-';
   end;
y:=floattostrex2(x);
z:='';
xlen:=length(y);
i:=0;
if (xlen>=1) then
   begin
   for p:=(xlen-1) downto 0 do
   begin
   inc(i);
   if (i>=3) and (p>0) then
      begin
      case xsep of//10mar2021
      true:z:=sep+strcopy0(y,p,3)+z;
      false:z:=strcopy0(y,p,3)+z;
      end;
      i:=0;
      end;
   end;//p
   end;
if (i<>0) then z:=strcopy0(y,0,i)+z;
//set
result:=z2+z;
except;end;
end;
//## low__mult ##
function low__mult64(xval,xval2:comp):comp;//multiply
begin
try
result:=xval;
result:=result*xval2;
except;end;
end;
//## low__add64 ##
function low__add64(xval,xval2:comp):comp;//add
begin
try
result:=xval;
result:=result+xval2;
except;end;
end;
//## low__sub64 ##
function low__sub64(xval,xval2:comp):comp;//subtract
begin
try
result:=xval;
result:=result-xval2;
except;end;
end;
//## low__sub32 ##
function low__sub32(xval,xval2:comp):longint;//30sep2022, subtract
begin
try;result:=restrict32(low__sub64(xval,xval2));except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//?????????????????????????????
//## low__div64 ##
function low__div64(xval,xdivby:comp):comp;//28dec2021, proper "comp division" -> fixes Delphi's "comp" division error -> which raises POINTER EXCEPTION and MEMORY ERRORS when used at speed and repeatedly - 13jul2021, 19apr2021
label
   vsmall,x1b,x100m,x10m,x1m,x100K,x10K,x1K,x100,x10,x1;
var
   xminus:boolean;
   vmax,v2,v,xoutval:comp;
begin
try
//defaults
result:=0;
xoutval:=0;
//zero value - 13jul2021
if (xval=0) then
   begin
   result:=0;
   exit;
   end;
//.divide by zero - 28dec2021
if (xdivby=0) then
   begin
   result:=0;
   exit;
   end;
//init
xminus:=(xval<0);
if xminus then xval:=-xval;
vmax:=low__mult64(100000000,1000);
//decide
if (xdivby>=vmax) then goto vsmall;

//1b
v:=xdivby*1000000000;
x1b:
if (v<=xval) then
   begin
   xoutval:=xoutval+1000000000;
   xval:=xval-v;
   goto x1b;
   end;

//100m
v:=xdivby*100000000;
x100m:
if (v<=xval) then
   begin
   xoutval:=xoutval+100000000;
   xval:=xval-v;
   goto x100m;
   end;
//10m
v:=xdivby*10000000;
x10m:
if (v<=xval) then
   begin
   xoutval:=xoutval+10000000;
   xval:=xval-v;
   goto x10m;
   end;
//1m
v:=xdivby*1000000;
x1m:
if (v<=xval) then
   begin
   xoutval:=xoutval+1000000;
   xval:=xval-v;
   goto x1m;
   end;
//100K
v:=xdivby*100000;
x100K:
if (v<=xval) then
   begin
   xoutval:=xoutval+100000;
   xval:=xval-v;
   goto x100K;
   end;
//10K
v:=xdivby*10000;
x10K:
if (v<=xval) then
   begin
   xoutval:=xoutval+10000;
   xval:=xval-v;
   goto x10K;
   end;
//1K
v:=xdivby*1000;
x1K:
if (v<=xval) then
   begin
   xoutval:=xoutval+1000;
   xval:=xval-v;
   goto x1K;
   end;
//100
v:=xdivby*100;
x100:
if (v<=xval) then
   begin
   xoutval:=xoutval+100;
   xval:=xval-v;
   goto x100;
   end;
//10
vsmall:
v:=xdivby*10;
x10:
if (v<=xval) then
   begin
   xoutval:=xoutval+10;
   xval:=xval-v;
   goto x10;
   end;
//1
v:=xdivby;
x1:
if (v<=xval) then
   begin
   xoutval:=xoutval+1;
   xval:=xval-v;
   goto x1;
   end;

//set
if xminus then result:=-xoutval else result:=xoutval;
except;end;
end;
//## low__div32 ##
function low__div32(xval,xdivby:comp):longint;//proper "comp division" - 19apr2021
var
   v:comp;
begin
try
result:=0;
v:=low__div64(xval,xdivby);
if (v<minint) then v:=minint else if (v>maxint) then v:=maxint;
result:=round(v);
except;end;
end;
//## low__pert32 ##
function low__pert32(xval,xlimit:comp):longint;
begin
try;result:=frcrange(low__div32(low__mult64(xval,100),xlimit),0,100);except;end;
end;
//## low__makepertD0 ##
function low__makepertD0(xpos,xlen:longint):double;//06mar2022
begin//Note: xpos=0..(len-1)
try
//defaults
result:=0;
//init
xlen:=frcrange(xlen,0,maxint);
xpos:=frcrange(xpos,0,xlen);
//get
result:=(xpos/frcmin(xlen-1,1))*100;
if (result<0) then result:=0 else if (result>100) then result:=100;
except;end;
end;
//## low__digpad20 ##
function low__digpad20(v:comp;s:longint):string;//1 -> 01
const
   p='00000000000000000000';//20
begin
try
v:=restrict64(v);
result:=floattostrex2(v);
result:=strcopy1(p,1,frcmin(s-length(result),0))+result;
except;end;
end;
//## low__digpad11 ##
function low__digpad11(v,s:longint):string;//1 -> 01
const
   p='00000000000';//11
begin
try
result:=inttostr(v);
result:=strcopy1(p,1,frcmin(s-length(result),0))+result;
except;end;
end;
//## rthtranslate ##
function rthtranslate(x:string):string;//31JAN2011, 05OCT2007 - don't translate, just mark the text for "sniffer", since text will be translated in realtime on demand
var
   tmp,e:string;
begin
try
//custom translator - just fill with empty translation
//disabled: if programlanguage then multilingual.translate(x,tmp,e,stHelp);
//return raw data - controls use this for bait and to fill "tsup" for later use
result:=x;
except;end;
end;
//## ntranslate ##
function ntranslate(x:string):string;//31JAN2011
begin
//xxxxxxxxxxxxxxxxxxxx try;result:=low__asname(translate(x));except;end;
try;result:=x;except;end;
end;
//## translate ##
function translate(x:string):string;//31JAN2011, 03NOV2010
begin
try;result:=x;except;end;
end;
//## xlang ##
function xlang(x:string):string;//06may2020
begin
try;result:=x;except;end;
end;
//## low__uptime ##
function low__uptime(xtime:comp;xforcehr,xforcemin,xshowms,xshowsec:boolean;xsep:string):string;//fixed - 27dec2021, fixed 10mar2021, 22feb2021, 22jun2018, 03MAY2011, 07SEP2007
const//Show: days, hours, min, sec - 03MAY2011
     //Math Warning: Type "comp" does not divide correctly, e.g. "xval = trunc(30000 / 1000)" should be 30 but comp returns 29 which is clearly wrong! - 10mar2021
     //              But type currency DOES work correctly returning the expected value of 30, but higher division values like oneday or 86400000 must use ".0" e.g. "86400000.0" to divide correclt - 10mar2021.
   oneday  =86400000.0;
   onehour =3600000.0;//Important: these values (x4) require their trailing ".0" to swing them into native currency mode for proper mathematical division to occur, else BAD rounding occurs rendering this proc inaccurate and utterly useless - 10mar2021
   onemin  =60000.0;
   onesec  =1000.0;
var
   x,dy,h,m,s,ms:currency;
   ok:boolean;
begin
try
//defaults
result:='';
ok:=false;
dy:=0;
h:=0;
m:=0;
s:=0;
ms:=0;

//range -> need to limit "xtime" to safe positive currency range with is "0..(maxcur-1)" for this proc
if (xtime>(maxcur-1)) then xtime:=(maxcur-1) else if (xtime<0) then xtime:=0;

//translate "xtime.comp" into "x.currency" as division with "comp" numbers does NOT work properly no matter what or how it is done - 10mar2021
x:=xtime;

//get
if (x>=0) then
   begin
   //.day
   dy:=trunc(x/oneday);
   x:=x-(dy*oneday);
   //.hour
   h:=trunc(x/onehour);
   if (h>23) then h:=23;//24feb2021
   x:=x-(h*onehour);
   //.minute
   m:=trunc(x/onemin);
   if (m>59) then m:=59;//24feb2021
   x:=x-(m*onemin);
   //.second
   s:=trunc(x/onesec);
   if (s>59) then s:=59;//24feb2021
   x:=x-(s*onesec);
   //.ms
   ms:=x;
   if (ms>999) then ms:=999;//24feb2021
   end;
//set
if (dy>=1) or ok then
   begin
   result:=result+low__insstr(xsep,length(result)>=1)+low__digpad20(dy,1)+'dy';//02MAY2011
   ok:=true;
   end;
if (h>=1) or ok or xforcehr then
   begin
   result:=result+low__insstr(xsep,length(result)>=1)+low__digpad20(h,2)+'h';
   ok:=true;
   end;
if (m>=1) or ok or xforcemin then
   begin
   result:=result+low__insstr(xsep,length(result)>=1)+low__digpad20(m,2)+'m';
   ok:=true;
   end;
if (xshowsec or xshowms) and ((s>=1) or ok) then//fixed - 27dec2021
   begin
   result:=result+low__insstr(xsep,length(result)>=1)+low__digpad20(s,2)+'s';
   ok:=true;
   end;
if xshowms then//fixed - 27dec2021
   begin
   //enforce range
   result:=result+low__insstr(xsep,length(result)>=1)+low__digpad20(ms,low__insint(3,ok))+'ms';
   ok:=true;
   end;
except;end;
end;
//## low__b ##
function low__b(x:comp;sym:boolean):string;//fixed - 30jan2016
begin
try;result:=low__thousands64(x)+low__insstr(#32+tsB,sym);except;end;
end;
//## bDOT ##
function low__bDOT(x:currency;sym:boolean):string;
begin
try;result:=curstrex(x,'.')+low__insstr(#32+tsB,sym);except;end;
end;
//## kb ##
function low__kb(x:currency;sym:boolean):string;
begin
try;result:=low__kbb(x,3,sym);except;end;
end;
//## kbb ##
function low__kbb(x:currency;p:byte;sym:boolean):string;
begin
try;result:=curdec(x/1000,p,true)+low__insstr(#32+tsKB,sym);except;end;
end;
//## mb ##
function low__mb(x:currency;sym:boolean):string;//28MAR2010
begin
try;result:=low__mbb(x,3,sym);except;end;
end;
//## mbb ##
function low__mbb(x:currency;p:byte;sym:boolean):string;//21APR2011
begin
try
if (x<-1) then x:=high(longint);//detect "integer.overload.2G" and patch roughly - 28MAR2010
result:=curdec(x/1000000,p,true)+low__insstr(#32+tsMB,sym);
except;end;
end;
//## gb ##
function low__gb(x:currency;sym:boolean):string;
begin
try;result:=low__gbb(x,3,sym);except;end;
end;
//## gbb ##
function low__gbb(x:currency;p:byte;sym:boolean):string;
begin
try;result:=curdec(x/1000000000,p,true)+low__insstr(#32+tsGB,sym);except;end;
end;
//## mbAUTO ##
function low__mbAUTO(x:currency;sym:boolean):string;//auto range - 08DEC2011, 14NOV2010
begin
try;result:=low__mbAUTO3(x,1,3,3,sym);except;end;//auto range - 08DEC2011, 14NOV2010
end;
//## mbAUTO2 ##
function low__mbAUTO2(x:currency;p:byte;sym:boolean):string;//auto range - 08DEC2011, 14NOV2010
begin
try;result:=low__mbAUTO3(x,p,p,p,sym);except;end;//auto range - 08DEC2011, 14NOV2010
end;
//## mbAUTO3 ##
function low__mbAUTO3(x:currency;pKB,pMB,pGB:byte;sym:boolean):string;//auto range - 08DEC2011, 14NOV2010
begin
try
//defaults
result:='';
//get
if (x>-1000) and (x<1000) then result:=low__b(x,sym)
else if (x>-1000000) and (x<1000000) then result:=low__kbb(x,pKB,sym)//updated 04APR2011, was "kb(x,sym)"
else if (x>-1000000000) and (x<1000000000) then result:=low__mbb(x,pMB,sym)
else result:=low__gbb(x,pGB,sym);
except;end;
end;
//## ipercentage ##
function low__ipercentage(a,b:longint):extended;
begin
try
if (a<0) then a:=0;
if (b<1) then b:=1;
result:=(a/nozero(1200003,b))*100;
if (result<0) then result:=0 else if (result>100) then result:=100;
except;end;
end;
//## percentage64 ##
function low__percentage64(a,b:comp):extended;//24jan2016
begin
try
if (a<0) then a:=0;
if (b<1) then b:=1;
result:=(a/nozero_cmp(1200005,b))*100;
if (result<0) then result:=0 else if (result>100) then result:=100;
except;end;
end;
//## low__percentage64str ##
function low__percentage64str(a,b:comp;xsymbol:boolean):string;//04oct2022
begin
try;result:=curdec(low__percentage64(a,b),2,false)+low__insstr('%',xsymbol);except;end;
end;
//## low__rateASstatus ##
function low__rateASstatus(_starttime64:currency;_totalBYTES:comp):string;
begin
try;result:=low__mbauto(low__rateASbytes32(_starttime64,_totalBYTES),true)+'/'+translate('sec');except;end;
end;
//## low__rateASbytes32 ##
function low__rateASbytes32(_starttime64:currency;_totalBYTES:comp):longint;
var
   _rate,_sec:currency;
begin
try
//defaults
result:=0;
//range
_totalBYTES:=restrict64(_totalBYTES);
//get
//.sec
_sec:=ms64;
_sec:=_sec-_starttime64;
_sec:=_sec/1000;//ms -> sec
if (_sec<1) then _sec:=1;
//.rate
if (_totalBYTES<0) then _totalBYTES:=0;
_rate:=_totalBYTES/nozero_cur(1200017,_sec);
//.range
if (_rate<0) then _rate:=0
else if (_rate>maxint) then _rate:=maxint;
//set
result:=round(_rate);
except;end;
end;
//## low__point ##
function low__point(x,y:longint):tpoint;
begin
try;result.x:=x;result.y:=y;except;end;
end;
//## low__minwh ##
procedure low__minwh(var a:trect;aminwidth,aminheight:longint);//25feb2021
begin
try
if (aminwidth<0) then aminwidth:=0;
if (aminheight<0) then aminheight:=0;
a.right:=frcmin(a.right,a.left+aminwidth);
a.bottom:=frcmin(a.bottom,a.top+aminheight);
except;end;
end;
//## nilrect ##
function nilrect:trect;
begin
result:=rect(0,0,-1,-1);
end;
//## nilarea ##
function nilarea:trect;//25jul2021
begin
result:=rect(0,0,-1,-1);
end;
//## maxarea ##
function maxarea:trect;//27jul2021
begin//allow for graphics sub-procs to have room with their maths -> don't push it too near to "maxint-1" - 28jul2021
result:=rect(0,0,maxint-1000,maxint-1000);
end;
//## validrect ##
function validrect(x:trect):boolean;
begin
result:=(x.left<=x.right) and (x.top<=x.bottom);
end;
//## validarea ##
function validarea(x:trect):boolean;//26jul2021
begin
result:=(x.left<=x.right) and (x.top<=x.bottom);
end;
//## low__shiftarea ##
function low__shiftarea(xarea:trect;xshiftx,xshifty:longint):trect;
begin
try
result.left:=xarea.left+xshiftx;
result.right:=xarea.right+xshiftx;
result.top:=xarea.top+xshifty;
result.bottom:=xarea.bottom+xshifty;
except;end;
end;
//## low__withinrect ##
function low__withinrect(x,y:longint;z:trect):boolean;
begin
try;result:=(z.left<=z.right) and (z.top<=z.bottom) and (x>=z.left) and (x<=z.right) and (y>=z.top) and (y<=z.bottom);except;end;
end;
//## low__withinrect2 ##
function low__withinrect2(xy:tpoint;z:trect):boolean;
begin
try;result:=(z.left<=z.right) and (z.top<=z.bottom) and (xy.x>=z.left) and (xy.x<=z.right) and (xy.y>=z.top) and (xy.y<=z.bottom);except;end;
end;
//## low__withinrect2LR ##
function low__withinrect2LR(xy:tpoint;z:trect):boolean;
begin
try;result:=(z.left<=z.right) and (z.top<=z.bottom) and (xy.x>=z.left) and (xy.x<=z.right);except;end;
end;
//## low__rect ##
function low__rect(xleft,xtop,xright,xbottom:longint):trect;
begin
try
result.left:=xleft;
result.top:=xtop;
result.right:=xright;
result.bottom:=xbottom;
except;end;
end;
//## low__rectgrow ##
function low__rectgrow(x:trect;xby:longint):trect;//07apr2021
begin
try
result.left    :=x.left  -xby;
result.top     :=x.top   -xby;
result.right   :=x.right +xby;
result.bottom  :=x.bottom+xby;
except;end;
end;
//## low__rectstr ##
function low__rectstr(x:trect):string;
begin
try;result:='rect('+inttostr(x.left)+','+inttostr(x.top)+','+inttostr(x.right)+','+inttostr(x.bottom)+') and '+inttostr(x.right-x.left+1)+'w x '+inttostr(x.bottom-x.top+1)+'h';except;end;
end;
//## low__ref32u ##
function low__ref32u(x:string):longint;{1..32}
var//Fast: 180% faster
   v:byte;
   p,xlen:longint;
begin
try
//default
result:=0;
//init
xlen:=length(x);
if (xlen<=0) then exit;
if (xlen>high(p4INT32)) then xlen:=high(p4INT32);
//get
for p:=0 to (xlen-1) do
begin
//2-stage - prevent math error
v:=byte(x[p+stroffset]);
if (v>=97) and (v<=122) then dec(v,32);
//inc
result:=result+p4INT32[p]*v;
end;//p
except;end;
end;
//## ref256 ##
function low__ref256(x:string):currency;
var//Fast: 300% faster
   p,xlen:longint;
begin
try
//default
result:=0;
//init
xlen:=length(x);
if (xlen<=0) then exit;
if (xlen>high(p4CUR256)) then xlen:=high(p4CUR256);
//get
for p:=0 to (xlen-1) do result:=result+p4CUR256[p]*byte(x[p+stroffset]);
except;end;
end;
//## ref256U ##
function low__ref256U(x:string):currency;
var//Fast: 300% faster
   d:currency;
   v:byte;
   p,xlen:longint;
begin
try
//default
result:=0;
//init
xlen:=length(x);
if (xlen<=0) then exit;
if (xlen>high(p4CUR256)) then xlen:=high(p4CUR256);
//get
for p:=0 to (xlen-1) do
begin
//lowercase
v:=byte(x[p+stroffset]);
if (v>=97) and (v<=122) then dec(v,32);
//add
d:=p4CUR256[p];
d:=d*v;
result:=result+p4CUR256[p]*v;
end;//p
except;end;
end;
//## low__cap2432 ##
function low__cap2432(xpos,ypos,dw,dh:longint;d:tobject):boolean;//low version - 07mar2020, 30may2019, 21jan2015, 17-JAN-2007
begin
try;result:=low__cap2432c(xpos,ypos,dw,dh,clnone,d);except;end;
end;
//## low__cap2432c ##
function low__cap2432c(xpos,ypos,dw,dh,doutofrangeColor:longint;d:tobject):boolean;//low version - 09sep2021, 07mar2020, 30may2019, 21jan2015, 17-JAN-2007
{$ifdef D3}
label//Note: doutofrangeColor=optional=clNone=disabled, else paint this color and capture overtop
   skipend;
var//Stabilised and verified at 21jan2015
   dcanvas,c:tcanvas;
   h:hwnd;
   dc:hdc;
   dbits,sw,sh:longint;
begin
try
//defaults
result:=false;
c:=nil;
dcanvas:=nil;//pointer only
h:=0;
//range
if zznil(d,2197) then exit;
dbits:=misb(d);
if (dbits<>24) and (dbits<>32) then exit;
//init
sw:=frcmin(misscreenw,1);
sh:=frcmin(misscreenh,1);
//.dcanvas
if      (d is tbitmap) then dcanvas:=(d as tbitmap).canvas
else if (d is tbmp)    then
   begin
   if (d as tbmp).cancanvas then dcanvas:=(d as tbmp).canvas else goto skipend;
   end
else goto skipend;
//.size
if (dw<1) then dw:=sw;
if (dh<1) then dh:=sh;
dw:=frcrange(dw,1,sw);
dh:=frcrange(dh,1,sh);
if (misw(d)<>dw) or (mish(d)<>dh) then
   begin
   missize(d,1,1);
   if not missize(d,dw,dh) then goto skipend;
   end;
//.pos
if (doutofrangeColor=clnone) then
   begin
   xpos:=frcrange(xpos,0,frcmin(sw-dw,0));
   ypos:=frcrange(ypos,0,frcmin(sh-dh,0));
   end
else
   begin
   xpos:=frcrange(xpos,-dw,sw);
   ypos:=frcrange(ypos,-dh,sh);
   end;

//init
h:=getdesktopwindow;
dc:=getwindowdc(h);
//get
c:=tcanvas.create;
c.handle:=dc;
//.screen -> d
if (doutofrangeColor<>clnone) then//09sep2021
   begin
   dcanvas.brush.style:=bsSolid;
   dcanvas.brush.color:=doutofrangeColor;
   dcanvas.fillrect(rect(0,0,dw,dh));
   end;
miscopyarea2(dcanvas,c,misrect(0,0,dw-1,dh-1),misrect(xpos,ypos,xpos+dw-1,ypos+dh-1));
//clear
c.handle:=0;
releasedc(h,dc);
//successful
result:=true;
skipend:
except;end;
try;if (c<>nil) then c.free;except;end;
{$endif}
{$ifdef D10}
begin
try;result:=false;except;end;
//D10: No support yet
{$endif}
end;
//## low__cap2432b ##
function low__cap2432b(d:tobject):boolean;
begin//Note: Capture full screen
try;result:=low__cap2432(0,0,0,0,d);except;end;
end;
//## low__capcolor ##
function low__capcolor(xpos,ypos:longint;xfromcursor:boolean):longint;
label
   skipend;
var
   a:tbmp;
   b:tpoint;
   int1,int2,abits:longint;
   c:tint4;
begin
try
//defaults
result:=0;
a:=nil;
//init
if xfromcursor then
   begin
   low__getcursorpos(b);
   xpos:=b.x;
   ypos:=b.y;
   end;
//get
a:=misbmp(24,1,1);
if low__cap2432(xpos,ypos,1,1,a) then
   begin
   if not a.lock then goto skipend;
   case a.bits of
   24:begin
      c.r:=a.prows24[0][0].r;
      c.g:=a.prows24[0][0].g;
      c.b:=a.prows24[0][0].b;
      c.a:=0;
      result:=c.val;
      end;
   32:begin
      c.r:=a.prows32[0][0].r;
      c.g:=a.prows32[0][0].g;
      c.b:=a.prows32[0][0].b;
      c.a:=0;
      result:=c.val;
      end;
   end;//case
   end;
skipend:
except;end;
try
a.unlock;
freeobj(@a);
except;end;
end;
//## low__firstnbl ##
function low__firstnbl(xdata,xoutdata:tstr8):boolean;//first non-blank line
label
   skipend;
var
   xline:tstr8;
   p:longint;
begin
try
//defaults
result:=false;
xline:=nil;
block(xdata);
block(xoutdata);
//check
if zznil(xdata,2198) or zznil(xoutdata,2199) then goto skipend;
//init
xline:=bnew;
p:=0;
//get
while low__nextline0(xdata,xline,p) do if (xline.count>=1) then
   begin
   xoutdata.replace:=xline;
   result:=true;
   break;
   end;
skipend:
except;end;
try
freeobj(@xline);
bunlockautofree(xdata);
bunlockautofree(xoutdata);
except;end;
end;
//## low__firstnbl2 ##
function low__firstnbl2(xtext:string):string;
var
   a,b:tstr8;
begin
try
//defaults
a:=nil;
b:=nil;
result:='';
//check
if (xtext='') then exit;
//init
a:=bnewstr(xtext);
b:=bnew;
if low__firstnbl(a,b) then result:=b.text;
except;end;
try;freeobj(@a);freeobj(@b);except;end;
end;
//## low__nextline0 ##
function low__nextline0(xdata,xlineout:tstr8;var xpos:longint):boolean;//17oct2018
label
   skipend;
var//0-base
   //Super fast line reader.  Supports #13 / #10 / #13#10 / #10#13,
   //with support for last line detection WITHOUT a trailing #10/#13 or combination thereof.
   xlen,int1,p:longint;
begin
try
//defaults
result:=false;
//cehck
block(xdata);
block(xlineout);
if zznil(xdata,2199) or zznil(xlineout,2200) then goto skipend;
//init
xlineout.clear;
if (xpos<0) then xpos:=0;
xlen:=xdata.count;
//get
if (xlen>=1) and (xpos<xlen) then for p:=xpos to (xlen-1) do if (xdata.pbytes[p]=10) or (xdata.pbytes[p]=13) or ((p+1)=xlen) then
   begin
   //get
   result:=true;//detect even blank lines
   if (p>=xpos) then//fixed, was "p>xpos" - 07apr2020
      begin
      if ((p+1)=xlen) and (xdata.pbytes[p]<>10) and (xdata.pbytes[p]<>13) then int1:=1 else int1:=0;//adjust for last line terminated by #10/#13 or without either - 18oct2018
      xlineout.add3(xdata,xpos,p-xpos+int1);
      end;
   //inc
   if (p<(xlen-1)) and (xdata.pbytes[p]=13) and (xdata.pbytes[p+1]=10) then xpos:=p+2//2 byte return code
   else if (p<(xlen-1)) and (xdata.pbytes[p]=10) and (xdata.pbytes[p+1]=13) then xpos:=p+2//2 byte return code
   else xpos:=p+1;//1 byte return code
   //quit
   break;
   end;
skipend:
except;end;
try
bunlockautofree(xdata);
bunlockautofree(xlineout);
except;end;
end;
//## low__matchmask ##
function low__matchmask(var xline,xmask:string):boolean;//04nov2019
label//Handles semi-complex masks (upto two "*" allow in a xmask - 04nov2019
     //Superfast: between 20,000 (short ~14c) to 4,000 (long ~160c) comparisons/sec -> Intel atom 1.33Ghz
     //Accepts masks:
     // exact='aaaaaaaaaaa', two-part='aaaaaa*aaaaaa', tri-part='aaa*aaa*aaa',
     // start='aaa*' or 'aaa*aaa*', end='*aaaa' or '*aaa*aaa', any='**' or '*'
   skipend;
var
   fs,fm,fe:string;
   fmlen,xpos,xpos2,xlen,p:longint;
   fexact,bol1:boolean;
begin
try
//defaults
result:=false;
//check
if (xmask='') then exit;
xlen:=length(xline);
if (xlen<=0) then exit;
//init
fs:=xmask;
fm:='';
fe:='';
fexact:=true;
//.fs
if (fs<>'') then for p:=1 to length(fs) do if (fs[p-1+stroffset]='*') then
   begin
   fe:=strcopy1(fs,p+1,length(fs));
   fs:=strcopy1(fs,1,p-1);
   fexact:=false;
   break;
   end;
//.fe
if (fe<>'') then for p:=length(fe) downto 1 do if (fe[p-1+stroffset]='*') then
   begin
   fm:=strcopy1(fe,1,p-1);
   strdel1(fe,1,p);
   fexact:=false;
   break;
   end;
//find
xpos:=1;

//.fexact
if fexact and (not low__comparetext(fs,xline)) then goto skipend;
//.fs
if (fs<>'') then
   begin
   if not low__comparetext(fs,strcopy1(xline,1,length(fs))) then goto skipend;
   xpos:=length(fs)+1;
   end;
//.fe
if (fe<>'') then
   begin
   xpos2:=length(xline)-length(fe)+1;
   if (xpos2<xpos) then goto skipend;
   if not low__comparetext(fe,strcopy1(xline,xpos2,length(fe))) then goto skipend;
   dec(xlen,length(fe));
   end;
//.fm
if (fm<>'') then
   begin
   fmlen:=length(fm);
   xpos2:=xlen-fmlen+1;
   if (xpos2<xpos) then goto skipend;
   bol1:=false;
   for p:=xpos to xpos2 do if low__comparetext(fm,strcopy1(xline,p,fmlen)) then//faster than "c1/c2" + comparetext (200% faster) - 04nov2019
      begin
      bol1:=true;
      break;
      end;//p
   if not bol1 then goto skipend;
   end;
//successful
result:=true;
skipend:
except;end;
end;
//## low__matchmaskb ##
function low__matchmaskb(xline,xmask:string):boolean;//04nov2019
begin
try;result:=low__matchmask(xline,xmask);except;end;
end;
//## low__matchmasklist ##
function low__matchmasklist(var xline,xmasklist:string):boolean;//04oct2020
var//Note: masklist => "*.bmp;*.jpg;*.jpeg" etc
   lp,p,xlen:longint;
   str1:string;
   bol1:boolean;
begin
try
//defaults
result:=false;
//init
xlen:=length(xmasklist);
if (xlen<=0) then exit;
//get
lp:=1;
for p:=1 to xlen do
begin
bol1:=(xmasklist[p-1+stroffset]=fesep);//fesep=";"
if bol1 or (p=xlen) then
   begin
   //init
   if bol1 then str1:=strcopy1(xmasklist,lp,p-lp) else str1:=strcopy1(xmasklist,lp,p-lp+1);
   lp:=p+1;
   //get
   if (str1<>'') and low__matchmask(xline,str1) then
      begin
      result:=true;
      break;
      end;
   end;
end;//p
except;end;
end;
//## low__matchmasklistb ##
function low__matchmasklistb(xline:string;var xmasklist:string):boolean;//04oct2020
begin
try;result:=low__matchmasklist(xline,xmasklist);except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//-- keyboard support ----------------------------------------------------------
//## low__shortcutOK ##
function low__shortcutOK(xcode:longint):boolean;//true=ak_key is assumed to be a shortcut key, false=else not
begin//Note: xcode is an action code, e.g. akctrlA => "CTRL+A"
try
result:=false;
case xcode of
akctrlA..akctrlZ,akaltA..akaltZ,akF1..akF12:result:=true;
end;//case
except;end;
end;
//## low__akstr ##
function low__akstr(xcode:longint;var xtext:string):boolean;
label//Note: xcode is an action code, e.g. akctrlA => "CTRL+A"
   skipend;
begin
try
//defaults
result:=false;
xtext:='';
//get
case xcode of
0..255                 :xtext:=char(xcode);
akctrlA..akctrlZ       :xtext:='Ctrl+'+char(65+xcode-akctrlA);
akaltA..akaltZ         :xtext:='Alt+' +char(65+xcode-akaltA);
akf1..akf12            :xtext:='F'    +inttostr(xcode-akf1+1);
akreturn               :xtext:=#13;
akreturn_press         :xtext:=#13;//31mar2021
aktab                  :xtext:=#9;
akdelete               :xtext:='Delete';
akback                 :xtext:='Back';
akescape               :xtext:='Esc';
//.direction keys
akleft                 :xtext:='Left';
akright                :xtext:='Right';
akup                   :xtext:='Up';
akdown                 :xtext:='Down';
//.extended direction keys
akhome                 :xtext:='Home';
akend                  :xtext:='End';
akprev                 :xtext:='Prev';
aknext                 :xtext:='Next';
else goto skipend;
end;//case
//successful
result:=true;
skipend:
except;end;
end;
//## low__akstrb ##
function low__akstrb(xcode:longint):string;
begin
try;low__akstr(xcode,result);except;end;
end;
//## low__keyboard__fromak ##
function low__keyboard__fromak(xcode:longint;var xctrl,xalt,xshift,xkeyx:boolean;var xkey:longint;var xhavekey:boolean):boolean;
label
   redo;
var
   xonce:boolean;
   //## kx ##
   procedure kx(xval:longint);
   begin
   xkey:=xval;
   xkeyx:=true;
   xhavekey:=true;
   end;
begin
try
//defaults
result:=false;
xonce   :=true;
xctrl   :=false;
xalt    :=false;
xshift  :=false;
xkeyx   :=false;
xkey    :=63;//?
xhavekey:=false;
//check
if (xcode=aknone) then exit;
//get
redo:
case xcode of
0..255:begin
   xkey:=xcode;
   xhavekey:=true;
   end;
akshift        :xshift:=true;
akshiftup      :xshift:=false;
akreturn       :kx(13);
akreturn_press :kx(13);//31mar2021
aktab          :kx(9);
akback         :kx(vkback);
akdelete       :kx(vkdelete);
akleft         :kx(vkleft);
akright        :kx(vkright);
akup           :kx(vkup);
akdown         :kx(vkdown);
akprev         :kx(vkprior);
aknext         :kx(vknext);
akhome         :kx(vkhome);
akend          :kx(vkend);
akaltA..akaltZ :begin
   xkeyx:=true;
   xkey:=65+(xcode-akaltA);
   xhavekey:=true;
   xalt:=true;
   end;
akctrlA..akctrlZ :begin
   xkeyx:=true;
   xkey:=65+(xcode-akctrlA);
   xhavekey:=true;
   xctrl:=true;
   end;
akf1..akf12:begin
   kx(vkf1+(xcode-akf1));
   end;
akctrlNone..akctrlLast:if xonce then
   begin
   xonce:=false;
   xctrl:=true;
   xcode:=xcode-akctrlnone+aknone;//convert from "akctrlleft -> akleft" - 31mar2021
   goto redo;
   end;
akaltNone..akaltLast:if xonce then
   begin
   xonce:=false;
   xalt:=true;
   xcode:=xcode-akaltnone+aknone;//convert from "akaltleft -> akleft" - 31mar2021
   goto redo;
   end;
end;
except;end;
end;
//## low__keyboard ##
function low__keyboard(xstyle:char;xkey:longint;xshift,xctrl,xalt:boolean;var xoutkey:longint):boolean;
begin
try;result:=low__keyboard2(xstyle,xkey,xshift,xctrl,xalt,xoutkey,syskeyboard_laststate);except;end;
end;
//## low__keyboard2 ##
function low__keyboard2(xstyle:char;xkey:longint;xshift,xctrl,xalt:boolean;var xoutkey:longint;var xlaststate:byte):boolean;
label//tshiftstate = set of (ssShift, ssAlt, ssCtrl, ssLeft, ssRight, ssMiddle, ssDouble);
   skipend;
var
   a:tint4;
   xval:longint;
   sshift,sctrl,salt:boolean;
   b1:byte;
begin
try
//defaults
result:=false;
xoutkey:=aknone;
xval:=aknone;
//init
sshift:=false;
sctrl:=false;
salt:=false;
b1:=xlaststate;
if (b1>=4) then
   begin
   salt:=true;
   dec(b1,4);
   end;
if (b1>=2) then
   begin
   sctrl:=true;
   dec(b1,2);
   end;
if (b1>=1) then sshift:=true;
if ((xstyle='d') or (xstyle='u')) and ((xshift<>sshift) or (xctrl<>sctrl) or (xalt<>salt)) then result:=true;
//get
if      (xstyle='d') then
   begin
   case xkey of
   vkdelete:xval:=akdelete;
   vkback:xval:=akback;
   //.direction keys
   vkleft: xval:=akleft   +low__aorb(low__insint(akctrlNone-aknone,xctrl),akaltNone-aknone,xalt);
   vkright:xval:=akright  +low__aorb(low__insint(akctrlNone-aknone,xctrl),akaltNone-aknone,xalt);
   vkup:   xval:=akup     +low__aorb(low__insint(akctrlNone-aknone,xctrl),akaltNone-aknone,xalt);
   vkdown: xval:=akdown   +low__aorb(low__insint(akctrlNone-aknone,xctrl),akaltNone-aknone,xalt);
   //.extended direction keys
   vkprior:xval:=akprev;
   vknext:xval:=aknext;
   vkhome:xval:=akhome;
   vkend:xval:=akend;
   else
      begin
      if xctrl and (xkey>=akA) and (xkey<=akZ) then xval:=akctrlA+(xkey-akA)//auto repeat support = YES - 01apr2020
      else if not result then goto skipend;
      end;
   end;
   end
else if (xstyle='p') or (xstyle='k') then
   begin
   //range: 32 - 255 and 13 - 31mar2021
   if (not xctrl) and (not xalt) and (xkey>=32) and (xkey<=255) then xval:=xkey
   else if (xkey=vkreturn) then xval:=akreturn_press
   else goto skipend;
   end
else if (xstyle='u') then
   begin
   case xkey of
   vkescape:xval:=akescape;
   vkreturn:xval:=akreturn;
   vktab:xval:=aktab;
   vkf1:xval:=akf1;
   vkf2:xval:=akf2;
   vkf3:xval:=akf3;
   vkf4:xval:=akf4;
   vkf5:xval:=akf5;
   vkf6:xval:=akf6;
   vkf7:xval:=akf7;
   vkf8:xval:=akf8;
   vkf9:xval:=akf9;
   vkf10:xval:=akf10;
   vkf11:xval:=akf11;
   vkf12:xval:=akf12;
   else
      begin
      if xalt and (xkey>=akA) and (xkey<=akZ) then xval:=akaltA+(xkey-akA)//auto repeat support = NO - 01apr2020
      else if not result then goto skipend;
      end;
   end;//case
   end;
//set
b1:=0;
if xshift then inc(b1,1);
if xctrl  then inc(b1,2);
if xalt   then inc(b1,4);
a.val:=xval;
a.bytes[3]:=b1;
xoutkey:=a.val;
xlaststate:=b1;
//successful
result:=true;
skipend:
except;end;
end;
//-- mouse support -------------------------------------------------------------
//## low__mousefine_turnon ##
procedure low__mousefine_turnon(x:boolean);
begin
try;if x then low__mouse(nil,'f.on') else low__mouse(nil,'f.off');except;end;
end;
//## low__mousefine ##
function low__mousefine:boolean;
begin
try;result:=sysmouse_fine;except;end;
end;
//## low__mouse ##
function low__mouse(x:tobject;xstyle:string):tpoint;
const
   xval=5;
var
   a:tpoint;
   //## xsync ##
   procedure xsync(xdown,xmove:boolean);
   begin
   case low__mousefine of
   true:begin
      a.x:=sysmouse_downxy.x+((a.x-sysmouse_movexy.x) div xval);
      a.y:=sysmouse_downxy.y+((a.y-sysmouse_movexy.y) div xval);
      end;
   false:begin
      if xdown then sysmouse_downxy:=a;
      if xmove then sysmouse_movexy:=a;
      end;
   end;//case
   end;
begin
try
//defaults
result:=low__point(0,0);
xstyle:=low__lowercase(xstyle);
//get
//.style
if      (xstyle='d') then
   begin
   a:=miscursorpos;
   xsync(true,true);
   sysmouse_down:=true;
   result:=a;
   end
else if (xstyle='m') then
   begin
   a:=miscursorpos;
   xsync(false,true);
   result:=a;
   end
else if (xstyle='u') then
   begin
   a:=miscursorpos;
   xsync(false,true);
   sysmouse_down:=false;//18mar2020
   result:=a;
   end
else if (xstyle='f.on') then//turn fine mode ON
   begin
   //off -> on
   if not low__mousefine then
      begin
      a:=miscursorpos;
      sysmouse_downxy:=a;
      sysmouse_movexy:=a;
      end;
   sysmouse_fine:=true;
   end
else if (xstyle='f.off') then//turn fine mode OFF
   begin
   sysmouse_fine:=false;
   end
else if system_debug then showerror('Mouse directive "'+xstyle+'" not supported');//15nov2022
//.localise
if (x<>nil) then
   begin
{$ifdef D3}
//was:   if zzok(x,7040) and (x is tcommonform) then a:=(x as tcommonform).clienttoscreen(low__point(0,0)) else a:=low__point(0,0);
if zzok(x,7040) and (x is tcommonform) then a:=low__clienttoscreen(x,low__point(0,0)) else a:=low__point(0,0);
{$endif}
{$ifdef D10}
   a.x:=0;
   a.y:=0;//xxxxxxxxxxxxx//D10: no support yet
   //if (x<>nil) and (x is tcommonform) then a:=(x as tcommonform).clienttoscreen(low__point(0,0)) else a:=low__point(0,0);
{$endif}
   result.x:=result.x-a.x;
   result.y:=result.y-a.y;
   end;
except;end;
end;
//## low__mouse2 ##
procedure low__mouse2(x:tobject;xstyle:string;var dx,dy:longint);
var
   a:tpoint;
begin
try;a:=low__mouse(x,xstyle);dx:=a.x;dy:=a.y;except;end;
end;
//## low__getcursorpos ##
function low__getcursorpos(var x:tpoint):boolean;
begin//As a function this proc can be used inline, e.g. if a and b and "low__getcursorpos(c)" and (c.x>=n) and (c.y>=n2) then ....
try;result:=true;x:=low__mouse(nil,'m');except;end;
end;
//## low__getcursorposb ##
function low__getcursorposb:tpoint;
begin
try;result:=low__mouse(nil,'m');except;end;
end;
//## low__getcursordownpos ##
function low__getcursordownpos(var x:tpoint):boolean;
begin//As a function this proc can be used inline, e.g. if a and b and "low__getcursorpos(c)" and (c.x>=n) and (c.y>=n2) then ....
try;result:=true;x:=sysmouse_downxy;except;end;
end;
//## low__getcursordownposb ##
function low__getcursordownposb:tpoint;
begin
try;low__getcursordownpos(result);except;end;
end;

//drop support (26jul2021)------------------------------------------------------
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//dddddddddddddddddddddddddd
//## drop_init ##
function drop_init(ximage:tobject;xcode2:string):boolean;//once only
begin
try;result:=drop_init3(ximage,misarea(ximage),xcode2,true);except;end;
end;
//## drop_init2 ##
function drop_init2(ximage:tobject;xarea:trect;xcode2:string):boolean;//once only
begin
try;result:=drop_init3(ximage,xarea,xcode2,true);except;end;
end;
//## drop_init3 ##
function drop_init3(ximage:tobject;xarea:trect;xcode2:string;xonce:boolean):boolean;
label
   skipend;
var
   dw,dh,sbits,sw,sh:longint;
begin
try
//defaults
result:=false;
//check
if xonce and sysdrop_showing then exit;//must exit -> don't hide BUT quite instead - 26jul2021
if sysdrop_shut or (not misok82432(ximage,sbits,sw,sh)) or (not validarea(xarea)) then goto skipend;
//range
xarea.left    :=frcrange(xarea.left,0,sw-1);
xarea.right   :=frcrange(xarea.right,xarea.left,sw-1);
xarea.top     :=frcrange(xarea.top,0,sh-1);
xarea.bottom  :=frcrange(xarea.bottom,xarea.top,sh-1);
//init
dw:=xarea.right-xarea.left+1;
dh:=xarea.bottom-xarea.top+1;
if (dw<=0) or (dh<=0) then goto skipend;
if (sysdrop_image=nil) then sysdrop_image:=misimg32(1,1);
if not missize(sysdrop_image,dw,dh) then goto skipend;
//draw
if not miscopyareaxx1A(0,0,dw,dh,xarea,sysdrop_image,ximage,false) then goto skipend;
//sync
sysdrop_power255:=190;
sysdrop_w:=dw;
sysdrop_h:=dh;
if sysdrop_showing then sysdrop_mustpaint:=true;
//successful
result:=true;
skipend:
except;end;
try
if not result then drop_hide;
except;end;
end;
//## drop_showing ##
function drop_showing:boolean;
begin
try;result:=sysdrop_showing;except;end;
end;
//## drop_show ##
function drop_show(dx,dy:longint):boolean;
begin
try
result:=false;
if (not sysdrop_showing) or (sysdrop_x<>dx) or (sysdrop_y<>dy) then
   begin
   sysdrop_x:=dx;
   sysdrop_y:=dy;
   sysdrop_showing:=true;
   sysdrop_mustpaint:=true;
   result:=true;
   end;
except;end;
end;
//## drop_hide ##
function drop_hide:boolean;
begin
try
//defaults
result:=false;
//check
if not sysdrop_showing then exit;
//get
sysdrop_showing:=false;
sysdrop_code2:='';
sysdrop_x:=minint;
sysdrop_y:=minint;
sysdrop_w:=0;
sysdrop_h:=0;
if not sysdrop_shut then
   begin
   if (sysdrop_buffer<>nil) then missize(sysdrop_buffer,1,1);
   if (sysdrop_image<>nil) then missize(sysdrop_image,1,1);
   end;
sysdrop_mustpaint:=true;
//successful
result:=true;
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxx//dddddddddddddddddddddddddddddd
//## drop_drawcancel ##
procedure drop_drawcancel;
begin
try;sysdrop_lastareaOK:=false;except;end;
end;
//## drop_draw ##
function drop_draw(xscreenbuffer:tbmp;xscreencanvas:tcanvas):boolean;
var
   xundraw,xdraw:trect;
begin
try;result:=drop_draw2(xscreenbuffer,xscreencanvas,xundraw,xdraw);except;end;
end;
//## drop_draw2 ##
function drop_draw2(xscreenbuffer:tbmp;xscreencanvas:tcanvas;var xundraw,xdraw:trect):boolean;
label
   skipend;
var
   da:trect;
   dw,dh:longint;
begin
try
//defaults
result:=false;
xundraw:=nilarea;
xdraw:=nilarea;
//check
if (xscreenbuffer=nil) or (xscreencanvas=nil) then exit;

//undraw
if sysdrop_lastareaOK and validarea(sysdrop_lastarea) then
   begin
   xundraw:=sysdrop_lastarea;
   miscopyarea(xscreencanvas,xscreenbuffer.canvas,sysdrop_lastarea);
   sysdrop_lastareaOK:=false;
   end;

//check
if sysdrop_shut or (not sysdrop_showing) then goto skipend;

//init
da.left:=sysdrop_x-(sysdrop_w div 2);
da.right:=da.left+sysdrop_w-1;
da.top:=sysdrop_y-(sysdrop_h div 2);
da.bottom:=da.top+sysdrop_h-1;
dw:=da.right-da.left+1;
dh:=da.bottom-da.top+1;
sysdrop_lastareaOK:=true;
sysdrop_lastarea:=da;

//1. screenbuffer.area -> sysdrop_buffer
if (sysdrop_buffer=nil) then sysdrop_buffer:=misbmp24(dw,dh);
if not misatleast(sysdrop_buffer,dw,dh) then goto skipend;
if not miscopyareaxx1B(0,0,dw,dh,da,sysdrop_buffer,xscreenbuffer,255,false) then goto skipend;
//.2 sysdrop_image -> sysdrop_buffer
if not miscopyareaxx1B(0,0,dw,dh,rect(0,0,dw-1,dh-1),sysdrop_buffer,sysdrop_image,sysdrop_power255,false) then goto skipend;
//.3 sysdrop_buffer -> xscreencanvas
xdraw:=da;
if not miscopyarea2(xscreencanvas,sysdrop_buffer.canvas,da,rect(0,0,dw-1,dh-1)) then goto skipend;

//succssful
result:=true;
skipend:
except;end;
end;
//## drop_shut ##
procedure drop_shut;
begin
try
//check
if not sysdrop_shut then exit;
//shutdown drop support - can't restart once shut - 26jul2021
sysdrop_shut:=true;
freeobj(@sysdrop_buffer);
freeobj(@sysdrop_image);
except;end;
end;

//text picture support ---------------------------------------------------------
//## low__teamake ##
function low__teamake(x:tobject;xout:tstr8;var e:string):boolean;
begin
try;result:=low__teamake2(x,false,false,false,0,0,xout,e);except;end;
end;
//## low__teamake2 ##
function low__teamake2(x:tobject;xver2,xtransparent,xsyscolors:boolean;xval1,xval2:longint;xout:tstr8;var e:string):boolean;//07apr2021
label
   skipend;
var
   xmustunlock:boolean;
   l:tint4;
   xw,xh,xbits,pc,xlen,xaddcount,sx,sy:longint;
   prows8:pcolorrows8;
   prows24:pcolorrows24;
   prows32:pcolorrows32;
   sr8:pcolorrow8;
   sr24:pcolorrow24;
   sr32:pcolorrow32;
   sc8:tcolor8;//07apr2021
   sc24:tcolor24;
   sc32:tcolor32;
   //## xadd24 ##
   procedure xadd24;
   begin
   if (l.r<>sc24.r) or (l.g<>sc24.g) or (l.b<>sc24.b) then
      begin
      if (l.a>=1) then xout.addint4(l.val);
      l.r:=sc24.r;
      l.g:=sc24.g;
      l.b:=sc24.b;
      l.a:=1;
      end
   else
      begin
      inc(l.a);
      if (l.a>=250) then
         begin
         xout.addint4(l.val);
         l.a:=0;//reset
         end;
      end;
   end;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
xmustunlock:=false;
block(xout);
if zznil(xout,2201) or zznil(x,2202) then goto skipend;
//init
//.bmp
if (x is tbmp) then
   begin
   if (x as tbmp).lock then xmustunlock:=true else goto skipend;
   if not (x as tbmp).canrows then goto skipend;
   prows8 :=(x as tbmp).prows8;
   prows24:=(x as tbmp).prows24;
   prows32:=(x as tbmp).prows32;
   end
//.image
else if (x is tbasicimage) then
   begin
   prows8 :=(x as tbasicimage).prows8;
   prows24:=(x as tbasicimage).prows24;
   prows32:=(x as tbasicimage).prows32;
   end
else goto skipend;
//.info
xbits:=misb(x);
xw:=misw(x);
xh:=mish(x);
if (xbits<>8) and (xbits<>24) and (xbits<>32) then goto skipend;
xout.clear;
xlen:=0;
xaddcount:=0;
pc:=0;
l.val:=0;
//head
if xver2 then
   begin
   xout.aadd([uuT,uuE,uuA,nn2,ssHash]);//TEA2#
   xout.addbyt1(low__insint(1,xtransparent));//0=solid, 1=transparent
   xout.addbyt1(low__insint(1,xsyscolors));//0=no, 1=yes
   xout.addbyt1(0);//reserved
   xout.addbyt1(0);//reserved
   xout.addbyt1(0);//reserved
   xout.addbyt1(0);//reserved
   xout.addint4(xval1);
   xout.addint4(xval2);
   end
else xout.aadd([uuT,uuE,uuA,nn1,ssHash]);//TEA1#
xout.addint4(xw);
xout.addint4(xh);//13 bytes
//pixels
e:=gecOutofmemory;
for sy:=0 to (xh-1) do
begin
if (xbits=8) then
   begin
   sr8:=prows8[sy];
   for sx:=0 to (xw-1) do
   begin
   sc8:=sr8[sx];
   sc24.r:=sc8;
   sc24.g:=sc8;
   sc24.b:=sc8;
   xadd24;
   end;//sx
   end
else if (xbits=24) then
   begin
   sr24:=prows24[sy];
   for sx:=0 to (xw-1) do
   begin
   sc24:=sr24[sx];
   xadd24;
   end;//sx
   end
else if (xbits=32) then
   begin
   sr32:=prows32[sy];
   for sx:=0 to (xw-1) do
   begin
   sc32:=sr32[sx];
   sc24.r:=sc32.r;
   sc24.g:=sc32.g;
   sc24.b:=sc32.b;
   xadd24;
   end;//sx
   end;
end;//xy
//.finalise
if (l.a>=1) then xout.addint4(l.val);
if (xout.len<>xout.count) then xout.setlen(xout.count);
//successful
result:=true;
skipend:
except;end;
try
if (not result) and zzok(xout,7041) then xout.clear;
//.unlock
if xmustunlock and zzok(x,7042) and (x is tbmp) then (x as tbmp).unlock;
bunlockautofree(xout);
except;end;
end;
//## low__teainfo ##
function low__teainfo(var adata:tlistptr;xsyszoom:boolean;var aw,ah,aSOD,aversion,aval1,aval2:longint;var atransparent,asyscolors:boolean):boolean;
label//Note: aSOD = start of data
   skipend;
var
   v:tint4;
   xpos:longint;
begin
try
//defaults
result:=false;
aw:=0;
ah:=0;
aSOD:=13;
aversion:=1;
aval1:=0;
aval2:=0;
atransparent:=true;
asyscolors:=true;
//check
if (adata.count<13) or (adata.bytes=nil) then goto skipend;
//get
//.header
xpos:=0;
if (adata.bytes[0]=uuT) and (adata.bytes[1]=uuE) and (adata.bytes[2]=uuA) and (adata.bytes[3]=nn2) and (adata.bytes[4]=ssHash) then
   begin
   //init
   aSOD:=27;//zero based (27=28 bytes)
   xpos:=5;
   aversion:=2;
   if (adata.count<(aSOD+1)) then goto skipend;//1 based
   //transparent
   atransparent:=(adata.bytes[xpos]<>0);
   inc(xpos,1);
   //syscolors -> black=font color, black+1=border color
   asyscolors:=(adata.bytes[xpos]<>0);
   inc(xpos,1);
   //reserved 1-4
   inc(xpos,4);
   //val1
   v.bytes[0]:=adata.bytes[xpos+0];
   v.bytes[1]:=adata.bytes[xpos+1];
   v.bytes[2]:=adata.bytes[xpos+2];
   v.bytes[3]:=adata.bytes[xpos+3];
   inc(xpos,4);
   aval1:=v.val;
   //val2
   v.bytes[0]:=adata.bytes[xpos+0];
   v.bytes[1]:=adata.bytes[xpos+1];
   v.bytes[2]:=adata.bytes[xpos+2];
   v.bytes[3]:=adata.bytes[xpos+3];
   inc(xpos,4);
   aval2:=v.val;
   end
else if (adata.bytes[0]=uuT) and (adata.bytes[1]=uuE) and (adata.bytes[2]=uuA) and (adata.bytes[3]=nn1) and (adata.bytes[4]=ssHash) then xpos:=5//TEA1#
else goto skipend;
//.w
v.bytes[0]:=adata.bytes[xpos+0];
v.bytes[1]:=adata.bytes[xpos+1];
v.bytes[2]:=adata.bytes[xpos+2];
v.bytes[3]:=adata.bytes[xpos+3];
aw:=v.val;
if (aw<=0) then goto skipend;
inc(xpos,4);
//.h
v.bytes[0]:=adata.bytes[xpos+0];
v.bytes[1]:=adata.bytes[xpos+1];
v.bytes[2]:=adata.bytes[xpos+2];
v.bytes[3]:=adata.bytes[xpos+3];
ah:=v.val;
if (ah<=0) then goto skipend;
//.multiplier
if xsyszoom then low__syszoom(aw,ah);
//successful
result:=true;
skipend:
except;end;
end;
//## low__teainfo2 ##
function low__teainfo2(adata:tstr8;xsyszoom:boolean;var aw,ah,aSOD,aversion,aval1,aval2:longint;var atransparent,asyscolors:boolean):boolean;
label
   skipend;
var
   v:tint4;
   xpos:longint;
begin
try
//defaults
result:=false;
aw:=0;
ah:=0;
aSOD:=13;
aversion:=1;
aval1:=0;
aval2:=0;
atransparent:=true;
asyscolors:=true;
//check
if zznil(adata,2205) or (adata.len<13) then goto skipend;
//get
//.header
xpos:=0;
if (adata.pbytes[0]=uuT) and (adata.pbytes[1]=uuE) and (adata.pbytes[2]=uuA) and (adata.pbytes[3]=nn2) and (adata.pbytes[4]=ssHash) then
   begin
   //init
   aSOD:=27;//zero based (27=28 bytes)
   xpos:=5;
   aversion:=2;
   if (adata.len<(aSOD+1)) then goto skipend;//1 based
   //transparent
   atransparent:=(adata.pbytes[xpos]<>0);
   inc(xpos,1);
   //syscolors -> black=font color, black+1=border color
   asyscolors:=(adata.pbytes[xpos]<>0);
   inc(xpos,1);
   //reserved 1-4
   inc(xpos,4);
   //val1
   v.bytes[0]:=adata.pbytes[xpos+0];
   v.bytes[1]:=adata.pbytes[xpos+1];
   v.bytes[2]:=adata.pbytes[xpos+2];
   v.bytes[3]:=adata.pbytes[xpos+3];
   inc(xpos,4);
   aval1:=v.val;
   //val2
   v.bytes[0]:=adata.pbytes[xpos+0];
   v.bytes[1]:=adata.pbytes[xpos+1];
   v.bytes[2]:=adata.pbytes[xpos+2];
   v.bytes[3]:=adata.pbytes[xpos+3];
   inc(xpos,4);
   aval2:=v.val;
   end
else if (adata.pbytes[0]=uuT) and (adata.pbytes[1]=uuE) and (adata.pbytes[2]=uuA) and (adata.pbytes[3]=nn1) and (adata.pbytes[4]=ssHash) then xpos:=5//TEA1#
else goto skipend;
//.w
v.bytes[0]:=adata.pbytes[xpos+0];
v.bytes[1]:=adata.pbytes[xpos+1];
v.bytes[2]:=adata.pbytes[xpos+2];
v.bytes[3]:=adata.pbytes[xpos+3];
aw:=v.val;
if (aw<=0) then goto skipend;
inc(xpos,4);
//.h
v.bytes[0]:=adata.pbytes[xpos+0];
v.bytes[1]:=adata.pbytes[xpos+1];
v.bytes[2]:=adata.pbytes[xpos+2];
v.bytes[3]:=adata.pbytes[xpos+3];
ah:=v.val;
if (ah<=0) then goto skipend;
//.multiplier
if xsyszoom then low__syszoom(aw,ah);
//successful
result:=true;
skipend:
except;end;
try;bautofree(adata);except;end;
end;
//## low__teadraw ##
function low__teadraw(xcolorise,xsyszoom:boolean;dx,dy,dc,dc2:longint;xarea,xarea2:trect;d:tobject;xtea:tlistptr;xfocus,xgrey,xround:boolean;xroundstyle:longint):boolean;//curved corner support - 07may2020, 09apr2020, 29mar2020
var
   prows24:pcolorrows24;
   prows32:pcolorrows32;
begin
try
//defaults
result:=false;
if zznil(d,2206) then exit;
//init
if (d is tbmp) then
   begin
   if not (d as tbmp).locked then exit;
   prows24:=(d as tbmp).prows24;
   prows32:=(d as tbmp).prows32;
   end
else if (d is tbasicimage) then//07mar2022
   begin
   prows24:=(d as tbasicimage).prows24;
   prows32:=(d as tbasicimage).prows32;
   end
else exit;
//get
result:=low__teadraw2(xcolorise,xsyszoom,dx,dy,dc,dc2,xarea,xarea2,misb(d),misw(d),mish(d),prows24,prows32,nil,-1,xtea,xfocus,xgrey,xround,xroundstyle);
except;end;
end;
//## low__teadraw2 ##
function low__teadraw2(xcolorise,xsyszoom:boolean;dx,dy,dc,dc2:longint;xarea,xarea2:trect;dbits,dw,dh:longint;drows24:pcolorrows24;drows32:pcolorrows32;xmask:tmask8;xmaskval:longint;xtea:tlistptr;xfocus,xgrey,xround:boolean;xroundstyle:longint):boolean;//curved corner support - 13may2020, 07may2020, 09apr2020, 29mar2020
label//Note: now supports curved corners on clip area "xarea" - 09apr2020
     //Note: xsys=optional system color information, if present (xsys<>nil) then image colors are replaced with shades of the system colors - 10mar2021
   skipdone,skipend,zoomdraw,zoomredo,redo;
var
   a:trect;
   b:tint4;
   //Note: int1 is used to corner rounding, do not use for anything else - 09apr2020
   int0,int1,int2,xzoom,ycount,zx,zy,v,mbits,lx,rx,lx2,rx2,lx3,rx3,lx4,rx4,amin,p,yi,xi,xx,xy,xw,xh,dd,xSOD,xversion,xval1,xval2:longint;
   zmr8,mr8,mr82,mr83,mr84:pcolorrow8;//for mask support
   zr24,dr24,dr242,dr243,dr244:pcolorrow24;
   zr32,dr32,dr322,dr323,dr324:pcolorrow32;
   sb,sf,sbD,sfD,ddc,tc,xc,xc2:tcolor24;
   ddc32:tcolor32;
   xcoloriseOK,finv,xzoomonce,dreplaceblackOK,dreplaceblackOK2,xonce,xtransparent,xsyscolors:boolean;
   //## x_sys ##
   procedure x_sys;
   begin
   v:=(ddc.r+ddc.g+ddc.b) div 3;
   if (v<100) then v:=100 else if (v>230) then v:=230;
   if finv then v:=255-v;//26mar2021
   ddc.r:=((xc.r*v) + (xc2.r*(255-v))) div 255;
   ddc.g:=((xc.g*v) + (xc2.g*(255-v))) div 255;
   ddc.b:=((xc.b*v) + (xc2.b*(255-v))) div 255;
   end;
   //## x_grey ##
   procedure x_grey;
   begin
   if not xcoloriseOK then
      begin
      //Nolonger greyscale -> instead a darker version of image -> far better appearance - 14mar2021
      v:=(ddc.r+ddc.g+ddc.b) div 3;
      if (v<150) then v:=150 else if (v>230) then v:=230;
      ddc.r:=(ddc.r*v) div 255;
      ddc.g:=(ddc.g*v) div 255;
      ddc.b:=(ddc.b*v) div 255;
      end;
   end;
   //## x_focus ##
   procedure x_focus;
   const
      xval=40;//was: 30 - 29mar2020
   var
      int1:longint;
   begin
   //.r
   int1:=ddc.r+xval;
   if (int1>255) then int1:=255;
   ddc.r:=byte(int1);
   //.g
   int1:=ddc.g+xval;
   if (int1>255) then int1:=255;
   ddc.g:=byte(int1);
   //.b
   int1:=ddc.b+xval;
   if (int1>255) then int1:=255;
   ddc.b:=byte(int1);
   end;
   //## xscan ##
   procedure xscan;
   begin
   case dbits of
   24:dr24:=drows24[yi];
   32:dr32:=drows32[yi];
   end;//case
   if (xmaskval>=0) then mr8:=xmask.prows8[yi];
   end;
   //## xscan2 ##
   procedure xscan2;
   begin
   case dbits of
   24:begin
      if ((zy+0)>=xarea.top) and ((zy+0)<=xarea.bottom) then dr24:=drows24[zy];
      if ((zy+1)>=xarea.top) and ((zy+1)<=xarea.bottom) then dr242:=drows24[zy+1];
      if ((zy+2)>=xarea.top) and ((zy+2)<=xarea.bottom) then dr243:=drows24[zy+2];
      if ((zy+3)>=xarea.top) and ((zy+3)<=xarea.bottom) then dr244:=drows24[zy+3];
      end;
   32:begin
      if ((zy+0)>=xarea.top) and ((zy+0)<=xarea.bottom) then dr32:=drows32[zy];
      if ((zy+1)>=xarea.top) and ((zy+1)<=xarea.bottom) then dr322:=drows32[zy+1];
      if ((zy+2)>=xarea.top) and ((zy+2)<=xarea.bottom) then dr323:=drows32[zy+2];
      if ((zy+3)>=xarea.top) and ((zy+3)<=xarea.bottom) then dr324:=drows32[zy+3];
      end;
   end;//case
   if (xmaskval>=0) then
      begin
      if ((zy+0)>=xarea.top) and ((zy+0)<=xarea.bottom) then mr8:=xmask.prows8[zy+0];
      if (xzoom>=2) and ((zy+1)>=xarea.top) and ((zy+1)<=xarea.bottom) then mr82:=xmask.prows8[zy+1];
      if (xzoom>=3) and ((zy+2)>=xarea.top) and ((zy+2)<=xarea.bottom) then mr83:=xmask.prows8[zy+2];
      if (xzoom>=4) and ((zy+3)>=xarea.top) and ((zy+3)<=xarea.bottom) then mr84:=xmask.prows8[zy+3];
      end;
   end;
begin
try
//defaults
result:=false;
//check image "d"
if (dw<1) or (dh<1) then exit;
case dbits of
24:if (drows24=nil) then exit;
32:if (drows32=nil) then exit;
else exit;
end;
//.zoom - optional
if xsyszoom then xzoom:=vizoom else xzoom:=1;
//check area
if (xarea.bottom<xarea.top) or (xarea.right<xarea.left) or (xarea.right<0) or (xarea.left>=dw) or (xarea.bottom<0) or (xarea.top>=dh) then exit;
if (xarea2.bottom<xarea2.top) or (xarea2.right<xarea2.left) or (xarea2.right<xarea.left) or (xarea2.left>xarea.right) or (xarea2.bottom<xarea.top) or (xarea2.top>xarea.bottom) then exit;
//check tea
if not low__teainfo(xtea,false,xw,xh,xSOD,xversion,xval1,xval2,xtransparent,xsyscolors) then exit;
//check mask
if (xmaskval>=0) then
   begin
   if zznil(xmask,2207) or ((xmask.width<dw) or (xmask.height<dh)) then xmaskval:=-1;//off
   end;
//init
//.dreplaceblackOK
dreplaceblackOK:=xsyscolors and (dc<>clnone);//(0,0,0) => dc.color
dreplaceblackOK2:=xsyscolors and (dc2<>clnone);//(0,0,1) => dc2.color - 02mar2021
//.xc -> dual purpose: replace "0,0,0 => xc" and "0,0,1 => xc2" OR colorise by converting color pixels into shades of "xc ... xc2" - 27mar2021
xc:=low__intrgb(dc);
xc2:=low__intrgb(dc2);
xcoloriseOK:=xcolorise and (dc<>clnone) and (dc2<>clnone);
finv:=(low__brightness2b(low__rgbint(xc))<low__brightness2b(low__rgbint(xc2)));
//.amin
a:=xarea2;//used for calculating curved cornersretain original copy of "xarea" for calculations and reference
amin:=smallest(low__sum32([a.bottom,-a.top,1]),low__sum32([a.right,-a.left,1]));
//.x
if (xarea.left<xarea2.left) then xarea.left:=xarea2.left;
xarea.left:=frcrange(xarea.left,0,dw-1);
if (xarea.right>xarea2.right) then xarea.right:=xarea2.right;
xarea.right:=frcrange(xarea.right,0,dw-1);
if (xarea.right<xarea.left) then exit;
//.y
if (xarea.top<xarea2.top) then xarea.top:=xarea2.top;
xarea.top:=frcrange(xarea.top,0,dh-1);
if (xarea.bottom>xarea2.bottom) then xarea.bottom:=xarea2.bottom;
xarea.bottom:=frcrange(xarea.bottom,0,dh-1);
if (xarea.bottom<xarea.top) then exit;
//.mbits
mbits:=dbits;
if (xmaskval>=0) then mbits:=mbits*10;
//get
xonce:=true;
dd:=xSOD;//start of data
xx:=0;
xi:=dx;
yi:=dy;
zx:=dx;
zy:=dy;
//.switch
if (xzoom>=2) then goto zoomdraw;


//-- normal draw ---------------------------------------------------------------
//.scan
if (yi>=xarea.top) and (yi<=xarea.bottom) then xscan;
//.corner
low__cornersolid(true,a,amin,yi,xarea.left,xarea.right,xroundstyle,xround,lx,rx);

redo:
if ((dd+3)<xtea.count) then
   begin
   b.bytes[0]:=xtea.bytes[dd+0];
   b.bytes[1]:=xtea.bytes[dd+1];
   b.bytes[2]:=xtea.bytes[dd+2];
   b.bytes[3]:=xtea.bytes[dd+3];
   //.transparent color - top-left (first) pixel
   if xonce then
      begin
      tc.r:=b.r;
      tc.g:=b.g;
      tc.b:=b.b;
      xonce:=false;
      end;

   //.draw pixels
   if (b.a>=1) then for p:=1 to b.a do
      begin
      //.fasttimer - xcheck - 07jul2021
      inc(sysfasttimer_xcount); if (sysfasttimer_xcount>=sysfasttimer_xtrigger) then fasttimer_xcheck;

      //.don't draw transparent pixels (tc -> top-left pixel defined) - 03mar2018
      if (yi>=xarea.top) and (yi<=xarea.bottom) and (xi>=lx) and (xi<=rx) and ((not xtransparent) or (b.r<>tc.r) or (b.g<>tc.g) or (b.b<>tc.b)) then
         begin
         //get
         //.black -> user specified color "dc"
         if dreplaceblackOK and (b.r=0) and (b.g=0) and (b.b=0) then ddc:=xc
         else if dreplaceblackOK2 and (b.r=0) and (b.g=0) and (b.b=1) then ddc:=xc2//02mar2021
         //.all other colors applied "as is"
         else
            begin
            ddc.r:=b.r;
            ddc.g:=b.g;
            ddc.b:=b.b;
            if xcoloriseOK then x_sys;
            end;
         //set
         if xgrey then x_grey;
         if xfocus then x_focus;

         case mbits of
         24:dr24[xi]:=ddc;
         240:if (mr8[xi]=xmaskval) then dr24[xi]:=ddc;
         32:begin
            ddc32.r:=ddc.r;
            ddc32.g:=ddc.g;
            ddc32.b:=ddc.b;
            ddc32.a:=255;
            dr32[xi]:=ddc32;
            end;
         320:begin
            if (mr8[xi]=xmaskval) then
               begin
               ddc32.r:=ddc.r;
               ddc32.g:=ddc.g;
               ddc32.b:=ddc.b;
               ddc32.a:=255;
               dr32[xi]:=ddc32;
               end;
            end;
         end;//case
         end;

      inc(xx);
      xi:=xx+dx;
      if (xx>=xw) then
         begin
         inc(yi);
         if (yi>=xarea.top) and (yi<=xarea.bottom) then xscan;
         //.corner
         low__cornersolid(true,a,amin,yi,xarea.left,xarea.right,xroundstyle,xround,lx,rx);
         xx:=0;
         xi:=dx;
         end;
      end;//b.a
   //.loop
   inc(dd,4);
   if ((dd+3)<xtea.count) and (yi<=xarea.bottom) then goto redo;
   end;
goto skipdone;


//-- zoom draw -----------------------------------------------------------------
zoomdraw:
//.scan
xscan2;
//.corner
low__cornersolid(true,a,amin,yi,xarea.left,xarea.right,xroundstyle,xround,lx,rx);
if (xzoom>=2) then low__cornersolid(true,a,amin,zy+1,xarea.left,xarea.right,xroundstyle,xround,lx2,rx2);
if (xzoom>=3) then low__cornersolid(true,a,amin,zy+2,xarea.left,xarea.right,xroundstyle,xround,lx3,rx3);
if (xzoom>=4) then low__cornersolid(true,a,amin,zy+3,xarea.left,xarea.right,xroundstyle,xround,lx4,rx4);

zoomredo:
if ((dd+3)<xtea.count) then
   begin
   b.bytes[0]:=xtea.bytes[dd+0];
   b.bytes[1]:=xtea.bytes[dd+1];
   b.bytes[2]:=xtea.bytes[dd+2];
   b.bytes[3]:=xtea.bytes[dd+3];
   //.transparent color - top-left (first) pixel
   if xonce then
      begin
      tc.r:=b.r;
      tc.g:=b.g;
      tc.b:=b.b;
      xonce:=false;
      end;

   //.draw pixels
   if (b.a>=1) then for p:=1 to b.a do
      begin
      //.fasttimer - xcheck - 07jul2021
      inc(sysfasttimer_xcount); if (sysfasttimer_xcount>=sysfasttimer_xtrigger) then fasttimer_xcheck;

      //.don't draw transparent pixels (tc -> top-left pixel defined) - 03mar2018
      if (zy>=xarea.top) and (zy<=xarea.bottom) and ((not xtransparent) or (b.r<>tc.r) or (b.g<>tc.g) or (b.b<>tc.b)) then
         begin
         //get
         //.black -> user specified color "dc"
         if dreplaceblackOK and (b.r=0) and (b.g=0) and (b.b=0) then ddc:=xc
         else if dreplaceblackOK2 and (b.r=0) and (b.g=0) and (b.b=1) then ddc:=xc2//02mar2021
         //.all other colors applied "as is"
         else
            begin
            ddc.r:=b.r;
            ddc.g:=b.g;
            ddc.b:=b.b;
            if xcoloriseOK then x_sys;
            end;
         //set
         if xgrey then x_grey;
         if xfocus then x_focus;

         case mbits of
         24:begin
            //y+0
            if (zx>=lx) and (zx<=rx)                        then dr24[zx+0]:=ddc;
            if (xzoom>=2) and ((zx+1)>=lx) and ((zx+1)<=rx) then dr24[zx+1]:=ddc;
            if (xzoom>=3) and ((zx+2)>=lx) and ((zx+2)<=rx) then dr24[zx+2]:=ddc;
            if (xzoom>=4) and ((zx+3)>=lx) and ((zx+3)<=rx) then dr24[zx+3]:=ddc;
            //y+1
            if (xzoom>=2) and ((zy+1)>=xarea.top) and ((zy+1)<=xarea.bottom) then
               begin
               if (zx>=lx) and (zx<=rx)                        then dr242[zx+0]:=ddc;
               if (xzoom>=2) and ((zx+1)>=lx) and ((zx+1)<=rx) then dr242[zx+1]:=ddc;
               if (xzoom>=3) and ((zx+2)>=lx) and ((zx+2)<=rx) then dr242[zx+2]:=ddc;
               if (xzoom>=4) and ((zx+3)>=lx) and ((zx+3)<=rx) then dr242[zx+3]:=ddc;
               end;
            //y+2
            if (xzoom>=3) and ((zy+2)>=xarea.top) and ((zy+2)<=xarea.bottom) then
               begin
               if (zx>=lx) and (zx<=rx)                        then dr243[zx+0]:=ddc;
               if (xzoom>=2) and ((zx+1)>=lx) and ((zx+1)<=rx) then dr243[zx+1]:=ddc;
               if (xzoom>=3) and ((zx+2)>=lx) and ((zx+2)<=rx) then dr243[zx+2]:=ddc;
               if (xzoom>=4) and ((zx+3)>=lx) and ((zx+3)<=rx) then dr243[zx+3]:=ddc;
               end;
            //y+32
            if (xzoom>=4) and ((zy+2)>=xarea.top) and ((zy+2)<=xarea.bottom) then
               begin
               if (zx>=lx) and (zx<=rx)                        then dr244[zx+0]:=ddc;
               if (xzoom>=2) and ((zx+1)>=lx) and ((zx+1)<=rx) then dr244[zx+1]:=ddc;
               if (xzoom>=3) and ((zx+2)>=lx) and ((zx+2)<=rx) then dr244[zx+2]:=ddc;
               if (xzoom>=4) and ((zx+3)>=lx) and ((zx+3)<=rx) then dr244[zx+3]:=ddc;
               end;
            end;//24
         240:begin
            //y+0
            if (zx>=lx) and (zx<=rx) and (mr8[zx]=xmaskval)                        then dr24[zx+0]:=ddc;
            if (xzoom>=2) and ((zx+1)>=lx) and ((zx+1)<=rx) and (mr8[zx]=xmaskval) then dr24[zx+1]:=ddc;
            if (xzoom>=3) and ((zx+2)>=lx) and ((zx+2)<=rx) and (mr8[zx]=xmaskval) then dr24[zx+2]:=ddc;
            if (xzoom>=4) and ((zx+3)>=lx) and ((zx+3)<=rx) and (mr8[zx]=xmaskval) then dr24[zx+3]:=ddc;
            //y+1
            if (xzoom>=2) and ((zy+1)>=xarea.top) and ((zy+1)<=xarea.bottom) then
               begin
               if (zx>=lx) and (zx<=rx) and (mr8[zx]=xmaskval)                         then dr242[zx+0]:=ddc;
               if (xzoom>=2) and ((zx+1)>=lx) and ((zx+1)<=rx) and (mr82[zx]=xmaskval) then dr242[zx+1]:=ddc;
               if (xzoom>=3) and ((zx+2)>=lx) and ((zx+2)<=rx) and (mr82[zx]=xmaskval) then dr242[zx+2]:=ddc;
               if (xzoom>=4) and ((zx+3)>=lx) and ((zx+3)<=rx) and (mr82[zx]=xmaskval) then dr242[zx+3]:=ddc;
               end;
            //y+2
            if (xzoom>=3) and ((zy+2)>=xarea.top) and ((zy+2)<=xarea.bottom) then
               begin
               if (zx>=lx) and (zx<=rx) and (mr8[zx]=xmaskval)                         then dr243[zx+0]:=ddc;
               if (xzoom>=2) and ((zx+1)>=lx) and ((zx+1)<=rx) and (mr83[zx]=xmaskval) then dr243[zx+1]:=ddc;
               if (xzoom>=3) and ((zx+2)>=lx) and ((zx+2)<=rx) and (mr83[zx]=xmaskval) then dr243[zx+2]:=ddc;
               if (xzoom>=4) and ((zx+3)>=lx) and ((zx+3)<=rx) and (mr83[zx]=xmaskval) then dr243[zx+3]:=ddc;
               end;
            //y+32
            if (xzoom>=4) and ((zy+2)>=xarea.top) and ((zy+2)<=xarea.bottom) then
               begin
               if (zx>=lx) and (zx<=rx) and (mr8[zx]=xmaskval)                         then dr244[zx+0]:=ddc;
               if (xzoom>=2) and ((zx+1)>=lx) and ((zx+1)<=rx) and (mr84[zx]=xmaskval) then dr244[zx+1]:=ddc;
               if (xzoom>=3) and ((zx+2)>=lx) and ((zx+2)<=rx) and (mr84[zx]=xmaskval) then dr244[zx+2]:=ddc;
               if (xzoom>=4) and ((zx+3)>=lx) and ((zx+3)<=rx) and (mr84[zx]=xmaskval) then dr244[zx+3]:=ddc;
               end;
            end;//240
         32:begin
            //init
            ddc32.r:=ddc.r;
            ddc32.g:=ddc.g;
            ddc32.b:=ddc.b;
            ddc32.a:=255;
            //y+0
            if (zx>=lx) and (zx<=rx)                        then dr32[zx+0]:=ddc32;
            if (xzoom>=2) and ((zx+1)>=lx) and ((zx+1)<=rx) then dr32[zx+1]:=ddc32;
            if (xzoom>=3) and ((zx+2)>=lx) and ((zx+2)<=rx) then dr32[zx+2]:=ddc32;
            if (xzoom>=4) and ((zx+3)>=lx) and ((zx+3)<=rx) then dr32[zx+3]:=ddc32;
            //y+1
            if (xzoom>=2) and ((zy+1)>=xarea.top) and ((zy+1)<=xarea.bottom) then
               begin
               if (zx>=lx) and (zx<=rx)                        then dr322[zx+0]:=ddc32;
               if (xzoom>=2) and ((zx+1)>=lx) and ((zx+1)<=rx) then dr322[zx+1]:=ddc32;
               if (xzoom>=3) and ((zx+2)>=lx) and ((zx+2)<=rx) then dr322[zx+2]:=ddc32;
               if (xzoom>=4) and ((zx+3)>=lx) and ((zx+3)<=rx) then dr322[zx+3]:=ddc32;
               end;
            //y+2
            if (xzoom>=3) and ((zy+2)>=xarea.top) and ((zy+2)<=xarea.bottom) then
               begin
               if (zx>=lx) and (zx<=rx)                        then dr323[zx+0]:=ddc32;
               if (xzoom>=2) and ((zx+1)>=lx) and ((zx+1)<=rx) then dr323[zx+1]:=ddc32;
               if (xzoom>=3) and ((zx+2)>=lx) and ((zx+2)<=rx) then dr323[zx+2]:=ddc32;
               if (xzoom>=4) and ((zx+3)>=lx) and ((zx+3)<=rx) then dr323[zx+3]:=ddc32;
               end;
            //y+32
            if (xzoom>=4) and ((zy+2)>=xarea.top) and ((zy+2)<=xarea.bottom) then
               begin
               if (zx>=lx) and (zx<=rx)                        then dr324[zx+0]:=ddc32;
               if (xzoom>=2) and ((zx+1)>=lx) and ((zx+1)<=rx) then dr324[zx+1]:=ddc32;
               if (xzoom>=3) and ((zx+2)>=lx) and ((zx+2)<=rx) then dr324[zx+2]:=ddc32;
               if (xzoom>=4) and ((zx+3)>=lx) and ((zx+3)<=rx) then dr324[zx+3]:=ddc32;
               end;
            end;//32
         320:begin
            //init
            ddc32.r:=ddc.r;
            ddc32.g:=ddc.g;
            ddc32.b:=ddc.b;
            ddc32.a:=255;
            //y+0
            if (zx>=lx) and (zx<=rx) and (mr8[zx]=xmaskval)                        then dr32[zx+0]:=ddc32;
            if (xzoom>=2) and ((zx+1)>=lx) and ((zx+1)<=rx) and (mr8[zx]=xmaskval) then dr32[zx+1]:=ddc32;
            if (xzoom>=3) and ((zx+2)>=lx) and ((zx+2)<=rx) and (mr8[zx]=xmaskval) then dr32[zx+2]:=ddc32;
            if (xzoom>=4) and ((zx+3)>=lx) and ((zx+3)<=rx) and (mr8[zx]=xmaskval) then dr32[zx+3]:=ddc32;
            //y+1
            if (xzoom>=2) and ((zy+1)>=xarea.top) and ((zy+1)<=xarea.bottom) then
               begin
               if (zx>=lx) and (zx<=rx) and (mr8[zx]=xmaskval)                         then dr322[zx+0]:=ddc32;
               if (xzoom>=2) and ((zx+1)>=lx) and ((zx+1)<=rx) and (mr82[zx]=xmaskval) then dr322[zx+1]:=ddc32;
               if (xzoom>=3) and ((zx+2)>=lx) and ((zx+2)<=rx) and (mr82[zx]=xmaskval) then dr322[zx+2]:=ddc32;
               if (xzoom>=4) and ((zx+3)>=lx) and ((zx+3)<=rx) and (mr82[zx]=xmaskval) then dr322[zx+3]:=ddc32;
               end;
            //y+2
            if (xzoom>=3) and ((zy+2)>=xarea.top) and ((zy+2)<=xarea.bottom) then
               begin
               if (zx>=lx) and (zx<=rx) and (mr8[zx]=xmaskval)                         then dr323[zx+0]:=ddc32;
               if (xzoom>=2) and ((zx+1)>=lx) and ((zx+1)<=rx) and (mr83[zx]=xmaskval) then dr323[zx+1]:=ddc32;
               if (xzoom>=3) and ((zx+2)>=lx) and ((zx+2)<=rx) and (mr83[zx]=xmaskval) then dr323[zx+2]:=ddc32;
               if (xzoom>=4) and ((zx+3)>=lx) and ((zx+3)<=rx) and (mr83[zx]=xmaskval) then dr323[zx+3]:=ddc32;
               end;
            //y+32
            if (xzoom>=4) and ((zy+2)>=xarea.top) and ((zy+2)<=xarea.bottom) then
               begin
               if (zx>=lx) and (zx<=rx) and (mr8[zx]=xmaskval)                         then dr324[zx+0]:=ddc32;
               if (xzoom>=2) and ((zx+1)>=lx) and ((zx+1)<=rx) and (mr84[zx]=xmaskval) then dr324[zx+1]:=ddc32;
               if (xzoom>=3) and ((zx+2)>=lx) and ((zx+2)<=rx) and (mr84[zx]=xmaskval) then dr324[zx+2]:=ddc32;
               if (xzoom>=4) and ((zx+3)>=lx) and ((zx+3)<=rx) and (mr84[zx]=xmaskval) then dr324[zx+3]:=ddc32;
               end;
            end;//320
         end;//case
         end;//if

      inc(xx);
      xi:=xx+dx;
      zx:=(xx*xzoom)+dx;//12mar2021
      if (xx>=xw) then
         begin
         inc(yi);
         zy:=((yi-dy)*xzoom)+dy;
         xscan2;
         //.corner
         low__cornersolid(true,a,amin,zy,xarea.left,xarea.right,xroundstyle,xround,lx,rx);
         if (xzoom>=2) then low__cornersolid(true,a,amin,zy+1,xarea.left,xarea.right,xroundstyle,xround,lx2,rx2);
         if (xzoom>=3) then low__cornersolid(true,a,amin,zy+2,xarea.left,xarea.right,xroundstyle,xround,lx3,rx3);
         if (xzoom>=4) then low__cornersolid(true,a,amin,zy+3,xarea.left,xarea.right,xroundstyle,xround,lx4,rx4);
         xx:=0;
         xi:=dx;
         zx:=dx;
         end;
      end;//b.a
   //.loop
   inc(dd,4);
   if ((dd+3)<xtea.count) and (yi<=xarea.bottom) then goto zoomredo;
   end;
goto skipdone;

//successful
skipdone:
result:=true;
skipend:
except;end;
end;
//## low__teatoraw24 ##
function low__teatoraw24(xtea:tlistptr;xdata:tstr8;var xw,xh:longint):boolean;
label
   skipend,redo;
var
   a:tint4;
   p,di,dd,xSOD,xversion,xval1,xval2:longint;
   xtransparent,xsyscolors:boolean;
begin
try
//defaults
result:=false;
xw:=0;
xh:=0;
//check
block(xdata);
if zznil(xdata,2208) or (not low__teainfo(xtea,false,xw,xh,xSOD,xversion,xval1,xval2,xtransparent,xsyscolors)) then goto skipend;
//init
xdata.clear;
xdata.setlen(xw*xh*3);//RGB
//get
dd:=xSOD;//start of data
di:=0;

redo:
if ((dd+3)<xtea.count) then
   begin
   a.bytes[0]:=xtea.bytes[dd+0];
   a.bytes[1]:=xtea.bytes[dd+1];
   a.bytes[2]:=xtea.bytes[dd+2];
   a.bytes[3]:=xtea.bytes[dd+3];
   //.get pixels
   if (a.a>=1) then
      begin
      for p:=1 to a.a do
      begin
      //.fasttimer - xcheck - 07jul2021
      inc(sysfasttimer_xcount); if (sysfasttimer_xcount>=sysfasttimer_xtrigger) then fasttimer_xcheck;

      if ((di+2)<xdata.count) then
         begin
         xdata.pbytes[di+0]:=a.r;
         xdata.pbytes[di+1]:=a.g;
         xdata.pbytes[di+2]:=a.b;
         end
      else break;
      end;//p
      end;//a.a
   //.loop
   inc(dd,4);
   if ((dd+3)<xtea.count) then goto redo;
   end;
//successful
result:=true;
skipend:
except;end;
try;bunlockautofree(xdata);except;end;
end;
//## low__teaTLpixel ##
function low__teaTLpixel(xtea:tlistptr):longint;//top-left pixel of TEA image - 01aug2020
var
   int1,int2:longint;
begin
try;low__teaTLpixel2(xtea,int1,int2,result);except;end;
end;
//## low__teaTLpixel2 ##
function low__teaTLpixel2(xtea:tlistptr;var xw,xh,xcolor:longint):boolean;//top-left pixel of TEA image - 01aug2020
var
   a:tint4;
   di,dd,xSOD,xversion,xval1,xval2:longint;
   xtransparent,xsyscolors:boolean;
begin
try
//defaults
result:=false;
xw:=0;
xh:=0;
xcolor:=clnone;
//check
if (not low__teainfo(xtea,false,xw,xh,xSOD,xversion,xval1,xval2,xtransparent,xsyscolors)) then exit;
//get
dd:=xSOD;//start of data
di:=0;
if ((dd+3)<xtea.count) then
   begin
   a.bytes[0]:=xtea.bytes[dd+0];
   a.bytes[1]:=xtea.bytes[dd+1];
   a.bytes[2]:=xtea.bytes[dd+2];
   a.bytes[3]:=xtea.bytes[dd+3];
   //.get pixels
   if (a.a>=1) then xcolor:=low__rgb(a.r,a.g,a.b);
   end;
//successful
result:=true;
except;end;
end;
//## low__teatoimg ##
function low__teatoimg(xtea:tlistptr;d:tbasicimage;var xw,xh:longint):boolean;//23may2020
label//Supports "d" in 8/24/32 bits
   redo;
var
   a:tint4;
   p,dd,dbits,dx,dy,dw,dh,xSOD,xversion,xval1,xval2:longint;
   xtransparent,xsyscolors,dhasai:boolean;
   dr8 :pcolorrow8;
   dr24:pcolorrow24;
   dr32:pcolorrow32;
   dc24:tcolor24;
   dc32:tcolor32;
   //## dscan ##
   procedure dscan;
   begin
   case dbits of
   8: dr8 :=d.prows8[dy];
   24:dr24:=d.prows24[dy];
   32:dr32:=d.prows32[dy];
   end;
   end;
begin
try
//defaults
result:=false;
xw:=0;
xh:=0;
//check
if (not low__teainfo(xtea,false,xw,xh,xSOD,xversion,xval1,xval2,xtransparent,xsyscolors)) or (not misinfo82432(d,dbits,dw,dh,dhasai)) then exit;
//init
d.sizeto(xw,xh);
dw:=d.width;
dh:=d.height;
//get
dd:=xSOD;//start of data
dx:=0;
dy:=0;
dscan;

redo:
if ((dd+3)<xtea.count) then
   begin
   a.bytes[0]:=xtea.bytes[dd+0];
   a.bytes[1]:=xtea.bytes[dd+1];
   a.bytes[2]:=xtea.bytes[dd+2];
   a.bytes[3]:=xtea.bytes[dd+3];
   //.get pixels
   if (a.a>=1) then
      begin
      for p:=1 to a.a do
      begin
      //.fasttimer - xcheck - 07jul2021
      inc(sysfasttimer_xcount); if (sysfasttimer_xcount>=sysfasttimer_xtrigger) then fasttimer_xcheck;

      case dbits of
      8:begin
         if (a.g>a.r) then a.r:=a.g;
         if (a.b>a.r) then a.r:=a.b;
         dr8[dx]:=a.r;
         end;
      24:begin
         dc24.r:=a.r;
         dc24.g:=a.g;
         dc24.b:=a.b;
         dr24[dx]:=dc24;
         end;
      32:begin
         dc32.r:=a.r;
         dc32.g:=a.g;
         dc32.b:=a.b;
         dc32.a:=255;
         dr32[dx]:=dc32;
         end;
      end;//case
      //.inc
      inc(dx);
      if (dx>=xw) then
         begin
         dx:=0;
         inc(dy);
         if (dy>=xh) then break;
         dscan;
         end;
      end;//p
      end;//a.a
   //.loop
   inc(dd,4);
   if ((dd+3)<xtea.count) then goto redo;
   end;
//xtransparent
d.ai.transparent:=xtransparent;//07apr2021
d.ai.syscolors:=xsyscolors;//13apr2021
//successful
result:=true;
except;end;
end;
//## low__teatobmp ##
function low__teatobmp(sdata:tstr8;d:tbmp;var xw,xh:longint):boolean;//12apr2021, 21aug2020
label//Supports "d" in 8/24/32 bits
   skipend,redo;
var
   a:tint4;
   slen,p,dd,dbits,dx,dy,xSOD,xversion,xval1,xval2:longint;
   dr8 :pcolorrow8;
   dr24:pcolorrow24;
   dr32:pcolorrow32;
   dc24:tcolor24;
   dc32:tcolor32;
   xtransparent,xsyscolors,dmustunlock:boolean;
begin
try
//defaults
result:=false;
xw:=0;
xh:=0;
dmustunlock:=false;
//check
block(sdata);
if (not low__teainfo2(sdata,false,xw,xh,xSOD,xversion,xval1,xval2,xtransparent,xsyscolors)) then goto skipend;
//size
missize(d,xw,xh);
if (not misok82432(d,dbits,xw,xh)) then goto skipend;
//get
bmplock(d);
dmustunlock:=true;
slen:=sdata.len;
dd:=xSOD;//start of data
dx:=0;
dy:=0;
if not misscan82432(d,dy,dr8,dr24,dr32) then goto skipend;
redo:
if ((dd+3)<slen) then
   begin
   a.bytes[0]:=sdata.pbytes[dd+0];
   a.bytes[1]:=sdata.pbytes[dd+1];
   a.bytes[2]:=sdata.pbytes[dd+2];
   a.bytes[3]:=sdata.pbytes[dd+3];
   //.get pixels
   if (a.a>=1) then
      begin
      for p:=1 to a.a do
      begin
      //.fasttimer - xcheck - 07jul2021
      inc(sysfasttimer_xcount); if (sysfasttimer_xcount>=sysfasttimer_xtrigger) then fasttimer_xcheck;

      case dbits of
      8:begin
         if (a.g>a.r) then a.r:=a.g;
         if (a.b>a.r) then a.r:=a.b;
         dr8[dx]:=a.r;
         end;
      24:begin
         dc24.r:=a.r;
         dc24.g:=a.g;
         dc24.b:=a.b;
         dr24[dx]:=dc24;
         end;
      32:begin
         dc32.r:=a.r;
         dc32.g:=a.g;
         dc32.b:=a.b;
         dc32.a:=255;
         dr32[dx]:=dc32;
         end;
      end;//case
      //.inc
      inc(dx);
      if (dx>=xw) then
         begin
         dx:=0;
         inc(dy);
         if (dy>=xh) then break;
         if not misscan82432(d,dy,dr8,dr24,dr32) then goto skipend;
         end;
      end;//p
      end;//a.a
   //.loop
   inc(dd,4);
   if ((dd+3)<slen) then goto redo;
   end;
//xtransparent
d.ai.transparent:=xtransparent;//07apr2021
d.ai.syscolors:=xsyscolors;//13apr2021
//successful
result:=true;
skipend:
except;end;
try
bunlockautofree(sdata);
if dmustunlock then bmpunlock(d);
except;end;
end;

//-- raw support ---------------------------------------------------------------
//## low__imgdraw2432 ##
function low__imgdraw2432(s:tobject;stransparent:boolean;d:tobject;dx,dy,dswapblack:longint;dclip:trect;xgreyscale,xfocus:boolean):boolean;
label
   skipend;
const
   fv=30;
var
   v,sbits,sw,sh,dbits,ddx,ddy,dw,dh,sx,sy:longint;
   dr24,sr24:pcolorrow24;
   dr32,sr32:pcolorrow32;
   c24,cswapblack:tcolor24;
   c32:tcolor32;
   //.transparency
   tr,tg,tb:byte;
   dswap,tok:boolean;
   //## g24 ##
   procedure g24;
   begin
   if (c24.g>c24.r) then c24.r:=c24.g;
   if (c24.b>c24.r) then c24.r:=c24.b;
   if (c24.r<100) then c24.r:=100;
   c24.g:=c24.r;
   c24.b:=c24.r;
   end;
   //## g32 ##
   procedure g32;
   begin
   if (c32.g>c32.r) then c32.r:=c32.g;
   if (c32.b>c32.r) then c32.r:=c32.b;
   if (c32.r<100) then c32.r:=100;
   c32.g:=c32.r;
   c32.b:=c32.r;
   end;
   //## f24 ##
   procedure f24;
   begin
   //.r
   v:=c24.r+fv;
   if (v<100) then v:=100;
   if (v>255) then v:=255;
   c24.r:=byte(v);
   //.g
   v:=c24.g+fv;
   if (v<100) then v:=100;
   if (v>255) then v:=255;
   c24.g:=byte(v);
   //.b
   v:=c24.b+fv;
   if (v<100) then v:=100;
   if (v>255) then v:=255;
   c24.b:=byte(v);
   end;
   //## f32 ##
   procedure f32;
   begin
   //.r
   v:=c32.r+fv;
   if (v<100) then v:=100;
   if (v>255) then v:=255;
   c32.r:=byte(v);
   //.g
   v:=c32.g+fv;
   if (v<100) then v:=100;
   if (v>255) then v:=255;
   c32.g:=byte(v);
   //.b
   v:=c32.b+fv;
   if (v<100) then v:=100;
   if (v>255) then v:=255;
   c32.b:=byte(v);
   end;
begin
try
//defaults
result:=false;
//check
//.s
if zznil(s,2209) then exit;
sw:=misw(s);
sh:=mish(s);
sbits:=misb(s);
if (sw<1) or (sh<1) or ((sbits<>24) and (sbits<>32)) then exit;
//.d
if zznil(d,2210) then exit;
dw:=misw(d);
dh:=mish(d);
dbits:=misb(d);
if (dw<1) or (dh<1) or ((dbits<>24) and (dbits<>32)) then exit;
//init
//.dclip
dclip.left:=frcrange(dclip.left,0,dw-1);
dclip.right:=frcrange(dclip.right,dclip.left,dw-1);
dclip.top:=frcrange(dclip.top,0,dh-1);
dclip.bottom:=frcrange(dclip.bottom,dclip.top,dh-1);
//.check -> dx/dy out of range -> do nothing
if (dx>dclip.right) or ((dx+sw)<dclip.left) or (dy>dclip.bottom) or ((dy+sh)<dclip.top) then
   begin
   result:=true;
   goto skipend;
   end;
//.tok
tok:=stransparent;
if tok then
   begin
   if not misscan2432(s,0,sr24,sr32) then goto skipend;
   case sbits of
   24:begin
      tr:=sr24[0].r;
      tg:=sr24[0].g;
      tb:=sr24[0].b;
      end;
   32:begin
      tr:=sr32[0].r;
      tg:=sr32[0].g;
      tb:=sr32[0].b;
      end;
   end;//case
   end;
//.dswapblack
dswap:=(dswapblack<>clnone);
if dswap then cswapblack:=low__intrgb(dswapblack);

//.s24 -> d24
if (sbits=24) and (dbits=24) then
   begin
   for sy:=0 to (sh-1) do
   begin
   ddy:=dy+sy;
   if (ddy>=dclip.top) and (ddy<=dclip.bottom) then
      begin
      if not misscan2432(s,sy,sr24,sr32) then goto skipend;
      if not misscan2432(d,ddy,dr24,dr32) then goto skipend;
      for sx:=0 to (sw-1) do
      begin
      ddx:=dx+sx;
      if (ddx>=dclip.left) and (ddx<=dclip.right) then
         begin
         c24:=sr24[sx];
         if (not tok) or (tr<>c24.r) or (tg<>c24.g) or (tb<>c24.b) then
            begin
            if dswap and (c24.r=0) and (c24.g=0) and (c24.b=0) then c24:=cswapblack;
            if xfocus then f24;
            if xgreyscale then g24;
            dr24[ddx]:=c24;
            end;
         end;//ddx
      end;//sx
      end;//ddy
   end;//sy
   end
//.s24 -> d32
else if (sbits=24) and (dbits=32) then
   begin
   for sy:=0 to (sh-1) do
   begin
   ddy:=dy+sy;
   if (ddy>=dclip.top) and (ddy<=dclip.bottom) then
      begin
      if not misscan2432(s,sy,sr24,sr32) then goto skipend;
      if not misscan2432(d,ddy,dr24,dr32) then goto skipend;
      for sx:=0 to (sw-1) do
      begin
      ddx:=dx+sx;
      if (ddx>=dclip.left) and (ddx<=dclip.right) then
         begin
         c24:=sr24[sx];
         if (not tok) or (tr<>c24.r) or (tg<>c24.g) or (tb<>c24.b) then
            begin
            if dswap and (c24.r=0) and (c24.g=0) and (c24.b=0) then c24:=cswapblack;
            c32.r:=c24.r;
            c32.g:=c24.g;
            c32.b:=c24.b;
            c32.a:=255;//fully solid
            if xfocus then f32;
            if xgreyscale then g32;
            dr32[ddx]:=c32;
            end;
         end;//ddx
      end;//sx
      end;//ddy
   end;//sy
   end
//.s32 -> d24
else if (sbits=32) and (dbits=24) then
   begin
   for sy:=0 to (sh-1) do
   begin
   ddy:=dy+sy;
   if (ddy>=dclip.top) and (ddy<=dclip.bottom) then
      begin
      if not misscan2432(s,sy,sr24,sr32) then goto skipend;
      if not misscan2432(d,ddy,dr24,dr32) then goto skipend;
      for sx:=0 to (sw-1) do
      begin
      ddx:=dx+sx;
      if (ddx>=dclip.left) and (ddx<=dclip.right) then
         begin
         c32:=sr32[sx];
         if (not tok) or (tr<>c32.r) or (tg<>c32.g) or (tb<>c32.b) then
            begin
            if dswap and (c32.r=0) and (c32.g=0) and (c32.b=0) then
               begin
               c32.r:=cswapblack.r;
               c32.g:=cswapblack.g;
               c32.b:=cswapblack.b;
               end;
            c24.r:=c32.r;
            c24.g:=c32.g;
            c24.b:=c32.b;
            if xfocus then f24;
            if xgreyscale then g24;
            dr24[ddx]:=c24;
            end;
         end;//ddx
      end;//sx
      end;//ddy
   end;//sy
   end
//.s32 -> d32
else if (sbits=32) and (dbits=32) then
   begin
   for sy:=0 to (sh-1) do
   begin
   ddy:=dy+sy;
   if (ddy>=dclip.top) and (ddy<=dclip.bottom) then
      begin
      if not misscan2432(s,sy,sr24,sr32) then goto skipend;
      if not misscan2432(d,ddy,dr24,dr32) then goto skipend;
      for sx:=0 to (sw-1) do
      begin
      ddx:=dx+sx;
      if (ddx>=dclip.left) and (ddx<=dclip.right) then
         begin
         c32:=sr32[sx];
         if (not tok) or (tr<>c32.r) or (tg<>c32.g) or (tb<>c32.b) then
            begin
            if dswap and (c32.r=0) and (c32.g=0) and (c32.b=0) then
               begin
               c32.r:=cswapblack.r;
               c32.g:=cswapblack.g;
               c32.b:=cswapblack.b;
               end;
            if xfocus then f32;
            if xgreyscale then g32;
            dr32[ddx]:=c32;
            end;
         end;//ddx
      end;//sx
      end;//ddy
   end;//sy
   end;
//successful
result:=true;
skipend:
except;end;
end;

//-- twordcore (c) 2020 BlaizEnterprises.com -----------------------------------
//## low__wordcore__inited ##
function low__wordcore__inited(var x:twordcore):boolean;
begin
try;result:=(x.initstate='inited');except;end;
end;
//## low__wordcore__lgfFILL ##
procedure low__wordcore__lgfFILL(var x:twordcore;lgfINDEX:longint;xwine_remake:boolean);
var
   xonefontsize,xlen,xsize,p:longint;
   xbol1,xbol2,xbold,xitalic,xunderline,xstrikeout:boolean;
   e,str1,xfontname:string;
begin
try                                                                                //only if font is NIL or EMPTY                                        //only if WINE and font is NOT-NIL and NOT-EMPTY
//if (lgfINDEX>=0) and (lgfINDEX<=high(x.lgfdata)) and (x.initstate='inited') and ( (zznil(x.lgfdata[lgfINDEX],2211) or (x.lgfdata[lgfINDEX].len<=0)) or  (xwine_remake and zzok(x.lgfdata[lgfINDEX],2211) and (x.lgfdata[lgfINDEX].len>=1)) then
if (lgfINDEX>=0) and (lgfINDEX<=high(x.lgfdata)) and (x.initstate='inited') then
   begin
   xonefontsize:=x.onefontsize;
   xbol1:=zznil(x.lgfdata[lgfINDEX],2211) or (x.lgfdata[lgfINDEX].len<=0);
   xbol2:=xwine_remake and zzok(x.lgfdata[lgfINDEX],2211) and (x.lgfdata[lgfINDEX].len>=1);
   if xbol1 or xbol2 then
      begin
      //init
      if zznil(x.lgfdata[lgfINDEX],2212) then x.lgfdata[lgfINDEX]:=bnew;
      xbold:=false;
      xitalic:=false;
      xunderline:=false;
      xstrikeout:=false;
      xsize:=12;
      xfontname:='$fontname';
      //split
      str1:=x.lgfnref[lgfINDEX];
      xlen:=length(str1);
      if (xlen>=6) then
         begin
         xbold       :=(strcopy1(str1,1,1)<>'0');
         xitalic     :=(strcopy1(str1,2,1)<>'0');
         xunderline  :=(strcopy1(str1,3,1)<>'0');
         xstrikeout  :=(strcopy1(str1,4,1)<>'0');
         //.size
         for p:=6 to xlen do if (strcopy1(str1,p,1)='|') then
            begin
            xsize:=frcmin(strint(strcopy1(str1,6,p-6)),1);
            xfontname:=strcopy1(str1,p+1,xlen);
            break;
            end;//p
         end;
      //.onefontsize
      case xonefontsize of
      0:xsize:=frcrange(viFontsize,4,300);
      1:xsize:=frcrange(viFontsize2,4,300);
      2..maxint:xsize:=frcrange(xonefontsize,4,300);
      end;
      //get
      if xbol1 or (xbol2 and low__findfontname(xfontname,xfontname)) or (xonefontsize=0) then
         begin
         xfontname:=low__udv(x.onefontname,xfontname);//onefontname overrides ALL fontnames - 05feb2022
         low__toLGF(xfontname,xsize,vifeatherf>=1,xbold,x.lgfdata[lgfINDEX],e);
         end;
      end;
   end;
except;end;
end;
//## low__wordcore__style ##
function low__wordcore__style(x:char):char;
begin
try
case ord(x) of
9,10,32..255:result:='t';//text
0:result:='i';//image
else result:='n';//nil -> unknown
end;
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//wwwwwwwwwwwwwwwwwwwwwwwww
//## low__wordcore__transform ##
function low__wordcore__transform(var x:twordcore;xstyle:string;xshowerrors:boolean):boolean;//30mar2022, 25jul2021
begin
try;result:=low__wordcore__transform2(x,xstyle,'','','',system_storeapp,system_paid,false,xshowerrors);except;end;
end;
//## low__wordcore__transform2 ##
function low__wordcore__transform2(var x:twordcore;xstyle,xappTitle,xappWebname,xappVersion:string;xappStoreAPP,xappPaid,xclaudeTAGs,xshowerrors:boolean):boolean;//13nov2022, 30mar2022, 07jan2022
label//Special Note: Optional Claude helper values "xapp*"
   redo,skipone,skipend;
const
   claude_header='$claude.header2';
   claude_text  ='$claude.text2';
var
   a:tbasicimage;
   ximgname:array[0..999] of string;
   ximgid  :array[0..999] of word;
   xbecomN,xbecomV,str1,n:string;
   int1,nlen,dlen,xskipstart,xstart,xpos,xlen,i,p:longint;
   xout:twordcharinfo;
   bol1,xwebimages,xwebimagesANDtopics:boolean;
   //## xnospaces ##
   function xnospaces(x:string):string;//02may2022
   var
      p:longint;
   begin
   try
   result:=x;
   for p:=1 to length(result) do if (strcopy1(result,p,1)=#32) or (strcopy1(result,p,1)=#160) or (strcopy1(result,p,1)=#9) then result[p-1+stroffset]:=#32;
   low__remchar(result,#32);
   except;end;
   end;
   //## xcharok ##
   function xcharok(xpos:longint):boolean;
   begin
   result:=low__wordcore__charinfo(x,xpos,xout) and (xout.cs=wc_t);
   end;
   //## ddelskipped ##
   procedure ddelskipped;
   var
      nlen:longint;
   begin
   try
   //remove previous
   if (xstart>=1) and (xskipstart>=1) then
      begin
      nlen:=xstart-xskipstart;
      if (nlen>=1) then
         begin
         //delete
         x.data.del3(xskipstart-1,nlen);
         x.data2.del3(xskipstart-1,nlen);
         x.data3.del3(xskipstart-1,nlen);
         //get
         xlen:=x.data.len;
         //inc
         dec(xstart,nlen);
         end;
      end;
   //reset
   xskipstart:=0;
   except;end;
   end;
   //## dtxt ##
   function dtxt(xnewval:string):boolean;
   var
      v1,v2:byte;
      a:tstr8;
      p:longint;
   begin
   try
   //defaults
   result:=false;
   a:=nil;
   a:=bnew;
   //init
   dlen:=length(xnewval);
   v1:=x.data2.bytes[xstart-1];
   v2:=x.data3.bytes[xstart-1];
   //remove previous
   x.data.del3(xstart-1,nlen);
   x.data2.del3(xstart-1,nlen);
   x.data3.del3(xstart-1,nlen);
   //add new content
   if (dlen>=1) then
      begin
      a.setlen(dlen);
      //.str
      x.data.sins(xnewval,xstart-1);
      //.id-0
      for p:=1 to dlen do a.pbytes[p-1]:=v1;
      x.data2.ins(a,xstart-1);
      //.id-1
      for p:=1 to dlen do a.pbytes[p-1]:=v2;
      x.data3.ins(a,xstart-1);
      end;
   //successful
   result:=true;
   except;end;
   try;bfree(a);except;end;
   end;
   //## dimg2 ##
   function dimg2(xtep:longint;dext:string):boolean;
   label
      skipend;
   var
      e:string;
      b:tstr8;
      v:twrd2;
      aw,ah,xid,p:longint;
      xadded:boolean;
   begin
   try
   //init
   result:=false;
   dlen:=0;
   xid:=-1;//off
   b:=nil;
   xadded:=false;
   //dext
   dext:=low__lowercase(dext);
   if (not system_jpeg) and ((dext='jif') or (dext='jpg')) then dext:='png';//jpeg disabled -> switch to png - 15may2021
   if (dext<>'tea') and (dext<>'jif') and (dext<>'jpg') and (dext<>'png') and (dext<>'bmp') then dext:='png';
   //.force JPEG or PNG only - 25jul2021
   if xwebimages or xwebimagesANDtopics then
      begin
      if (not system_jpeg) and ((dext='jif') or (dext='jpg')) then dext:='png';
      if (dext<>'jif') and (dext<>'jpg') and (dext<>'png')    then dext:='png';
      end;
   //remove previous
   x.data.del3(xstart-1,nlen);
   x.data2.del3(xstart-1,nlen);
   x.data3.del3(xstart-1,nlen);
   //find existing
   for p:=0 to high(ximgname) do if (n=ximgname[p]) then
      begin
      xid:=ximgid[p];
      break;
      end;
   //new
   if (xid<0) then
      begin
      //init
      if (a=nil) then a:=misimg32(1,1);
      b:=bnew;
      //get
      if (xtep=-1) or (xtep=-2) then//31may2021 -> ensure it's in an acceptable image format - 25jul2021
         begin
         case xtep of
         -1:b.aadd(programbanner);
         -2:b.aadd(programbanner2);
         end;
         misfromdata(a,b,e);
         b.clear;
         mistodata(a,b,dext,e)
         end
      else if low__teatoimg(tepfind2(xtep),a,aw,ah) then mistodata(a,b,dext,e)
      else goto skipend;
      //set
      x.cursorpos:=xstart;
      x.cursorpos2:=xstart;
      if not low__wordcore(x,'insimg.noundo',b) then goto skipend;
      xadded:=true;
      if (xstart<=x.data.len) then
         begin
         v.bytes[0]:=x.data2.bytes[xstart-1];
         v.bytes[1]:=x.data3.bytes[xstart-1];
         xid:=v.val;
         end;
      //add
      if (xid>=0) then
         begin
         for p:=0 to high(ximgname) do if (ximgname[p]='') then
            begin
            ximgname[p]:=n;
            ximgid[p]:=xid;
            break;
            end;//p
         end;
      end;
   //add new content
   if (xid>=0) and (not xadded) then
      begin
      //init
      v.val:=xid;
      //get
      x.data.ains([0],xstart-1);//0 is style of wc_i or "image"
      x.data2.ains(v.bytes[0],xstart-1);
      x.data3.ains(v.bytes[1],xstart-1);
      //dlen
      dlen:=1;
      end;

   //successful
   result:=true;
   skipend:
   except;end;
   try;bfree(b);except;end;
   end;
   //## dimg ##
   function dimg(xtep:longint):boolean;
   begin
   result:=dimg2(xtep,'');
   end;
   //## xkeeptag ##
   function xkeeptag(xtagname:string):boolean;//pass-thru
   begin
   result:=true;
   dtxt('['+xtagname+']');
   inc(xstart,2+length(xtagname));//skip over tag - 07jan2022
   end;
begin
try
//defaults
result:=false;
a:=nil;
//check
if not low__wordcore__inited(x) then exit;
//style
xwebimages:=(xstyle='webimages');
xwebimagesANDtopics:=(xstyle='webimages+topics');
xskipstart:=0;//off
//init
//was: xbecomN:=protect_text(16771969,'http://software.blaizenterprises.com/');
xbecomN:=protect_text(16772067,'http://www.blaizenterprises.com/');//02may2022
xbecomV:=protect_text(16771912,'http://vintage.blaizenterprises.com/');
xlen:=x.data.len;
xpos:=1;
xstart:=0;//off
if (xlen<=0) then
   begin
   result:=true;
   goto skipend;
   end;
for p:=0 to high(ximgname) do
begin
ximgname[p]:='';
ximgid[p]:=0;
end;//p

//get
redo:

if xcharok(xpos) then
   begin
   if      (xout.c=ssLSquarebracket) then xstart:=xpos
   else if (xout.c=ssRSquarebracket) and (xstart>=1) then
      begin
      //init
      dlen:=0;
      nlen:=xpos-xstart+1;//includes brackets
      n:=low__lowercase(x.data.str1[xstart+1,xpos-xstart-1]);//excludes brackets

      //get
      if (n='t') or (n='ts') or (n='td') or (n='h1') or (n='h2') or (n='h3') or (n='h4') or (n='h5') then//mark as a help topic using "claude color support"
         begin
         //delete to just before this tag
         if (xskipstart>=1) then ddelskipped;

         //special - retain topic codes "[t]" for higher up processing by Claude - 13nov2022
         if (n='t') and xwebimagesANDtopics then
            begin
            xstart:=xpos+3;
            goto skipone;
            end;

         //init
         dtxt('');
         xlen:=x.data.len;
         //next line
         int1:=xstart;
         for i:=xstart to xlen do
         begin
         int1:=i;
         if xcharok(i) and (xout.c=ss10) then break;
         end;//p
         //decide
         if (n='ts')      then//include topic if "ts:Store APP" - 30mar2022
            begin
            if not xappStoreAPP then xskipstart:=xstart;
            end
         else if (n='td') then//include topic if "td:Desktop APP" - 30mar2022
            begin
            if xappStoreAPP then xskipstart:=xstart;
            end;
         //change
         if (xskipstart<=0) then
            begin
            x.cursorpos:=xstart;
            x.cursorpos2:=int1;
            if (n='t') or (n='ts') or (n='td') then x.cfontname:=claude_header else x.cfontname:='$claude.header'+strcopy1(n,2,1);//1..5
            low__wordcore_str(x,'cwritesel','name');//change font name
            end;
         end
      else if (xskipstart>=1)                       then goto skipone
      else if (n='ls') or (n='ld') then//include line if "ls:Store APP" or "ld:Desktop APP"
         begin
         //delete to just before this tag
         if (xskipstart>=1) then ddelskipped;
         //init
         dtxt('');
         xlen:=x.data.len;
         //get
         if (n='ls')      then bol1:=xappStoreAPP
         else if (n='ld') then bol1:=not xappStoreAPP;
         //set
         if not bol1 then
            begin
            for i:=xstart to xlen do
            begin
            if xcharok(i) and (xout.c=ss10) then
               begin
               nlen:=i-xstart+1;//include the return code as well - 30mar2022
               dtxt('');
               break;
               end;
            end;//i
            end;
         end
      else if (n='programname')                     then dtxt(low__udv(xapptitle,programname))
      else if (n='programversion') or (n='version') then dtxt(low__udv(xappversion,programversion))
      else if (n='programurl') or (n='nprogram') then
         begin
         if (xappwebname<>'') then dtxt(xbecomN+low__lowercase(safename(xnospaces(xappwebname))+'.html')) else dtxt(low__plat('nprogram','',false));
         end
      else if (n='programzip') or (n='nprogramzip') then
         begin
         if (xappwebname<>'') then dtxt(xbecomN+low__lowercase(safename(xnospaces(xappwebname))+'.zip')) else dtxt(low__plat('nprogramzip','',false));
         end
      else if (n='vprogram') then
         begin
         if (xappwebname<>'') then dtxt(xbecomV+low__lowercase(safename(xnospaces(xappwebname))+'.html')) else dtxt(low__plat('vprogram','',false));
         end
      else if (n='vprogramzip') then
         begin
         if (xappwebname<>'') then dtxt(xbecomV+low__lowercase(safename(xnospaces(xappwebname))+'.zip')) else dtxt(low__plat('vprogramzip','',false));
         end
      else if (n='programpaid') or (n='freepaid') then//30mar2022
         begin
         if xclaudeTAGs               then xkeeptag(n)
         else if xappPaid             then dtxt('Paid')
         else                              dtxt('Free to use');//was Free To Use - 25may2022
         end
      else if (n='programmode') then//30mar2022
         begin
         if xclaudeTAGs               then xkeeptag(n)
         else if xappStoreAPP         then dtxt('Windows Store App')
         else                              dtxt('Desktop Application');
         end
      else if (n='programscope') then//30mar2022
         begin
         if xclaudeTAGs               then xkeeptag(n)
         else if xappStoreAPP         then dtxt('Windows 11')//16sep2022, 19apr2022
         else                              dtxt('Windows 95-11 and Wine');//16sep2022, 19apr2022
         end
      else if (n='softwareurl')                then dtxt(low__plat('software','',false))
      else if (n='vintageurl')                 then dtxt(low__plat('vintage','',false))
      else if (n='instagramurl')               then dtxt(low__plat('instagram','',false))
      else if (n='facebookurl')                then dtxt(low__plat('facebook','',false))
      else if (n='twitterurl')                 then dtxt(low__plat('twitter','',false))
      else if (n='beurl')                      then dtxt(low__plat('portal','',false))
      else if (n='bename')                     then
         begin
         str1:=low__plat('portal','',false);
         for p:=1 to length(str1) do if low__comparetext(strcopy1(str1,p,11),'http://www.') then str1:=strcopy1(str1,12,length(str1));
         dtxt(str1);
         end
      else if (n='l') or (n='c') or (n='r')    then
         begin
         if (xskipstart>=1) then dtxt('')
         else
            begin
            dtxt('');
            x.cursorpos:=xstart;
            x.cursorpos2:=xstart+dlen;
            if      (n='l') then x.calign:=wcaLeft
            else if (n='c') then x.calign:=wcaCenter
            else if (n='r') then x.calign:=wcaRight;
            low__wordcore(x,'cwritealign',nil);
            end;
         end
      //.images
      else if (n='banner2')   then dimg(-2)//31may2021
      else if (n='banner')    then//07jan2022
         begin
         if xclaudeTAGs then xkeeptag('helpbanner.tep')
         else if (sizeof(programbanner)>=2) then dimg(-1)
         else if tepfindbyname('helpbanner',int1) then dimg(int1)
         else
            begin
            dtxt('');
            if system_debug then
               begin
               showerror('Text image not found "'+n+'".');
               goto skipend;
               end;
            end;
         end
      else if (n='*')         then
         begin
         if xclaudeTAGs then dtxt('*') else dimg(tepBullet);//07jan2022
         end
      else if (n='sep')       then dimg(tepSep)
      else if (strcopy1(n,1,4)='tep:') then
         begin
         if (xskipstart>=1) then dtxt('')
         else
            begin
            if xclaudeTAGs then xkeeptag(strcopy1x(n,5,length(n))+'.tep')
            else if tepfindbyname(strcopy1(n,5,length(n)),int1) then dimg(int1)
            else
               begin
               dtxt('');
               if system_debug then
                  begin
                  showerror('Text image not found "'+n+'".');
                  goto skipend;
                  end;
               end;
            end;
         end
      //.error - not found
      else
         begin
         //.keep tag if "xclaudeTAGs=true" - 07jan2022
         if xclaudeTAGs then xkeeptag(n) else dtxt('');
         //.show error
         if system_debug then
            begin
            showerror('Transform dirtective "'+n+'" not found.');
            goto skipend;
            end;
         end;

skipone:
      //sync
      xpos:=frcmin(xstart-1,0);
      xstart:=0;//off
      xlen:=x.data.len;
      end;
   end;

//loop
inc(xpos);
if (xpos>=1) and (xpos<=xlen) then goto redo;

//.finalise
ddelskipped;

//.translate all non-claude fontnames into "$claude.text1" - 28aug2021
low__wordcore_str(x,'all','~'+claude_text);

//successful
result:=true;
skipend:
except;end;
try;freeobj(@a);except;end;
end;
//## low__wordcore__filtertext ##
procedure low__wordcore__filtertext(x:tstr8);
label
   skipend;
var
   xlen,dlen,p:longint;
   v:byte;
begin
try
//init
block(x);
xlen:=blen(x);
if (xlen<=0) then goto skipend;
dlen:=0;
//get
for p:=1 to xlen do
begin
v:=x.byt1[p-1];//was: ord(x[p]);
if (v=9) or (v=10) or (v>=32) then
   begin
   inc(dlen);
   if (dlen<xlen) then x.byt1[dlen-1]:=x.byt1[p-1];//was: x[dlen]:=x[p];
   end;
end;//p
//trim
if (dlen<xlen) then x.setlen(dlen);
skipend:
except;end;
try;bunlockautofree(x);except;end;
end;
//## low__wordcore__charinfo ##
function low__wordcore__charinfo(var x:twordcore;xpos:longint;var xout:twordcharinfo):boolean;
var
   wrd2:twrd2;
   xzoom:longint;
   //## xstyle ##
   function xstyle(x:byte):byte;
   begin
   case ord(x) of
   9,10,32..255:result:=wc_t;//text
   0:result:=wc_i;//image
   else result:=wc_n;//nil -> unknown
   end;//case
   end;
   //## xsafe ##
   function xsafe(xindex:longint):longint;
   begin
   result:=xindex;
   if (result<0) then result:=0 else if (result>high(x.txtname)) then result:=high(x.txtname);
   end;
begin
try
//defaults
result:=false;
//init
if zzok(x.data,7050) and (xpos>=1) and (xpos<=x.data.len) then
   begin
   //init
   xout.c             :=x.data.byt1[xpos-1];//fixed 23aug2020
   xout.cs            :=xstyle(xout.c);
   wrd2.bytes[0]      :=x.data2.byt1[xpos-1];
   wrd2.bytes[1]      :=x.data3.byt1[xpos-1];
   xout.wid           :=xsafe(wrd2.val);
   //get
   //.text character
   if (xout.cs=wc_t) then
      begin
      //.text font id
      xout.txtid    :=xsafe(x.txtid[xout.wid]);
      //.lgfFILL - faster - 22apr2022
      if (not x.dataonly) and ((x.lgfdata[xout.txtid]=nil) or (x.lgfdata[xout.txtid].len=0)) then low__wordcore__lgfFILL(x,xout.txtid,false);
      //was: if (not x.dataonly) and (blen(x.lgfdata[xout.txtid])=0) then low__wordcore__lgfFILL(x,xout.txtid,false);
      //.height
      xout.height   :=low__fromLGF_height (x.lgfdata[xout.txtid]);
      xout.height1  :=low__fromLGF_height1(x.lgfdata[xout.txtid]);
      //.width
      if      (xout.c=9)  then xout.width:=5*low__fromLGF_charw(x.lgfdata[xout.txtid],32)
      else if (xout.c=10) then xout.width:=0//return code -> no width
      else                     xout.width:=low__fromLGF_charw(x.lgfdata[xout.txtid],xout.c);
      end
   //.image
   else if (xout.cs=wc_i) then
      begin
      //.width & height
      if x.usezoom then xzoom:=vizoom else xzoom:=1;
      xout.width    :=x.imgw[xout.wid]*xzoom; if (xout.width<1) then xout.width:=1;
      xout.height   :=x.imgh[xout.wid]*xzoom; if (xout.height<1) then xout.height:=1;
      xout.height1  :=xout.height;
      end
   //.nil
   else
      begin
      //.width & height
      xout.width    :=0;
      xout.height   :=0;
      xout.height1  :=0;
      end;
   //successful
   result:=true;
   end;//if
except;end;
end;
//## low__wordcore__charinfo2 ##
function low__wordcore__charinfo2(var x:twordcore;d1,d2,d3:tstr8;xpos:longint;var xout:twordcharinfo):boolean;
var
   wrd2:twrd2;
   xzoom:longint;
   //## xstyle ##
   function xstyle(x:byte):byte;
   begin
   case ord(x) of
   9,10,32..255:result:=wc_t;//text
   0:result:=wc_i;//image
   else result:=wc_n;//nil -> unknown
   end;//case
   end;
   //## xsafe ##
   function xsafe(xindex:longint):longint;
   begin
   result:=xindex;
   if (result<0) then result:=0 else if (result>high(x.txtname)) then result:=high(x.txtname);
   end;
begin
try
//defaults
result:=false;
//check
if (d1=nil) or (d2=nil) or (d3=nil) then exit;
//init
if zzok(d1,7050) and (xpos>=1) and (xpos<=d1.len) then
   begin
   //init
   xout.c             :=d1.byt1[xpos-1];//fixed 23aug2020
   xout.cs            :=xstyle(xout.c);
   wrd2.bytes[0]      :=d2.byt1[xpos-1];
   wrd2.bytes[1]      :=d3.byt1[xpos-1];
   xout.wid           :=xsafe(wrd2.val);
   //get
   //.text character
   if (xout.cs=wc_t) then
      begin
      //.text font id
      xout.txtid    :=xsafe(x.txtid[xout.wid]);
      //.lgfFILL - faster - 22apr2022
      if (not x.dataonly) and ((x.lgfdata[xout.txtid]=nil) or (x.lgfdata[xout.txtid].len=0)) then low__wordcore__lgfFILL(x,xout.txtid,false);
      //was: if (not x.dataonly) and (blen(x.lgfdata[xout.txtid])=0) then low__wordcore__lgfFILL(x,xout.txtid,false);
      //.height
      xout.height   :=low__fromLGF_height (x.lgfdata[xout.txtid]);
      xout.height1  :=low__fromLGF_height1(x.lgfdata[xout.txtid]);
      //.width
      if      (xout.c=9)  then xout.width:=5*low__fromLGF_charw(x.lgfdata[xout.txtid],32)
      else if (xout.c=10) then xout.width:=0//return code -> no width
      else                     xout.width:=low__fromLGF_charw(x.lgfdata[xout.txtid],xout.c);
      end
   //.image
   else if (xout.cs=wc_i) then
      begin
      //.width & height
      if x.usezoom then xzoom:=vizoom else xzoom:=1;
      xout.width    :=x.imgw[xout.wid]*xzoom; if (xout.width<1) then xout.width:=1;
      xout.height   :=x.imgh[xout.wid]*xzoom; if (xout.height<1) then xout.height:=1;
      xout.height1  :=xout.height;
      end
   //.nil
   else
      begin
      //.width & height
      xout.width    :=0;
      xout.height   :=0;
      xout.height1  :=0;
      end;
   //successful
   result:=true;
   end;//if
except;end;
end;
//## low__wordcore__isplaintext ##
function low__wordcore__isplaintext(var x:twordcore):boolean;//19jun2022
begin
try;result:=(0=low__wordcore__findformatlevel(x));except;end;
end;
//## low__wordcore__findformatlevel ##
function low__wordcore__findformatlevel(var x:twordcore):longint;//19jun2022
var//Returns the maximum format used: 0=txt (plaintext), 1=bwd, 2=bwp
   v,xlastw,p:longint;
   w:twrd2;
   //## xsafe ##
   function xsafe(xindex:longint):longint;
   begin
   result:=xindex;
   if (result<0) then result:=0 else if (result>high(x.txtname)) then result:=high(x.txtname);
   end;
begin
try
//defaults
result:=0;
//check
if not low__wordcore__inited(x) then exit;
if (x.data.len<=1) then exit;
//get
xlastw:=-1;
for p:=0 to (x.data.len-1) do
begin
v:=x.data.pbytes[p];
case v of
9,10,32..255:begin
   if (result<=0) then
      begin
      w.bytes[0]      :=x.data2.pbytes[p];
      w.bytes[1]      :=x.data3.pbytes[p];
      if (w.val<>xlastw) or (v=10) then
         begin
         //Note: aign=works ONLY with c=10 and no other characters - 19jun2022
         xlastw:=w.val;
         if x.txtbold[xlastw] or x.txtitalic[xlastw] or x.txtunderline[xlastw] or x.txtstrikeout[xlastw] or (x.txtbk[xlastw]<>clnone) or (x.txtborder[xlastw]<>clnone) or ((v=10) and (x.txtalign[xlastw]<>0)) then
            begin
            result:=1;//enhanced text - bwd
            if (result>=x.maxformatlevel) then break;
            end;
         end;
      end;
   end;
0:begin//image -> not plain text
   xlastw:=-1;
   result:=2;
   break;
   end;
end;//case
end;//p
except;end;
end;
//## low__wordcore__charinfoULTRA ##
function low__wordcore__charinfoULTRA(var x:twordcore;xpos:longint;var xout:twordcharinfo;var xlastWID,xlastWID2:longint):boolean;//12jun2022 (7.30pm), 22apr2022
var
   wrd2:twrd2;
   xzoom:longint;
begin
//defaults
result:=false;
//init
if zzok(x.data,7050) and (xpos>=1) and (xpos<=x.data.len) then
   begin
   //.c
   xout.c             :=x.data.pbytes[xpos-1];//fixed 23aug2020
   //.wid
   wrd2.bytes[0]      :=x.data2.pbytes[xpos-1];//was: x.data2.byt1[xpos-1];
   wrd2.bytes[1]      :=x.data3.pbytes[xpos-1];//was: x.data3.byt1[xpos-1];
   xout.wid           :=wrd2.val;
   if (xout.wid>high(x.txtname)) then xout.wid:=high(x.txtname);
   //.cs
   case xout.c of
   9,10,32..255:begin//text
      xout.cs:=wc_t;
      //.text font id
      xout.txtid    :=x.txtid[xout.wid];
      if (xout.txtid>high(x.txtname)) then xout.txtid:=high(x.txtname);
      //.lgfFILL - faster - 22apr2022
      if (not x.dataonly) and ((x.lgfdata[xout.txtid]=nil) or (x.lgfdata[xout.txtid].len=0)) then low__wordcore__lgfFILL(x,xout.txtid,false);
      //.height
      if (xlastWID<>xout.wid) or (xlastWID2<>xout.txtid) then//fixed "null" image lineheight carry-on error -> now resamples lineheight for wordcore's wrapnow proc - 12jun2022
         begin
         xlastWID:=xout.wid;
         xlastWID2:=xout.txtid;
         xout.height   :=low__fromLGF_height (x.lgfdata[xout.txtid]);
         xout.height1  :=low__fromLGF_height1(x.lgfdata[xout.txtid]);
         end;
      //.width
      if      (xout.c=9)  then xout.width:=5*low__fromLGF_charw(x.lgfdata[xout.txtid],32)
      else if (xout.c=10) then xout.width:=0//return code -> no width
      else                     xout.width:=low__fromLGF_charw(x.lgfdata[xout.txtid],xout.c);
      end;
   0:begin//image
      xout.cs:=wc_i;
      //.width & height
      if (xlastWID<>xout.wid) or (xlastWID2>=0) then
         begin
         xlastWID:=xout.wid;
         if x.usezoom then xzoom:=vizoom else xzoom:=1;
         xout.width    :=x.imgw[xout.wid]*xzoom; if (xout.width<1) then xout.width:=1;
         xout.height   :=x.imgh[xout.wid]*xzoom; if (xout.height<1) then xout.height:=1;
         xout.height1  :=xout.height;
         end;
      xlastWID2:=-1;//reset the text id handler
      end
   else
      begin//nil -> unknown
      xout.cs:=wc_n;
      xlastWID:=xout.wid;
      xlastWID2:=-1;//reset the text id handler
      //.width & height
      xout.width    :=0;
      xout.height   :=0;
      xout.height1  :=0;
      end;
   end;//case
   //successful
   result:=true;
   end;//if
end;
//## low__wordcore__charinfoFAST ##
function low__wordcore__charinfoFAST(var x:twordcore;xpos:longint;var xout:twordcharinfo):boolean;
var
   wrd2:twrd2;
begin
//defaults
result:=false;
//init
if zzok(x.data,7050) and (xpos>=1) and (xpos<=x.data.len) then
   begin
   //.c
   xout.c             :=x.data.byt1[xpos-1];//fixed 23aug2020
   //.cs
   case xout.c of
   9,10,32..255:xout.cs:=wc_t;//text
   0           :xout.cs:=wc_i;//image
   else         xout.cs:=wc_n;//nil -> unknown
   end;//case
   //.wid
   wrd2.bytes[0]      :=x.data2.byt1[xpos-1];
   wrd2.bytes[1]      :=x.data3.byt1[xpos-1];
   xout.wid           :=wrd2.val;
   if (xout.wid>high(x.txtname)) then xout.wid:=high(x.txtname);


{
   xout.txtid         :=0;
   xout.width         :=0;
   xout.height        :=0;
   xout.height1       :=0;
{}
   //successful
   result:=true;
   end;//if
end;
//## low__wordcore__findalignFAST ##
function low__wordcore__findalignFAST(var x:twordcore;xpos1:longint):longint;//22apr2022, 28dec2021
var//Note: Speed => 922ms => 719ms (128% faster)
   wrd2:twrd2;
   xwid,p:longint;
begin
//defaults
result:=0;//0=left, 1=centre, 2=right
//check
if (x.data<>nil) and (x.data.len>=1) then
   begin
   for p:=frcrange(xpos1,1,x.data.len) to x.data.len do if (x.data.byt1[p-1]=10) then
      begin
      //get
      x.lastfindalignpos:=p;//22apr2022
      wrd2.bytes[0]      :=x.data2.byt1[p-1];
      wrd2.bytes[1]      :=x.data3.byt1[p-1];
      xwid               :=wrd2.val;
      if (xwid>high(x.txtname)) then xwid:=high(x.txtname);
      //set
      result:=x.txtalign[xwid];
      break;
      end;//p
   end;
end;
//## low__wordcore__txtcolor ##
function low__wordcore__txtcolor(var x:twordcore;xwid:longint):longint;//14jul2020
var
   n:string;
begin
try
//defaults
result:=0;//black
//get
if (xwid>=0) and (xwid<=high(x.txtname)) then
   begin
   //.actual user specified color
   result:=x.txtcolor[xwid];

   //Special Note: Claude colors only override user colors if text color is
   //              set to BLACK "0" and "useclaudecolors=true" and font name
   //              is a "$claude.*" based font name - 14jul2020
   if x.useclaudecolors and (result=0) and (strcopy1(x.txtname[xwid],1,1)='$') then
      begin
      //init
      n:=x.txtname[xwid];
      //get
      //.text
      if      (n='$claude.text1') then result:=x.claude_text1
      else if (n='$claude.text2') then result:=x.claude_text2
      else if (n='$claude.text3') then result:=x.claude_text3
      else if (n='$claude.text4') then result:=x.claude_text4
      else if (n='$claude.text5') then result:=x.claude_text5
      //.header
      else if (n='$claude.header1') then result:=x.claude_header1
      else if (n='$claude.header2') then result:=x.claude_header2
      else if (n='$claude.header3') then result:=x.claude_header3
      else if (n='$claude.header4') then result:=x.claude_header4
      else if (n='$claude.header5') then result:=x.claude_header5;
      end;
   end;
except;end;
end;
//## low__wordcore__paint2432 ##
function low__wordcore__paint2432(var x:twordcore;aw,ah:longint;xcliparea,xpaintarea:trect;ar24:pcolorrows24;ar32:pcolorrows32;xdebug:tbmp;xmask:tmask8;xmaskval:longint;xround:boolean;xroundstyle,xrowcolor:longint):boolean;//19apr2021
label//Note: acanvas is optional -> for debug purposes only - 29aug2019
   skipchar,redo,skipdone,skipend;
var
   xstr1:tstr8;
   xchar,xcur:twordcharinfo;
   xlastWID,xlastWID2,xzoom,hpos,vpos,ax,ay,xselstart,xselcount,sel1,sel2,int1,intPART1,lx,ly,lh,lh1,xpos,xcount,lpos,lp,lc,xlen,p,dx,dy,sx,sy,sw,sh:longint;
   mr8:pcolorrows8;
   xfc:tstr8;
   xc,xc2,crowback24,c24:tcolor24;
   crowback32,c32:tcolor32;
   xselcol,xselcol2,int4:tint4;
   xurlpos,xurlpos2,xpagecolor,xpagefontselcolor,xpageselcolorX,xpageselcolor,xpagefontcolor2,xpagecolor2:longint;
   finv,xcoloriseOK,xpagecolorise2,xpageoverride2,bol1,bol2,bol3,xrowok,xcursoronscrn:boolean;
   acliparea:trect;
   //## xdrawrow ##
   procedure xdrawrow;
   var
      ymin,ymax,xmin,xmax,dx,dy:longint;
      r24:pcolorrow24;
      r32:pcolorrow32;
   begin
   //init
   //.y-range
   ymin:=ly;
   ymax:=ly+lh-1;
   if (ymin>acliparea.bottom) or (ymax<acliparea.top) then exit;
   ymin:=frcrange(ymin,acliparea.top,acliparea.bottom);
   ymax:=frcrange(ymax,acliparea.top,acliparea.bottom);
   //.x-range
   xmin:=acliparea.left;
   xmax:=acliparea.right;
   if (xmax<xmin) then exit;
   //24
   if (ar24<>nil) and (xmaskval>=0) then
      begin
      for dy:=ymin to ymax do
      begin
      //.fasttimer - ycheck
      inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

      r24:=ar24[dy];
      for dx:=xmin to xmax do if (mr8[dy][dx]=xmaskval) then r24[dx]:=crowback24;
      end;//dy
      end
   else if (ar24<>nil) then
      begin
      for dy:=ymin to ymax do
      begin
      //.fasttimer - ycheck
      inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

      r24:=ar24[dy];
      for dx:=xmin to xmax do r24[dx]:=crowback24;
      end;//dy
      end
   //32
   else if (ar32<>nil) and (xmaskval>=0) then
      begin
      for dy:=ymin to ymax do
      begin
      //.fasttimer - ycheck
      inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

      r32:=ar32[dy];
      for dx:=xmin to xmax do if (mr8[dy][dx]=xmaskval) then r32[dx]:=crowback32;
      end;//dy
      end
   else if (ar32<>nil) then
      begin
      for dy:=ymin to ymax do
      begin
      //.fasttimer - ycheck
      inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

      r32:=ar32[dy];
      for dx:=xmin to xmax do r32[dx]:=crowback32;
      end;//dy
      end;
   end;
   //## xdrawhighlight ##
   procedure xdrawhighlight(xcolor:longint);//mask support as of 26aug2020
   var
      ymin,ymax,xmin,xmax,dx,dy:longint;
      r24:pcolorrow24;
      r32:pcolorrow32;
      int4:tint4;
   begin
   //check
   if (xcolor=clnone) then exit;
   //init
   //.y-range
   ymin:=ly;
   ymax:=ly+lh-1;
   if (ymin>acliparea.bottom) or (ymax<acliparea.top) then exit;
   ymin:=frcrange(ymin,acliparea.top,acliparea.bottom);
   ymax:=frcrange(ymax,acliparea.top,acliparea.bottom);
   //.x-range
   xmin:=sx;
   xmax:=sx+xchar.width-1;
   if (xmin>acliparea.right) or (xmax<acliparea.left) then exit;
   xmin:=frcrange(xmin,acliparea.left,acliparea.right);
   xmax:=frcrange(xmax,acliparea.left,acliparea.right);
   //.int4
   int4.val:=xcolor;
   //24
   if (ar24<>nil) and (xmaskval>=0) then
      begin
      for dy:=ymin to ymax do
      begin
      //.fasttimer - ycheck
      inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

      r24:=ar24[dy];
      for dx:=xmin to xmax do if (mr8[dy][dx]=xmaskval) then
         begin
         c24:=r24[dx];
         c24.r:=int4.r;
         c24.g:=int4.g;
         c24.b:=int4.b;
         r24[dx]:=c24;
         end;//dx
      end;//dy
      end
   else if (ar24<>nil) then
      begin
      for dy:=ymin to ymax do
      begin
      //.fasttimer - ycheck
      inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

      r24:=ar24[dy];
      for dx:=xmin to xmax do
      begin
      c24:=r24[dx];
      c24.r:=int4.r;
      c24.g:=int4.g;
      c24.b:=int4.b;
      r24[dx]:=c24;
      end;//dx
      end;//dy
      end
   //32
   else if (ar32<>nil) and (xmaskval>=0) then
      begin
      for dy:=ymin to ymax do
      begin
      //.fasttimer - ycheck
      inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

      r32:=ar32[dy];
      for dx:=xmin to xmax do if (mr8[dy][dx]=xmaskval) then
         begin
         c32:=r32[dx];
         c32.r:=int4.r;
         c32.g:=int4.g;
         c32.b:=int4.b;
         r32[dx]:=c32;
         end;//dx
      end;//dy
      end
   else if (ar32<>nil) then
      begin
      for dy:=ymin to ymax do
      begin
      //.fasttimer - ycheck
      inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

      r32:=ar32[dy];
      for dx:=xmin to xmax do
      begin
      c32:=r32[dx];
      c32.r:=int4.r;
      c32.g:=int4.g;
      c32.b:=int4.b;
      r32[dx]:=c32;
      end;//dx
      end;//dy
      end;
   end;
   //## xdrawsel ##
   procedure xdrawsel(xmerge:boolean;var xselcol:tint4);//mask support as of 26aug2020
   var
      ymin,ymax,xmin,xmax,dx,dy:longint;
      r24:pcolorrow24;
      r32:pcolorrow32;
   begin
   //init
   //.y-range
   ymin:=ly;
   ymax:=ly+lh-1;
   if (ymin>acliparea.bottom) or (ymax<acliparea.top) then exit;
   ymin:=frcrange(ymin,acliparea.top,acliparea.bottom);
   ymax:=frcrange(ymax,acliparea.top,acliparea.bottom);
   //.x-range
   xmin:=sx;
   xmax:=sx+xchar.width-1;
   if (xmin>acliparea.right) or (xmax<acliparea.left) then exit;
   xmin:=frcrange(xmin,acliparea.left,acliparea.right);
   xmax:=frcrange(xmax,acliparea.left,acliparea.right);
   //24
   if (ar24<>nil) and (xmaskval>=0) then
      begin
      for dy:=ymin to ymax do
      begin
      //.fasttimer - ycheck
      inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

      r24:=ar24[dy];
      for dx:=xmin to xmax do if (mr8[dy][dx]=xmaskval) then
         begin
         c24:=r24[dx];
         if xmerge then
            begin
            c24.r:=(c24.r+xselcol.r) div 2;
            c24.g:=(c24.g+xselcol.g) div 2;
            c24.b:=(c24.b+xselcol.b) div 2;
            end
         else
            begin
            c24.r:=xselcol.r;
            c24.g:=xselcol.g;
            c24.b:=xselcol.b;
            end;
         r24[dx]:=c24;
         end;//dx
      end;//dy
      end
   else if (ar24<>nil) then
      begin
      for dy:=ymin to ymax do
      begin
      //.fasttimer - ycheck
      inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

      r24:=ar24[dy];
      for dx:=xmin to xmax do
      begin
      c24:=r24[dx];
      if xmerge then
         begin
         c24.r:=(c24.r+xselcol.r) div 2;
         c24.g:=(c24.g+xselcol.g) div 2;
         c24.b:=(c24.b+xselcol.b) div 2;
         end
      else
         begin
         c24.r:=xselcol.r;
         c24.g:=xselcol.g;
         c24.b:=xselcol.b;
         end;
      r24[dx]:=c24;
      end;//dx
      end;//dy
      end
   //32
   else if (ar32<>nil) and (xmaskval>=0) then
      begin
      for dy:=ymin to ymax do
      begin
      //.fasttimer - ycheck
      inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

      r32:=ar32[dy];
      for dx:=xmin to xmax do if (mr8[dy][dx]=xmaskval) then
         begin
         c32:=r32[dx];
         if xmerge then
            begin
            c32.r:=(c32.r+xselcol.r) div 2;
            c32.g:=(c32.g+xselcol.g) div 2;
            c32.b:=(c32.b+xselcol.b) div 2;
            end
         else
            begin
            c32.r:=xselcol.r;
            c32.g:=xselcol.g;
            c32.b:=xselcol.b;
            end;
         r32[dx]:=c32;
         end;//dx
      end;//dy
      end
   else if (ar32<>nil) then
      begin
      for dy:=ymin to ymax do
      begin
      //.fasttimer - ycheck
      inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

      r32:=ar32[dy];
      for dx:=xmin to xmax do
      begin
      c32:=r32[dx];
      if xmerge then
         begin
         c32.r:=(c32.r+xselcol.r) div 2;
         c32.g:=(c32.g+xselcol.g) div 2;
         c32.b:=(c32.b+xselcol.b) div 2;
         end
      else
         begin
         c32.r:=xselcol.r;
         c32.g:=xselcol.g;
         c32.b:=xselcol.b;
         end;
      r32[dx]:=c32;
      end;//dx
      end;//dy
      end;
   end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//555555555555555555555555
   //## xdraw24 ##
   procedure xdraw24(x:tbasicimage);//now support transparent mode for TEA1(default) and should support TEA2(optional transparency) - 19apr2021
   var
      v,ycount,tr,tg,tb,xw,xh,yoff,sbits,ssx,ssy,dx,dy:longint;
      s24,r24:pcolorrow24;
      s32,r32:pcolorrow32;
      t24:tcolor24;
      //## x_sys24 ##
      procedure x_sys24;
      begin
      v:=(c24.r+c24.g+c24.b) div 3;
      if (v<100) then v:=100 else if (v>230) then v:=230;
      if finv then v:=255-v;//26mar2021
      c24.r:=((xc.r*v) + (xc2.r*(255-v))) div 255;
      c24.g:=((xc.g*v) + (xc2.g*(255-v))) div 255;
      c24.b:=((xc.b*v) + (xc2.b*(255-v))) div 255;
      end;
      //## x_sys32 ##
      procedure x_sys32;
      begin
      v:=(c32.r+c32.g+c32.b) div 3;
      if (v<100) then v:=100 else if (v>230) then v:=230;
      if finv then v:=255-v;//26mar2021
      c32.r:=((xc.r*v) + (xc2.r*(255-v))) div 255;
      c32.g:=((xc.g*v) + (xc2.g*(255-v))) div 255;
      c32.b:=((xc.b*v) + (xc2.b*(255-v))) div 255;
      end;
   begin
   try
   //check
   if zznil(x,2213) or (x.width<=0) or (x.height<=0) then exit;
   //init
   xw:=x.width;
   xh:=x.height;
   sbits:=x.bits;
   if (sbits<>24) and (sbits<>32) then exit;
   //.yoff
   yoff:=frcmin(lh1-xh*xzoom,0);
   //.transparent color
   tr:=-1;
   tg:=-1;
   tb:=-1;
   if x.ai.transparent then
      begin
      t24:=mispixel24(x,0,0);
      tr:=t24.r;
      tg:=t24.g;
      tb:=t24.b;
      end;

   //24 + 24 = zoom.OK -
   if (ar24<>nil) and (sbits=24) then
      begin
      for ssy:=0 to (xh-1) do
      begin
      //.fasttimer - ycheck
      inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

      dy:=ly+yoff+(ssy*xzoom);
      if (dy>=acliparea.top) and (dy<=acliparea.bottom) then
         begin
         s24:=x.prows24[ssy];
         for ycount:=0 to (xzoom-1) do
         begin
         if (dy>=acliparea.top) and (dy<=acliparea.bottom) then
            begin
            r24:=ar24[dy];
            //.masked
            if (xmaskval>=0) then
               begin
               dx:=sx;
               for ssx:=0 to (xw-1) do
               begin
               if (dx>=acliparea.left) and (dx<=acliparea.right) and (mr8[dy][dx]=xmaskval) then
                  begin
                  c24:=s24[ssx];
                  if (c24.r<>tr) or (c24.g<>tg) or (c24.b<>tb) then
                     begin
                     if xcoloriseOK then x_sys24;
                     r24[dx]:=c24;
                     if (xzoom>=2) and ((dx+1)>=acliparea.left) and ((dx+1)<=acliparea.right) and (mr8[dy][dx+1]=xmaskval) then r24[dx+1]:=c24;
                     if (xzoom>=3) and ((dx+2)>=acliparea.left) and ((dx+2)<=acliparea.right) and (mr8[dy][dx+2]=xmaskval) then r24[dx+2]:=c24;
                     if (xzoom>=4) and ((dx+3)>=acliparea.left) and ((dx+3)<=acliparea.right) and (mr8[dy][dx+3]=xmaskval) then r24[dx+3]:=c24;
                     end;
                  end;//dx
               inc(dx,xzoom);//inc dx
               end;//ssx
               end//if.masked
            //.no mask
            else
               begin
               dx:=sx;
               for ssx:=0 to (xw-1) do
               begin
               if (dx>=acliparea.left) and (dx<=acliparea.right) then
                  begin
                  c24:=s24[ssx];
                  if (c24.r<>tr) or (c24.g<>tg) or (c24.b<>tb) then
                     begin
                     if xcoloriseOK then x_sys24;
                     r24[dx]:=c24;
                     if (xzoom>=2) and ((dx+1)>=acliparea.left) and ((dx+1)<=acliparea.right) then r24[dx+1]:=c24;
                     if (xzoom>=3) and ((dx+2)>=acliparea.left) and ((dx+2)<=acliparea.right) then r24[dx+2]:=c24;
                     if (xzoom>=4) and ((dx+3)>=acliparea.left) and ((dx+3)<=acliparea.right) then r24[dx+3]:=c24;
                     end;
                  end;//dx
               inc(dx,xzoom);//inc dx
               end;//ssx
               end;//if.masked
            end;//dy
         inc(dy);//inc dy
         end;//ycount
         end;//dy
      end;//ssy
      end
   //24 + 32 = zoom.OK - 14mar2021
   else if (ar24<>nil) and (sbits=32) then
      begin
      for ssy:=0 to (xh-1) do
      begin
      //.fasttimer - ycheck
      inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

      dy:=ly+yoff+(ssy*xzoom);
      if (dy>=acliparea.top) and (dy<=acliparea.bottom) then
         begin
         s32:=x.prows32[ssy];
         for ycount:=0 to (xzoom-1) do
         begin
         if (dy>=acliparea.top) and (dy<=acliparea.bottom) then
            begin
            r24:=ar24[dy];
            //.masked
            if (xmaskval>=0) then
               begin
               dx:=sx;
               for ssx:=0 to (xw-1) do
               begin
               if (dx>=acliparea.left) and (dx<=acliparea.right) and (mr8[dy][dx]=xmaskval) then
                  begin
                  c32:=s32[ssx];
                  c24.r:=c32.r;
                  c24.g:=c32.g;
                  c24.b:=c32.b;
                  if (c24.r<>tr) or (c24.g<>tg) or (c24.b<>tb) then
                     begin
                     if xcoloriseOK then x_sys24;
                     r24[dx]:=c24;
                     if (xzoom>=2) and ((dx+1)>=acliparea.left) and ((dx+1)<=acliparea.right) and (mr8[dy][dx+1]=xmaskval) then r24[dx+1]:=c24;
                     if (xzoom>=3) and ((dx+2)>=acliparea.left) and ((dx+2)<=acliparea.right) and (mr8[dy][dx+2]=xmaskval) then r24[dx+2]:=c24;
                     if (xzoom>=4) and ((dx+3)>=acliparea.left) and ((dx+3)<=acliparea.right) and (mr8[dy][dx+3]=xmaskval) then r24[dx+3]:=c24;
                     end;
                  end;//dx
               inc(dx,xzoom);//inc dx
               end;//ssx
               end//if.masked
            //.no mask
            else
               begin
               dx:=sx;
               for ssx:=0 to (xw-1) do
               begin
               if (dx>=acliparea.left) and (dx<=acliparea.right) then
                  begin
                  c32:=s32[ssx];
                  c24.r:=c32.r;
                  c24.g:=c32.g;
                  c24.b:=c32.b;
                  if (c24.r<>tr) or (c24.g<>tg) or (c24.b<>tb) then
                     begin
                     if xcoloriseOK then x_sys24;
                     r24[dx]:=c24;
                     if (xzoom>=2) and ((dx+1)>=acliparea.left) and ((dx+1)<=acliparea.right) then r24[dx+1]:=c24;
                     if (xzoom>=3) and ((dx+2)>=acliparea.left) and ((dx+2)<=acliparea.right) then r24[dx+2]:=c24;
                     if (xzoom>=4) and ((dx+3)>=acliparea.left) and ((dx+3)<=acliparea.right) then r24[dx+3]:=c24;
                     end;
                  end;//dx
               inc(dx,xzoom);//inc dx
               end;//ssx
               end;//if.masked
            end;//dy
         inc(dy);//inc dy
         end;//ycount
         end;//dy
      end;//ssy
      end
   //32 + 32 = zoom.OK - 14mar2021
   else if (ar32<>nil) and (sbits=32) then
      begin
      for ssy:=0 to (xh-1) do
      begin
      //.fasttimer - ycheck
      inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

      dy:=ly+yoff+(ssy*xzoom);
      if (dy>=acliparea.top) and (dy<=acliparea.bottom) then
         begin
         s32:=x.prows32[ssy];
         for ycount:=0 to (xzoom-1) do
         begin
         if (dy>=acliparea.top) and (dy<=acliparea.bottom) then
            begin
            r32:=ar32[dy];
            //.masked
            if (xmaskval>=0) then
               begin
               dx:=sx;
               for ssx:=0 to (xw-1) do
               begin
               if (dx>=acliparea.left) and (dx<=acliparea.right) and (mr8[dy][dx]=xmaskval) then
                  begin
                  c32:=s32[ssx];
                  if (c32.r<>tr) or (c32.g<>tg) or (c32.b<>tb) then
                     begin
                     if xcoloriseOK then x_sys32;
                     r32[dx]:=c32;
                     if (xzoom>=2) and ((dx+1)>=acliparea.left) and ((dx+1)<=acliparea.right) and (mr8[dy][dx+1]=xmaskval) then r32[dx+1]:=c32;
                     if (xzoom>=3) and ((dx+2)>=acliparea.left) and ((dx+2)<=acliparea.right) and (mr8[dy][dx+2]=xmaskval) then r32[dx+2]:=c32;
                     if (xzoom>=4) and ((dx+3)>=acliparea.left) and ((dx+3)<=acliparea.right) and (mr8[dy][dx+3]=xmaskval) then r32[dx+3]:=c32;
                     end;
                  end;//dx
               inc(dx,xzoom);//inc dx
               end;//ssx
               end//if.masked
            //.no mask
            else
               begin
               dx:=sx;
               for ssx:=0 to (xw-1) do
               begin
               if (dx>=acliparea.left) and (dx<=acliparea.right) then
                  begin
                  c32:=s32[ssx];
                  if (c32.r<>tr) or (c32.g<>tg) or (c32.b<>tb) then
                     begin
                     if xcoloriseOK then x_sys32;
                     r32[dx]:=c32;
                     if (xzoom>=2) and ((dx+1)>=acliparea.left) and ((dx+1)<=acliparea.right) then r32[dx+1]:=c32;
                     if (xzoom>=3) and ((dx+2)>=acliparea.left) and ((dx+2)<=acliparea.right) then r32[dx+2]:=c32;
                     if (xzoom>=4) and ((dx+3)>=acliparea.left) and ((dx+3)<=acliparea.right) then r32[dx+3]:=c32;
                     end;
                  end;//dx
               inc(dx,xzoom);//inc dx
               end;//ssx
               end;//if.masked
            end;//dy
         inc(dy);//inc dy
         end;//ycount
         end;//dy
      end;//ssy
      end
   //32 + 24 = zoom.OK - 14mar2021
   else if (ar32<>nil) and (sbits=24) then
      begin
      for ssy:=0 to (xh-1) do
      begin
      //.fasttimer - ycheck
      inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

      dy:=ly+yoff+(ssy*xzoom);
      if (dy>=acliparea.top) and (dy<=acliparea.bottom) then
         begin
         s24:=x.prows24[ssy];
         for ycount:=0 to (xzoom-1) do
         begin
         if (dy>=acliparea.top) and (dy<=acliparea.bottom) then
            begin
            r32:=ar32[dy];
            //.masked
            if (xmaskval>=0) then
               begin
               dx:=sx;
               for ssx:=0 to (xw-1) do
               begin
               if (dx>=acliparea.left) and (dx<=acliparea.right) and (mr8[dy][dx]=xmaskval) then
                  begin
                  c24:=s24[ssx];
                  c32.r:=c24.r;
                  c32.g:=c24.g;
                  c32.b:=c24.b;
                  c32.a:=255;//fully visible
                  if (c32.r<>tr) or (c32.g<>tg) or (c32.b<>tb) then
                     begin
                     if xcoloriseOK then x_sys32;
                     r32[dx]:=c32;
                     if (xzoom>=2) and ((dx+1)>=acliparea.left) and ((dx+1)<=acliparea.right) and (mr8[dy][dx+1]=xmaskval) then r32[dx+1]:=c32;
                     if (xzoom>=3) and ((dx+2)>=acliparea.left) and ((dx+2)<=acliparea.right) and (mr8[dy][dx+2]=xmaskval) then r32[dx+2]:=c32;
                     if (xzoom>=4) and ((dx+3)>=acliparea.left) and ((dx+3)<=acliparea.right) and (mr8[dy][dx+3]=xmaskval) then r32[dx+3]:=c32;
                     end;
                  end;//dx
               inc(dx,xzoom);//inc dx
               end;//ssx
               end//if.masked
            //.no mask
            else
               begin
               dx:=sx;
               for ssx:=0 to (xw-1) do
               begin
               if (dx>=acliparea.left) and (dx<=acliparea.right) then
                  begin
                  c24:=s24[ssx];
                  c32.r:=c24.r;
                  c32.g:=c24.g;
                  c32.b:=c24.b;
                  c32.a:=255;//fully visible
                  if (c32.r<>tr) or (c32.g<>tg) or (c32.b<>tb) then
                     begin
                     if xcoloriseOK then x_sys32;
                     r32[dx]:=c32;
                     if (xzoom>=2) and ((dx+1)>=acliparea.left) and ((dx+1)<=acliparea.right) then r32[dx+1]:=c32;
                     if (xzoom>=3) and ((dx+2)>=acliparea.left) and ((dx+2)<=acliparea.right) then r32[dx+2]:=c32;
                     if (xzoom>=4) and ((dx+3)>=acliparea.left) and ((dx+3)<=acliparea.right) then r32[dx+3]:=c32;
                     end;
                  end;//dx
               inc(dx,xzoom);//inc dx
               end;//ssx
               end;//if.masked
            end;//dy
         inc(dy);//inc dy
         end;//ycount
         end;//dy
      end;//ssy
      end;//if
   except;end;
   end;
   //## xurlscan ##
   procedure xurlscan(xpos:longint);
   label
      skipend;
   var
      xchar:twordcharinfo;
      p,xlastWID,xlastWID2,v1,v2:longint;
   begin
   try
   //defaults
   v1:=-1;
   v2:=-1;
   //check
   if (xpos<=0) then exit;
   if not low__urlok(x.data.str1[xpos,8],true) then exit;
   //start
   v1:=xpos;
   v2:=xpos;
   //stop
   if (v1>=0) then
      begin
      //before
      xlastWID:=-1;
      xlastWID2:=-1;
      if low__wordcore__charinfoULTRA(x,xpos-1,xchar,xlastWID,xlastWID2) and (xchar.c>ssSpace) then
         begin
         v1:=-1;
         v2:=-1;
         goto skipend;
         end;
      //after
      xlastWID:=-1;
      xlastWID2:=-1;
      for p:=xpos to (xpos+999) do
      begin
      if not low__wordcore__charinfoULTRA(x,p,xchar,xlastWID,xlastWID2) then
         begin
         v2:=frcmin(p-1,0);
         break;
         end;
      if (xchar.c<=ssSpace) then
         begin
         v2:=frcmin(p-1,0);
         break;
         end;
      v2:=p;
      end;//p
      end;
   skipend:
   except;end;
   try
   if (v1<0) or (v2<0) then
      begin
      xurlpos:=-1;
      xurlpos2:=-1;
      end
   else
      begin
      xurlpos:=v1;
      xurlpos2:=v2;
      end;
   except;end;
   end;
   //## cur24 ##
   procedure cur24(var r,g,b:byte);
   begin
   try
   //grey correction
   if (r>=120) and (r<=140) and (g>=120) and (g<=140) and (b>=120) and (b<=140) then
      begin
      r:=255;
      g:=255;
      b:=255;
      end
   //invert color
   else
      begin
      r:=255-r;
      g:=255-g;
      b:=255-b;
      end;
   except;end;
   end;
begin
try
//defaults
result:=false;
xcursoronscrn:=false;
xfc:=nil;//feather core -> used when "x.feather=true"
xstr1:=nil;
ax:=0;
ay:=0;
xurlpos:=-1;//off
xurlpos2:=-1;
//check
if not low__wordcore__inited(x) then exit;
if ((ar24=nil) and (ar32=nil)) or (aw<0) or (ah<0) then exit;
if (xcliparea.right<xcliparea.left) or (xcliparea.bottom<xcliparea.top) then exit;
if (xpaintarea.right<xpaintarea.left) or (xpaintarea.bottom<xpaintarea.top) then exit;

//check mask
if (xmaskval>=0) then
   begin
   if zznil(xmask,2216) or ((xmask.width<aw) or (xmask.height<ah)) then xmaskval:=-1;//off
   if (xmaskval>=0) then mr8:=xmask.prows8;
   end;

//zoom
xzoom:=x.zoomnow;

//cliparea + adjust coordinates to match host system - 23aug2020
acliparea.left:=frcrange(largest(xcliparea.left,xpaintarea.left),0,aw-1);
acliparea.right:=frcrange(smallest(xcliparea.right,xpaintarea.right),0,aw-1);
acliparea.top:=frcrange(largest(xcliparea.top,xpaintarea.top),0,ah-1);
acliparea.bottom:=frcrange(smallest(xcliparea.bottom,xpaintarea.bottom),0,ah-1);
ax:=-(xcliparea.left-acliparea.left);
ay:=-(xcliparea.top -acliparea.top);
//.rowback colors -> for drawing alternative row background colors
xrowok:=true;
if (xrowcolor<>clnone) then
   begin
   crowback24:=low__intrgb(xrowcolor);
   crowback32.r:=crowback24.r;
   crowback32.g:=crowback24.g;
   crowback32.b:=crowback24.b;
   crowback32.a:=255;
   end;

//init
//.continue
xselcol.val:=x.pageselcolor;
xselcol2.val:=low__dc(x.pageselcolor,-35);
xpagefontselcolor:=x.pagefontselcolor;
xpageselcolor:=x.pageselcolor;
xpageselcolorX:=low__dc(xpageselcolor,10);
xpagefontcolor2:=x.pagefontcolor2;
xpagecolor:=x.pagecolor;
xpagecolor2:=x.pagecolor2;
xpageoverride2:=x.pageoverride2;
xpagecolorise2:=x.pagecolorise2;
xselstart:=low__wordcore_str2(x,'selstart','');
xselcount:=low__wordcore_str2(x,'selcount','');
if (xselcount>=1) then
   begin
   sel1:=xselstart;
   sel2:=sel1+xselcount-1;
   end
else
   begin
   sel1:=-1;
   sel2:=-1;
   end;
//.colorise images support - 19apr2021
xc:=low__intrgb(x.pagefontcolor2);
xc2:=low__intrgb(x.pagecolor2);
xcoloriseOK:=xpageoverride2 and x.pagecolorise2 and (x.pagefontcolor2<>clnone) and (x.pagecolor2<>clnone);
finv:=(low__brightness2b(low__rgbint(xc))<low__brightness2b(low__rgbint(xc2)));

xpos:=0;//not set
xlen:=x.data.len;
if (xlen<1) then goto skipdone;

//find start line (top of client area)
hpos:=low__wordcore2(x,'hpos',nil);//11mar2021
vpos:=low__wordcore2(x,'vpos',nil);
if (vpos>=0) and (vpos<x.linecount) and (vpos<x.linesize) then
   begin
   int1:=x.liney[vpos];
   intPART1:=x.vposPART;
   end
else
   begin
   int1:=0;
   intPART1:=0;
   end;
//was: lpos:=low__wordcore_str2(x,'y>line',inttostr(int1));
lpos:=low__wordcore_str2(x,'y>line',inttostr(int1+low__insint(intPART1,intPART1<0)));
if (int1<>0) then inc(ay,int1);
inc(ay,intPART1);//21jun2022
if (lpos<0) or (lpos>=x.linecount) or (lpos>=x.linesize) then goto skipdone;

//init
if (x.feather>=1) then xfc:=bnew;

//-- Paint By Lines ------------------------------------------------------------
//Note: Painting by lines requires 14x less RAM to map characters with
//      little to no extra lag time - Aug2019
//------------------------------------------------------------------------------

redo:

//init
xlastWID:=-1;
xlastWID2:=-1;
//get
xpos:=low__wordcore_str2(x,'line>pos',inttostr(lpos));//convert line number (0..N) into a text position "xpos", e.g. character at location -> "x.data[xpos]"
if (xpos<=0) or (xpos>xlen) then goto skipdone;
xcount:=low__wordcore_str2(x,'line>itemcount',inttostr(lpos));//return number of characters in the line
if (xcount<=0) then goto skipdone;

//.line info
//xxxxxxxxxxxxxxxxxxxxxxxxx//######################//???????????????
lx:=x.linex[lpos]+acliparea.left-ax-hpos;//need to fill this in later..xxxxxxxxxxxxxxxxxxxxxxxxx
ly:=x.liney[lpos]+acliparea.top-ay;
lh:=x.lineh[lpos];
lh1:=x.lineh1[lpos];
//.draw alternating row background color
if (xrowcolor<>clnone) then
   begin
   if xrowok then xdrawrow;;
   xrowok:=not xrowok;
   end;

//draw each line using their series of in-order "chars"
sx:=lx;
for p:=xpos to (xpos+xcount-1) do
begin
//.fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

//.check
if (p<0) or (p>xlen) then goto skipdone;
//.wrap more
if (p>x.wrapcount) then
   begin
   //can't paint -> wrap is not upto date
   low__wordcore_str(x,'wrapto',inttostr(p+x.c_pagewrap));
   //trigger a repaint
   x.mustpaint:=true;
   goto skipdone;
   end;
//.get char
//was: if not low__wordcore__charinfo(x,p,xchar) then goto skipdone;
if not low__wordcore__charinfoULTRA(x,p,xchar,xlastWID,xlastWID2) then goto skipdone;//FASTER - 19jun2022
sy:=ly+lh1-xchar.height1;
if ((sx+xchar.width)<acliparea.left) then goto skipchar;

//.draw char
if (xchar.cs=wc_t) then
   begin
   if (xchar.c<>10) then
      begin
      //scan for url
      if x.oviewurl then
         begin
         //init
         bol3:=false;
         //.http and https
         if ((xchar.c=uuH) or (xchar.c=llH)) then
            begin
            int1:=x.data.bytes[p];
            bol3:=(int1=uuT) or (int1=llT);
            end
         //.ftp and ftps
         else if ((xchar.c=uuF) or (xchar.c=llF)) then
            begin
            int1:=x.data.bytes[p];
            bol3:=(int1=uuT) or (int1=llT);
            end
         //.mailto
         else if ((xchar.c=uuM) or (xchar.c=llM)) then
            begin
            int1:=x.data.bytes[p];
            bol3:=(int1=uuA) or (int1=llA);
            end;
         //get
         if bol3 then xurlscan(p);
         end;
      //draw highlight
      bol2:=(x.txtbk[xchar.wid]<>clnone);
      if bol2 then xdrawhighlight(low__aorb(x.txtbk[xchar.wid],xpageselcolor,xpageoverride2));
      //draw sel
      bol1:=false;
      if (p>=sel1) and (p<=sel2) then
         begin
         if bol2 then xdrawsel(false,xselcol2) else xdrawsel(false,xselcol);
         bol1:=true;
         end;
      //draw character
      if (xchar.c<>9) then
         begin
         //.lgfFILL
         if (not x.dataonly) and (blen(x.lgfdata[xchar.txtid])<=0) then low__wordcore__lgfFILL(x,xchar.txtid,false);
         //.text color
         if bol1 then int1:=xpagefontselcolor
         else if xpageoverride2 then
            begin
            int1:=xpagefontcolor2;
            if (x.txtbk[xchar.wid]<>clnone) then int1:=xpagefontselcolor;//19jun2022
            end
         else int1:=low__wordcore__txtcolor(x,xchar.wid);
         //.draw
         low__fromLGF_drawchar2432(x.lgfdata[xchar.txtid],ord(xchar.c),sx,sy,aw,ah,int1,acliparea,acliparea,ar24,ar32,xmask,xmaskval,xfc,x.feather,false,x.txtitalic[xchar.wid],x.txtunderline[xchar.wid],(p>=xurlpos) and (p<=xurlpos2),x.txtstrikeout[xchar.wid],xround,xroundstyle);
         end;
      end;
   end
else if (xchar.cs=wc_i) then
  begin
  //draw image
  if zzok(x.img24[xchar.wid],7051) then xdraw24(x.img24[xchar.wid]);
  //draw sel (ontop of image)
  if (p>=sel1) and (p<=sel2) then xdrawsel(true,xselcol);
  end;

skipchar:
//.draw cursor -> mask support as of 26aug2020
if (p=x.cursorpos) then
   begin
   xcursoronscrn:=true;
   if x.drawcursor and x.havefocus then
      begin
//      for dx:=(sx-1) to sx do
//      for dx:=sx to (sx+1) do
      for dx:=sx to (sx+1) do
      begin
      if (dx>=acliparea.left) and (dx<=acliparea.right) then
         begin
         //init
         if low__wordcore__charinfo(x,frcmin(p-1,1),xcur) then
            begin
            int1:=ly+lh1-xcur.height1;
            //get
            if (ar24<>nil) then
               begin
               for dy:=(0+int1) to (0+int1+xcur.height-1) do if (dy>=acliparea.top) and (dy<=acliparea.bottom) and ((xmaskval<0) or (mr8[dy][dx]=xmaskval)) then
                  begin
                  cur24(ar24[dy][dx].r,ar24[dy][dx].g,ar24[dy][dx].b);
                  end;//dy
               end
            else if (ar32<>nil) then
               begin
               for dy:=(0+int1) to (0+int1+xcur.height-1) do if (dy>=acliparea.top) and (dy<=acliparea.bottom) and ((xmaskval<0) or (mr8[dy][dx]=xmaskval)) then
                  begin
                  cur24(ar32[dy][dx].r,ar32[dy][dx].g,ar32[dy][dx].b);
                  ar32[dy][dx].a:=255;//fully solid
                  end;//dy
               end;
            end;//dx
         end;//xcur=OK
      end;//dx
      end;//drawcursor
   end;//cursor

//.inc
inc(sx,xchar.width);
if (sx>acliparea.right) then break;//19jun2022
end;//p
//.next line
inc(lpos);
if (ly<ah) and (lpos<x.linecount) and (lpos<x.linesize) then goto redo;
//.sync
x.cursoronscrn:=xcursoronscrn;

//successful
skipdone:
result:=true;
skipend:
except;end;
try
bfree(xfc);
bfree(xstr1);
except;end;
end;
//## low__wordcore__keyboard ##
procedure low__wordcore__keyboard(var x:twordcore;xctrl,xalt,xshift,xkeyX:boolean;xkey:byte);
var
   a:tstr8;
begin
try
a:=bnew_autofree;
a.addbol1(xctrl);
a.addbol1(xalt);
a.addbol1(xshift);
a.addbol1(xkeyX);
a.addbyt1(xkey);
low__wordcore(x,'kstack',a);
except;end;
end;
//## low__wordcore__keyboard2 ##
procedure low__wordcore__keyboard2(var x:twordcore;akcode:longint);
var
   a:tstr8;
begin
try
a:=bnew_autofree;
a.addbyt1(2);//using "akcode" system
a.addint4(akcode);
low__wordcore(x,'kstack',a);
except;end;
end;
//## low__wordcore__mouse ##
procedure low__wordcore__mouse(var x:twordcore;xmousex,xmousey:longint;xmousedown,xmouseright:boolean);
var
   a:tstr8;
begin
try
a:=bnew_autofree;
a.addint4(xmousex);
a.addint4(xmousey);
a.addbol1(xmousedown);
a.addbol1(xmouseright);
low__wordcore(x,'mstack',a);
except;end;
end;
//## low__wordcore ##
function low__wordcore(var x:twordcore;xcmd:string;xval:tstr8):boolean;
var
   xoutval,e:string;
begin
try;result:=false;low__wordcore4(x,xcmd,xval,nil,xoutval,e);result:=(xoutval<>'') and (xoutval<>'0');except;end;
end;
//## low__wordcore_str ##
function low__wordcore_str(var x:twordcore;xcmd,xval:string):boolean;
var
   xoutval,e:string;
begin
try;result:=false;low__wordcore4(x,xcmd,bcopystrall(xval),nil,xoutval,e);result:=(xoutval<>'') and (xoutval<>'0');except;end;
end;
//## low__wordcore2 ##
function low__wordcore2(var x:twordcore;xcmd:string;xval:tstr8):longint;
var
   xoutval,e:string;
begin
try;result:=0;low__wordcore4(x,xcmd,xval,nil,xoutval,e);result:=strint(xoutval);except;end;
end;
//## low__wordcore_str2 ##
function low__wordcore_str2(var x:twordcore;xcmd,xval:string):longint;
var
   xoutval,e:string;
begin
try;result:=0;low__wordcore4(x,xcmd,bcopystrall(xval),nil,xoutval,e);result:=strint(xoutval);except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//5555555555555555555555
//## low__wordcore3 ##
function low__wordcore3(var x:twordcore;xcmd:string;xval:tstr8;var xoutval,e:string):boolean;
begin
try;result:=low__wordcore4(x,xcmd,xval,nil,xoutval,e);except;end;
end;
//## low__wordcore4 ##
function low__wordcore4(var x:twordcore;xcmd:string;xval,xoutbin:tstr8;var xoutval,e:string):boolean;//return result: true=OK, false=error, result stored in "xoutval" - 25aug2019
label
   skipkeyboard,skipdone,skipend;
var
   xvar1:tvars8;
   d1,d2,d3,ximgdata,xstr1,xstr2,xstr3,xstr4,xstr5,xstr6:tstr8;
   xid,v1,v2,xnewcursorpos,xsize,xmin,xmax,xfontsize,xcolor,xcolor2,xbk,xborder,xlen,dlen,xline,xline2,xcursor_keyboard_moveto,xoldcursorpos,dx,dy,i,int1,int2,int3,int4,int5,p,p2,imax:longint;
   wrd2:twrd2;
   xtype,n,v,str1,str2,str3,str4,str5,str6:string;
   xfontname:string;
   xfull,xonce,xonce2,xchklinecursorx,xctrl,xalt,xshift,xkeyx,xmustpaint,xmusttimerunbusy,bol1,bol2,bol3:boolean;
   xbold,xitalic,xunderline,xstrikeout,xswap,xusecolor2:boolean;
   xalign:byte;
   v8,c,cs:byte;
   c32:tcolor32;
   r32:pcolorrow32;
   xchar:twordcharinfo;
   xint4,xint4b:tint4;
   xlist:pdllongint;
   xlisti:pdllongint;
   xlist2:array[0..999] of tstr8;
   //## xscootable ##
   function xscootable(x:byte):boolean;
   begin
   result:=(x=ssspace) or (x=ssdot) or (x=sscomma) or (x=sscolon) or (x=sssemicolon) or (x=ssexclaim) or (x=ssquestion) or (x=ss10) or (x=ss9) or (x=ssdoublequote) or (x=sssinglequote);
   end;
   //## xsafeline ##
   function xsafeline(var xindex:longint):boolean;
   var
      xmax:longint;
   begin
   try
   //defaults
   result:=false;
   //init
   xmax:=frcmax(x.linecount-1,x.linesize-1);
   if (xmax<0) then xmax:=0;
   //get
   result:=(xindex>=0) and (xindex<=xmax);
   if (xindex<0) then xindex:=0 else if (xindex>xmax) then xindex:=xmax;
   except;end;
   end;
   //## xposTOx ##
   function xposTOx(xpos:longint;var dx,dx2:longint):boolean;
   var
      xmin,p,xline:longint;
      xchar:twordcharinfo;
   begin
   try
   //defaults
   result:=false;
   dx:=0;
   dx2:=0;
   //range
   xpos:=frcrange(xpos,1,blen(x.data));
   //init
   xline:=low__wordcore_str2(x,'pos>line',inttostr(xpos));
   //get
   if xsafeline(xline) then
      begin
      result:=true;
      dx:=x.linex[xline];
      xmin:=x.linep[xline];
      for p:=xmin to blen(x.data) do
      begin
      if not low__wordcore__charinfo(x,p,xchar) then break;
      dx2:=dx+xchar.width;//right side of cursor character
      if (p>=xpos) then break;
      inc(dx,xchar.width);
      end;//p
      end;
   except;end;
   end;
   //## xcursor_offscreenX ##
   function xcursor_offscreenX:longint;
   var//Note: returns<0 if cursor is off left of screen, returns>0 if off to right and returns 0 when cursor is on screen - 31mar2021
      int1,int2,int3:longint;
   begin
   try
   //defaults
   result:=0;
   //init
   if xposTOx(x.cursorpos,int1,int2) then
      begin
      dec(int1,x.hpos);
      dec(int2,x.hpos);
      //get
      if (int1<0) then result:=int1;
      if (int2>=x.viewwidth) then result:=int2-x.viewwidth+1;
      end;
   except;end;
   end;
   //## xcursor_bringintoview ##
   procedure xcursor_bringintoview;
   var
      int1:longint;
   begin
   try
   int1:=xcursor_offscreenX;
   if (int1<>0) then
      begin
      x.hhostsync:=true;
      x.hpos:=x.hpos+int1+((x.viewwidth div 3)*(int1 div low__posn(int1)));
      x.mustpaint:=true;
      end;
   except;end;
   end;
   //## xlinecursorx ##
   procedure xlinecursorx(xpos:longint);
   var
      int1,int2:longint;
   begin
   try
   if xposTOx(xpos,int1,int2) then x.linecursorx:=int1;
   xcursor_bringintoview;
   except;end;
   end;
   //## xmmTOpixels ##
   function xmmTOpixels(xval:longint):longint;//now supports zoom - 17mar2021
   begin
   try;result:=round(frcmin(x.zoomnow*xval,0)*(x.dpi/25.4));except;end;
   end;
   //## xvalstr ##
   function xvalstr:string;
   begin
   result:='';
   if zzok(xval,7052) then result:=xval.text;
   end;
   //## xneed1 ##
   procedure xneed1;
   begin
   if zznil(xstr1,2216) then xstr1:=bnew;
   end;
   //## xneed123 ##
   procedure xneed123;
   begin
   if zznil(xstr1,2217) then xstr1:=bnew;
   if zznil(xstr2,2218) then xstr2:=bnew;
   if zznil(xstr3,2219) then xstr3:=bnew;
   end;
   //## xneed1234 ##
   procedure xneed1234;
   begin
   if zznil(xstr1,2220) then xstr1:=bnew;
   if zznil(xstr2,2221) then xstr2:=bnew;
   if zznil(xstr3,2222) then xstr3:=bnew;
   if zznil(xstr4,2223) then xstr4:=bnew;
   end;
   //## xneed123456 ##
   procedure xneed123456;
   begin
   if zznil(xstr1,2224) then xstr1:=bnew;
   if zznil(xstr2,2225) then xstr2:=bnew;
   if zznil(xstr3,2226) then xstr3:=bnew;
   if zznil(xstr4,2227) then xstr4:=bnew;
   if zznil(xstr5,2228) then xstr5:=bnew;
   if zznil(xstr6,2229) then xstr6:=bnew;
   end;
//04jun2020
   //## xlinebefore ##
   function xlinebefore(xpos:longint):longint;
   begin
   result:=low__wordcore_str2(x,'pos>line-1>pos',inttostr(xpos));
   end;
//
   //## xwrapadd ##
   procedure xwrapadd(xpos,xpos2:longint);
   begin
   try
   x.wrapstack.addint4(frcmin(xpos,0));
   x.wrapstack.addint4(frcmin(xpos2,0));
   except;end;
   end;
   //## xchanged ##
   procedure xchanged;
   begin
   try
   x.modified:=true;
   if (x.dataid<maxint) then inc(x.dataid) else x.dataid:=1;
   if (x.dataid2<maxint) then inc(x.dataid2) else x.dataid2:=1;//14jun2022
   x.mustpaint:=true;
   except;end;
   end;
   //## xmakefont2 ##
   function xmakefont2(xoverride:boolean;xLGFdata_optional:tstr8;xfontname:string;xfontsize,xcolor,xbk,xborder:longint;xbold,xitalic,xunderline,xstrikeout:boolean;xalign:byte):longint;
   label
      skipend;
   var
      e,xref:string;
      xnew,i,p:longint;
   begin
   try
   //defaults
   result:=0;
   xnew:=-1;
   block(xLGFdata_optional);
   //init
   if not xoverride then
      begin
      if zzok(xLGFdata_optional,7053) then xLGFdata_optional.clear;
      xfontname:=low__udv(x.cfontname,'$fontname');
      xfontsize:=frcrange(x.cfontsize,4,300);
      xbold:=x.cbold;
      xitalic:=x.citalic;
      xunderline:=x.cunderline;
      xstrikeout:=x.cstrikeout;
      xcolor:=x.ccolor;
      xbk:=x.cbk;
      //.filter
      xborder:=x.cborder;
      xalign:=x.calign;
      end;
   //range
   xfontname:=low__udv(xfontname,'$fontname');
   xfontname:=low__udv(x.onefontname,xfontname);//onefontname overrides ALL fontnames - 05feb2022
   xfontsize:=frcrange(xfontsize,4,300);
   case x.onefontsize of
   0:xfontsize:=frcrange(viFontsize,4,300);
   1:xfontsize:=frcrange(viFontsize2,4,300);
   2..maxint:xfontsize:=frcrange(x.onefontsize,4,300);
   end;
   //.color check
//02jun2020
   if (xcolor=clnone) then xcolor:=low__rgb(255,255,255);//was: xcolor=0, but when "color=0 and bk=clnone" then we ended up with black on black
//
   //find existing
   for p:=0 to high(x.txtname) do if (x.txtname[p]<>'') and (x.zoomnow=x.txtzoom[p]) and (xcolor=x.txtcolor[p]) and (xbk=x.txtbk[p]) and (xborder=x.txtborder[p]) and (xfontsize=x.txtsize[p]) and (xbold=x.txtbold[p]) and (xitalic=x.txtitalic[p]) and (xunderline=x.txtunderline[p]) and (xstrikeout=x.txtstrikeout[p]) and (xalign=x.txtalign[p]) and low__comparetext(xfontname,x.txtname[p]) then
      begin
      result:=p;
      goto skipend;
      end;//p
   //find free
   if (xnew<0) then for p:=0 to high(x.txtname) do if (x.txtname[p]='') then
      begin
      xnew:=p;
      break;
      end;//p
   //emergency limit -> we need to find items that are nolonger being pointed to and reuse them before just parking it here at the uppermost limit - 21aug2019
   if (xnew<0) then xnew:=high(x.txtname);
   //get
   result:=xnew;
   x.txtname[result]:=xfontname;
   x.txtsize[result]:=xfontsize;
   x.txtzoom[result]:=x.zoomnow;//reference only - 14mar2021
   x.txtbold[result]:=xbold;
   x.txtitalic[result]:=xitalic;
   x.txtunderline[result]:=xunderline;
   x.txtstrikeout[result]:=xstrikeout;
   x.txtcolor[result]:=xcolor;
   x.txtbk[result]:=xbk;
   x.txtborder[result]:=xborder;
   x.txtalign[result]:=xalign;//21sep2019
   x.txtid[result]:=0;//point to default for safety
   xref:=bnc(xbold)+bnc(xitalic)+bnc(xunderline)+bnc(xstrikeout)+'|'+inttostr(xfontsize*x.zoomnow)+'|'+xfontname;//14mar2021
   //.find existing lgf
   i:=-1;
   if (i<0) then for p:=0 to high(x.lgfnref) do if (x.lgfnref[p]<>'') and low__comparetext(xref,x.lgfnref[p]) then
      begin
      i:=p;
      break;
      end;//p
   //.create new lgf
   if (i<0) then for p:=0 to high(x.lgfnref) do if (x.lgfnref[p]='') then
      begin
      if (blen(xLGFdata_optional)>=1) then x.lgfdata[p].replace:=xLGFdata_optional
      else if (not x.dataonly) then
         begin
         if zznil(x.lgfdata[p],2230) then x.lgfdata[p]:=bnew;
         low__toLGF(xfontname,xfontsize*x.zoomnow,vifeatherf>=1,xbold,x.lgfdata[p],e);
         end
      else
         begin
         if (x.lgfdata[p]<>nil) then x.lgfdata[p].clear;//don't destroy ONCE object has been created for stability - 19dec2021, 21aug2020
         end;
      x.lgfnref[p]:=xref;
      i:=p;
      break;
      end;//p
   //.set id
   if (i>=0) then x.txtid[result]:=i;
   //changed
   xchanged;
   skipend:
   except;end;
   try;bunlockautofree(xLGFdata_optional);except;end;
   end;
   //## xmakefont ##
   function xmakefont:longint;
   begin
   try;result:=xmakefont2(false,nil,x.defFontname,x.defFontsize,x.defFontcolor,clnone,clnone,false,false,false,false,0);except;end;
   end;
   //## xappend ##
   function xappend(xout:tstr8;n:string;xval:tstr8):boolean;//fixed - 28jan2021
   label
      skipend;
   begin//n='' -> finalise output buffer "xout"
   try
   //defaults
   result:=false;
   block(xout);
   block(xval);
   //check
   if zznil(xout,2231) then goto skipend;
   //get
   if (n='') or zznil(xval,2232) then
      begin
      //nil - nothing to do
      end
   else
      begin
      //filter -> n is fixed at 4 characters
      if not xout.sadd(strcopy1(n+'    ',1,4)) then goto skipend;
      if not xout.addint4(xval.len) then goto skipend;
      //get
      if (xval.len>=1) and (not xout.add(xval)) then goto skipend;
      end;
   //successful
   result:=true;
   skipend:
   except;end;
   try
   bunlockautofree(xout);
   bunlockautofree(xval);
   except;end;
   end;
   //## xappendstr ##
   function xappendstr(xout:tstr8;n,v:string):boolean;
   begin
   try;result:=xappend(xout,n,bcopystrall(v));except;end;
   end;
   //## xappendint4 ##
   function xappendint4(xout:tstr8;n:string;v:longint):boolean;
   var
      a:tstr8;
   begin
   try;result:=false;a:=bnew_autofree;a.addint4(v);result:=xappend(xout,n,a);except;end;
   end;
   //## xpull ##
   function xpull(var xoutpos:longint;xout:tstr8;var n:string;v:tstr8):boolean;
   var
      xpos,int1:longint;
   begin//n='' -> finalise output buffer "xout"
   try
   //defaults
   result:=false;
   n:='';
   //check
   if zzok(v,7054) then v.clear else exit;
   if zznil(xout,2233) then exit;
   xpos:=xoutpos;
   //range
   if (xpos<1) then xpos:=1
   else if ((xpos+7)>xout.len) then exit;
   //get
   n:=bgetstr1(xout,xpos,4);
   int1:=xout.int4[xpos+4-1];//was: int1:=frcmin(to32bit(copy(xout,xpos+4,4)),0);

   //inc -> still incs even on error
   xoutpos:=xpos+8+int1;
   //set
   if (int1>=1) then v.add3(xout,xpos+8-1,int1);//was: v:=copy(xout,xpos+8,int1);
   //successful
   result:=true;
   except;end;
   end;
   //## xpullstr ##
   function xpullstr(var xoutpos:longint;xout:tstr8;var n,v:string):boolean;
   var
      a:tstr8;
   begin
   try
   //defaults
   result:=false;
   n:='';
   v:='';
   a:=nil;
   a:=bnew;
   //get
   result:=xpull(xoutpos,xout,n,a);
   if result then v:=a.text;
   except;end;
   try;bfree(a);except;end;
   end;
   //## xpullint4 ##
   function xpullint4(var xoutpos:longint;xout:tstr8;var n:string;v:longint):boolean;
   var
      a:tstr8;
   begin
   try
   //defaults
   result:=false;
   n:='';
   v:=0;
   a:=nil;
   a:=bnew;
   //get
   result:=xpull(xoutpos,xout,n,a);
   if result and (a.len>=4) then v:=a.int4[0];
   except;end;
   try;bfree(a);except;end;
   end;
   //## xnoidle ##
   procedure xnoidle;
   begin
   x.idleref:=ms64+x.c_idlepause;
   end;
   //## knoidle ##
   procedure knoidle;
   begin
   x.k_idleref:=ms64+x.c_idlepause;
   end;
   //## xmincheck2 ##
   procedure xmincheck2(d1,d2,d3:tstr8);
   var
      i:longint;
   begin
   try
   //check
   if (d1=nil) or (d2=nil) or (d3=nil) then exit;
   //get
   if (blen(d1)<=0) or (d1.byt1[d1.len-1]<>10) then
      begin
      i:=blen(d1);
      d1.addbyt1(10);//was: x.data:=x.data+#10;
      if (i>=1) then//carry on font/style index from last character
         begin
         d2.addbyt1(x.data2.byt1[i-1]);
         d3.addbyt1(x.data3.byt1[i-1]);
         end
      else
         begin//completely empty -> font/style from default "index=0"
         d2.addbyt1(0);
         d3.addbyt1(0);
         end;
      //check
      if (d1=x.data) and (not x.dataonly) then
         begin
         x.wrapstack.addint4(i);
         x.wrapstack.addint4(i);//same as "xwrapadd('start',i,i);"
         xchanged;
         end;
      end;
   except;end;
   end;
   //## xmincheck ##
   procedure xmincheck;
   begin
   xmincheck2(x.data,x.data2,x.data3);
   end;
//04jun2020
   //## cread ##
   procedure cread;
   var
      xpos:longint;
      xchar:twordcharinfo;
   begin
   try
   //check
   xpos:=frcmin(x.cursorpos-1,0);
   if not low__wordcore__charinfo(x,xpos,xchar) then exit;
   //get
   x.cfontname    :=x.txtname[xchar.wid];
   x.cfontsize    :=x.txtsize[xchar.wid];
   x.cbold        :=x.txtbold[xchar.wid];
   x.citalic      :=x.txtitalic[xchar.wid];
   x.cunderline   :=x.txtunderline[xchar.wid];
   x.cstrikeout   :=x.txtstrikeout[xchar.wid];
   x.ccolor       :=x.txtcolor[xchar.wid];
   x.cbk          :=x.txtbk[xchar.wid];
   x.cborder      :=x.txtborder[xchar.wid];
   x.calign       :=low__wordcore_str2(x,'findalign',inttostr(xpos));
   except;end;
   end;
//
//04jun2020
//
   //## cwritesel ##
   procedure cwritesel(xstyle:string);
   var
      int1,p,xlastwid,xselstart,xselcount:longint;
      wrd2:twrd2;
      xmustchange,xtxt,ximg:boolean;
   begin
   try
   //init
   xmustchange:=false;
   xselstart:=low__wordcore2(x,'selstart',nil);
   xselcount:=low__wordcore2(x,'selcount',nil);
   xstyle:=low__lowercase(xstyle);
   //check
   if (xselcount<=0) then exit;
   //get
   xlastwid:=-1;//not set
   wrd2.val:=maxword;//not set
//04jun2020
   for p:=xselstart to (xselstart+xselcount-1) do
   begin
   if not low__wordcore__charinfo(x,p,xchar) then break;
   xtxt:=(xchar.cs=wc_t);
   ximg:=(xchar.cs=wc_i);
   if (xtxt or ximg) then
      begin
      //data changers - 19dec2021
      if xtxt then
         begin
         if (xstyle='uppercase')  then//19dec2021
            begin
            int1:=x.data.byt1[p-1];
            if (int1>=97) and (int1<=122) then
               begin
               x.data.byt1[p-1]:=int1-32;
               xmustchange:=true;
               end;
            end
         else if (xstyle='lowercase')  then//19dec2021
            begin
            int1:=x.data.byt1[p-1];
            if (int1>=65) and (int1<=90) then
               begin
               x.data.byt1[p-1]:=int1+32;
               xmustchange:=true;
               end;
            end;
         end;
      //get
      if (xchar.wid<>xlastwid) then
         begin
         //store current "wid"
         xlastwid:=xchar.wid;
         wrd2.val:=xchar.wid;
         //merge new font+style
         if xtxt then
            begin
            if      (xstyle='name')       then wrd2.val:=xmakefont2(true,nil,x.cfontname,x.txtsize[xchar.wid],x.txtcolor[xchar.wid],x.txtbk[xchar.wid],x.txtborder[xchar.wid],x.txtbold[xchar.wid],x.txtitalic[xchar.wid],x.txtunderline[xchar.wid],x.txtstrikeout[xchar.wid],x.txtalign[xchar.wid])
            else if (xstyle='size')       then wrd2.val:=xmakefont2(true,nil,x.txtname[xchar.wid],x.cfontsize,x.txtcolor[xchar.wid],x.txtbk[xchar.wid],x.txtborder[xchar.wid],x.txtbold[xchar.wid],x.txtitalic[xchar.wid],x.txtunderline[xchar.wid],x.txtstrikeout[xchar.wid],x.txtalign[xchar.wid])
            else if (xstyle='bold')       then wrd2.val:=xmakefont2(true,nil,x.txtname[xchar.wid],x.txtsize[xchar.wid],x.txtcolor[xchar.wid],x.txtbk[xchar.wid],x.txtborder[xchar.wid],x.cbold,x.txtitalic[xchar.wid],x.txtunderline[xchar.wid],x.txtstrikeout[xchar.wid],x.txtalign[xchar.wid])
            else if (xstyle='italic')     then wrd2.val:=xmakefont2(true,nil,x.txtname[xchar.wid],x.txtsize[xchar.wid],x.txtcolor[xchar.wid],x.txtbk[xchar.wid],x.txtborder[xchar.wid],x.txtbold[xchar.wid],x.citalic,x.txtunderline[xchar.wid],x.txtstrikeout[xchar.wid],x.txtalign[xchar.wid])
            else if (xstyle='underline')  then wrd2.val:=xmakefont2(true,nil,x.txtname[xchar.wid],x.txtsize[xchar.wid],x.txtcolor[xchar.wid],x.txtbk[xchar.wid],x.txtborder[xchar.wid],x.txtbold[xchar.wid],x.txtitalic[xchar.wid],x.cunderline,x.txtstrikeout[xchar.wid],x.txtalign[xchar.wid])
            else if (xstyle='strikeout')  then wrd2.val:=xmakefont2(true,nil,x.txtname[xchar.wid],x.txtsize[xchar.wid],x.txtcolor[xchar.wid],x.txtbk[xchar.wid],x.txtborder[xchar.wid],x.txtbold[xchar.wid],x.txtitalic[xchar.wid],x.txtunderline[xchar.wid],x.cstrikeout,x.txtalign[xchar.wid])
            else if (xstyle='color')      then wrd2.val:=xmakefont2(true,nil,x.txtname[xchar.wid],x.txtsize[xchar.wid],x.ccolor,x.txtbk[xchar.wid],x.txtborder[xchar.wid],x.txtbold[xchar.wid],x.txtitalic[xchar.wid],x.txtunderline[xchar.wid],x.txtstrikeout[xchar.wid],x.txtalign[xchar.wid])
            else if (xstyle='bk')         then wrd2.val:=xmakefont2(true,nil,x.txtname[xchar.wid],x.txtsize[xchar.wid],x.txtcolor[xchar.wid],x.cbk,x.txtborder[xchar.wid],x.txtbold[xchar.wid],x.txtitalic[xchar.wid],x.txtunderline[xchar.wid],x.txtstrikeout[xchar.wid],x.txtalign[xchar.wid])
            else if (xstyle='color+bk')   then wrd2.val:=xmakefont2(true,nil,x.txtname[xchar.wid],x.txtsize[xchar.wid],x.ccolor,x.cbk,x.txtborder[xchar.wid],x.txtbold[xchar.wid],x.txtitalic[xchar.wid],x.txtunderline[xchar.wid],x.txtstrikeout[xchar.wid],x.txtalign[xchar.wid])
            else if (xstyle='color+bk+style') then wrd2.val:=xmakefont2(true,nil,x.txtname[xchar.wid],x.txtsize[xchar.wid],x.ccolor,x.cbk,x.cborder,x.cbold,x.citalic,x.cunderline,x.cstrikeout,x.txtalign[xchar.wid])
            else if (xstyle='border')     then wrd2.val:=xmakefont2(true,nil,x.txtname[xchar.wid],x.txtsize[xchar.wid],x.txtcolor[xchar.wid],x.txtbk[xchar.wid],x.cborder,x.txtbold[xchar.wid],x.txtitalic[xchar.wid],x.txtunderline[xchar.wid],x.txtstrikeout[xchar.wid],x.txtalign[xchar.wid])
            else if (xstyle='uppercase') or (xstyle='lowercase') then
               begin
               //nil
               end
            else break;//unknown style -> quit
            end;//txt
         end;
      //set
      if xtxt and (xchar.wid<>wrd2.val) then
         begin
         x.data2.byt1[p-1]:=wrd2.bytes[0];
         x.data3.byt1[p-1]:=wrd2.bytes[1];
         xmustchange:=true;
         end;
      end;
   end;//p
//
   except;end;
   try
   if xmustchange then
      begin
      xwrapadd(xlinebefore(xselstart),xselstart+x.c_bigwrap);//need to wrap ATLEAST current page, else flicker may occur due to multiple paint attempts - 07dec2019
      x.timer_chklinecursorx:=true;
      xchanged;
      end;
   except;end;
   end;
   //## cwriteall ##
   procedure cwriteall(xstyle:string);//28aug2021, 05jun2020
   var
      p,xlastwid,xselstart,xselcount:longint;
      wrd2:twrd2;
      xclaudefontFORCE,xclaudefontONLYIFNOT,xmustchange,xtxt,ximg:boolean;
   begin
   try
   //init
   xmustchange:=false;
   xstyle:=low__lowercase(xstyle);
   //.onlyifnot
   xclaudefontONLYIFNOT:=(strcopy1(xstyle,1,9)='~$claude.');//Example: "$claude.text1" will convert fontnames THAT ARE not currently "$claude.*" into the specified "$claude.???" fontname - 28aug2021
   if xclaudefontONLYIFNOT then xstyle:=strcopy1(xstyle,2,length(xstyle));//strip leading "~" away - 28aug2021
   //.force
   xclaudefontFORCE:=(strcopy1(xstyle,1,8)='$claude.');//Example: "$claude.text1" will convert fontnames THAT ARE not currently "$claude.*" into the specified "$claude.???" fontname - 28aug2021

   //check
   //was: if (xselcount<=0) then exit;
   //get
   xlastwid:=-1;//not set
   wrd2.val:=maxword;//not set
//04jun2020
   for p:=1 to blen(x.data) do
   begin
   if not low__wordcore__charinfo(x,p,xchar) then break;
   xtxt:=(xchar.cs=wc_t);
   ximg:=(xchar.cs=wc_i);
   //.text only
   if xtxt then//08jun2020
      begin
      //get
      if (xchar.wid<>xlastwid) then
         begin
         //store current "wid"
         xlastwid:=xchar.wid;
         wrd2.val:=xchar.wid;
         //merge new font+style
         if xtxt then
            begin
            //.basc translators
            if (xstyle='arial')              then wrd2.val:=xmakefont2(true,nil,'arial',x.txtsize[xchar.wid],x.txtcolor[xchar.wid],x.txtbk[xchar.wid],x.txtborder[xchar.wid],x.txtbold[xchar.wid],x.txtitalic[xchar.wid],x.txtunderline[xchar.wid],x.txtstrikeout[xchar.wid],x.txtalign[xchar.wid])
            else if (xstyle='courier')       then wrd2.val:=xmakefont2(true,nil,'courier new',x.txtsize[xchar.wid],x.txtcolor[xchar.wid],x.txtbk[xchar.wid],x.txtborder[xchar.wid],x.txtbold[xchar.wid],x.txtitalic[xchar.wid],x.txtunderline[xchar.wid],x.txtstrikeout[xchar.wid],x.txtalign[xchar.wid])
            else if (xstyle='-')             then wrd2.val:=xmakefont2(true,nil,x.txtname[xchar.wid],frcmin(x.txtsize[xchar.wid]-1,6),x.txtcolor[xchar.wid],x.txtbk[xchar.wid],x.txtborder[xchar.wid],x.txtbold[xchar.wid],x.txtitalic[xchar.wid],x.txtunderline[xchar.wid],x.txtstrikeout[xchar.wid],x.txtalign[xchar.wid])
            else if (xstyle='+')             then wrd2.val:=xmakefont2(true,nil,x.txtname[xchar.wid],frcmax(x.txtsize[xchar.wid]+1,48),x.txtcolor[xchar.wid],x.txtbk[xchar.wid],x.txtborder[xchar.wid],x.txtbold[xchar.wid],x.txtitalic[xchar.wid],x.txtunderline[xchar.wid],x.txtstrikeout[xchar.wid],x.txtalign[xchar.wid])
            //.special CLAUDE font translators - 28aug2021
            else if xclaudefontONLYIFNOT     then
               begin
               if not low__comparetext(strcopy1(x.txtname[xchar.wid],1,8),'$claude.') then wrd2.val:=xmakefont2(true,nil,xstyle,x.txtsize[xchar.wid],x.txtcolor[xchar.wid],x.txtbk[xchar.wid],x.txtborder[xchar.wid],x.txtbold[xchar.wid],x.txtitalic[xchar.wid],x.txtunderline[xchar.wid],x.txtstrikeout[xchar.wid],x.txtalign[xchar.wid]);//translate non-Claude fontnames into Claude font name - 28aug2021
               end
            else if xclaudefontFORCE         then wrd2.val:=xmakefont2(true,nil,xstyle,x.txtsize[xchar.wid],x.txtcolor[xchar.wid],x.txtbk[xchar.wid],x.txtborder[xchar.wid],x.txtbold[xchar.wid],x.txtitalic[xchar.wid],x.txtunderline[xchar.wid],x.txtstrikeout[xchar.wid],x.txtalign[xchar.wid])//force Claude fontname - 28aug2021
            //.unknown style
            else break;//unknown style -> quit
            end;
         end;
      //set
      if (xchar.wid<>wrd2.val) then
         begin
         x.data2.byt1[p-1]:=wrd2.bytes[0];
         x.data3.byt1[p-1]:=wrd2.bytes[1];
         xmustchange:=true;
         end;
      end;
   end;//p
//
   except;end;
   try
   if xmustchange then
      begin
      low__wordcore(x,'wrapall',nil);
      x.timer_chklinecursorx:=true;
      xchanged;
      end;
   except;end;
   end;
   //## xsetcursorpos2 ##
   procedure xsetcursorpos2(xpos:longint;xshift:boolean);
   var
      int1:longint;
   begin
   try
   xpos:=frcrange(xpos,1,blen(x.data));
   if (x.cursorpos<>xpos) or (x.cursorpos2<>xpos) then
      begin
      x.cursorpos:=xpos;
      if not xshift then x.cursorpos2:=xpos;
      x.timer_chklinecursorx:=true;//update cursor x pos -> used for key up an down on same column between lines - 31mar2021
      int1:=xpos+x.c_pagewrap;
      if (int1>x.wrapcount) then
         begin
         x.wrapstack.addint4(x.wrapcount);
         x.wrapstack.addint4(int1);//same as "xwrapadd('auto',*,xpos+page);"
         end;
      inc(x.vcheck);//make system check to see if the contents needs to scroll up or down based on the text cursor - 25jul2021
      x.mustpaint:=true;
      end;
   cread;
   except;end;
   end;
   //## xsetcursorpos ##
   procedure xsetcursorpos(xpos:longint);
   begin
   try;xsetcursorpos2(xpos,false);except;end;
   end;
   //## xatleast ##
   procedure xatleast(xstyle:string;xnewsize:longint);
   var
      p,olen,nlen:longint;
   begin
   try
   //range
   xnewsize:=frcmin(xnewsize,1);
   nlen:=xnewsize*4;
   //line
   if (xstyle='line') then
      begin
      olen:=blen(x.coreliney);
      if (nlen<>olen) then
         begin
         if (nlen<olen) then x.linesize:=xnewsize;//shrink -> update right now
         bsetlen(x.corelinex,nlen);
         bsetlen(x.coreliney,nlen);
         bsetlen(x.corelineh,nlen);
         bsetlen(x.corelineh1,nlen);
         bsetlen(x.corelinep,nlen);
         if (nlen>=olen) then x.linesize:=xnewsize;//enlarge -> update now -> streams at size
         x.linex:=x.corelinex.core;
         x.liney:=x.coreliney.core;
         x.lineh:=x.corelineh.core;
         x.lineh1:=x.corelineh1.core;
         x.linep:=x.corelinep.core;
         //cls new data
         if (nlen>olen) then
            begin
            for p:=(olen+1) to nlen do x.corelinex.byt1[p-1]:=0;
            for p:=(olen+1) to nlen do x.coreliney.byt1[p-1]:=0;
            for p:=(olen+1) to nlen do x.corelineh.byt1[p-1]:=0;
            for p:=(olen+1) to nlen do x.corelineh1.byt1[p-1]:=0;
            for p:=(olen+1) to nlen do x.corelinep.byt1[p-1]:=0;
            end;
         end;
      end//line
   else
      begin
      showerror('Wordcore: Unknown atleast style "'+xstyle+'"');
      end;
   except;end;
   end;
   //## xstackpull ##
   function xstackpull(xstack,xval:tstr8):boolean;
   var//supports variable size entry lengths
      xlen:longint;
   begin
   try
   //defaults
   result:=false;
   if zznil(xstack,2235) then exit;
   //init
   if zzok(xval,7055) then xval.clear;
   //get
   if (blen(xstack)>=4) then
      begin
      xlen:=frcmin(xstack.int4[0],0);//0..3
      if (xlen>=1) and (xval<>nil) then xval.add3(xstack,4,xlen);
      bdel1(xstack,1,4+xlen);
      result:=true;
      end;
   except;end;
   end;
   //## xwrappull ##
   function xwrappull(var xpos,xpos2:longint):boolean;
   begin
   try
   //defaults
   result:=false;
   xpos:=-1;
   xpos2:=-1;
   //get
   if (blen(x.wrapstack)>=8) then
      begin
      xpos :=x.wrapstack.int4[0];//0..3
      xpos2:=x.wrapstack.int4[4];//4..7
      bdel1(x.wrapstack,1,8);
      result:=true;
      end;
   except;end;
   end;
//04jun2020
   //## xpagewidth ##
   function xpagewidth:longint;
   begin
   case x.wrapstyle of
   wwsNone   :result:=frcmin(x.widestline+3,x.viewwidth);//Note: +3px is a patch -> required to display last part of trailing char on line AND the 2px cursor - 27mar2021
   wwsWindow :result:=x.viewwidth;
   wwsPage   :result:=xmmTOpixels(x.paperwidth);//converts "paperwidth" which is in millimetres into pixels (e.g. for the screenat default dpi of 95) - 12mar2021
   else       result:=x.viewwidth;
   end;//case
   x.pagewidth:=frcmin(result,0);
   end;
   //## xwrap_hvsync_changed ##
   procedure xwrap_hvsync_changed;
   begin
   xwrapadd(0,x.cursorpos+x.c_pagewrap);
   x.hhostsync:=true;
   x.vhostsync:=true;
   xchanged;
   end;
   //## xwrapnow ##
   procedure xwrapnow(xmin,xmax,xlinecount:longint);
//xxxxxxxxxxxxxxxxxxxxxxxxxxxx Needs to break the wrap on a SPACE or TAB if following word/characters exceed page width - 02aug2019
   label
      redo;
   const
      xlineblock=5000;//22apr2022
   var
      a:twordcharinfo;
      awid,awid2,xwidestline,xwrapstyle,xlastalign,xdif,odx,olh1,olh2,lp,int1,sh2,p,ddx,dx,pw,ph,lc,lh1,lh2,lx,ly,xlen:longint;
      lac:byte;
      xwrapNone:boolean;//14mar2021
      //## xmustbreak ##
      function xmustbreak(var xdif:longint):boolean;
      var
         a:twordcharinfo;
         ddx,i:longint;
      begin
      //defaults
      result:=false;
      xdif:=0;
      //get
      ddx:=dx;
      for i:=p to xmax do
      begin
      low__wordcore__charinfo(x,i,a);
      if (a.c=10) or (a.c=9) or (a.c=32) then break
      else if ((ddx+a.width)>=pw) then//and (a.c<>10) then
         begin
         result:=true;
         break;
         end;
      inc(ddx,a.width);
      end;//p
      xdif:=ddx-dx;
      end;
      //## xalign_lx ##
      function xalign_lx(xfrompos:longint):longint;
      var
         xalign:longint;
      begin
      //defaults
      result:=0;

      //get
      if (xfrompos>=x.lastfindalignpos) then
         begin
         //was: xalign:=low__wordcore_str2(x,'findalign',inttostr(xfrompos));
         xalign:=low__wordcore__findalignFAST(x,xfrompos);//100% -> 50% time (2x faster) - 22apr2022
         xlastalign:=xalign;
         end
      else xalign:=xlastalign;
      //set -> Important Note: can't use align.CENTER or align.RIGHT with "wrap=wwsNone" as there is no permanent right handside boundary to work with - 14mar2021
      if not xwrapNone then
         begin
         if      (xalign=wcaCenter) then result:=((pw-lx-a.width) div 2)
         else if (xalign=wcaRight)  then result:=pw-lx-a.width;
         end;
{//was:
      if      (xalign=x.c_aligncentre) then result:=((pw-lx) div 2)
      else if (xalign=x.c_alignright)  then result:=pw-lx;
{}
      //filter
      result:=frcmin(result,0);
      end;
   begin
   try
   //defaults
   xmincheck;
   xlen:=blen(x.data);
   //check
   if (xlen<1) then exit;
   //range
   awid:=-1;
   awid2:=-1;//12jun2022
   xmin:=frcrange(xmin,1,xlen);
   xmax:=frcrange(xmax,xmin,xlen);
   xwrapstyle:=x.wrapstyle;
   xwidestline:=x.widestline;
   //init
   case xwrapstyle of
   wwsNone   :pw:=maxint-1000;//allow some math space
   wwsWindow :pw:=frcmin(x.viewwidth-3,0);//noticed the letter "r" on a Reminder paste prompt was beneath scrollbar border by 1-2px - 09mar2022
   wwsPage   :pw:=frcmin(xmmtopixels(x.paperwidth)-3,0);//09mar2022, 17mar2021
   else       pw:=frcmin(x.viewwidth-3,0);
   end;//case
   xwrapNone:=(xwrapstyle=wwsNone);//if "true" then disable align.modes, e.g. CENTER and RIGHT become offline - 14mar2021
   pw:=frcmin(pw,1);
   ph:=frcmin(x.pageheight,1);
   x.lastfindalignpos:=-1;//used to speed up "xalign_lx()" for very long lines of text - 11oct2020
   xlastalign:=0;
   dx:=0;
   lc:=0;
   lh1:=0;
   lh2:=0;
   lx:=0;
   ly:=0;
   //start at the nearest "completed" line - 25aug2019
   if (xmin>=2) then
      begin
      //init
      int1:=xmin;
      xmin:=1;
      //find -> Important Note: NEVER include the very last line -> it always ends with a #10 -> this can cause return codes to be detected when none are present - 23aug2019
      if (x.linecount>=2) and (x.linesize>=1) then for p:=0 to frcmax(x.linecount-2,x.linesize-1) do
         begin
         if (x.linep[p]<=int1) then
            begin
            //treat as beginning of new line -> set all vars accorddingly - 23aug2019
            lc:=p;
            xmin:=x.linep[p];//1st item on the line
            ly:=x.liney[p];//required
            lx:=0;//not required yet -> alignment not finalised yet -> done last
            dx:=0;
            end
         else break;

         //.fasttimer - xcheck - 07jul2021
         inc(sysfasttimer_xcount); if (sysfasttimer_xcount>=sysfasttimer_xtrigger) then fasttimer_xcheck;
         end;//p
      end;
   //get
   if (lc>=x.linesize) then xatleast('line',lc+xlineblock);
   lp:=xmin;
   lac:=0;//was: #0
   p:=xmin;

   //for p:=xmin to xmax do
   //begin
redo:
   //init
   //was:
   //low__wordcore__charinfo(x,p,a);//very slow -> taking 6s for 6Mb, BUT ultra does it in 1s (6x faster!!!) - 22apr2022
   low__wordcore__charinfoULTRA(x,p,a,awid,awid2);
   sh2:=a.height-a.height1;
   if (sh2<0) then sh2:=0;
   //.store line   [never break on #10] [line must have 1+ chars]
   xdif:=0;
   bol1:=((dx+a.width)>=pw) and (p>lp) and (a.c<>10) and (a.c<>32);//deny auto-wrap on #10 and #32
   if (not bol1) and (p>lp) and ((lac=9) or (lac=32)) and xmustbreak(xdif) then bol1:=true;//break line on a tab(9) or space(32) if remaining text exceeds pagewidth

   if bol1 then
      begin
      //init
      lx:=frcmin(dx-a.width,0);//xxxxxxxxxxxxxxxxxxxfrcmin(dx-xdif,0);
      x.linex[lc]:=xalign_lx(p);//need to workout alignment inorder to set "lx"
      x.liney[lc]:=ly;//top of line
      x.lineh[lc]:=lh1+lh2;//overheight of line
      x.lineh1[lc]:=lh1;//distance from top of line to the base line of line
      x.linep[lc]:=lp;//first item in line
      //inc
      lp:=p;
//yyyyy//was:      if bol1 then lp:=p else lp:=p+1;
      inc(lc);
      if (lc>=x.linesize) then xatleast('line',lc+xlineblock);
      //reset
      inc(ly,lh1+lh2);
      lx:=0;
      lh1:=0;
      lh2:=0;
      dx:=0;
      xdif:=0;
      end;
   //.item
   inc(dx,a.width);
   if (xwrapstyle=wwsNone) and (dx>xwidestline) then xwidestline:=dx;//12mar2021

   //.lh1 + lh2
   if (a.height1>lh1) then lh1:=a.height1;
   if (sh2>lh2) then lh2:=sh2;

   //.store line   [never break on #10] [line must have 1+ chars]
   if (not bol1) and ((a.c=10) or (p=xmax)) then
      begin
      //init
      lx:=frcmin(dx-xdif,0);
      x.linex[lc]:=xalign_lx(p);//need to workout alignment inorder to set "lx"
      x.liney[lc]:=ly;//top of line
      x.lineh[lc]:=lh1+lh2;//overheight of line
      x.lineh1[lc]:=lh1;//distance from top of line to the base line of line
      x.linep[lc]:=lp;//first item in line
      //inc
      lp:=p+1;
      inc(lc);
      if (lc>=x.linesize) then xatleast('line',lc+xlineblock);
      //reset
      inc(ly,lh1+lh2);
      lx:=0;
      lh1:=0;
      lh2:=0;
      dx:=0;
      xdif:=0;
      end;
   //.store progress
   lac:=a.c;
   x.wrapcount:=p;
   x.linecount:=lc;
   x.totalheight:=ly;
   //.fasttimer - xcheck - 07jul2021
   inc(sysfasttimer_xcount); if (sysfasttimer_xcount>=sysfasttimer_xtrigger) then fasttimer_xcheck;
   //inc
   inc(p);
   if (p<=xlen) and ( (p<=xmax) or ((xlinecount>=1) and (x.linecount<xlinecount)) ) then goto redo;
   //30aug2019
   x.vhostsync:=true;
   if (xwrapstyle=wwsNone) and (xwidestline>x.widestline) then
      begin
      x.widestline:=xwidestline;
      xpagewidth;
      x.hhostsync:=true;
      end;
   except;end;
   end;
//
   //## xsafe ##
   function xsafe(xindex:longint):longint;
   begin
   result:=xindex;
   if (result<0) then result:=0 else if (result>high(x.txtname)) then result:=high(x.txtname);
   end;
   //## xstyle ##
   function xstyle(x:byte):byte;//21aug2020
   begin
   case x of
   9,10,32..255:result:=wc_t;//text
   0:result:=wc_i;//image
   else result:=wc_n;//nil -> unknown
   end;//case
   end;
   //## xsel1 ##
   function xsel1:longint;
   begin
   result:=x.cursorpos;if (x.cursorpos2<result) then result:=x.cursorpos2;
   end;
   //## xsel2 ##
   function xsel2:longint;
   begin
   result:=x.cursorpos2;if (x.cursorpos>result) then result:=x.cursorpos;
   end;
   //## xselstart ##
   function xselstart:longint;
   begin
   result:=frcrange(xsel1,1,blen(x.data));
   end;
   //## xselcount ##
   function xselcount:longint;
   begin
   result:=frcrange(xsel2-xsel1,0,blen(x.data));
   end;
   //## xdelsel2 ##
   procedure xdelsel2(xmoveto:boolean);
   var
      int1,int2:longint;
   begin
   try
   //init
   int1:=xselstart;
   int2:=xselcount;
   //check
   if (int2<1) then exit;
   //get
   bdel1(x.data ,int1,int2);
   bdel1(x.data2,int1,int2);
   bdel1(x.data3,int1,int2);
   xmincheck;
   xsetcursorpos(int1);
   xwrapadd(xlinebefore(int1),int1+x.c_pagewrap);//04jun2020
   if xmoveto then x.cursor_keyboard_moveto:=int1;
   x.timer_chklinecursorx:=true;
   xchanged;
   except;end;
   end;
   //## xdelsel ##
   procedure xdelsel;
   begin
   try;xdelsel2(true);except;end;
   end;
   //## xmakeimage2 ##
   function xmakeimage2(ximgdata:tstr8):longint;
   label
      skipend;
   var
      xformat,e:string;
      dw,dh,xnew,p:longint;
   begin
   try
   //defaults
   result:=0;
   xnew:=-1;
   block(ximgdata);
   //find existing
   for p:=0 to high(x.txtname) do if (blen(x.imgdata[p])>=1) and x.imgdata[p].same(ximgdata) then
      begin
      result:=p;
      goto skipend;
      end;//p
   //find free
   if (xnew<0) then for p:=0 to high(x.txtname) do if (blen(x.imgdata[p])<=0) then
      begin
      xnew:=p;
      break;
      end;//p
   //emergency limit -> we need to find items that are nolonger being pointed to and reuse them before just parking it here at the uppermost limit - 21aug2019
   if (xnew<0) then xnew:=high(x.txtname);
   //get
   result:=xnew;
   if zznil(x.imgdata[result],2237) then x.imgdata[result]:=bnew;
   //check
   if (x.maxformatlevel>=2) then x.imgdata[result].replace:=ximgdata else x.imgdata[result].replace:=nil;//#1 - store
   x.imgtrans[result]:=false;
   x.imgw[result]:=1;
   x.imgh[result]:=1;
   //.convert to "img24.tbasicimage"
   dw:=1;
   dh:=1;
   if zznil(x.img24[result],2238) then x.img24[result]:=misimg24(1,1);
   //.get
   case (x.maxformatlevel>=2) and misfromdata(x.img24[result],x.imgdata[result],e) of
   true:begin
      dw:=misw(x.img24[result]);
      dh:=mish(x.img24[result]);
      x.imgtrans[result]:=x.img24[result].ai.transparent;//27dec2021
      end;
   false:begin;
      dw:=1;
      dh:=1;
      missize(x.img24[result],1,1);//once created DON'T destroy, but instead shrink for maximum stability - 21aug2020
      end;
   end;//case
   //sync width & height
   x.imgw[result]:=frcmin(dw,1);
   x.imgh[result]:=frcmin(dh,1);
   //changed
   xchanged;
   skipend:
   except;end;
   try;bunlockautofree(ximgdata);except;end;//28jan2021
   end;
   //## xcanpaste ##
   function xcanpaste:boolean;
   begin
   try;result:=clipboard.hasformat(cf_text) or clipboard.hasformat(cf_bitmap);except;end;
   end;
   //## xpaste ##
   function xpaste(xreplace:boolean):boolean;
   label
      skipend;
   var
      a:tbmp;
      xformat,e:string;
      adata,adata2:tstr8;
      c1,c2,v1,v2:longint;
      xbase64:boolean;
      //## creplace ##
      procedure creplace;
      begin
      if xreplace then low__wordcore_str(x,'clear2','');
      end;
   begin
   try
   //defaults
   result:=false;
   a:=nil;
   adata:=nil;
   adata2:=nil;
   c1:=x.cursorpos;
   c2:=x.cursorpos2;
   //.bwp
   if clipboard.hasformat(cf_bwp) then
      begin
      adata:=bnew;
      if low__pasteformat(cf_bwp,adata) then
         begin
         //.ins
         creplace;
         case misformat(adata,xformat,xbase64) of
         true:low__wordcore(x,'insimg',adata);//text is an image
         false:low__wordcore(x,'ioins',adata);//text is text
         end;
         //successful
         result:=true;
         goto skipend;
         end;
      end;
   //.text
   if clipboard.hasformat(cf_text) then
      begin
      adata:=bnew;
      if low__pasteformat(cf_text,adata) then
         begin
         //.ins
         creplace;
         case misformat(adata,xformat,xbase64) of
         true:low__wordcore(x,'insimg',adata);//text is an image
         false:low__wordcore(x,'ioins',adata);//text is text
         end;
         //successful
         result:=true;
         goto skipend;
         end;
      end;
   //.image
   if clipboard.hasformat(cf_bitmap) then
      begin
      a:=misbmp32(1,1);
      (a as tbmp).assign(clipboard);//21dec2021, was fixed via "xinfo" - 18jun2021
      adata:=bnew;
      adata2:=bnew;
      //.jif
      mistodata(a,adata,'jif',e);//bmp -> jif
      v1:=adata.len;if (v1<=0) then v1:=maxint;
      //.png
      mistodata(a,adata2,'png',e);
      v2:=adata2.len;if (v2<=0) then v2:=maxint;
      //.ins
      creplace;
      if (v1<v2) then low__wordcore(x,'insimg',adata) else low__wordcore(x,'insimg',adata2);
      //successful
      result:=true;
      goto skipend;
      end;
   skipend:
   except;end;
   try
   //.restore cursor
   if not result then
      begin
      x.cursorpos:=c1;
      x.cursorpos2:=c2;
      end;
   freeobj(@a);
   bfree(adata);
   bfree(adata2);
   except;end;
   end;
   //## xapplyzoom ##
   procedure xapplyzoom;
   var
      xlastwid,p:longint;
      wrd2:twrd2;
      xtxt,ximg,xmustchange:boolean;
   begin
   try
   //init
   xmustchange:=false;
   xlastwid:=-1;//not set
   wrd2.val:=maxword;//not set
   //get
   for p:=1 to blen(x.data) do
   begin
   if not low__wordcore__charinfo(x,p,xchar) then break;
   xtxt:=(xchar.cs=wc_t);
   ximg:=(xchar.cs=wc_i);
   //.text only
   if xtxt then//14mar2021
      begin
      //get
      if (xchar.wid<>xlastwid) then
         begin
         //store current "wid"
         xlastwid:=xchar.wid;
         wrd2.val:=xmakefont2(true,nil,x.txtname[xchar.wid],x.txtsize[xchar.wid],x.txtcolor[xchar.wid],x.txtbk[xchar.wid],x.txtborder[xchar.wid],x.txtbold[xchar.wid],x.txtitalic[xchar.wid],x.txtunderline[xchar.wid],x.txtstrikeout[xchar.wid],x.txtalign[xchar.wid]);
         end;
      //set
      if (xchar.wid<>wrd2.val) then
         begin
         x.data2.byt1[p-1]:=wrd2.bytes[0];
         x.data3.byt1[p-1]:=wrd2.bytes[1];
         xmustchange:=true;
         end;
      end;
   end;//p
   except;end;
   try
   if xmustchange then
      begin
      low__wordcore(x,'wrapall',nil);
      x.timer_chklinecursorx:=true;
      xchanged;
      end;
   except;end;
   end;
   //## xcursorword_loose ##
   function xcursorword_loose:string;//boundaries are "<=32", was: "spaces, tabs and return codes only" - 19jun2022
   var
      p,s,slen:longint;
      xchar:twordcharinfo;
   begin
   try
   //defaults
   result:='';
   s:=0;
   slen:=0;
   //find start point
   for p:=x.cursorpos downto 1 do
   begin
   if not low__wordcore__charinfo(x,p,xchar) then break
//was:   else if (xchar.cs<>wc_t) or ((xchar.c=ss10) or (xchar.c=ss9) or (xchar.c=ssSpace)) then break
   else if (xchar.cs<>wc_t) or (xchar.c<=ssSpace) then break
   else s:=p;
   end;//p
   //find length
   if (s>=1) then
      begin
      for p:=s to x.data.len do
      begin
      if not low__wordcore__charinfo(x,p,xchar) then break
      //was: else if (xchar.cs<>wc_t) or ((xchar.c=ss10) or (xchar.c=ss9) or (xchar.c=ssSpace)) then break
      else if (xchar.cs<>wc_t) or (xchar.c<=ssSpace) then break
      else slen:=p-s+1;
      end;//p
      end;
   //get
   if (s>=1) and (slen>=1) then result:=x.data.str1[s,slen];
   except;end;
   end;
   //## xmouseup_specialactions ##
   procedure xmouseup_specialactions;
   var
      xselcount:longint;
   begin
   try
   //init
   xselcount:=low__wordcore2(x,'selcount',nil);
   //get
   if x.oviewurl then
      begin
      if (xselcount<=0) then
         begin
         v:=xcursorword_loose;
         if low__urlok(v,true) then runlow(v,'');
         end;
      end;
   except;end;
   end;
   //## xwine_remakefonts ##
   procedure xwine_remakefonts;
   var
      p:longint;
   begin
   try;for p:=0 to high(x.lgfnref) do if (x.lgfnref[p]<>'') and (x.lgfdata[p]<>nil) then low__wordcore__lgfFILL(x,p,true);except;end;
   end;
   //## xwrapfinish ##
   function xwrapfinish(vpos:longint;xpx:boolean):longint;//pass-thru proc
   begin
   try
   result:=vpos;
   if (not low__wordcore(x,'wrapdone',nil)) and (vpos>=low__aorb(x.linecount,x.totalheight,xpx)) then xwrapnow(0,blen(x.data),x.vpos);//xxxxxxxxxxxxxxxxx
   except;end;
   end;
   //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//444444444444444444444444444444444444
   //## xaddrtf ##
   function xaddrtf(var e:string):boolean;//used by "ioset" - 22jun2022
   label//Special Note: We do not alter "xval" -> we read from it only -> ioset() is NOT mean't to alter the inbound datastream e.g. "xval" - 22jun2022
      redo,skipone,skipdone,skipend;
   const
      //modes
      mNone         =-1;
      mMain         =0;
      mFontlist     =1;
      mFontvalue    =2;
      mColorlist    =3;
      mPicture      =4;
      mfield        =5;
   var
      xignorecount,xmax,p,p2,dlen,xlen:longint;
      xcolorlist:array[0..999] of longint;//colors
      xnamelist:array[0..999] of string;//font names
      xmode:array[0..999] of longint;//current mode - tracking only
      m,xmodeindex:longint;
      v:byte;
      xslashcmd,xparOK:boolean;//true=inside a paragraph
      xnamecount,xcolorcount,xdefsize,xdefcharset,xdefred,xdefgreen,xdefblue:longint;
      xdefname:string;
      //.temp vars
      xsize:longint;
      xcharset:longint;
      xname:string;
      xred:longint;
      xgreen:longint;
      xblue:longint;
      //current + last vars
      ccolorindex,cnameindex,csize,cbold,citalic,cunderline,cstrikeout,calign:longint;
      lcolorindex,lnameindex,lsize,lbold,litalic,lunderline,lstrikeout,lalign:longint;
      windex:word;
      //## xcleartmp ##
      procedure xcleartmp;
      begin
      xsize:=xdefsize;
      xcharset:=xdefcharset;
      xname:=xdefname;
      xred:=xdefred;
      xgreen:=xdefgreen;
      xblue:=xdefblue;
      end;
      //## xaddchar ##
      function xaddchar(v:byte;w:word):boolean;
      var
         w2:twrd2;
      begin
      //defaults
      result:=false;
      //init
      if ((v=9) or (v=10) or (v>=32)) and xstr1.minlen(dlen+1) and xstr2.minlen(dlen+1) and xstr3.minlen(dlen+1) then
         begin
         //get
         w2.val:=w;
         xstr1.pbytes[dlen]:=v;
         xstr2.pbytes[dlen]:=w2.bytes[0];
         xstr3.pbytes[dlen]:=w2.bytes[1];
         //set
         inc(dlen);
         //successful
         result:=true;
         end;
      end;
      //## xinc ##
      function xinc(x:longint):boolean;
      begin
      result:=true;
      inc(p,x);
      end;
      //## xgetcolorlist ##
      procedure xgetcolorlist;
      var
         int1,sp,c,r,g,b,i:longint;
         v:byte;
         xok:boolean;
         str1:string;
      begin
      try
      //init
      r:=0;
      g:=0;
      b:=0;
      c:=0;
      sp:=maxint;
      xok:=false;
      //find start
      for i:=p to frcmax(p+99,xlen-1) do
      begin
      v:=xval.pbytes[i];
      //stop color element
      if xok and (i>=sp) and ((v=ssBackslash) or (v=ssSemicolon) or (v=ssRCurlybracket)) then
         begin
         int1:=frcrange(strint(xval.str1[sp+1,i-sp]),0,255);
         case c of
         1:r:=int1;
         2:g:=int1;
         3:b:=int1;
         end;//case
         //finalise the color
         if (v=ssSemicolon) or (v=ssRCurlybracket) then
            begin
            if (xcolorcount<=xmax) then
               begin
               xcolorlist[xcolorcount]:=low__rgb(r,g,b);
               inc(xcolorcount);
               end;
            end;
         c:=0;
         end;
      //start color element
      if xok and (v=ssBackslash) then
         begin
         //start color element
         if xval.asame3(i,[ssBackslash,uuR,uuE,uuD],false) then
            begin
            c:=1;//red
            sp:=i+4;
            end
         else if xval.asame3(i,[ssBackslash,uuG,uuR,uuE,uuE,uuN],false) then
            begin
            c:=2;//green
            sp:=i+6;
            end
         else if xval.asame3(i,[ssBackslash,uuB,uuL,uuU,uuE],false) then
            begin
            c:=3;//blue
            sp:=i+5;
            end
         else
            begin
            c:=0;//none
            sp:=i+1;
            end;
         end;
      //start/stop
      if (v=ssRCurlybracket) then
         begin
         p:=frcmin(i-1,0);
         break;
         end
      else if (v=ssSemicolon) then
         begin
         r:=0;
         g:=0;
         b:=0;
         c:=0;
         p:=frcmin(i-1,0);
         sp:=maxint;
         xok:=true;//start
         end
      end;//i
      except;end;
      end;
      //## cclear ##
      procedure cclear;
      begin
      ccolorindex:=0;
      cnameindex:=0;
      csize:=xdefsize;
      cbold:=0;
      citalic:=0;
      cunderline:=0;
      cstrikeout:=0;
      calign:=wcaLeft;//03jul2022
      end;
      //## lclear ##
      procedure lclear;
      begin
      lcolorindex:=-1;
      lnameindex:=-1;
      lsize:=-1;
      lbold:=-1;
      litalic:=-1;
      lunderline:=-1;
      lstrikeout:=-1;
      lalign:=-1;
      end;
      //## xlast ##
      function xlast:boolean;
      begin
      result:=false;
      if (lcolorindex<>ccolorindex) or (lnameindex<>cnameindex) or (lsize<>csize) or (lbold<>cbold) or (litalic<>citalic) or (lunderline<>cunderline) or (lstrikeout<>cstrikeout) or (lalign<>calign) then//fixed 03jul2022
         begin
         //get
         result:=true;
         lcolorindex    :=ccolorindex;
         lnameindex     :=cnameindex;
         lsize          :=csize;
         lbold          :=cbold;
         litalic        :=citalic;
         lunderline     :=cunderline;
         lstrikeout     :=cstrikeout;
         lalign         :=calign;//fixed 03jul2022
         //set
         windex:=xmakefont2(true,nil,low__udv(xnamelist[lnameindex],xdefname),lsize,xcolorlist[lcolorindex],clnone,clnone,lbold>=1,litalic>=1,lunderline>=1,lstrikeout>=1,lalign);
         end;
      end;
      //## xaddchar2 ##
      function xaddchar2(v:byte;xinc:longint):boolean;
      begin
      result:=true;
      xlast;
      xaddchar(v,windex);
      inc(p,xinc);
      end;
      //## xfindval ##
      function xfindval(xfrom:longint):string;//22jun2022
      var
         i:longint;
      begin
      try
      //defaults
      result:='';
      //check
      if (xfrom>=xlen) then exit;
      //get
      for i:=xfrom to xlen do
      begin
      v:=xval.pbytes[i];
      if (v=ssRCurlyBracket) or (v=ssBackslash) or (v=ssSemicolon) or (v=10) or (v=13) or (v=32) then
         begin
         result:=xval.str1[xfrom+1,i-xfrom];
         p:=frcmin(i-1,0);
         break;
         end;
      end;//i
      except;end;
      end;
      //## xalphabetic ##
      function xalphabetic(x:longint):boolean;
      begin
      result:=((x>=uuA) and (x<=uuZ)) or ((x>=llA) and (x<=llZ));
      end;
      //## xeocw ##
      function xeocw(x:byte):boolean;//end of control word  (space, \, curly btackets, or (not A-Z,a-Z,0-9,-))
      begin
      result:=(x=32) or (x=ssBackslash) or (x=ssLCurlyBracket) or (x=ssRCurlyBracket) or (not ( ((x>=uuA) and (x<=uuZ)) or ((x>=llA) and (x<=llZ)) or ((x>=nn0) and (x<=nn9)) or (x=ssMinus) ));
      end;
   begin
   try
   //defaults
   result:=false;
   e:=gecUnknownformat;
   //check
   if not low__comparetext(bgetstr1(xval,1,7),'{\rtf1\') then goto skipend;
   //init
   e:=gecTaskfailed;
   xmax:=high(xcolorlist);
   dlen:=0;
   xlen:=xval.len;
   xignorecount:=0;
   //.default values
   xdefsize:=10;
   xdefcharset:=0;
   xdefname:='Calibri';//Arial';
   xdefred:=0;
   xdefgreen:=0;
   xdefblue:=0;
   //.lists
   for p:=0 to xmax do
   begin
   xcolorlist[p]:=0;
   xnamelist[p]:='';
   if (p=0) then xmode[p]:=mmain else xmode[p]:=mnone;//no mode
   end;//p
   //.current pointers
   cclear;
   lclear;
   xparOK:=false;
   xslashcmd:=false;
   xnamecount:=0;
   xcolorcount:=0;
   //.first name is default fontname -> this is OUR hard value, RTF doc will override with it's own
   xnamelist[xnamecount]:='Airal';
   //.first color is default color
   xcolorlist[xcolorcount]:=low__rgb(xdefred,xdefgreen,xdefblue);
   inc(xcolorcount);
   //get
   xmodeindex:=-1;
   m:=mnone;
   p:=0;
   redo:
   v:=xval.pbytes[p];
   //.ignore -> skip over unknown groups "{...}"
   if (xignorecount>=1) then
      begin
      if      (v=ssLCurlyBracket) then inc(xignorecount)
      else if (v=ssRCurlyBracket) then xignorecount:=frcmin(xignorecount-1,0);
      goto skipone;
      end;
   //.decide
   if (v=ssLCurlyBracket) then
      begin
      //unknown group
      if xval.asame3(p,[ssLCurlyBracket,ssBackslash,ssAsterisk],false) then
         begin
         inc(xignorecount);
         goto skipone;
         end;
      //get
      xmodeindex:=frcmin(xmodeindex+1,0);
      if      xval.asame3(p,[ssLCurlyBracket,ssBackslash,uuF,uuO,uuN,uuT,uuT,uuB,uuL],false)     then xmode[xmodeindex]:=mFontlist
      else if xval.asame3(p,[ssLCurlyBracket,ssBackslash,uuF],false) and (m=mFontlist)           then xmode[xmodeindex]:=mFontvalue
      else if xval.asame3(p,[ssLCurlyBracket,ssBackslash,uuC,uuO,uuL,uuO,uuR,uuT,uuB,uuL],false) then xmode[xmodeindex]:=mColorlist
      else if xval.asame3(p,[ssLCurlyBracket,ssBackslash,uuR,uuT,uuF,nn1,ssBackslash],false)     then xmode[xmodeindex]:=mmain
//      else if xval.asame3(p,[ssLCurlyBracket,ssBackslash,uuF,uuI,uuE,uuL,uuD],false)             then xmode[xmodeindex]:=mfield
      else if xval.asame3(p,[ssLCurlyBracket,ssBackslash,uuP,uuI,uuC,uuT],false)                 then xmode[xmodeindex]:=mPicture
      else                                                                                            xmode[xmodeindex]:=mnone;
      //set
      m:=xmode[xmodeindex];//fast lookup var
      goto skipone;
      end
   else if (v=ssRCurlyBracket) then
      begin
      //get
      dec(xmodeindex);
      if (xmodeindex<0) then
         begin
         m:=mnone;
         goto skipdone;//do not raise an error - 22jun2022
         end;
      //set
      m:=xmode[xmodeindex];//fast lookup var
      end
   else if (v=ssBackSlash) then
      begin
      //special text escape sequences ------------------------------------------
      if      xval.asame3(p,[ssBackslash,ssBackslash],false)        and xaddchar2(ssBackslash,1)     then goto skipone
      else if xval.asame3(p,[ssBackslash,ssLCurlyBracket],false)    and xaddchar2(ssLCurlyBracket,1) then goto skipone
      else if xval.asame3(p,[ssBackslash,ssRCurlyBracket],false)    and xaddchar2(ssRCurlyBracket,1) then goto skipone;

      //commands ---------------------------------------------------------------
      xslashcmd:=true;
      //.colorlist
      if (m=mColorlist) then xgetcolorlist
      //.start paragraph
      else if xval.asame3(p,[ssBackslash,uuP,uuA,uuR,uuD],false) then
         begin
         xparOK:=true;
         xinc(4);
         end
      //.stop paragraph
      else if xval.asame3(p,[ssBackslash,uuP,uuA,uuR],false) then
         begin
         if (dlen>=1) then xaddchar2(ss10,0);//insert return code
         xinc(3);
         end
      //control symbols => "\<non-alhabetical symbol, single char>"
      else if ((p+1)<xlen) and (not xalphabetic(xval.pbytes[p+1])) then
         begin
         v2:=xval.pbytes[p+1];
         //special characters
         if (v2=ssSquiggle) then xaddchar2(160,0);//non-breaking space
         xinc(1);
         xslashcmd:=false;
         end
      //.paragraph based formating
      else if xparOK then
         begin
         //.bold
         if      xval.asame3(p,[ssBackslash,uuB,nn0],false)                     then cbold:=0//off
         else if xval.asame3(p,[ssBackslash,uuB],false)                         then cbold:=1//on
         //.italic
         else if xval.asame3(p,[ssBackslash,uuI,nn0],false)                     then citalic:=0//off
         else if xval.asame3(p,[ssBackslash,uuI],false)                         then citalic:=1//on
         //.underline                         ulnone
         else if xval.asame3(p,[ssBackslash,uuU,uuL,uuN,uuO,uuN,uuE],false)     then cunderline:=0//off "\ulnone"
         else if xval.asame3(p,[ssBackslash,uuU,uuL],false)                     then cunderline:=1//on "\ul"
         //.strikeout
         else if xval.asame3(p,[ssBackslash,uuS,uuT,uuR,uuI,uuK,uuE,nn0],false) then cstrikeout:=0//off "\strike0"
         else if xval.asame3(p,[ssBackslash,uuS,uuT,uuR,uuI,uuK,uuE],false)     then cstrikeout:=1//on "\strike"
         //.colorindex "\cf#"
         else if xval.asame3(p,[ssBackslash,uuC,uuF],false) then ccolorindex:=frcrange(strint(xfindval(p+3)),0,frcmin(xcolorcount-1,0))
         //.fontsize "\fs#"
         else if xval.asame3(p,[ssBackslash,uuF,uuS],false) then csize:=frcrange(round(strint(xfindval(p+3))/2),1,300)//Note: 1pt = 1.333 pixels sourced from Goggle, but WordPad uses 2 @ 100% zoom - 22jun2022
         //.nameindex "\f#"
         else if xval.asame3(p,[ssBackslash,uuF],false) then cnameindex:=frcrange(strint(xfindval(p+2)),0,frcmin(xnamecount-1,0))

         //.other
         else
            begin

            end;
         end;
      //not text -> skip over
      goto skipone;
      end;

   //.add plain text
//was: if ((v=32) or (v=10) or (v=13)) and xslashcmd then
   if xslashcmd and xeocw(v) then
      begin
      xslashcmd:=false;
      end
   else if (m=mmain) and xparOK and (not xslashcmd) and ((v=9) or (v>=32)) and ((v<>ssLCurlyBracket) and (v<>ssRCurlyBracket) and (v<>ssBackslash)) then
      begin
      xaddchar2(v,0);
      end;

//********** We are having trouble SKIPPING over MS's hyperlink code in the RTF file....around the G..H..IIII marks in "document8e3.rtf" - 06jul2022

   //.inc
skipone:
   inc(p);
   if (p<xlen) then goto redo;

skipdone:
   //.finalise
   if (dlen>=1) then
      begin
      xstr1.setlen(dlen);
      xstr2.setlen(dlen);
      xstr3.setlen(dlen);
      end;
   //successful
   result:=true;
   skipend:
   except;end;
   end;
   //## cdefault ##
   procedure cdefault;//05jul2022
   begin
   try
   x.cfontname     :=low__udv(x.defFontname,'$fontname');
   x.cfontsize     :=frcrange(x.defFontsize,4,300);
   x.cbold         :=false;
   x.citalic       :=false;
   x.cunderline    :=false;
   x.cstrikeout    :=false;
   x.ccolor        :=x.defFontcolor;
   x.cbk           :=clnone;
   x.cborder       :=clnone;
   x.calign        :=wcaLeft;
   except;end;
   end;
   //## me ##
   function me(x:tstr8):tstr8;//pass-thru - encode
   var
      e:string;
   begin
   try
   result:=x;
   low__compress(x,e);
   low__lestr(x);
   result:=x;
   except;end;
   end;
   //## md ##
   function md(x:tstr8):tstr8;//pass-thru - decode
   var
      e:string;
   begin
   try
   result:=x;
   low__ldstr(x);
   low__decompress(x,e);
   result:=x;
   except;end;
   end;
   //## mclear ##
   procedure mclear(xcleanfiles:boolean);
   var
      p:longint;
   begin
   try
   for p:=low(x.mn) to high(x.mn) do
   begin
   if (x.mn[p]<>'') and xcleanfiles then low__remfile(low__plattemp+x.mn[p]);
   end;//p
   if (x.mlist<>nil) then low__mclear(x.mlist);
   bclear(x.md1);
   bclear(x.md2);
   bclear(x.md3);
   x.mstyle:=musNone;//27jun2022
   x.mfrom1:=1;
   x.mact:=muaRep;
   x.mlen:=0;
   except;end;
   end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//77777777777777777777777
//xxxxxxxxx
   //## mdok ##
   function mdok:boolean;
   begin
   result:=(x.md1<>nil) and (x.md2<>nil) and (x.md3<>nil);
   end;
   //## mmax ##
   function mmax:longint;
   begin
   result:=frcrange(x.mlimit-1,0,high(x.mn));
   end;
   //## mstore12 ##
   function mstore12(xuseslot:longint;xstoreRecovered:boolean):boolean;//27sep2022 fixed "no undo in use issue", multi-undo write
   label
      skipend;
   var
      v:tvars8;
      a,b:tstr8;
      h:tint4;
      e:string;
      xact,xstyle,xslot,xfrom1,xlen:longint;
      xmustdel:boolean;
   begin
   try
   //defaults
   result:=false;
   v:=nil;
   a:=nil;
   b:=nil;
   xslot:=-1;
   xmustdel:=true;
   //check - 27sep2022
   if not x.menabled then
      begin
      result:=true;
      exit;
      end;
   //range
   xstyle:=frcrange(x.mstyle,musNone,musMax);
   xfrom1:=frcrange(x.mfrom1,1,blen(x.data));
   xlen  :=frcrange(x.mlen,  0,blen(x.data));
   xact  :=muaRep;
   //check
   if (xstyle=musRecovered) and (not xstoreRecovered) then
      begin
      xmustdel:=false;
      result:=true;
      goto skipend;
      end;

   case xstyle of
   musDelL,musDelR:begin
      xlen:=0;//from side stream
      xact:=muaAdd;
      end;
   musIns,musInsimg:begin
      xact:=muaSub;
      end;
   musRangekeep:begin
      xact:=muaRep;
      end;
   musRecovered:begin
      xlen:=blen(x.md1);
      xact:=frcrange(x.mact,0,muaMax);
      end;
   musSel,musSelKeep:begin
      xfrom1:=xselstart;//from data stream
      xlen  :=xselcount;
      if (xstyle=musSelKeep) then xact:=muaRep else xact:=muaAdd;
      //check for empty selection requests and IGNORE them - 03jul2022
      if (xlen<=0) then
         begin
         result:=true;
         goto skipend;
         end;
      end;
   else
      begin//nothing to do here for these modes
      result:=true;
      goto skipend;
      end;
   end;//case

   //init
   //.slot
   if (xuseslot>=-1) then xslot:=xuseslot
   else                   xslot:=low__mnewslot(x.mlist);

   //.tmps
   a:=bnew;
   b:=bnew;
   v:=vnew;
   xact:=frcrange(xact,0,muaMax);//action

   //header ID - 28jun2022
   h.bytes[0]:=uuU;
   h.bytes[1]:=uuN;
   h.bytes[2]:=uuD;
   h.bytes[3]:=nn1;
   a.datpush(h.val,nil);

   //info
   try
   v.i['x']:=xfrom1;
   v.i['a']:=xact;
   v.i['1']:=x.cursorpos;
   v.i['2']:=x.cursorpos2;
   v.i['v']:=low__wordcore2(x,'vpos.px',nil);
   v.i['h']:=low__wordcore2(x,'hpos',nil);
   a.datpush(0,v.data);
   freeobj(@v);
   except;end;

   //data
   case xstyle of
   musDelL,musDelR:begin
      a.datpush(1,me(x.md1));
      a.datpush(2,me(x.md2));
      a.datpush(3,me(x.md3));
      end;
   musIns,musSel,musSelKeep,musRangekeep,musInsimg:begin
      b.clear; b.add31(x.data ,xfrom1,xlen); a.datpush(1,me(b));
      b.clear; b.add31(x.data2,xfrom1,xlen); a.datpush(2,me(b));
      b.clear; b.add31(x.data3,xfrom1,xlen); a.datpush(3,me(b));
      end;
   musRecovered:begin
      if mdok then
         begin
         a.datpush(1,me(x.md1));
         a.datpush(2,me(x.md2));
         a.datpush(3,me(x.md3));
         end;
      end;
   end;//case

   //save
   if not low__tofile(low__plattemp+x.mn[xslot],a,e) then goto skipend;
   //successful
   result:=true;
   skipend:
   except;end;
   try
   //clear
   if (xstyle<>musNone) then//and (xstyle<>musRangekeep) then
      begin
      //temp streams
      bclear(x.md1);
      bclear(x.md2);
      bclear(x.md3);
      //vars
      x.mfrom1 :=1;
      x.mlen   :=0;
      x.mstyle :=musNone;
      x.mact   :=muaRep;
      //delete selection
      if xmustdel and (xstyle=musSel) and (xselcount>=1) then xdelsel2(false);//???? xdelsel2(true);//don't set "*_moveto" when inserting one or more characters - 02sep2019
      end;
   //free
   freeobj(@a);
   freeobj(@b);
   freeobj(@v);
   except;end;
   end;
   //## mstore1 ##
   function mstore1:boolean;//multi-undo write
   begin
   try;result:=mstore12(minint,false);except;end;
   end;
   //## mread1 ##
   function mread1(xslot:longint;xundo:boolean):boolean;//27sep2022 fixed "no undo in use issue"
   label
      skipend;
   var
      v:tvars8;
      a,b:tstr8;
      h:tint4;
      bcount,xact,xfrom1,xcursor,xcursor2,xposV,xposH,bn,xpos:longint;
      e:string;
   begin
   try
   //defaults
   result:=false;
   v:=nil;
   a:=nil;
   b:=nil;
   //check - 27sep2022
   if not x.menabled then
      begin
      result:=true;
      exit;
      end;
   //range
   xslot:=frcrange(xslot,low(x.mn),mmax);
   //init
   a:=bnew;
   b:=bnew;
   v:=vnew;
   xact    :=muaRep;
   xfrom1  :=0;
   xcursor :=1;
   xcursor2:=1;
   xposV   :=0;
   xposH   :=0;
   bcount  :=0;
   bclear(x.md1);//03jul2022
   bclear(x.md2);
   bclear(x.md3);
   //load
   if not low__fromfile(low__plattemp+x.mn[xslot],a,e) then goto skipend;
   //get
   xpos:=0;
   //.header ID
   h.bytes[0]:=uuU;
   h.bytes[1]:=uuN;
   h.bytes[2]:=uuD;
   h.bytes[3]:=nn1;
   if (not a.datpull(xpos,bn,b)) or (bn<>h.val) then goto skipend;
   //.data values
   while true do
   begin
   if not a.datpull(xpos,bn,b) then break;
   //.info
   if (bn=0) then
      begin
      //get
      v.data   :=b;
      xfrom1   :=frcmin(v.i['x'],1);
      xact     :=frcrange(v.i['a'],0,muaMax);
      xcursor  :=frcmin(v.i['1'],1);
      xcursor2 :=frcmin(v.i['2'],1);
      xposV    :=v.i['v'];
      xposH    :=v.i['h'];
      //clear
      v.clear;
      //action inversion
      if not xundo then
         begin
         if      (xact=muaAdd) then xact:=muaSub
         else if (xact=muaSub) then xact:=muaAdd;
         end;
      end
   //data
   else if (bn=1) and (xfrom1>=1) then
      begin
      //init
      md(b);
      bcount:=blen(b);
      //get
      if (xfrom1>=1) and (bcount>=1) and ((xact=muaRep) or (xact=muaSub)) then
         begin
         if (xact=muaRep) and mdok then
            begin
            bclear(x.md1); x.md1.add3(x.data, xfrom1-1,bcount);
            bclear(x.md2); x.md2.add3(x.data2,xfrom1-1,bcount);
            bclear(x.md3); x.md3.add3(x.data3,xfrom1-1,bcount);
            end;
         x.data .del3(xfrom1-1,bcount);
         x.data2.del3(xfrom1-1,bcount);
         x.data3.del3(xfrom1-1,bcount);
         end;
      if (xact<>muaSub) then x.data.ins(b,xfrom1-1);
      if (x.md1<>nil) and (xact<>muaRep) then x.md1.replace:=b;//hold the undo value in the MD1-3 handlers - doubls up on the data but makes management easier and more reliable - 03jul2022
      end
   else if (bn=2) and (xfrom1>=1) then
      begin
      md(b);
      if (xact<>muaSub) then x.data2.ins(b,xfrom1-1);
      if (x.md2<>nil) and (xact<>muaRep) then x.md2.replace:=b;
      end
   else if (bn=3) and (xfrom1>=1) then
      begin
      md(b);
      if (xact<>muaSub) then x.data3.ins(b,xfrom1-1);
      if (x.md3<>nil) and (xact<>muaRep) then x.md3.replace:=b;
      end;
   end;
   //finalise
   case xact of
   muaRep,muaAdd:xcursor:=xfrom1+bcount;
   muaSub       :xcursor:=xfrom1;
   end;//case
   xcursor2:=xcursor;

   //successful
   result:=true;
   skipend:
   except;end;
   try
   //finalise
   xmincheck;
   x.cursorpos :=frcrange(xcursor,1,blen(x.data));
   x.cursorpos2:=frcrange(xcursor2,1,blen(x.data));
   low__wordcore_str(x,'vpos.px',inttostr(xposV));
   low__wordcore_str(x,'hpos',inttostr(xposH));
   if (xfrom1>=1) then xwrapadd(xlinebefore(xfrom1),xfrom1+bcount+x.c_pagewrap);
   x.mfrom1 :=xfrom1;
   x.mlen   :=0;
   x.mact   :=xact;
   x.mstyle :=musRecovered;
   x.timer_chklinecursorx:=true;
   xchanged;
   //rewrite modified "replace" version back to same slot - 03jul2022
   if (xact=muaRep) then mstore12(xslot,true);
   //free
   freeobj(@a);
   freeobj(@b);
   freeobj(@c);
   freeobj(@v);
   except;end;
   end;
   //## cwritealign ##
   procedure cwritealign;
   var
      p,xlastwid,xselstart,xselcount,xminp,xmaxp:longint;
      wrd2:twrd2;
      xalignok,xmustchange,xtxt,ximg:boolean;
   begin
   try
   //init
   xmustchange:=false;
   xselstart:=low__wordcore2(x,'selstart',nil);
   xselcount:=low__wordcore2(x,'selcount',nil);
   if (xselcount>=1) then
      begin
      xminp:=xselstart;
      xmaxp:=low__wordcore_str2(x,'pos>rc',inttostr(xselstart+xselcount-1));
      end
   else
      begin
      xminp:=frcmin(x.cursorpos,1);
      xmaxp:=low__wordcore_str2(x,'pos>rc',inttostr(xminp));
      end;
   //range
   xminp:=frcrange(xminp,1,blen(x.data));
   xmaxp:=frcrange(xmaxp,1,blen(x.data));
   //check
   if (xmaxp<xminp) then exit;
   //m-undo - 28jun2022
   mstore1;//previous
   x.mstyle:=musRangekeep;
   x.mfrom1:=xminp;
   x.mlen:=xmaxp-xminp+1;
   mstore1;
   //get
   for p:=xminp to xmaxp do
   begin
   if not low__wordcore__charinfo(x,p,xchar) then break;
   if (xchar.cs=wc_t) and (xchar.c=10) then
      begin
      wrd2.val:=xmakefont2(true,nil,x.txtname[xchar.wid],x.txtsize[xchar.wid],x.txtcolor[xchar.wid],x.txtbk[xchar.wid],x.txtborder[xchar.wid],x.txtbold[xchar.wid],x.txtitalic[xchar.wid],x.txtunderline[xchar.wid],x.txtstrikeout[xchar.wid],x.calign);
      if (xchar.wid<>wrd2.val) then
         begin
         x.data2.byt1[p-1]:=wrd2.bytes[0];
         x.data3.byt1[p-1]:=wrd2.bytes[1];
         xmustchange:=true;
         end;
      end;
   end;//p
   except;end;
   try
   if xmustchange then
      begin
      xwrapadd(xlinebefore(xminp),xmaxp+x.c_bigwrap);//need to wrap ATLEAST current page, else flicker may occur due to multiple paint attempts - 07dec2019
      x.timer_chklinecursorx:=true;
      xchanged;
      end;
   except;end;
   end;
   //## mcopy ##
   function mcopy(sslot,dslot:longint):boolean;
   var
      v,e:string;
   begin
   try
   //defaults
   result:=false;
   //range
   sslot:=frcrange(sslot,low(x.mn),mmax);
   dslot:=frcrange(dslot,low(x.mn),mmax);
   //check
   if (sslot=dslot) then
      begin
      result:=true;
      exit;
      end;
   //get
   v:=low__plattemp;
   result:=low__copyfile(v+x.mn[sslot],v+x.mn[dslot],e);
   except;end;
   end;
   //## mcanundo ##
   function mcanundo:boolean;
   begin
   result:=x.menabled and ( low__mcanundo(x.mlist) or ((x.mstyle>musNone) and (x.mstyle<>musRecovered)) );
   end;
   //## mundo ##
   function mundo:boolean;
   var
      xfrom1,xlen,sslot,wstyle:longint;
      dmustslot:boolean;
      //## dsave ##
      procedure dsave;
      begin
      mcopy(-1,low__mnewslot(x.mlist));
      dmustslot:=false;
      end;
   begin
   try
   //defaults
   result:=false;
   wstyle:=x.mstyle;
   sslot:=-1;
   xfrom1:=1;
   xlen:=0;
   //check
   if not mcanundo then exit;
   //current -> temp
   dmustslot:=(wstyle>musNone);
   if dmustslot then
      begin
      if (wstyle=musNone) then
         begin
         //nil
         end
      else if (wstyle=musRecovered) then
         begin
         dmustslot:=false;
         bclear(x.md1);
         bclear(x.md2);
         bclear(x.md3);
         x.mfrom1:=1;
         x.mlen:=0;
         x.mact:=muaRep;
         x.mstyle:=musNone;
         end
      else
         begin
//was:   if (wstyle=musDelL) or (wstyle=musDelR) or (wstyle=musSel) or (wstyle=musSelKeep) or (wstyle=musRangeKeep) or (wstyle=musIns) or (wstyle=musInsimg) then mstore12(-1,true);
         mstore12(-1,true);
         dsave;
         end;
      end;
   //load
   if low__mundo(x.mlist,sslot) then mread1(sslot,true);
   //temp -> slot
   if dmustslot then dsave;//not ever used
   //reposition the cursor - 28jun2022
   x.cursor_keyboard_moveto:=frcrange(x.cursorpos,1,blen(x.data));
   x.timer_chklinecursorx:=true;
   //successful
   result:=true;
   except;end;
   end;
   //## mcanredo ##
   function mcanredo:boolean;
   begin
   result:=x.menabled and low__mcanredo(x.mlist);
   end;
   //## mredo ##
   function mredo:boolean;
   var
      sslot:longint;
   begin
   try
   //defaults
   result:=false;
   sslot:=-1;
   //check
   if not mcanredo then exit;
   //load
   if low__mredo(x.mlist,sslot) then mread1(sslot,false);
   //reposition the cursor - 28jun2022
   x.cursor_keyboard_moveto:=frcrange(x.cursorpos,1,blen(x.data));
   x.timer_chklinecursorx:=true;
   //successful
   result:=true;
   except;end;
   end;
begin
try
//defaults
result:=false;
xcmd:=low__lowercase(xcmd);
xoutval:='';
xmusttimerunbusy:=false;
e:=gecTaskfailed;
block(xval);
block(xoutbin);
d1:=nil;//pointer only
d2:=nil;//pointer only
d3:=nil;//pointer only
xstr1:=nil;
xstr2:=nil;
xstr3:=nil;
xstr4:=nil;
xstr5:=nil;
xstr6:=nil;
ximgdata:=nil;
xvar1:=nil;
for p:=0 to high(xlist2) do xlist2[p]:=nil;
//init
if x.usezoom and (x.initstate='inited') then x.zoomnow:=vizoom else x.zoomnow:=1;
imax:=high(x.lgfdata);

//check + init
if (xcmd='timer') then//special host driven call -> used by this proc to check keep params and act accordingly - 22aug2019
   begin
//   dbstatus(15,inttostr(xcursor_offscreenX)+'<<'+ms64str);//xxxxxxxxxxxxxx

   //check
   if x.timerbusy or (x.initstate<>'inited') then goto skipend;
   //init
   xmusttimerunbusy:=true;//remember to turn busy signal back off down below
   x.timerbusy:=true;
   xoldcursorpos:=x.cursorpos;
   xmustpaint:=false;

   //wine sync
   if low__setint(x.lastvisyncid,visyncid) or (ms64>=x.timerfont500) then
      begin                                                                                                                                                                                   //13feb2022
      if (not x.dataonly) and low__or3(low__setstr(x.sysfontDefault,low__findfontnameb('$fontname')),low__setstr(x.sysfontDefault2,low__findfontnameb('$fontname2')),low__setstr(x.onefontREF,bnc(vifeatherf>=1)+'|'+inttostr(x.onefontsize)+'|'+low__insstr(inttostr(vifontsize),x.onefontsize=0)+'|'+low__insstr(inttostr(vifontsize2),x.onefontsize=1)+'|'+low__findfontnameb(x.onefontname)))  then
         begin
         xwine_remakefonts;
         xpagewidth;
         xwrap_hvsync_changed;
         end;
      //reset
      x.timerfont500:=ms64+500;
      end;

   //zoom sync
   if (x.lastzoom<>x.zoomnow) then
      begin
      x.lastzoom:=x.zoomnow;
      xapplyzoom;
      end;

   //mstack --------------------------------------------------------------------
   xneed1;
   while xstackpull(x.mstack,xstr1) do
   begin
   if (blen(xstr1)>=10) then
      begin
      //init
      xnoidle;
      dx:=xstr1.int4[0];//0..3
      dy:=xstr1.int4[4];//4..7
      bol1:=(xstr1.bol1[8]);//8 - down
      bol2:=(xstr1.bol1[9]);//9 - right click
      bol3:=false;//was barfocused
      //.sync cursor
      x.cursorstyle:='t';//text cursor
      //get
      //.text box
      if bol1 and (not bol2) then
         begin
         xsetcursorpos2(low__wordcore_str2(x,'xy>pos',inttostr(dx)+#32+inttostr(dy)),x.wasdown);
         end;//if

      //left.mouse.button.upstroke -> special actkions
      if (not bol2) and (not bol1) and x.wasdown and (not x.wasright) then xmouseup_specialactions;

      //set
      x.wasdown:=bol1;
      x.wasright:=bol2;
      end;//if
   end;//while

   //kstack --------------------------------------------------------------------
   xneed1;
   while xstackpull(x.kstack,xstr1) do
   begin
   if (blen(xstr1)>=5) then
      begin
      //init
      xnoidle;
      knoidle;
      case xstr1.byt1[0] of
      2:begin//ak_code keyboard system
         if (akshift=xstr1.int4[1]) then
            begin
            x.shift:=true;
            goto skipkeyboard;
            end
         else if (akshiftup=xstr1.int4[1]) then
            begin
            x.shift:=false;
            goto skipkeyboard;
            end
         else
            begin
            low__keyboard__fromak(xstr1.int4[1],xctrl,xalt,xshift,xkeyx,int1,bol1);
            xshift:=x.shift;//retain value
            c:=int1;
            if not bol1 then goto skipkeyboard;
            end;
         end;
      0..1:begin//traditional MS keyboard input
         xctrl:=xstr1.bol1[0];//0
         xalt:=xstr1.bol1[1];//1
         xshift:=xstr1.bol1[2];//2
         xkeyx:=xstr1.bol1[3];//3
         c:=xstr1.byt1[4];//4
         end;
      else
         begin//unspported keyboard input format - 24aug2020
         xctrl:=false;
         xalt:=false;
         xshift:=false;
         xkeyx:=false;
         c:=63;//?
         end;
      end;//case
      xstr1.clear;
      //.retain these key states - 31aug2019
      x.shift:=xshift;
      //get
      //.shortcut           //((c>='A') and (c<='Z'))
      if xctrl and xkeyx and ((c>=65) and (c<=90)) then
         begin
         if x.shortcuts or x.styleshortcuts then
            begin
            str1:='Unable';
            //-- edit shortcuts --//"P"
            if x.shortcuts and (c=80) and low__wordcore(x,'canpaste',nil) then
               begin
               low__wordcore(x,'paste',nil);
               str1:='Paste';
               end                   //"T"
            else if x.shortcuts and (c=84) and low__wordcore(x,'cancut',nil) then
               begin
               low__wordcore(x,'cut',nil);
               str1:='Cut';
               end                    //C
            else if x.shortcuts and (c=67) and low__wordcore(x,'cancopy',nil) then
               begin
               low__wordcore(x,'copy',nil);
               str1:='Copy';
               end                     //U
            else if x.shortcuts and (c=85) and low__wordcore(x,'canundo',nil) then
               begin
               low__wordcore(x,'undo',nil);
               str1:='Undo';
               end                     //R
            else if x.shortcuts and (c=82) and low__wordcore(x,'canredo',nil) then
               begin
               low__wordcore(x,'redo',nil);
               str1:='Redo';
               end                     //S
            else if x.shortcuts and (c=83) and low__wordcore(x,'cansave',nil) then
               begin
               low__wordcore(x,'save',nil);
               str1:='Save';
               end
            //-- style shortcuts --      //N
            else if x.styleshortcuts and (c=78) and low__wordcore(x,'canstyle',nil) then
               begin
               low__wordcore_str(x,'style','normal');
               str1:='Normal';
               end                         //B
            else if x.styleshortcuts and (c=66) and low__wordcore(x,'canstyle',nil) then
               begin
               low__wordcore_str(x,'style','bold');
               str1:='Bold';
               end                        //I
            else if x.styleshortcuts and (c=73) and low__wordcore(x,'canstyle',nil) then
               begin
               low__wordcore_str(x,'style','italic');
               str1:='Italic';
               end                         //D
            else if x.styleshortcuts and (c=68) and low__wordcore(x,'canstyle',nil) then
               begin
               low__wordcore_str(x,'style','underline');
               str1:='Underline';
               end                         //K
            else if x.styleshortcuts and (c=75) and low__wordcore(x,'canstyle',nil) then
               begin
               low__wordcore_str(x,'style','strikeout');
               str1:='Strikeout';
               end                         //H
            else if x.styleshortcuts and (c=72) and low__wordcore(x,'canstyle',nil) then
               begin
               low__wordcore_str(x,'style','highlight');
               str1:='Highlight';
               end                         //Z
            else if x.styleshortcuts and (c=90) and low__wordcore(x,'canstyle',nil) then
               begin
               low__wordcore_str(x,'style','alignment');
               str1:='Alignment';
               end
            //-- unknown shortcut --
            else str1:='';
            //brief status
            if (x.briefstatus<>'') then x.briefstatus:=str1;
            end;//c
         end
      //.special key
      else if xkeyx then
         begin
         case ord(c) of
         vkreturn:   if (not x.readonly) then low__wordcore(x,'ins',bchar(10));
         vktab:      if (not x.readonly) then low__wordcore(x,'ins',bchar(9));
         vkdelete:   if (not x.readonly) then low__wordcore(x,'delr',nil);
         vkback:     if (not x.readonly) then low__wordcore(x,'dell',nil);
         vkleft:begin
            if not x.showcursor then low__wordcore_str(x,'vpos',inttostr(x.vpos-1))//25jul2021
            else if xctrl then low__wordcore_str(x,'move','scoot.left')
            else if xalt  then low__wordcore_str(x,'move','line.start')
            else               low__wordcore_str(x,'move','left');
            end;
         vkright:begin
            if not x.showcursor then low__wordcore_str(x,'vpos',inttostr(x.vpos+1))//25jul2021
            else if xctrl then low__wordcore_str(x,'move','scoot.right')
            else if xalt  then low__wordcore_str(x,'move','line.end')
            else               low__wordcore_str(x,'move','right');
            end;
         vkup:begin
            if not x.showcursor then low__wordcore_str(x,'vpos',inttostr(x.vpos-1))//25jul2021
            else                     low__wordcore_str(x,'move','up');
            end;
         vkdown:begin
            if not x.showcursor then low__wordcore_str(x,'vpos',inttostr(x.vpos+1))//25jul2021
            else                     low__wordcore_str(x,'move','down');
            end;
         vkprior:    low__wordcore_str(x,'move','pageup');
         vknext:     low__wordcore_str(x,'move','pagedown');
         vkhome:     low__wordcore_str(x,'move','home');
         vkend:      low__wordcore_str(x,'move','end');
         {
         vkf2:if canfind then find(true);//find up - 16aug2014
         vkf3:if canfind then find(false);//find down - 16aug2014
         vkf7:if (odic<>nil) then odic.spellstatus:=3;//find next spelling error - 19aug2014
         {}//xxxxxxxxxx
         end;//case
         end
      //.standard character
      else if (not xkeyx) and (not x.readonly) then low__wordcore(x,'ins',bchar(c));
      end;//if
skipkeyboard:
   end;//while

   xcursor_keyboard_moveto:=x.cursor_keyboard_moveto;       x.cursor_keyboard_moveto:=0;//take value and set to zero (off)
   xchklinecursorx:=x.timer_chklinecursorx;                 x.timer_chklinecursorx:=false;

   //wrap list -----------------------------------------------------------------
   //init
   bol1:=false;
   int1:=maxint;
   int2:=minint;
   //.special "timer_setcursorpos" -> need to wrap to this point inorder to paint the screen AND set the cursor for real - 30aug2019
   if (xcursor_keyboard_moveto>=1) then
      begin
      xsetcursorpos2(xcursor_keyboard_moveto,x.shift);//auto adds wrap request if required
      end;
   //get
   if not x.hostsizing then
      begin
      while xwrappull(int3,int4) do
      begin
      if (int3>=0) and (int4>=0) then
         begin
         //extend range
         if (int3<int1) then int1:=int3;
         if (int4>int2) then int2:=int4;
         bol1:=true;
         end;
      end;//while
      end;//if
   //set
   if bol1 then
      begin
      //.reposition realtime wrap
      if (int1=int2) then x.wrapcount:=frcrange(int1,0,blen(x.data))
      //.rewrap selected area
      else xwrapnow(int1,int2,x.vpos+1);
      //update
      xmustpaint:=true;
      end;

   //realtime wrap -------------------------------------------------------------
   if (ms64>=x.timer100) then
      begin
      int1:=x.wrapcount;
      if (x.data.len>=1) and (int1<blen(x.data)) and (not x.hostsizing) then
         begin
         //init
         if      (low__keyidle<=2000) then int2:=1000
         else if (low__keyidle<=5000) then int2:=x.c_smallwrap
         else int2:=x.c_bigwrap;
         //get
         xwrapnow(int1,int1+int2,x.vpos+1);
         if (int1<>x.wrapcount) then xmustpaint:=true;
         end;

      //system feather
      if x.sysfeather then x.feather:=vifeather;//26aug2020

      //sync
      str1:=inttostr(low__wordcore2(x,'viewwidth',nil))  +'|'+
            inttostr(low__wordcore2(x,'viewheight',nil)) +'|'+
            inttostr(low__wordcore2(x,'pagewidth',nil))  +'|'+
            inttostr(low__wordcore2(x,'pageheight',nil)) +'|'+
            inttostr(x.zoomnow)+'|'+//17mar2021
            inttostr(x.feather)+'|'+//02jun2020, 21sep2019
            '';
      if (x.syncref<>str1) then
         begin
         x.syncref:=str1;
         x.mustpaint:=true;
         end;

      //reset
      x.timer100:=ms64+100;
      end;

   //vhostsync -----------------------------------------------------------------
   if (x.vpos>=x.linecount) then
      begin
      low__wordcore_str(x,'vpos',inttostr(x.linecount-1));
      end;


   if (xcursor_keyboard_moveto>=1) or (x.vcheck>=1) then
      begin
      //was: x.vcheck:=frcmin(x.vcheck-1,0);// -> this was taking TOO long when selecting text up and down rapidly THEN attempting to scroll with scrollbar caused the scrollbar to PAUSE for seconds without movement - 25jul2021
      x.vcheck:=0;
      int1:=low__wordcore_str2(x,'pos>line',inttostr(x.cursorpos));
      if xsafeline(int1) then
         begin
         bol1:=true;
         bol2:=true;
         //.check 1 -> scroll up to cursor
         int3:=low__wordcore2(x,'paintline1',nil);
         bol2:=xsafeline(int3);
         if bol1 and bol2 and (x.liney[int1]<(x.liney[int3]+x.vposPART)) then
            begin
            bol1:=false;
            x.vpos:=int1;
            if (x.lineh[int1]>x.viewheight) then x.vposPART:=x.lineh[int1]-x.viewheight else x.vposPART:=0;
            x.vhostsync:=true;
            end;
         //.check 2 -> scroll down to cursor
         int3:=low__wordcore2(x,'paintline2',nil);
         xsafeline(int3);
         if bol1 and ((x.liney[int1])>x.liney[int3]) then
            begin
            //init
            bol1:=false;
            //get
//            if (int3>0) then for p:=int3 downto 0 do if ((x.liney[int3]+x.lineh[int3]+x.vposPART-x.liney[p])<=x.viewheight) then int1:=p else break;
            //set
            x.vpos:=int1;
            x.vposPART:=x.lineh[int1]-x.viewheight;//not perfect - but it is working OK - 21jun2022
            x.vhostsync:=true;
            end;
         //.check 3 -> fallback check (when 1 above fails) -> scroll to x.cursorpos
         if bol1 and (not bol2) then
            begin
            x.vpos:=int1;
            x.vposPART:=0;
            x.vhostsync:=true;
           end;
         end;
      end;

   //linecursorx update --------------------------------------------------------
   if xchklinecursorx then xlinecursorx(x.cursorpos);

   //flash cursor
   if (ms64>=x.timerslow) then
      begin
      x.flashcursor:=not x.flashcursor;
      //reset
      x.timerslow:=ms64+500;
      end;
   //.draw cursor -> detect change and trigger paint -> 29aug2019
   bol1:=x.showcursor and x.havefocus and (x.flashcursor or (x.k_idleref>=ms64));
   if (bol1<>x.drawcursor) then
      begin
      x.drawcursor:=bol1;
      if x.cursoronscrn then xmustpaint:=true;
      end;

   //set
   if xmustpaint then x.mustpaint:=true;

   //done
   goto skipdone;
   end
//.init support
else if (xcmd='getinited') then
   begin
   if (x.initstate='inited') then xoutval:='1' else xoutval:='0';
   goto skipdone;
   end
else if (x.initstate='initing') then
   begin
   e:='Init busy';
   exit;
   end
else if (x.initstate<>'inited') then
   begin
   if (xcmd='init') or (xcmd='init.dataonly') then//wordcore
      begin
      //init
      x.initstate:='initing';
      x.hostsizing:=false;//22apr2022
      x.maxformatlevel:=2;//supports 0=TXT, 1=BWD and 2=BWP - 12jun2022
      x.lastvisyncid:=visyncid;//13feb2022
      x.onefontname:='';//off - 05feb2022
      x.onefontsize:=-1;//off  - 05feb2022
      x.sysfontDefault :=low__findfontnameb('$fontname');//do this FIRST  before anything critical - 02feb2022
      x.sysfontDefault2:=low__findfontnameb('$fontname2');//do this FIRST  before anything critical - 02feb2022
      int1:=low__rgb(255,255,255);
      //special delayed events/vars
      x.cursor_keyboard_moveto  :=0;
      x.timer_chklinecursorx    :=false;
      //constant values
      x.c_bigwrap     :=300*1000;//300K item blocks
      x.c_smallwrap   :=10000;//10K item blocks
      x.c_pagewrap    :=10000;//for entire page (best guess), may not be adequate for large screens - 26aug2019
      x.c_idlepause   :=500;//500ms
      //other
      x.lastfindalignpos:=-1;
      x.landscape     :=false;
      x.wrapstyle     :=wwsWindow;//wrap to window - 12mar2021 (was wwsPage)
      x.wrapreadonly  :=false;//12mar2021
      x.usezoom       :=true;//14mar2021
      x.lastzoom      :=1;//internal use only - 14mar2021
      //.paper support - 12mar2021
      x.papersize     :=psA4;
      x.paperwidth    :=210;
      x.paperheight   :=297;
      x.dpi           :=95;//default=95, widescreen=120
      x.widestline    :=0;//used only in "wrapstyle=wwsNone" mode - 12mar2021
      //multi-undo support - 25jun2022
      x.menabled  :=false;
      x.mlimit    :=200;//03jul2022
      x.mstyle    :=musNone;//02jul2022
      x.mlist     :=nil;
      x.md1       :=nil;
      x.md2       :=nil;
      x.md3       :=nil;
      for p:=low(x.mn) to high(x.mn) do x.mn[p]:='';//stores only the NAME part and path is assumed to be local temp folder - 26jun2022
      mclear(false);
      //system
      x.dataonly      :=(xcmd='init.dataonly');//07dec2019
      x.timer100      :=ms64;
      x.timerslow     :=ms64;
      x.timerfont500  :=ms64;
      x.idleref       :=ms64+x.c_idlepause;
      x.k_idleref     :=ms64+x.c_idlepause;//26sep2022
      x.timerbusy     :=false;
      x.wrapstack     :=bnew;
      x.kstack        :=bnew;
      x.mstack        :=bnew;
      x.briefstatus   :='';
      x.shortcuts     :=true;
      x.styleshortcuts:=true;
      x.flashcursor   :=false;
      x.drawcursor    :=true;
      x.cursoronscrn  :=false;
      x.linecursorx   :=0;
      x.havefocus     :=true;
      x.showcursor    :=true;
      x.readonly      :=false;
      x.shift         :=false;
      x.wasdown       :=false;
      x.wasright      :=false;
      x.feather       :=0;//off
      x.sysfeather    :=true;//26aug2020
      //.buffer support -> used for screen painting
      x.buffer24      :=nil;//when in use, it should be 32bit - 29aug2019
      x.bufferref     :='';
      x.vpos          :=0;
      x.vposPART      :=0;//21jun2022
      x.vhostsync     :=false;
      x.vcheck        :=0;
      x.hpos          :=0;
      x.hhostsync     :=false;
      x.syncref       :='';
      //get
      try
      for p:=0 to imax do
      begin
      //font list
      x.lgfdata[p]     :=nil;//create's "tstr8" when required - 21aug2020
      x.lgfnref[p]     :='';
      //text list
      x.txtname[p]     :='';
      x.txtsize[p]     :=0;
      x.txtzoom[p]     :=1;//14mar2021
      x.txtbold[p]     :=false;
      x.txtitalic[p]   :=false;
      x.txtunderline[p]:=false;
      x.txtstrikeout[p]:=false;
      x.txtcolor[p]    :=0;
      x.txtbk[p]       :=clnone;//off - //was: int1; - 21jun2022
      x.txtborder[p]   :=clnone;//off
      x.txtalign[p]    :=wcaLeft;
      x.txtid[p]       :=0;//set to default
      //image list
      x.imgdata[p]    :=nil;//creates "tstr8" when required
      x.img24[p]      :=nil;//** as above
      x.imgw[p]       :=1;
      x.imgh[p]       :=1;
      end;//p
      //data streams
      x.data          :=bnew;
      x.data2         :=bnew;
      x.data3         :=bnew;
      x.data.addbyt1(10);
      x.data2.addbyt1(0);
      x.data3.addbyt1(0);
      //.alt data streams - 26jun2022
      x.alt1          :=nil;
      x.alt2          :=nil;
      x.alt3          :=nil;
      //support streams
      x.linesize:=0;
      x.listsize:=0;
      x.corelinex     :=bnew;
      x.coreliney     :=bnew;
      x.corelineh     :=bnew;
      x.corelineh1    :=bnew;
      x.corelinep     :=bnew;
      //.size -> ready for use
      xatleast('line',1000);
      except;end;
      //special options - 06oct2020
      x.defCopyformat :='multi';//was: 'txt';
      x.defFontname   :='$fontname';
      x.defFontsize   :=12;
      x.defFontcolor  :=0;
      //current default
      cdefault;//05jul2022
      //paint
      x.cursorpos     :=1;
      x.cursorpos2    :=1;
      x.pagewidth     :=800;
      x.pageheight    :=maxint;//continuous
      x.pagecolor     :=low__rgb(255,255,255);
      x.pagecolor2    :=low__rgb(240,240,240);
      x.pagefontcolor2:=low__rgb(0,0,0);
      x.pagecolorise2 :=false;                 
      x.pageoverride2 :=false;//enacts "pagecolor2" and "pagefontcolor2"
      x.pageselcolor  :=low__rgb(136,195,255);//text.background highlight
      x.pagefontselcolor:=low__rgb(0,0,160);//text.font highlight
      x.viewwidth     :=800;
      x.viewheight    :=600;
      x.viewcolor     :=low__rgb(152,152,152);
      x.pagecount     :=1;
      x.totalheight   :=0;
      x.linecount     :=0;
      x.line          :=0;
      x.col           :=0;
      x.wrapcount     :=0;
      x.dataid        :=0;
      x.dataid2       :=0;//only time this datais is ever reset by the control - this is a PERSISTEN dataid handler - 14jun2022
      x.modified      :=false;
      x.mustpaint     :=true;
      x.paintlock     :=false;
      x.cursorstyle   :='t';//text cursor
      //.reference
      x.bwd_color     :=clnone;
      x.bwd_color2    :=clnone;
      x.bwd_bk        :=clnone;
      //.claude support - optional - 14jul2020
      x.useclaudecolors :=false;
      x.claude_text1    :=0;
      x.claude_text2    :=0;
      x.claude_text3    :=0;
      x.claude_text4    :=0;
      x.claude_text5    :=0;
      x.claude_header1  :=0;
      x.claude_header2  :=0;
      x.claude_header3  :=0;
      x.claude_header4  :=0;
      x.claude_header5  :=0;
      //.special actions - 19apr2021
      x.oviewurl        :=true;
      //finalise
      x.initstate:='inited';
      //successful
      result:=true;
      goto skipend;
      end
   else
      begin
      e:='Must init';
      goto skipend;
      end;
   end;

//-- information ---------------------------------------------------------------
if (xcmd='init') or (xcmd='init.dataonly') then
   begin
   //nil
   end
//.optional toolbar support #2
else if (xcmd='cwritesel') then cwritesel(xvalstr)
else if (xcmd='cwritesel.hasundo') then
   begin
   //was: mstore5('writesel',xselcount,false);
   mstore1;
   x.mstyle:=musSelKeep;
   mstore1;
   cwritesel(xvalstr);//28jun2022
   end
else if (xcmd='canstyle') then xoutval:=bnc(not x.readonly)//12jun2022, 26aug2020
else if (xcmd='style') or (xcmd='style2') then
   begin
   if (not x.readonly) or (xcmd='style2') then//style2 overrides "readonly" - 26aug2020
      begin
      bol1:=(x.maxformatlevel>=1);
      str1:=low__lowercase(xvalstr);
      str2:='cwritesel.hasundo';
      if (str1='bold') and bol1 then
         begin
         x.cbold:=not x.cbold;
         low__wordcore_str(x,str2,str1);
         end
      else if (str1='italic') and bol1 then
         begin
         x.citalic:=not x.citalic;
         low__wordcore_str(x,str2,str1);
         end
      else if (str1='underline') and bol1 then
         begin
         x.cunderline:=not x.cunderline;
         low__wordcore_str(x,str2,str1);
         end
      else if (str1='strikeout') and bol1 then
         begin
         x.cstrikeout:=not x.cstrikeout;
         low__wordcore_str(x,str2,str1);
         end
      else if (str1='normal') and bol1 then
         begin
         x.cbold:=false;
         x.citalic:=false;
         x.cunderline:=false;
         x.cstrikeout:=false;
         x.ccolor:=0;
         x.cbk:=clnone;
         x.cborder:=clnone;
         low__wordcore_str(x,str2,'color+bk+style');//02jun2020
         end
      else if (str1='highlight') and bol1 then
         begin
         low__swapint(x.ccolor,x.cbk);
         if (x.onefontname<>'') and (x.ccolor<>clnone) and (x.cbk<>clnone) then x.cbk:=clnone;
         low__wordcore_str(x,str2,'color+bk');//include both font.color and background.color
         end
      else if (str1='alignment') and bol1 then
         begin
         int1:=x.calign+1;//0=left, 1=centre, 2=right
         if (int1>wcaMax) then int1:=wcaLeft;
         x.calign:=int1;
         low__wordcore_str(x,str2,inttostr(int1));//include both font.color and background.color
         end
      else if (str1='uppercase') then
         begin
         low__wordcore_str(x,str2,str1);
         end
      else if (str1='lowercase') then
         begin
         low__wordcore_str(x,str2,str1);
         end;
      end;
   end
else if (xcmd='canalign') then xoutval:=bnc(not x.readonly)//19jun2022
else if (xcmd='align') or (xcmd='align2') then
   begin
   if (not x.readonly) or (xcmd='align2') then//align2 overrides "readonly" - 19jun2022
      begin
      bol1:=(x.maxformatlevel>=2);//bwp only
      str1:=low__lowercase(xvalstr);
      //filter
      if      (str1='l') or (str1='left')   then str1:='0'
      else if (str1='c') or (str1='center') then str1:='1'
      else if (str1='r') or (str1='right')  then str1:='2';
      //get
      if bol1 then
         begin
         x.calign:=frcrange(strint(str1),0,2);//0=left, 1=centre, 2=right
         cwritealign;
         end;
      end;
   end
//04jun2020
else if (xcmd='cwritealign') then cwritealign
//
//.paint
else if (xcmd='canpaint') then
   begin
   if (x.wrapstack.len<=0) then xoutval:='1';
   end
else if (xcmd='mustpaint') then
   begin
   //set
   if (xvalstr<>'') then x.mustpaint:=(strint(xvalstr)<>0);
   //get
   if x.mustpaint then xoutval:='1';
   end
else if (xcmd='paintlock') then
   begin
   if (xvalstr<>'') then
      begin
      bol1:=(strint(xvalstr)<>0);
      if bol1 and x.paintlock then xoutval:='0'//already painting
      else
         begin
         x.paintlock:=bol1;
         xoutval:='1';
         end;
      end;
   end
else if (xcmd='havefocus') then
   begin
   //set
   if (xvalstr<>'') then
      begin
      bol1:=x.havefocus;
      x.havefocus:=(strint(xvalstr)<>0);
      if (bol1<>x.havefocus) then x.mustpaint:=true;
      end;
   //get
   if x.havefocus then xoutval:='1';
   end
else if (xcmd='showcursor') then
   begin
   //set
   if (xvalstr<>'') then
      begin
      bol1:=x.showcursor;
      x.showcursor:=(strint(xvalstr)<>0);
      if (bol1<>x.showcursor) then x.mustpaint:=true;
      end;
   //get
   if x.showcursor then xoutval:='1';
   end
//.keyboard support
else if (xcmd='kstack') then
   begin
   if (blen(xval)>=1) then
      begin
      x.kstack.addint4(xval.len);
      x.kstack.add(xval);
      end;
   end
//.mouse support
else if (xcmd='mstack') then
   begin
   if (blen(xval)>=1) then
      begin
      x.mstack.addint4(xval.len);
      x.mstack.add(xval);
      end;
   end
else if (xcmd='briefstatus') then
   begin
   xoutval:=x.briefstatus;
   x.briefstatus:='';
   end
//.wrap
else if (xcmd='wrap') then xwrapadd(0,0)//restart wrap
else if (xcmd='wrapto') then
   begin
   int1:=strint(xvalstr);
   if (int1>x.wrapcount) then xwrapadd(x.wrapcount,int1)//auto wrap
   end
else if (xcmd='wrapall') then xwrapadd(0,blen(x.data))
else if (xcmd='wrapbusy') then//18dec2021
   begin
   int1:=0;
   if (x.wrapstack.len>=1) then int1:=1;
   xoutval:=inttostr(int1);//fixed - 21jun2022
   end
else if (xcmd='wrapdone') then//21jun2022
   begin
   if (x.wrapcount>=x.data.len) then xoutval:='1';
   end
//.font style
//04jun2020
else if (xcmd='findalign') then//find alignment value based on input position "1..length(x.data)"
   begin
   xoutval:='0';//0=left, 1=centre, 2=right
   if (x.data.len>=1) and (xvalstr<>'') then
      begin
      int1:=low__wordcore2(x,'pos>rc',xval);//find nearest return code "#10"
      x.lastfindalignpos:=int1;//used for fast cache reference
      if low__wordcore__charinfo(x,int1,xchar) and (xchar.cs=wc_t) and (xchar.c=10) then xoutval:=inttostr(x.txtalign[xchar.wid]);
      end;
   end
//
//.other
else if (xcmd='selstart') then xoutval:=inttostr(xselstart)
else if (xcmd='selcount') then xoutval:=inttostr(xselcount)
else if (xcmd='cursorpos') then
   begin
   //set
   if (xvalstr<>'') then
      begin
      xsetcursorpos(strint(xvalstr));
      xchanged;
      end;
   //get
   xoutval:=inttostr(x.cursorpos);
   end
else if (xcmd='cursorpos2') then
   begin
   //set
   if (xvalstr<>'') then
      begin
      x.cursorpos2:=frcrange(strint(xvalstr),1,blen(x.data));
      int1:=x.cursorpos2+x.c_pagewrap;
      if (int1>x.wrapcount) then xwrapadd(x.wrapcount,int1);
      xchanged;
      end;
   //get
   xoutval:=inttostr(x.cursorpos2);
   end
else if (xcmd='wrapstyle') then//12mar2021
   begin
   if (xvalstr<>'') and low__setint(x.wrapstyle,frcrange(strint(xvalstr),0,wwsMax)) then
      begin
      xpagewidth;
      xwrap_hvsync_changed;
      end;
   xoutval:=inttostr(x.wrapstyle);
   end
else if (xcmd='papersize') then
   begin
   //init
   int1:=x.paperwidth;//paper width
   int2:=x.paperheight;//paper height
   //get
   if (xvalstr<>'') and low__setint(x.papersize,frcrange(strint(xvalstr),0,psMax)) then
      begin
      case x.papersize of
      psA3:begin
         int1:=297;
         int2:=420;
         end;
      psA4:begin
         int1:=210;
         int2:=297;
         end;
      psA5:begin
         int1:=148;
         int2:=210;
         end;
      psLetter:begin
         int1:=215;
         int2:=279;
         end;
      psLegal:begin
         int1:=215;
         int2:=355;
         end;
      else
         begin//fallback to A4
         int1:=210;
         int2:=297;
         end;
      end;//case
      end;
   //set
   if (int1<>x.paperwidth) or (int2<>x.paperheight) then
      begin
      x.paperwidth:=int1;
      x.paperheight:=int2;
      if (x.wrapstyle=wwsPage) then
         begin
         xpagewidth;
         xwrap_hvsync_changed;
         end;
      end;
   //return
   xoutval:=inttostr(x.papersize);
   end
else if (xcmd='paperwidth') then xoutval:=inttostr(x.paperwidth)//read-only
else if (xcmd='paperheight') then xoutval:=inttostr(x.paperheight)//read-only
else if (xcmd='pagewidth') then xoutval:=inttostr(x.pagewidth)//read-only
else if (xcmd='pageheight') then xoutval:=inttostr(x.pageheight)//read-only
else if (xcmd='useclaudecolors') then//14jul2020
   begin
   //set
   if (xvalstr<>'') then
      begin
      bol1:=x.useclaudecolors;
      x.useclaudecolors:=nbs(xvalstr);
      if (bol1<>x.useclaudecolors) then xchanged;
      end;
   //get
   xoutval:=bnc(x.useclaudecolors);
   end
else if (xcmd='auto.pagecolor') then xoutval:=inttostr(low__aorb(x.pagecolor,x.pagecolor2,x.pageoverride2))//auto detect current pagecolor
else if (xcmd='pagecolor') then
   begin
   //set
   if (xvalstr<>'') then
      begin
      i:=x.pagecolor;
      x.pagecolor:=strint(xvalstr);
      if (i<>x.pagecolor) then xchanged;
      end;
   //get
   xoutval:=inttostr(x.pagecolor);
   end
else if (xcmd='pagecolor2') then
   begin
   //set
   if (xvalstr<>'') then
      begin
      i:=x.pagecolor2;
      x.pagecolor2:=strint(xvalstr);
      if (i<>x.pagecolor2) then xchanged;
      end;
   //get
   xoutval:=inttostr(x.pagecolor2);
   end
else if (xcmd='pagefontcolor2') then
   begin
   //set
   if (xvalstr<>'') then
      begin
      i:=x.pagefontcolor2;
      x.pagefontcolor2:=strint(xvalstr);
      if (i<>x.pagefontcolor2) then xchanged;
      end;
   //get
   xoutval:=inttostr(x.pagefontcolor2);
   end
else if (xcmd='pagecolorise2') then
   begin
   //set
   if (xvalstr<>'') then
      begin
      bol1:=x.pagecolorise2;
      x.pagecolorise2:=(strint(xvalstr)<>0);
      if (bol1<>x.pagecolorise2) then xchanged;
      end;
   //get
   xoutval:=bnc(x.pagecolorise2);
   end
else if (xcmd='pageoverride2') then
   begin
   //set
   if (xvalstr<>'') then
      begin
      bol1:=x.pageoverride2;
      x.pageoverride2:=(strint(xvalstr)<>0);
      if (bol1<>x.pageoverride2) then xchanged;
      end;
   //get
   xoutval:=bnc(x.pageoverride2);
   end
else if (xcmd='pageselcolor') then
   begin
   //set
   if (xvalstr<>'') then
      begin
      i:=x.pageselcolor;
      x.pageselcolor:=strint(xvalstr);
      if (i<>x.pageselcolor) then xchanged;
      end;
   //get
   xoutval:=inttostr(x.pageselcolor);
   end
else if (xcmd='pagefontselcolor') then
   begin
   //set
   if (xvalstr<>'') then
      begin
      i:=x.pagefontselcolor;
      x.pagefontselcolor:=strint(xvalstr);
      if (i<>x.pagefontselcolor) then xchanged;
      end;
   //get
   xoutval:=inttostr(x.pagefontselcolor);
   end
//.host viewing area
else if (xcmd='viewwidth') then
   begin
   //set
   if (xvalstr<>'') then
      begin
      i:=x.viewwidth;
      x.viewwidth:=frcmin(strint(xvalstr),1);
      if (i<>x.viewwidth) then
         begin
         xpagewidth;
         xwrap_hvsync_changed;
//         x.hhostsync:=true;
//         x.vhostsync:=true;
//         x.mustpaint:=true;
         end;
      end;
   //get
   xoutval:=inttostr(x.viewwidth);
   end
else if (xcmd='viewheight') then
   begin
   //set
   if (xvalstr<>'') then
      begin
      i:=x.viewheight;
      x.viewheight:=frcmin(strint(xvalstr),1);
      if (i<>x.viewheight) then
         begin
         x.vhostsync:=true;
         x.mustpaint:=true;
         end;
      end;
   //get
   xoutval:=inttostr(x.viewheight);
   end
else if (xcmd='viewcolor') then
   begin
   //set
   if (xvalstr<>'') then
      begin
      i:=x.viewcolor;
      x.viewcolor:=strint(xvalstr);
      if (i<>x.viewcolor) then xchanged;
      end;
   //get
   xoutval:=inttostr(x.viewcolor);
   end
//.host v/h scrollbar ranges
else if (xcmd='vmax') then xoutval:=inttostr(frcmin(x.linecount-1,0))
else if (xcmd='vpos') then
   begin
   int1:=frcmin(x.linecount-1,0);
   //set
   if (xvalstr<>'') then
      begin
      int2:=frcrange(xwrapfinish(strint(xvalstr),false),0,frcmin(x.linecount-1,0));
      if (x.vpos<>int2) then
         begin
         x.vpos:=int2;
         x.vposPART:=0;
         x.mustpaint:=true;
         x.vhostsync:=true;//sync vertical scrollbar when cursor is NOT showing (e.g. readonly mode) - 27aug2021
         end;
      end;
   //get
   xoutval:=inttostr(frcrange(x.vpos,0,int1));
   end
else if (xcmd='vhostsync') then//tells host it must re-sync vertical scrollbar
   begin
   if (xvalstr<>'') then x.vhostsync:=(strint(xvalstr)<>0);//set
   if x.vhostsync then xoutval:='1';//get
   end
//.v - pixel version - 21jun2022
else if (xcmd='vmax.px') then xoutval:=inttostr(frcmin(x.totalheight-1,0))
else if (xcmd='vpos.px') then
   begin
   int1:=frcmin(x.totalheight-1,0);
   int4:=0;
   //set
   if (xvalstr<>'') then
      begin
      int2:=frcrange(xwrapfinish(strint(xvalstr),true),0,frcmin(x.totalheight-1,0));
      int3:=frcmin(low__wordcore_str2(x,'y>line',xvalstr),0);
      if (int3>=0) then int4:=x.liney[int3] else int4:=0;
      if (x.vpos<>int3) or ((int4+x.vposPART)<>int2) then
         begin
         x.vpos:=int3;
         x.vposPART:=int2-int4;
         x.mustpaint:=true;
         x.vhostsync:=true;//sync vertical scrollbar when cursor is NOT showing (e.g. readonly mode) - 27aug2021
         end;
      end;
   //get
   int1:=x.vposPART;
   if (x.linecount>=1) then
      begin
      int2:=frcrange(x.vpos,0,frcmin(x.linecount-1,0));
      inc(int1,x.liney[int2]);
      end;
   xoutval:=inttostr(int1);
   end
//.h
else if (xcmd='hmax') then xoutval:=inttostr(frcmin(x.pagewidth-x.viewwidth,0))
else if (xcmd='hpos') then
   begin
   int1:=frcmin(x.pagewidth-x.viewwidth,0);
   //set
   if (xvalstr<>'') then
      begin
      int2:=frcrange(strint(xvalstr),0,int1);
      if (x.hpos<>int2) then
         begin
         x.hpos:=int2;
         x.mustpaint:=true;
         end;
      end;
   //get
   xoutval:=inttostr(frcrange(x.hpos,0,int1));
   end
else if (xcmd='hpos2') then//only return hpos value if showing the horizontal scrollbar
   begin
   int1:=frcmin(x.pagewidth-x.viewwidth,0);
   if (int1>=1) then xoutval:=inttostr(frcrange(x.hpos,0,int1));
   end
else if (xcmd='hshow') then
   begin
   case x.wrapstyle of
   wwsNone   :xoutval:='1';
   wwsWindow :xoutval:='0';
   wwsPage   :if (x.pagewidth<=x.viewwidth) then xoutval:='0' else xoutval:='1';
   end;//case
   end
else if (xcmd='hhostsync') then//tells host it must re-sync horizontal scrollbar
   begin
   if (xvalstr<>'') then x.hhostsync:=(strint(xvalstr)<>0);//set
   if x.hhostsync then xoutval:='1';//get
   end
//.other
else if (xcmd='totalheight') then xoutval:=inttostr(x.totalheight)
else if (xcmd='dataid') then
   begin
   //set
   if (xvalstr<>'') then x.dataid:=frcmin(strint(xvalstr),0);
   //get
   xoutval:=inttostr(x.dataid);
   end
else if (xcmd='modified') then
   begin
   if (xvalstr<>'') then x.modified:=(xvalstr<>'0');
   xoutval:=bnc(x.modified);
   end
else if (xcmd='feather') then
   begin
   if (xvalstr<>'') then x.feather:=frcrange(strint(xvalstr),0,4);//feather//permit larger range?????????????????//xxxxxxxxxxxxxxxxxxxxx//feather - 21aug2020
   xoutval:=inttostr(x.feather);
   end
else if (xcmd='linecount') then xoutval:=inttostr(x.linecount)
else if (xcmd='line') then xoutval:=inttostr(x.line)
else if (xcmd='col') then xoutval:=inttostr(x.col)
else if (xcmd='bytes') then xoutval:=inttostr(frcmin( (blen(x.data)-1)*3 ,0))//just text data -> images and fonts MAY NOT be in use, but MAY BE present in the cache system - 24aug2019
else if (xcmd='haveshortcut') then
   begin
   xoutval:='0';
   if x.shortcuts then
      begin
      case strint(xvalstr) of
      akctrlP,akctrlT,akctrlC,akctrlU,akctrlR,akctrlS,akctrlN,akctrlB,akctrlI,akctrlD,akctrlK,akctrlH,akctrlZ:xoutval:='1';
      end;//case
      end;
   end
//-- actions -------------------------------------------------------------------
else if (xcmd='free') then
   begin
   x.initstate:='';//disable control
   //.core data streams
   bfree(x.data);
   bfree(x.data2);
   bfree(x.data3);
   //.support items
   for p:=0 to imax do
   begin
   if zzok(x.lgfdata[p],7056) then bfree(x.lgfdata[p]);
   x.lgfnref[p]:='';
   x.txtname[p]:='';
   if zzok(x.imgdata[p],7057) then bfree(x.imgdata[p]);
   if zzok(x.img24[p],7058) then freeobj(@x.img24[p]);
   end;//p
   //.support refs
   bfree(x.corelinex);
   bfree(x.coreliney);
   bfree(x.corelineh);
   bfree(x.corelineh1);
   bfree(x.corelinep);
   //..stacks - 11jan202
   bfree(x.wrapstack);
   bfree(x.kstack);
   bfree(x.mstack);
   //.undo
   mclear(true);
   bfree(x.mlist);
   bfree(x.md1);
   bfree(x.md2);
   bfree(x.md3);
   //.buffer
   freeobj(@x.buffer24);
   end
//.clearall - 27sep2022
else if (xcmd='canclearall') or (xcmd='canclear') or (xcmd='canclear2') then xoutval:='1'
else if (xcmd='clearall') or (xcmd='clear') or (xcmd='clear2') then//Note: clear2 does NOT wipe undo
   begin
   //.doing this first PREVENTS memory consumption from climbing - 27sep2022
   mstore1;//previous
   x.cursorpos:=1;
   x.cursorpos2:=blen(x.data);
   x.mstyle:=musSel;
   mstore1;
   cdefault;
   //.clear everything - 27sep2022
   x.widestline:=0;//12mar2021
   x.data.replacebyt1:=10;
   x.data2.replacebyt1:=0;
   x.data2.replacebyt1:=0;
   for p:=0 to imax do
   begin
   if zzok(x.lgfdata[p],7059) then x.lgfdata[p].clear;//once created don't destroy, shrink only -> max. stability - 21aug2020
   x.lgfnref[p]:='';
   x.txtname[p]:='';
   if zzok(x.imgdata[p],7060) then x.imgdata[p].clear;
   if zzok(x.img24[p],7061) then x.img24[p].sizeto(1,1);
   end;//p
   //.current defaults - 05jul2022
   cdefault;
   //finalise
   x.cursorpos     :=1;
   x.cursorpos2    :=1;
   x.linecount     :=0;
   x.line          :=0;
   x.col           :=0;
   x.dataid        :=0;
   x.modified      :=false;
   x.wrapcount     :=0;
   x.wrapstack.clear;
   x.mustpaint     :=true;
   //.reference
   x.bwd_color     :=clnone;
   x.bwd_color2    :=clnone;
   x.bwd_bk        :=clnone;
   //.undo clear
   if (xcmd='clearall') or (xcmd='clear') then mclear(true);
   end
else if (xcmd='mincheck') then xmincheck
else if (xcmd='ins') or (xcmd='ins2') then//ins2 overrides readonly
   begin
   if (not x.readonly) or (xcmd='ins2') then
      begin
      //init
      xnoidle;
      knoidle;
      int1:=x.cursorpos;
      //filter text -> remove any characters in the system range
      low__wordcore__filtertext(xval);

      //check
      if (x.mstyle<>musIns) or (xselstart<>(x.mfrom1+x.mlen)) then
         begin
         mstore1;
         x.mstyle:=musIns;
         x.mfrom1:=xselstart;
         x.mlen  :=0;
         end;
      //get
      bol1:=true;
      if (xselcount>=1) then
         begin
         x.mstyle:=musSel;
         mstore1;
         end;
      //insert text
      if (blen(xval)>=1) then
         begin
         if (x.mstyle<>musIns) then
            begin
            x.mstyle:=musIns;
            x.mfrom1:=xselstart;
            x.mlen  :=0;
            end;
         xneed123;
         xstr1.replace:=xval;
         xstr2.replace:=xval;
         xstr3.replace:=xval;
         wrd2.val:=xmakefont;//once only
         for p:=1 to blen(xstr1) do
         begin
         c:=xstr1.byt1[p-1];//was: str1[p];
         if (xstyle(c)<>wc_t) then c:=63;//'?';
         xstr1.byt1[p-1]:=c;
         xstr2.byt1[p-1]:=wrd2.bytes[0];
         xstr3.byt1[p-1]:=wrd2.bytes[1];
         end;//p
         //get
         xmincheck;
         inc(x.mlen,blen(xstr1));
         int2:=x.cursorpos;
         x. data.ins(xstr1,int2-1);  //was: insert(str1,x.data ,int2);
         x.data2.ins(xstr2,int2-1);  //was: insert(str2,x.data2,int2);
         x.data3.ins(xstr3,int2-1);  //was: insert(str3,x.data3,int2);
         xsetcursorpos(int2+blen(xstr1));
         xwrapadd(xlinebefore(int2),int2+blen(xstr1)+x.c_pagewrap);
         x.timer_chklinecursorx:=true;
         xchanged;
         end;
      end;
   end
else if (xcmd='insimg') or (xcmd='insimg.noundo') then
   begin
   if (not x.readonly) and (x.maxformatlevel>=2) then
      begin
      xnoidle;
      knoidle;
      //undo + insert image
      if (blen(xval)>=1) then
         begin
         //init
         xneed123;
         xstr1.replacebyt1:=0;
         wrd2.val:=xmakeimage2(xval);
         xstr2.replacebyt1:=wrd2.bytes[0];
         xstr3.replacebyt1:=wrd2.bytes[1];
         //get
         xmincheck;
         int2:=xselstart;
         //m-undo
         if (xcmd='insimg') then
            begin
            mstore1;//previous
            if (xselcount>=1) then
               begin
               x.mstyle:=musSel;
               mstore1;
               end;
            x.mstyle:=musInsImg;
            x.mfrom1:=int2;
            x.mlen:=1;//1 byte for the image in the datastream below - 02jul2022
            end;
         x.data.ins(xstr1,int2-1);   //was: insert(str1,x.data ,int2);
         x.data2.ins(xstr2,int2-1);  //was: insert(str2,x.data2,int2);
         x.data3.ins(xstr3,int2-1);  //was: insert(str3,x.data3,int2);
         xsetcursorpos(int2+blen(xstr1));
         xwrapadd(xlinebefore(int2),int2+blen(xstr1)+x.c_pagewrap);
         x.timer_chklinecursorx:=true;
         xchanged;
         end;
      end;
   end
//04jun2020
else if (xcmd='all') then cwriteall(xvalstr)
else if (xcmd='selectall') then
   begin
   low__wordcore_str(x,'cursorpos',inttostr(1));
   low__wordcore_str(x,'cursorpos2',inttostr(blen(x.data)));
   end
//.deleteall - 28jun2022
else if (xcmd='candeleteall') then xoutval:=bnc((not x.readonly) and (x.data.len>=2))
else if (xcmd='deleteall') then
   begin
   if (not x.readonly) and (x.data.len>=2) then
      begin
      mstore1;//previous
      x.cursorpos:=1;
      x.cursorpos2:=blen(x.data);
      x.mstyle:=musSel;
      mstore1;
      cdefault;
      //successful
      xoutval:='1';
      end;
   end
//.cut
else if (xcmd='cancut') then xoutval:=bnc((not x.readonly) and (xselcount>=1))
else if (xcmd='cut') then
   begin
   if (not x.readonly) and (xselcount>=1) then
      begin
      xnoidle;
      knoidle;
      low__wordcore_str(x,'copy',xvalstr);//16mar2021
      if (xselcount>=1) then
         begin
         mstore1;//previous
         x.mstyle:=musSel;
         mstore1;
         end;
      end;
   end
else if (xcmd='cancopyany') then xoutval:='1'
else if (xcmd='copyany') then
   begin
   if (xselcount>=1) then low__wordcore(x,'copy',nil) else low__wordcore(x,'copyall',nil);
   end
else if (xcmd='cancopy') then xoutval:=bnc(xselcount>=1)
else if (xcmd='copy') then//handles bitmap+text image+text - 14jul2020, 05jun2020
   begin
   //init
   str1:=xvalstr;
   if (str1<>'txt') and (str1<>'txtwin') and (str1<>'bwd') and (str1<>'bwp') and (str1<>'rtf') and (str1<>'multi') then str1:=low__udv(x.defcopyformat,'txt');
   //get
   if (str1='multi') then
      begin
      if not low__copywordcore(false,x) then goto skipend;
      end
   else
      begin
      xneed1;
      xstr1.clear;
      if not low__wordcore4(x,'ioget',bcopystr1(str1+'# sel',1,maxint),xstr1,str2,e) then goto skipend;
      if not low__copytxt2b(xstr1.text) then goto skipend;
      end;
   xoutval:='1';//ok - 18jun2022
   end
else if (xcmd='cancopyall') then xoutval:='1'
else if (xcmd='copyall') then//handles bitmap+text image+text - 14jul2020, 05jun2020
   begin
   //init
   str1:=xvalstr;
   if (str1<>'txt') and (str1<>'txtwin') and (str1<>'bwd') and (str1<>'bwp') and (str1<>'rtf') then str1:=low__udv(x.defcopyformat,'txt');
   //get
   if (str1='multi') then
      begin
      if not low__copywordcore(true,x) then goto skipend;
      end
   else
      begin
      xneed1;
      xstr1.clear;
      if not low__wordcore4(x,'ioget',bcopystr1(str1+'# all',1,maxint),xstr1,str2,e) then goto skipend;
      if not low__copytxt2b(xstr1.text) then goto skipend;
      end;
   xoutval:='1';//ok - 18jun2022
   end
//pastereplace - 19jun2022
else if (xcmd='canpastereplace') then xoutval:=bnc((not x.readonly) and xcanpaste)
else if (xcmd='pastereplace') then//handles bitmap+text image+text
   begin
   if (not x.readonly) and xcanpaste then
      begin
      if not xpaste(true) then goto skipend;
      xoutval:='1';
      end;
   end
//paste
else if (xcmd='canpaste') then xoutval:=bnc((not x.readonly) and xcanpaste)
else if (xcmd='paste') then//handles bitmap+text image+text
   begin
   if (not x.readonly) and xcanpaste then
      begin
      if not xpaste(false) then goto skipend;
      xoutval:='1';
      end;
   end
else if (xcmd='dell') then
   begin
   if (not x.readonly) then
      begin
      //init
      xnoidle;
      knoidle;
      //check
      if (x.mstyle<>musDelL) or (xselstart<>x.mfrom1) then mstore1;
      //get
      if (xselcount>=1) then
         begin
         x.mstyle:=musSel;
         mstore1;
         end
      else if (x.cursorpos>=2) then
         begin
         int1:=xselstart-1;//x.cursorpos-1;
         if x.menabled and mdok and (int1>=1) and (int1<blen(x.data)) then
            begin
            if (x.mstyle<>musDelL) then
               begin
               x.mstyle:=musDelL;
               x.mfrom1:=int1;//xselstart;
               x.mlen  :=0;//not used
               end;
            x.md1.ains([x.data.pbytes[int1-1]],0);
            x.md2.ains([x.data2.pbytes[int1-1]],0);
            x.md3.ains([x.data3.pbytes[int1-1]],0);
            end;
         bdel1(x.data,int1,1);
         bdel1(x.data2,int1,1);
         bdel1(x.data3,int1,1);
         xmincheck;
         xsetcursorpos(int1);
         xwrapadd(xlinebefore(int1),int1+x.c_pagewrap);//04jun2020
         x.cursor_keyboard_moveto:=int1;
         x.timer_chklinecursorx:=true;
         xchanged;
         x.mfrom1:=xselstart;
         end;
      end;
   end
else if (xcmd='delr') then
   begin
   if (not x.readonly) then
      begin
      //init
      xnoidle;
      knoidle;
      int1:=x.cursorpos;
      //check
      if (x.mstyle<>musDelR) or (xselstart<>x.mfrom1) then mstore1;
      //get
      if (xselcount>=1) then
         begin
         x.mstyle:=musSel;
         mstore1;
         end
      else
         begin
         int1:=xselstart;//02jul2022
         if x.menabled and mdok and (int1>=1) and (int1<blen(x.data)) then
            begin
            if (x.mstyle<>musDelR) then
               begin
               x.mstyle:=musDelR;
               x.mfrom1:=int1;
               x.mlen:=0;//not used
               end;
            x.md1.aadd([x.data.pbytes[int1-1]]);
            x.md2.aadd([x.data2.pbytes[int1-1]]);
            x.md3.aadd([x.data3.pbytes[int1-1]]);
            end;
//         bdel1(x.data,x.cursorpos,1);
//         bdel1(x.data2,x.cursorpos,1);
//         bdel1(x.data3,x.cursorpos,1);
         bdel1(x.data,int1,1);
         bdel1(x.data2,int1,1);
         bdel1(x.data3,int1,1);
         xmincheck;
         xsetcursorpos(int1);//x.cursorpos);
         xwrapadd(xlinebefore(x.cursorpos),x.cursorpos+x.c_pagewrap);//04jun2020
         x.timer_chklinecursorx:=true;
         xchanged;
         end;
      end;
   end
//.move - wheel
else if (xcmd='vwheel') then
   begin
   //get
   int1:=strint(xvalstr);
   int3:=0;
   if (int1>=1) then
      begin
      for int2:=x.vpos to (x.vpos+int1-1) do
      begin
      if (int2>=0) and (int2<x.linecount) and (int2<x.linesize)  then dec(int3,x.lineh[int2]) else break;
      end;//int2
      end
   else if (int1<=-1) then
      begin
      for int2:=x.vpos downto (x.vpos+int1+1) do
      begin
      if (int2>=0) and (int2<x.linecount) and (int2<x.linesize)  then inc(int3,x.lineh[int2]) else break;
      end;//int2
      end;
   //set
   if (int3<>0) then
      begin
      int2:=frcmin(frcmax(100,x.viewheight div 3),10);
      low__wordcore_str(x,'vpos.px',inttostr(low__wordcore_str2(x,'vpos.px','')+frcrange(int3,-int2,int2)));
      end;
   end
//.move - cursor
else if (xcmd='move') then
   begin
   //init
   str1:=xvalstr;
   //left
   if low__comparetext(str1,'left') then
      begin
      x.cursor_keyboard_moveto:=frcrange(x.cursorpos-1,1,blen(x.data));
      x.timer_chklinecursorx:=true;
      end
   //line.start
   else if low__comparetext(str1,'line.start') then//31mar2021
      begin
      int1:=low__wordcore_str2(x,'pos>line',inttostr(x.cursorpos));
      int1:=low__wordcore_str2(x,'line>pos',inttostr(int1));
      //.already at start of line -> so go to end of previous line
      if (int1=x.cursorpos) then int1:=int1-1;
      x.cursor_keyboard_moveto:=frcrange(int1,1,blen(x.data));
      x.timer_chklinecursorx:=true;
      end
   //scoot.left
   else if low__comparetext(str1,'scoot.left') then//31mar2021
      begin
      if low__wordcore__charinfo(x,x.cursorpos-1,xchar) and (xchar.cs=wc_t) and ((xchar.c=ss10) or ((x.cursorpos-1)<=0)) then
         begin
         x.cursor_keyboard_moveto:=frcrange(x.cursorpos-1,1,blen(x.data));
         x.timer_chklinecursorx:=true;
         end
      else if (x.cursorpos>=3) then
         begin
         for int1:=(x.cursorpos-2) downto 1 do
         begin
         if not low__wordcore__charinfo(x,int1,xchar) then break
         else if (xchar.cs=wc_i) or ((xchar.cs=wc_t) and xscootable(xchar.c)) then
            begin
            x.cursor_keyboard_moveto:=frcrange(int1+1,1,blen(x.data));
            x.timer_chklinecursorx:=true;
            break;
            end
         else if (int1<=1) then//18jun2022
            begin
            x.cursor_keyboard_moveto:=frcrange(int1,1,blen(x.data));
            x.timer_chklinecursorx:=true;
            break;
            end;
         end;//int1
         end;
      end
   //right
   else if low__comparetext(str1,'right') then
      begin
      x.cursor_keyboard_moveto:=frcrange(x.cursorpos+1,1,blen(x.data));
      x.timer_chklinecursorx:=true;
      end
   //line.end
   else if low__comparetext(str1,'line.end') then
      begin
      int1:=low__wordcore_str2(x,'pos>line',inttostr(x.cursorpos));
      int1:=frcmin(low__wordcore_str2(x,'line>pos',inttostr(int1+1)),0);
      if (int1<blen(x.data)) then dec(int1,1);
      //.already at end of line -> so go to start of next line
      if (int1=x.cursorpos) then int1:=int1+1;
      x.cursor_keyboard_moveto:=frcrange(int1,1,blen(x.data));
      x.timer_chklinecursorx:=true;
      end
   //scoot.right
   else if low__comparetext(str1,'scoot.right') then//31mar2021
      begin
      if low__wordcore__charinfo(x,x.cursorpos,xchar) and (xchar.cs=wc_t) and (xchar.c=ss10) then
         begin
         x.cursor_keyboard_moveto:=frcrange(x.cursorpos+1,1,blen(x.data));
         x.timer_chklinecursorx:=true;
         end
      else if (x.cursorpos<=(blen(x.data)-2)) then
         begin
         for int1:=(x.cursorpos+1) to blen(x.data) do
         begin
         if not low__wordcore__charinfo(x,int1,xchar) then break
         else if (xchar.cs=wc_i) or ((xchar.cs=wc_t) and xscootable(xchar.c)) then
            begin
            x.cursor_keyboard_moveto:=frcrange(int1,1,blen(x.data));
            x.timer_chklinecursorx:=true;
            break;
            end;
         end;//int1
         end;
      end
   //up
   else if low__comparetext(str1,'up') then
      begin
      xline:=low__wordcore_str2(x,'pos>line',inttostr(x.cursorpos))-1;
      if (xline<0) then
         begin
         x.cursor_keyboard_moveto:=1;
         x.timer_chklinecursorx:=true;
         end
      else if xsafeline(xline) then
         begin
         int1:=x.linep[xline];
         int2:=int1;
         int3:=low__wordcore_str2(x,'line>pos',inttostr(xline+1))-1;
         if (int3>=int2) then
            begin
            dx:=x.linex[xline];
            for p:=int2 to int3 do
            begin
            if not low__wordcore__charinfo(x,p,xchar) then break;
            if (dx<=x.linecursorx) then int1:=p;
            inc(dx,xchar.width);
            end;//p
            end;//if
         x.cursor_keyboard_moveto:=frcrange(int1,1,blen(x.data));
         end;
      end
   //down
   else if low__comparetext(str1,'down') then
      begin
      xline:=low__wordcore_str2(x,'pos>line',inttostr(x.cursorpos))+1;
      if xsafeline(xline) then
         begin
         int1:=x.linep[xline];
         int2:=int1;
         int3:=low__wordcore_str2(x,'line>pos',inttostr(xline+1))-1;
         if (int3>=int2) then
            begin
            dx:=x.linex[xline];
            for p:=int2 to int3 do
            begin
            if not low__wordcore__charinfo(x,p,xchar) then break;
            if (dx<=x.linecursorx) then int1:=p;
            inc(dx,xchar.width);
            end;//p
            end;//if
         x.cursor_keyboard_moveto:=frcrange(int1,1,blen(x.data));
         end;
      end
   //pageup
   else if low__comparetext(str1,'pageup') then
      begin
      //scan up X lines
      xline:=low__wordcore_str2(x,'pos>line',inttostr(x.cursorpos));
      int3:=xline;
      if xsafeline(xline) then
         begin
         bol1:=false;
         int1:=xline;
         int2:=xline;
         while true do
         begin
         dec(int2);
         if not xsafeline(int2) then break;
         if ((x.liney[int1]-x.liney[int2])>x.viewheight) and bol1 then break;
         xline:=int2;
         bol1:=true;
         end;//while
         end;
      //get
      if (xline<0) then
         begin
         x.cursor_keyboard_moveto:=1;
         x.timer_chklinecursorx:=true;
         end
      else if xsafeline(xline) then
         begin
         int1:=x.linep[xline];
         int2:=int1;
         int3:=low__wordcore_str2(x,'line>pos',inttostr(xline+1))-1;
         if (int3>=int2) then
            begin
            dx:=x.linex[xline];
            for p:=int2 to int3 do
            begin
            if not low__wordcore__charinfo(x,p,xchar) then break;
            if (dx<=x.linecursorx) then int1:=p;
            inc(dx,xchar.width);
            end;//p
            end;//if
         x.cursor_keyboard_moveto:=frcrange(int1,1,blen(x.data));
         end;
      end
   //pagedown
   else if low__comparetext(str1,'pagedown') then
      begin
      //scan up X lines
      xline:=low__wordcore_str2(x,'pos>line',inttostr(x.cursorpos));
      int3:=xline;
      if xsafeline(xline) then
         begin
         bol1:=false;
         int1:=xline;
         int2:=xline;
         while true do
         begin
         inc(int2);
         if not xsafeline(int2) then break;
         if ((x.liney[int2]-x.liney[int1])>x.viewheight) and bol1 then break;//force atleast ONE line increment -> covers images that span MANY lines/pages in one go - 21jun2022
         xline:=int2;
         bol1:=true;
         end;//while
         end;
      //get
      if xsafeline(xline) then
         begin
         int1:=x.linep[xline];
         int2:=int1;
         int3:=low__wordcore_str2(x,'line>pos',inttostr(xline+1))-1;
         if (int3>=int2) then
            begin
            dx:=x.linex[xline];
            for p:=int2 to int3 do
            begin
            if not low__wordcore__charinfo(x,p,xchar) then break;
            if (dx<=x.linecursorx) then int1:=p;
            inc(dx,xchar.width);
            end;//p
            end;//if
         x.cursor_keyboard_moveto:=frcrange(int1,1,blen(x.data));
         end;
      end
   //home
   else if low__comparetext(str1,'home') then x.cursor_keyboard_moveto:=1
   //end
   else if low__comparetext(str1,'end') then x.cursor_keyboard_moveto:=blen(x.data)
   //error
   else
      begin
      showerror('Wordcore: Unknown move directive "'+xvalstr+'"');
      end;
   end
//.find previous line start "xpos"
//04jun2020
else if (xcmd='pos>line-1>pos') then//expects input of xpos=1..x.data.len
   begin
   xoutval:='1';
   if (blen(xval)>=1) then
      begin
      int1:=frcmin(low__wordcore2(x,'pos>line',xval)-1,0);
      xoutval:=inttostr(frcrange(low__wordcore_str2(x,'line>pos',inttostr(int1)),1,blen(x.data)));
      end;
   end
//
//.find earliest line by "xpos"
else if (xcmd='pos>line') then//expects input of xpos=1..x.data.len
   begin
   //init
   xoutval:='0';//closest match
   int1:=frcrange(strint(xvalstr),1,blen(x.data));
   int1:=frcmin(frcmax(int1,x.wrapcount),1);
   int2:=0;
   //find line by text.xpos
   if (x.wrapcount>=1) and (x.linecount>=1) then
      begin
      for p:=0 to frcmax(x.linecount-1,x.linesize-1) do
      begin
      if (x.linep[p]=int1) then
         begin
         int2:=p;
         break;
         end
      else if (x.linep[p]>int1) then break
      else int2:=p;
      end;//p
      end;//if
   //return result
   xoutval:=inttostr(int2);
   end
//.find earliest line by "y" coordinate position
else if (xcmd='y>line') then//expects input of y=0..(x.totalheight-1)
   begin
   //init
   xoutval:='-1';//not found
   int1:=strint(xvalstr);
   //find line by y.coordinate
   if (x.linecount>=1) then for p:=0 to frcmax(x.linecount-1,x.linesize-1) do if ((x.liney[p]+x.lineh[p])>=int1) then
      begin
      xoutval:=inttostr(p);
      break;
      end;//p
   end
//.find pos at start of line
else if (xcmd='line>pos') then//expects input of lineindex=0..(x.linecount-1)
   begin
   xoutval:='0';//not found
   int1:=strint(xvalstr);
   if (int1>=0) then
      begin
      if (int1<x.linecount) and (int1<x.linesize) then xoutval:=inttostr(x.linep[int1])
      else if (x.wrapcount>=blen(x.data)) then xoutval:=inttostr(blen(x.data))//last line
      else if (x.linecount>=1) and (x.linecount<=x.linesize) then xoutval:=inttostr(x.linep[x.linecount-1]);//return the furtherest line pos we can - 31aug2019
      end;
   end
//.find number of items in line
else if (xcmd='line>itemcount') then//expects input of lineindex=0..(x.linecount-1)
   begin
   xoutval:='0';//none
   int1:=strint(xvalstr);
   if (int1>=0) and (int1<x.linecount) and (int1<x.linesize) then
      begin
      int2:=x.linep[int1];
      if ((int1+1)<x.linecount) and ((int1+1)<x.linesize) then int2:=x.linep[int1+1]-int2 else int2:=blen(x.data)-int2+1;
      if (int2<0) then int2:=0;//enforce min. range
      xoutval:=inttostr(int2);
      end;
   end
//.find position in data stream from x,y coordinates (relative to current vpos/hpos)
else if (xcmd='xy>pos') then
   begin
   //init
   xoutval:='0';//not found
   bol1:=false;
   if (blen(xval)>=1) then
      begin
      for p:=1 to blen(xval) do if (xval.pbytes[p-1]=32) then
         begin
         dx:=strint(bgetstr1(xval,1,p-1));
         dy:=strint(bgetstr1(xval,p+1,blen(xval)));//coordinate correction - 06dec2019
         if (x.vposPART<>0) then inc(dy,x.vposPART);//21jun2022
         bol1:=true;
         break;
         end;
      end;
   //find y.coordinate
   if bol1 and (x.linecount>=1) then
      begin
      int1:=low__wordcore2(x,'vpos',nil);
      if (int1>=0) and (int1<x.linecount) and (int1<x.linesize) then
         begin
         inc(dy,x.liney[int1]);//make dy relative
         //find best line
         int4:=int1;
         for p:=frcmin(int1-100,0) to frcmax(x.linecount-1,x.linesize-1) do if (dy>=x.liney[p]) then int4:=p else break;
         //get
         if (int4>=0) then
            begin
            p:=int4;
            //make dx relative
            if (x.pagewidth<x.viewwidth) then dec(dx,(x.viewwidth-x.pagewidth) div 2) else inc(dx,low__wordcore2(x,'hpos2',nil));
            int2:=x.linex[p];
            int3:=x.linep[p];
            for p2:=x.linep[p] to (x.linep[p]+low__wordcore_str2(x,'line>itemcount',inttostr(p))-1) do
            begin
            if not low__wordcore__charinfo(x,p2,xchar) then break;
            if (dx>=(int2-2)) then int3:=p2 else break;
            inc(int2,xchar.width);
            end;//p2
            xoutval:=inttostr(int3);
            end;//p
         end;//int1
      end;//if
   end
//04jun2020
else if (xcmd='pos>rc') then//find end of line #10
   begin
   xoutval:='1';
   if (blen(x.data)>=1) and (blen(xval)>=1) then for p:=frcrange(strint(xvalstr),1,blen(x.data)) to blen(x.data) do if low__wordcore__charinfo(x,p,xchar) and (xchar.cs=wc_t) and (xchar.c=10) then
      begin
      xoutval:=inttostr(p);
      break;
      end;//p
   end
//
//.find position in data stream from x,y coordinates (relative to current vpos/hpos)
else if (xcmd='paintline1') then
   begin
   xoutval:='0';
   if (x.vpos>=0) and (x.vpos<x.linecount) and (x.vpos<x.linesize) then xoutval:=inttostr(x.vpos);
   end
else if (xcmd='paintline2') then
   begin
   xoutval:='0';
   int2:=0;
   int1:=x.vpos;
   if (int1>=0) and (int1<x.linecount) and (int1<x.linesize) then
      begin
      for p:=int1 to frcmax(x.linecount-1,x.linesize-1) do
      begin
      if ((x.liney[p]+x.lineh[p]-x.liney[int1]-x.vposPART)<=x.viewheight) then int2:=p else break;
      end;//p
      end;//if
   xoutval:=inttostr(int2);
   end
//-- multi undo support - 25jun2022 --------------------------------------------
else if (xcmd='m.on') or (xcmd='undoon') then
   begin
   x.menabled:=true;
   if (blen(xval)>=1) then int1:=strint(xval.text) else int1:=x.mlimit;
   bol1:=low__setint(x.mlimit,frcrange(int1,2,200));//27jun2022
   for p:=low(x.mn) to high(x.mn) do if (x.mn[p]='') then x.mn[p]:=low__newnameid('','TMP');//name PART only
   if (x.mlist=nil) then
      begin
      x.mlist:=bnew;
      bol1:=true;
      end;
   if bol1 then low__minit(x.mlist,x.mlimit);
   if (x.md1=nil) then x.md1:=bnew;
   if (x.md2=nil) then x.md2:=bnew;
   if (x.md3=nil) then x.md3:=bnew;
   //alt handlers
   x.alt1:=x.md1;
   x.alt2:=x.md2;
   x.alt3:=x.md3;
   end
else if (xcmd='m.clear') or (xcmd='undoclear') then mclear(true)
else if (xcmd='m.off') or (xcmd='undooff') then
   begin
   x.menabled:=false;
   mclear(true);
   //alt handlers
   if (x.alt1=x.md1) then x.alt1:=nil;
   if (x.alt2=x.md2) then x.alt2:=nil;
   if (x.alt3=x.md3) then x.alt3:=nil;
   end
else if (xcmd='m.canundo') or (xcmd='canundo') then xoutval:=bnc(mcanundo)
else if (xcmd='m.undo') or (xcmd='undo')       then xoutval:=bnc(mundo)
else if (xcmd='m.canredo') or (xcmd='canredo') then xoutval:=bnc(mcanredo)
else if (xcmd='m.redo') or (xcmd='redo')       then xoutval:=bnc(mredo)

//-- io streams ----------------------------------------------------------------
else if (xcmd='ioget') or (xcmd='ioget2') or (xcmd='ioget.alt') then//accepts "ioget" + "txt,txtwin/bwd/bwd#/bwp/bwp#" +"<space>sel/all/<from><space><to>" - 25jun2022
   begin
   //defaults
   e:=gecOutofmemory;
   //init
   d1:=x.data;
   d2:=x.data2;
   d3:=x.data3;
   xoutval:='';
   if zznil(xoutbin,2239) then goto skipend else block(xoutbin);
   xoutbin.clear;
   if (xcmd='ioget.alt') then
      begin
      if (x.alt1=nil) or (x.alt2=nil) or (x.alt3=nil) or (blen(x.alt2)<blen(x.alt1)) or (blen(x.alt3)<blen(x.alt1)) then goto skipend;
      d1:=x.alt1;
      d2:=x.alt2;
      d3:=x.alt3;
      end;
   xmincheck2(d1,d2,d3);
   //.blen
   xlen:=blen(d1);
   dlen:=0;
   xmin:=1;
   xmax:=xlen;
   //.split multiple params
   int1:=1;
   int2:=0;
//02jun2020
   xtype:='';
   xneed1234;
   xstr1.add(xval);//was: str1:=xval+#32;
   xstr1.addbyt1(32);
   xstr2.clear;
   xstr3.clear;
   xstr4.clear;
   if zznil(xvar1,2240) then xvar1:=vnew2(957);
//
   if (blen(xstr1)>=1) then for p:=1 to blen(xstr1) do
      begin
      if (xstr1.pbytes[p-1]=32) then
         begin
         xstr2.clear;//26aug2020
         xstr2.add3(xstr1,int1-1,p-int1);//was: xstr2:=copy(str1,int1,p-int1);
         case int2 of
         0:xtype:=xstr2.text;
         1:begin
            xmin:=frcrange(strint(xstr2.text),1,xlen);
            if low__comparetext(xstr2.text,'sel') then
               begin
               xmin:=xselstart;
               xmax:=xmin+frcmin(xselcount-1,0);//always 1 char or more
               break;
               end
            else if low__comparetext(xstr2.text,'all') then
               begin
               xmin:=1;
               xmax:=xlen;
               break;
               end
            else if low__comparetext(xstr2.text,'all2') then//21dec2021
               begin
               xmin:=1;
               xmax:=xlen;
               if (xlen>=1) then
                  begin
                  for p2:=xlen downto 1 do if (d1.bytes1[p2]<>10) then
                  begin
                  xmax:=p2;
                  break;
                  end;//p2
                  end;//if
               break;
               end;
            end;
         2:begin
            xmax:=frcrange(strint(xstr2.text),xmin,xlen);
            break;
            end;
         end;//case
         inc(int2);
         int1:=p+1;
         end;//if
      end;//p
   xsize:=xmax-xmin+1;
   //plain text "txt"
   if low__comparetext(xtype,'txt') or low__comparetext(xtype,'txt#') then//05jun2020
      begin
      //init
      xoutbin.setlen(xsize);//pre-size for max speed
      //get
      for p:=xmin to xmax do if low__wordcore__charinfo2(x,d1,d2,d3,p,xchar) and (xchar.cs=wc_t) then
         begin
         inc(dlen);
         xoutbin.pbytes[dlen-1]:=xchar.c;
         end;//p
      //.finalise
      if (dlen<xsize) then xoutbin.setlen(dlen);
      end
   //plain text "txtwin" -> Windows text (#13#10) - 14jul2020
   else if low__comparetext(xtype,'txtwin') or low__comparetext(xtype,'txtwin#') then//14jul2020
      begin
      //init
      xoutbin.setlen(xsize);//pre-size for max speed
      //get
      for p:=xmin to xmax do if low__wordcore__charinfo2(x,d1,d2,d3,p,xchar) and (xchar.cs=wc_t) then
         begin
         //check size
         if ((dlen+2)>xsize) then
            begin
            inc(xsize,100000);//inc by 100K blocks -> for return codes only really - 14jul2020
            xoutbin.minlen(xsize);//pre-size for max speed
            end;
         if (xchar.c=10) then
            begin
            inc(dlen);
            xoutbin.pbytes[dlen-1]:=13;
            end;
         inc(dlen);
         xoutbin.pbytes[dlen-1]:=xchar.c;
         end;//p
      //.finalise
      if (dlen<xsize) then xoutbin.setlen(dlen);
      end
   //blaizwriter "bwd"
   else if low__comparetext(xtype,'bwd') or low__comparetext(xtype,'bwd#') then
      begin
      //init
      xonce:=true;
      xonce2:=true;
      xstr1.setlen(xsize);//pre-size for max speed
      xstr2.setlen(xsize);
      xfontname:='courier new';
      xfontsize:=12;
      xcolor:=0;//black
      xcolor2:=255;//red

      //.color info
      for p:=xmin to xmax do if low__wordcore__charinfo2(x,d1,d2,d3,p,xchar) and (xchar.cs=wc_t) then
         begin
         //font information - once only
         if xonce then
            begin
            xonce:=false;
            xfontname :=x.txtname[xchar.wid];
            xfontsize :=x.txtsize[xchar.wid];
            xcolor    :=x.txtcolor[xchar.wid];
            end;
         //.search for 2nd color -> if one is used
         if xonce2 and (xcolor<>x.txtcolor[xchar.wid]) then
            begin
            xonce2:=false;
            xcolor2   :=x.txtcolor[xchar.wid];
            break;//done
            end;
         if xonce2 and (xcolor<>x.txtbk[xchar.wid]) and (x.txtbk[xchar.wid]<>clnone) and (x.txtbk[xchar.wid]<>x.pagecolor) then
            begin
            xonce2:=false;
            xcolor2   :=x.txtbk[xchar.wid];
            break;//done
            end;
         end;//p

      //get
      for p:=xmin to xmax do if low__wordcore__charinfo2(x,d1,d2,d3,p,xchar) and (xchar.cs=wc_t) then
         begin
         inc(dlen);
         //text stream
         xstr1.pbytes[dlen-1]:=xchar.c;//was: str1[dlen]:=xchar.c;
         //style stream
         int1:=0;
         if x.txtbold[xchar.wid] then inc(int1);//bold
         if x.txtitalic[xchar.wid] then inc(int1,2);//italic
         if x.txtunderline[xchar.wid] then inc(int1,4);//underline
         if x.txtstrikeout[xchar.wid] then inc(int1,8);//strikeout
         if (x.txtbk[xchar.wid]<>clnone) and (x.txtbk[xchar.wid]<>x.pagecolor) then inc(int1,16);//swap (highlight background)
         if (x.txtcolor[xchar.wid]<>xcolor) then inc(int1,32);//color2 (use color2, e.g. red)
         xstr2.pbytes[dlen-1]:=byte(int1);
         end;//p
      //.finalise
      if (dlen<xsize) then
         begin
         xstr1.setlen(dlen);
         xstr2.setlen(dlen);
         end;

      //set
      int1:=0;

      //.header
      if not xappendstr(xoutbin,'BWD1','') then goto skipend;

      //.info -> include only the settings we can comfortably provide - BW will fill in the rest as needed - 04sep2019
      xvar1.clear;
      xvar1.b['landscape']:=false;
      xvar1.b['systemscheme']:=false;
      xvar1.i['wrapstyle']:=low__aorb(wwsWindow,wwsPage,x.pagewidth<>x.viewwidth);//1=wrap to window, 2=wrap to page
      xvar1.s['fontname']:=xfontname;
      xvar1.i['fontsize']:=xfontsize;
      xvar1.i['fontcolor']:=xcolor;
      xvar1.i['fontcolor2']:=xcolor2;
      xvar1.i['fontstyle']:=0;
      xvar1.i['bgcolor']:=x.pagecolor;

      if not xappend(xoutbin,'info',xvar1.data) then goto skipend;

      //.font - reserved for future use
      if not xappendstr(xoutbin,'font','') then goto skipend;

      //.text
      if not xappend(xoutbin,'text',xstr1) then goto skipend;
      xstr1.clear;//reduce ram

      //.styl
      if not xappend(xoutbin,'styl',xstr2) then goto skipend;
      xstr2.clear;//reduce ram

      //.base64 for clipboard transport
      if low__comparetext(xtype,'bwd#') then
         begin
         if not low__tob64(xoutbin,xoutbin,1000,e) then goto skipend;//1,000c lines
         if not xoutbin.ains([66,87,68,35],0) then goto skipend;//insert 'BWD#' header at start of stream
         end;
      end
   //blaiz wordprocessor "bwp"
   else if low__comparetext(xtype,'bwp') or low__comparetext(xtype,'bwp#') then//25jun2022
      begin
      //init
      int1:=0;
      //get
      //.header
      if not xappendstr(xoutbin,'BWP1','') then goto skipend;

      //.info -> include only the settings we can comfortably provide - BW will fill in the reset as needed - 04sep2019
      xvar1.clear;
      xvar1.b['landscape']:=x.landscape;
      xvar1.b['systemscheme']:=false;
      xvar1.i['wrapstyle']:=x.wrapstyle;
      xvar1.i['bgcolor']:=x.pagecolor;
      if not xappend(xoutbin,'info',xvar1.data) then goto skipend;

      //.data
      dlen:=0;
      xstr1.setlen(3*xsize);//pre-size for max speed
      for p:=xmin to xmax do if low__wordcore__charinfo2(x,d1,d2,d3,p,xchar) then
         begin
         inc(dlen,3);
         //was: xstr1.pbytes[dlen-2-1]:=x.data.pbytes[p-1];
         //was: xstr1.pbytes[dlen-1-1]:=x.data2.pbytes[p-1];
         //was: xstr1.pbytes[dlen-0-1]:=x.data3.pbytes[p-1];
         v8:=d1.pbytes[p-1];xstr1.pbytes[dlen-2-1]:=v8;
         v8:=d2.pbytes[p-1];xstr1.pbytes[dlen-1-1]:=v8;
         v8:=d3.pbytes[p-1];xstr1.pbytes[dlen-0-1]:=v8;
         end;//p

      if (dlen<xstr1.len) then xstr1.setlen(dlen);//finalise
      if not xappend(xoutbin,'data',xstr1) then goto skipend;
      xstr1.clear;//reduce ram

      //.list ------------------------------------------------------------------
      if not xappendstr(xoutbin,'list','') then goto skipend;
      //init
      dlen:=0;
      str1:='';
      xstr2.setlen(imax+1);for p:=1 to (imax+1) do xstr2.pbytes[p-1]:=0;//track used "lgf" items - optional
      xstr3.setlen(imax+1);for p:=1 to (imax+1) do xstr3.pbytes[p-1]:=0;//track used "lgf" items - optional
      xstr4.setlen(imax+1);for p:=1 to (imax+1) do xstr4.pbytes[p-1]:=0;//track used "lgf" items - optional
      //Include all used LGF fonts - optional (must use "ioget2")
      if (xcmd='ioget2') then
         begin
         for p:=xmin to xmax do if low__wordcore__charinfo2(x,d1,d2,d3,p,xchar) and (xchar.cs=wc_t) then xstr3.pbytes[1+xchar.txtid-1]:=1;//mark as used
         //.f0..f999 -> store all "lgf" font snapshots that have been referred to -> optional -> allows viewing of document on platforms even without the original fonts (system independent viewing) - 04sep2019
         for p:=1 to blen(xstr3) do if (xstr3.pbytes[p-1]=1) then
         begin
         if not xappendstr(xoutbin,'begi','f'+inttostr(p-1)) then goto skipend;//begin
         //if not xappendb(int1,xoutval,'_fdn',x.lgfnref[p-1]) then goto skipend;//font name/size/style fast reference
         if (blen(x.lgfdata[p-1])<=0) then low__wordcore__lgfFILL(x,p-1,false);//.lgfFILL -> fill regardless of dataonly mode
         if not xappend(xoutbin,'_fds',x.lgfdata[p-1]) then goto skipend;//lgf datastream
         if not xappendstr(xoutbin,'end!','') then goto skipend;//end
         end;//p
         end;//if

      //text & images
      for p:=xmin to xmax do if low__wordcore__charinfo2(x,d1,d2,d3,p,xchar) then
         begin
         //.t0..t999
         if (xchar.cs=wc_t) and (xstr2.pbytes[1+xchar.wid-1]=0) then
            begin
            //mark as done
            xstr2.pbytes[1+xchar.wid-1]:=1;
            //init
            //.xint4
            xint4.val:=0;
            if x.txtbold[xchar.wid]      then xint4.bytes[0]:=1;
            if x.txtitalic[xchar.wid]    then xint4.bytes[1]:=1;
            if x.txtunderline[xchar.wid] then xint4.bytes[2]:=1;
            if x.txtstrikeout[xchar.wid] then xint4.bytes[3]:=1;
            //.xint4b
            xint4b.val:=0;
            xint4b.bytes[0]:=frcrange(x.txtalign[xchar.wid],0,wcaMax);
            //get
            if not xappendstr(xoutbin,'begi','t'+inttostr(xchar.wid)) then goto skipend;//begin
            if not xappendint4(xoutbin,'_tid',x.txtid[xchar.wid]) then goto skipend;//lgf index -> txtid
            if not xappendint4(xoutbin,'_brc',x.txtborder[xchar.wid]) then goto skipend;//border color
            if not xappendint4(xoutbin,'_bkc',x.txtbk[xchar.wid]) then goto skipend;//font background color
            if not xappendint4(xoutbin,'_fcl',x.txtcolor[xchar.wid]) then goto skipend;//font color
            if not xappendint4(xoutbin,'_fsz',x.txtsize[xchar.wid]) then goto skipend;//font size
            if not xappendint4(xoutbin,'_fsy',xint4.val) then goto skipend;//font style
            if not xappendint4(xoutbin,'_fs2',xint4b.val) then goto skipend;//font style2 (align)
            if not xappendstr(xoutbin,'_fnm',x.txtname[xchar.wid]) then goto skipend;//font name
            if not xappendstr(xoutbin,'end!','') then goto skipend;//end
            end
         //.i0..i999
         else if (xchar.cs=wc_i) and (xstr4.pbytes[1+xchar.wid-1]=0) then
            begin
            //mark as done
            xstr4.pbytes[1+xchar.wid-1]:=1;
            //get
            if not xappendstr(xoutbin,'begi','i'+inttostr(xchar.wid)) then goto skipend;//begin
//            if not xappendb(int1,xoutval,'_iid',from32bit(-1)) then goto skipend;//-1=directly points to image, 0..N=points to a copy of image (not in use yet)
//            if not xappendb(int1,xoutval,'_imw',from32bit(x.imgwidth[xchar.wid])) then goto skipend;//image width
//            if not xappendb(int1,xoutval,'_imh',from32bit(x.imgheight[xchar.wid])) then goto skipend;//image height
            if not  xappend(xoutbin,'_imd',x.imgdata[xchar.wid]) then goto skipend;//imdata datastream
            if not xappendstr(xoutbin,'end!','') then goto skipend;//end
            end;//if
         end;//p
      if not xappendstr(xoutbin,'lise','') then goto skipend;//list end

      //.finalise
      //was: if not xappendb(int1,xoutval,'','') then goto skipend;

      //.base64 for clipboard transport
      if low__comparetext(xtype,'bwp#') then
         begin
         if not low__tob64(xoutbin,xoutbin,1000,e) then goto skipend;//1,000c lines
         if not xoutbin.ains([66,87,80,35],0) then goto skipend;//insert 'BWP#' header at start of stream
         end;
      end
   else
      begin
      showerror('Wordcore: Unknown ioget directive "'+xvalstr+'"');
      goto skipend;
      end;
   //successful
   xoutval:='1';
   end

//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//5555555555555555555555555555555555555
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//xxxxxxxxxxxxxxxxxxxxxx twordcore xxxxxxxxxxxxxxxxxx
else if (xcmd='ioset') or (xcmd='ioins') or (xcmd='ioins.noundo') then
   begin//Note: ioset=replace current content with new one, ioins=insert at cursorpos (deletes current selection)
   //defaults
   e:=gecOutofmemory;
   //init
   xmincheck;
   xneed123456;
   xstr1.clear;
   xstr2.clear;
   xstr3.clear;
   xstr4.clear;
   xstr5.clear;
   xstr6.clear;
   if zznil(ximgdata,2240) then ximgdata:=bnew;
   ximgdata.clear;
   if zznil(xvar1,2241) then xvar1:=vnew2(958);
   xlen:=blen(x.data);
   xfull:=(xcmd='ioset');
   if (xcmd='ioset') then low__wordcore(x,'clear2',nil);//leave undo alone
   xtype:=bgetstr1(xval,1,4);//inbound stream header - 21aug2020
   //get -----------------------------------------------------------------------
   //blaizwriter "bwd" - 15may2021
   if (blen(xval)>=1) and ( low__comparetext(xtype,'bwd1') or low__comparetext(xtype,'bwd#') ) then
      begin
      //init
      e:=gecUnknownformat;

      //decode from base64
      if low__comparetext(xtype,'bwd#') then
         begin
         if not low__fromb641(xval,xval,5,e) then goto skipend;
         if (blen(xval)<=0) then goto skipend;
         end;
      int2:=1;

      //get
      //.header
      if (not xpullstr(int2,xval,n,v)) or (not low__comparetext(n,'BWD1')) then goto skipend;
      v:='';
      //.info
      if (not xpull(int2,xval,n,xstr4)) or (not low__comparetext(n,'info')) then goto skipend;
      xvar1.data:=xstr4;
      xfontname:=low__udv(xvar1.s['fontname'],'$fontname');
      xfontsize:=frcrange(strint(low__udv(xvar1.s['fontsize'],'12')),4,300);
      xcolor :=strint(low__udv(xvar1.s['fontcolor'] ,'0'));//black
      xcolor2:=strint(low__udv(xvar1.s['fontcolor2'],'255'));//red
      xbk:=strint(low__udv(xvar1.s['bgcolor'],inttostr(low__rgb(255,255,255))));//white
      if xfull then x.pagecolor:=xbk;
      //..store reference info
      x.bwd_color:=xcolor;
      x.bwd_color2:=xcolor2;
      x.bwd_bk:=xbk;

      //.font
      if (not xpullstr(int2,xval,n,v)) or (not low__comparetext(n,'font')) then goto skipend;
      v:='';

      //.text
      if (not xpull(int2,xval,n,xstr1)) or (not low__comparetext(n,'text')) then goto skipend;
      //.style
      if (not xpull(int2,xval,n,xstr4)) or (not low__comparetext(n,'styl')) then goto skipend;

      //filter out reserved chars
      if (blen(xstr1)>=1) then
         begin
         int4:=blen(xstr1);
         int5:=blen(xstr4);
         dlen:=0;
         for p:=1 to int4 do
         begin
         v1:=xstr1.pbytes[p-1];
         if (v1=9) or (v1=10) or (v1>=32) then
            begin
            inc(dlen);
            if (dlen<int4) then xstr1.pbytes[dlen-1]:=xstr1.pbytes[p-1];
            if (dlen<int5) then xstr4.pbytes[dlen-1]:=xstr4.pbytes[p-1];
            end;
         end;//p
         //trim
         if (dlen<int4) then xstr1.setlen(dlen);//text
         if (dlen<int5) then xstr4.setlen(dlen);//style
         end;
      //init
      if (blen(xstr1)>=1) then
         begin
         xstr5.setlen((imax+1)*sizeof(longint));
         xlist:=xstr5.pints4;//was: xlist:=pointer(longint(str6));
         for p:=0 to imax do xlist[p]:=-1;//not set - track all font-style combinations -> allows us to quickly check if we need to create a new font
         int4:=blen(xstr4);
         //xval:='';//reduce ram
         xstr2.setlen(blen(xstr1));
         xstr3.setlen(blen(xstr1));
         //convert style stream
         for p:=1 to blen(xstr1) do
         begin
         //.read the BWD1 style
         if (p<=int4) then i:=xstr4.pbytes[p-1] else i:=0;
         if (i<0) then i:=0 else if (i>imax) then i:=imax;//range - 22aug2020
         //.format filter
         if (x.maxformatlevel<=0) then i:=0;
         //.make font
         if (xlist[i]=-1) then
            begin
            //read style
            int1:=i;
            xbold:=false;
            xitalic:=false;
            xunderline:=false;
            xstrikeout:=false;
            xswap:=false;
            xusecolor2:=false;
            //get
            if (int1>=128) then dec(int1,128);
            if (int1>=64) then dec(int1,64);
            if (int1>=32) then
               begin
               xusecolor2:=true;
               dec(int1,32);
               end;
            if (int1>=16) then
               begin
               xswap:=true;
               dec(int1,16);
               end;
            if (int1>=8) then
               begin
               xstrikeout:=true;
               dec(int1,8);
               end;
            if (int1>=4) then
               begin
               xunderline:=true;
               dec(int1,4);
               end;
            if (int1>=2) then
               begin
               xitalic:=true;
               dec(int1,2);
               end;
            if (int1>=1) then
               begin
               xbold:=true;
               dec(int1,1);
               end;
            //create font
            if xusecolor2 and xswap then
               begin
               v1:=xbk;
               v2:=xcolor2;
               end
            else if xswap then
               begin
               v1:=xbk;
               v2:=xcolor;
               end
            else if xusecolor2 then
               begin
               v1:=xcolor2;
               v2:=clnone;
               end
            else
               begin
               v1:=xcolor;
               v2:=clnone;
               end;
            xlist[i]:=xmakefont2(true,nil,xfontname,xfontsize,v1,v2,clnone,xbold,xitalic,xunderline,xstrikeout,0);
            end;//i

         //.apply font
         wrd2.val:=xlist[i];//id that points to text-font
         xstr2.pbytes[p-1]:=wrd2.bytes[0];
         xstr3.pbytes[p-1]:=wrd2.bytes[1];
         end;//p
         end;//str1
      end
   //blaiz wordprocessor "bwp"
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//55555555555555555555555555
   else if (blen(xval)>=1) and ( low__comparetext(xtype,'bwp1') or low__comparetext(xtype,'bwp#') ) then
      begin
      //init
      e:=gecUnknownformat;
      //decode from base64
      if low__comparetext(xtype,'bwp#') then
         begin
         if not low__fromb641(xval,xval,5,e) then goto skipend;
         if (blen(xval)<=0) then goto skipend;
         end;
      int2:=1;
      xstr5.setlen((imax+1)*sizeof(longint));
      xlist:=xstr5.pints4;
      for p:=0 to imax do xlist[p]:=p;//1-to-1 mapping to start with -> used to merge inbound items with current items (when ioins etc) -> e.g. image99 "i99" might map to "i303", therefore all inbound x.wid[]'s "part1&2" must be changed from i99 to i303 to reflect the changes - 05sep2019

      //get
      //.header
      if (not xpullstr(int2,xval,n,v)) or (not low__comparetext(n,'BWP1')) then goto skipend;
      v:='';

      //.info -> include only the settings we can comfortably provide - BW will fill in the reset as needed - 04sep2019
      if (not xpull(int2,xval,n,xstr2)) or (not low__comparetext(n,'info')) then goto skipend;
      if xfull then
         begin
         xvar1.data:=xstr2;
         x.landscape:=xvar1.b['landscape'];
         if not x.wrapreadonly then x.wrapstyle:=frcrange(strint(low__udv(xvar1.s['wrapstyle'],inttostr(wwsWindow))),0,wwsMax);
         x.pagecolor:=strint(low__udv(xvar1.s['bgcolor'],inttostr(low__rgb(255,255,255))));//white
         xpagewidth;
         xwrap_hvsync_changed;
         end;

      //.data
      if (not xpull(int2,xval,n,xstr4)) or (not low__comparetext(n,'data')) then goto skipend;
      int1:=blen(xstr4) div 3;
      if (int1>=1) then
         begin
         //init
         xstr1.setlen(int1);
         xstr2.setlen(int1);
         xstr3.setlen(int1);
         //get
         for p:=1 to int1 do
         begin
         int3:=(p*3)-2;
         //was: xstr1.pbytes[p-1]:=xstr4.pbytes[int3+0-1];//text
         //.wid's "part1&2" may need to be remapped further down
         //was: xstr2.pbytes[p-1]:=xstr4.pbytes[int3+1-1];//id.part1
         //was: xstr3.pbytes[p-1]:=xstr4.pbytes[int3+2-1];//id.part2

         v8:=xstr4.pbytes[int3+0-1];xstr1.pbytes[p-1]:=v8;//text
         //.wid's "part1&2" may need to be remapped further down
         v8:=xstr4.pbytes[int3+1-1];xstr2.pbytes[p-1]:=v8;//id.part1
         v8:=xstr4.pbytes[int3+2-1];xstr3.pbytes[p-1]:=v8;//id.part2
         end;//p
         end;//if

      //.list ------------------------------------------------------------------
      //Special Note: any stored LGF fonts will be first in the list
      //init
      if (not xpullstr(int2,xval,n,v)) or (not low__comparetext(n,'list')) then goto skipend;
      xstr6.setlen((imax+1)*sizeof(longint));
      xstr5.setlen((imax+1)*sizeof(longint));
      xlist:=xstr6.pints4;
      xlisti:=xstr5.pints4;
      for p:=0 to imax do
      begin
      xlist[p]:=p;//use to "remap" incoming resources to target slots in resource cache
      xlisti[p]:=p;
      if zzok(xlist2[p],7062) then bfree(xlist2[p]);//use to temp-store any included LGF fonts
      end;
      //get
      str4:='';
      int4:=0;
      while true do
      begin
      if not xpull(int2,xval,n,xstr4) then break;//don't raise error -> attempt to continue
      //.begin
      if (n='lise') then break//list end
      else if (n='begi') then
         begin
         str4:=bgetstr1(xstr4,1,1);//"t"(text) or "i"(image) or "f"(LGF font - optional)
         int4:=xsafe(strint(bgetstr1(xstr4,2,xstr4.len)));
         //.text defaults
         xid:=0;
         xborder:=clnone;
         xbk:=clnone;
         xcolor:=0;
         xfontsize:=12;
         xfontname:='$fontname';
         xbold:=false;
         xitalic:=false;
         xunderline:=false;
         xstrikeout:=false;
         xalign:=wcaLeft;//left
         //.image defaults
         ximgdata.clear;
         end
      //.font values
      else if (n='_fds') then
         begin
         if (x.maxformatlevel>=2) then
            begin
            if zznil(xlist2[int4],2242) then xlist2[int4]:=bnew;
            xlist2[int4].replace:=xstr4;//these are done first before any text, so they can be temp-stored in "xlist2" for access with text values
            end;
         end
      //.text values
      else if (n='_tid') then xid:=xsafe(xstr4.int4[0])
      else if (n='_brc') then
         begin
         if (x.maxformatlevel>=2) then xborder:=xstr4.int4[0];
         end
      else if (n='_bkc') then
         begin
         if (x.maxformatlevel>=2) then xbk:=xstr4.int4[0];
         end
      else if (n='_fcl') then
         begin
         if (x.maxformatlevel>=2) then xcolor:=xstr4.int4[0];
         end
      else if (n='_fsz') then
         begin
         if (x.maxformatlevel>=2) then xfontsize:=frcrange(xstr4.int4[0],4,300);
         end
      else if (n='_fsy') then
         begin
         if (x.maxformatlevel>=1) then xint4.val:=xstr4.int4[0] else xint4.val:=0;
         xbold      :=(xint4.bytes[0]<>0);
         xitalic    :=(xint4.bytes[1]<>0);
         xunderline :=(xint4.bytes[2]<>0);
         xstrikeout :=(xint4.bytes[3]<>0);
         end
      else if (n='_fs2') then
         begin
         if (x.maxformatlevel>=1) then xint4.val:=xstr4.int4[0] else xint4.val:=wcaLeft;
         xalign     :=frcrange(xint4.bytes[0],0,wcaMax);
         end
      else if (n='_fnm') then
         begin
         if (x.maxformatlevel>=1) then xfontname:=low__udv(bstr(xstr4),'$fontname') else xfontname:='$fontname';//12jun2022
         end
      //.image values
      else if (n='_imd') then ximgdata.replace:=xstr4
      //.finalise
      else if (n='end!') then
         begin
         if (str4='t') then
            begin
            xlist[int4]:=xmakefont2(true,xlist2[xid],xfontname,xfontsize,xcolor,xbk,xborder,xbold,xitalic,xunderline,xstrikeout,xalign);
            end
         else if (str4='i') then
            begin
            xlisti[int4]:=xmakeimage2(ximgdata);
            ximgdata.clear;//reduce ram
            end;
         end;
      end;//loop

      //Remap All Inbound Resource IDS to their new values ---------------------
      //Special Note: Both (t)ext and (i)mages can use the same id range (0..999)
      //              but they don't overlap with their values, as each text/image
      //              has it's own dedicated stack of values.
      if (blen(xstr1)>=1) then for p:=1 to blen(xstr1) do
         begin
         int4:=xstyle(xstr1.pbytes[p-1]);
         wrd2.bytes[0]:=xstr2.pbytes[p-1];
         wrd2.bytes[1]:=xstr3.pbytes[p-1];
         wrd2.val:=xsafe(wrd2.val);
         if (int4=wc_t) then
            begin
            //.id has been remapped -> write new id
            if (wrd2.val<>xlist[wrd2.val]) then
               begin
               wrd2.val:=xlist[wrd2.val];
               xstr2.pbytes[p-1]:=wrd2.bytes[0];
               xstr3.pbytes[p-1]:=wrd2.bytes[1];
               end;
            end
         else if (int4=wc_i) then
            begin
            //.id has been remapped -> write new id
            if (wrd2.val<>xlisti[wrd2.val]) then
               begin
               wrd2.val:=xlisti[wrd2.val];
               xstr2.pbytes[p-1]:=wrd2.bytes[0];
               xstr3.pbytes[p-1]:=wrd2.bytes[1];
               end;
            end;
         end;
      end
   //richtext v1 "rtf" - 22jun2022 ---------------------------------------------
   else if (blen(xval)>=1) and ( low__comparetext(xtype,'rtf#') or low__comparetext(bgetstr1(xval,1,7),'{\rtf1\') ) then
      begin
      //init
      e:=gecUnknownformat;
      //decode from base64
      if low__comparetext(xtype,'rtf#') then
         begin
         if not low__fromb641(xval,xval,5,e) then goto skipend;
         if (blen(xval)<=0) then goto skipend;
         end;
      //read datastream//xxxxxxxxxxxxxxxxxxxxxxx//4444444444444444444444
      if not xaddrtf(e) then goto skipend;
      end
   //assume data is plain text "txt" -------------------------------------------
   else if (blen(xval)>=1) then
      begin
      //init
      xstr1.replace:=xval;
//was:      xval.clear; //we wish to RETAIN the inbound datastream - 18jun2022
      low__wordcore__filtertext(xstr1);
      int1:=blen(xstr1);
      if (int1>=1) then
         begin
         //init
         wrd2.val:=xmakefont;
         xstr2.setlen(int1);
         xstr3.setlen(int1);
        //get
         for p:=1 to int1 do
         begin
         xstr2.pbytes[p-1]:=wrd2.bytes[0];
         xstr3.pbytes[p-1]:=wrd2.bytes[1];
         end;//p
         end;//int1      end;
      end;

   //set -> insert the 3 streams and update ---------------------------------
   if (blen(xstr1)>=1) then
      begin
      if (xcmd='ioins') or (xcmd='ioins.noundo') then
         begin
         //m-undo
         if (xcmd='ioins') then
            begin
            mstore1;//previous
            x.mstyle:=musSel;
            mstore1;
            end;
         //delete existing selection
         if (xselcount>=1) then xdelsel2(blen(xval)<=0);//don't set "*_moveto" when inserting one or more characters - 02sep2019
         end;

      //init
      xmincheck;
      int1:=blen(x.data);
      int2:=x.cursorpos;
      //m-undo - 03jul2022
      if (xcmd='ioins') then
         begin
         if (x.mstyle<>musIns) then
            begin
            mstore1;
            x.mstyle:=musIns;
            x.mfrom1:=int2;
            x.mlen:=blen(xstr1);
            end;
         end;
      x.data.ins(xstr1,int2-1);   //was: insert(str1,x.data ,int2);
      x.data2.ins(xstr2,int2-1);  //was: insert(str2,x.data2,int2);
      x.data3.ins(xstr3,int2-1);  //was: insert(str3,x.data3,int2);

      //if xundook then mudelset(int2,xstr1.len);//25jun2022

      xmincheck;
      //.trim trailing second #10 -> prevents continuous appending of a single #10 each time "ioset" is called - 29feb2020
//was:if (xcmd='ioset') and (blen(x.data)>=2) and (copy(x.data,length(x.data)-1,2)=(#10#10)) then
      if (xcmd='ioset') and (blen(x.data)>=2) and x.data.asame3(blen(x.data)-2,[10,10],false) then
         begin
         int3:=blen(x.data);
         bdel1(x.data,int3,1);
         bdel1(x.data2,int3,1);
         bdel1(x.data3,int3,1);
         end;
      //.sync
      if (xcmd<>'ioset') then xsetcursorpos(int2+blen(xstr1));
      xwrapadd(xlinebefore(int2),int2+blen(xstr1)+x.c_pagewrap);
      x.timer_chklinecursorx:=true;
      xchanged;
      end;

   //successful
   xoutval:='1';
   end
//.transform - convert "[<name>]" into system images and text - 15may2021
else if (xcmd='transform') or (xcmd='transform.webimages')then//25jul2021, 15may2021
   begin
   if low__wordcore__transform(x,low__insstr('webimages',(xcmd='transform.webimages')),system_debug) then
      begin
      xmincheck;
      xwrapadd(0,xselstart+x.c_bigwrap);
      x.timer_chklinecursorx:=true;
      xchanged;
      end;
   end
else
   begin
   //suppress this error now: showerror('Wordcore: Unknown command "'+xcmd+'"');
   goto skipend;
   end;
//successful
skipdone:
result:=true;
skipend:
except;end;
try
bfree(xstr1);
bfree(xstr2);
bfree(xstr3);
bfree(xstr4);
bfree(xstr5);
bfree(xstr6);
bfree(ximgdata);
freeobj(@xvar1);
for p:=0 to high(xlist2) do if zzok(xlist2[p],7063) then bfree(xlist2[p]);
if xmusttimerunbusy then x.timerbusy:=false;
except;end;
try
bunlockautofree(xval);
bunlockautofree(xoutbin);
except;end;
end;


//-- font support --------------------------------------------------------------
//## low__toLGF ##
function low__toLGF(xfontname:string;xfontsize:longint;xgreyscale,xbold:boolean;xdata:tstr8;var e:string):boolean;//$claude.* patch - 02feb2022
label//LGF - linear Graphic Font (all chars as a horizontal image strip)
     //Optimisations: "Courier New/300pt" took: 4,000ms -> now 1,000ms (4x faster)
   detect16,detect32,detect32__greyscale,skipunderline,skipdone,skipend;
const
   xmaxsize  =65532;//nearest block of 6px (12b)
   xblackok  =25;//25 or less
type
   tcolor96=packed record v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11:byte;end;//12b => 6px for 15/16bit image - 19apr2020
   pcolorrow96=^tcolorrow96;tcolorrow96=array[0..(maxint div 48)] of tcolor96;
   pcolorrows96=^tcolorrows96;tcolorrows96=array[0..maxrow] of pcolorrow96;
var
   a:tbmp;
   dbuffer:tstr8;
   dlen:longint;
   wrd2:twrd2;
   int4:tint4;
   //scan support
   xleft,xright,dw3,dw6,i,tw,sx,sy,p,xlen,xpad,int1,int2,dbufferlen,xcount:longint;//-1=not set, 0..127=>1..128 | any value over 127 indicates non-transparent pixel
   awcount3,awcount6,abits,aw,ah:longint;
   ac96:tcolor96;
   ac8:tcolor8;
   xwh:tpoint;
   xmaxw,xmaxh,xmaxh1:longint;
   xrows8:pcolorrows8;
   xrows24:pcolorrows24;
   xrows32:pcolorrows32;
   xrowsmem:string;
   ar8:pcolorrow8;
   ar32:pcolorrow32;
   ar96:pcolorrow96;
   dx,dy:longint;
   xlocked,xcounton,bol2,bol1,dyok:boolean;
   xcount8:longint;
   xval8:byte;
   xws:array[0..255] of longint;
   //## xround3 ##
   function xround3(x:longint):longint;//32bit = 3 pixel blocks
   begin
   result:=x;
   if (((result div 3)*3)<>x) then result:=((x div 3)+1)*3;//round up to nearest 3 pixels
   end;
   //## xround6 ##
   function xround6(x:longint):longint;//16bit = 6 pixel blocks
   begin
   result:=x;
   if (((result div 6)*6)<>x) then result:=((x div 6)+1)*6;//round up to nearest 6 pixels
   end;
   //## xpull1 ##
   function xpull1(sx:longint):boolean;
   var
      v:tbit8;
      dx:longint;
   begin
   v.val:=ar8[sx div 8];
   dx:=sx-((sx div 8)*8);
   result:=not ((7-dx) in v.bits);
   end;
   //## xfirstset ##
   function xfirstset(bol2:boolean):boolean;
   begin
   result:=true;
   xcounton:=bol2;
   inc(dlen);
   if xcounton then dbuffer.pbytes[dlen-1]:=1 else dbuffer.pbytes[dlen-1]:=0;//start solid "#1" or transparent "#0"
   end;
   //## xadd8 ##
   procedure xadd8(xval:byte);
   var
      int1:longint;
   begin
   //bol1
   if (xval<255) then bol1:=true;
   //get
   if (xval<>xval8) or (xcount8>=65536) then
      begin
      if (xcount8=0) then
         begin
         //nil
         end
      else if (xcount8<=256) then//val(0..15)+len(0..255)
         begin
         dec(xcount8);
         inc(dlen);dbuffer.pbytes[dlen-1]:=(xval8 div 17);//0..255 -> 0..15 -> 0..255 (x17)
         inc(dlen);dbuffer.pbytes[dlen-1]:=byte(xcount8);
         end
      else if (xcount8<=65536) then//val(16..31)+len(0..65535)
         begin
         dec(xcount8);
         inc(dlen);dbuffer.pbytes[dlen-1]:=16+(xval8 div 17);//0..255 -> 16..31 -> ( (val-16)*17 => 0..255 )
         int1:=xcount8 div 256;
         inc(dlen);dbuffer.pbytes[dlen-1]:=byte(int1);
         inc(dlen);dbuffer.pbytes[dlen-1]:=byte(xcount8-(int1*256));
         end;
      //reset
      xcount8:=1;
      xval8:=xval;
      end
   else if (xval=xval8) then inc(xcount8);
   end;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
xlocked:=false;
a:=nil;
dbuffer:=nil;
xlen:=0;
block(xdata);

//check
if zznil(xdata,2243) then goto skipend else xdata.clear;

//finalise fontname - 02feb2022
xfontname:=low__findfontnameb(xfontname);//02feb2022

//xxxxxxxxxxxxxxxxxxxxxx//???????????????//D10: No working support for text capture yet
{$ifdef D10}
result:=true;
xdata.aadd(sysfont__arial_8);
exit;//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//??????????????????????????
{$endif}

//range
if (xfontsize>=0) then xfontsize:=frcmin(xfontsize,4);//allow a negative range which specifies fontsize via height in pixels - 11apr2020

//init
aw:=1;
ah:=1;
//test for non-antialised font on Wine (works, but font is still ROUGH): a:=misbmp(low__aorb(16,1,viWine),1,1);//ask for 16 or 1bit(wine), but may get 32
a:=misbmp(low__aorb(16,32,xgreyscale),1,1);//ask for 16 but may get 32
abits:=misb(a);
misset_brushcolor(a,low__rgb(255,255,255));//Special Note: "a.canvas.brush.style=bsclear" produces unreliable and scrambled results - DO NOT USE - 17apr2020
misset_fontcolor(a,0);//black font color
misset_fontname(a,xfontname);
if (xfontsize>=0) then misset_fontsize(a,xfontsize) else misset_fontheight(a,-xfontsize);
misset_fontstyle(a,xbold,false,false,false);
//init
xmaxw:=1;
xmaxh:=1;
xmaxh1:=1;//use A-D (no drop parts like "Q" has)
//get
for p:=0 to 255 do
begin
xwh:=misset_textextent(a,char(p));
if (xwh.x<1) then xwh.x:=1 else if (xwh.x>xmaxsize) then xwh.x:=xmaxsize;//1..65532
if (xwh.y<1) then xwh.y:=1 else if (xwh.y>xmaxsize) then xwh.y:=xmaxsize;//1..65532
if (xwh.x>xmaxw) then xmaxw:=xwh.x;
if (xwh.y>xmaxh) then xmaxh:=xwh.y;
xws[p]:=xwh.x;
app__fasttimer;//fasttimer - 07jul2021
end;//p

//-- Scan font characters ------------------------------------------------------
//size
xpad     :=frcrange(round(xmaxw*0.1),2,20);//widen capture area to allow for left/right boundary overlap detection - 20apr2020
case abits of
16:begin
   aw       :=frcrange(xround6(xmaxw+(2*xpad)),1,xmaxsize);
   awcount6 :=aw div 6;
   end;
32:begin
   aw       :=frcrange(xround3(xmaxw+(2*xpad)),1,xmaxsize);
   awcount3 :=aw div 3;
   end;
end;//case
ah       :=frcrange(xmaxh,1,xmaxsize);
missize(a,aw,ah);
app__fasttimer;//fasttimer - 07jul2021
a.sharp:=low__aorb(1,8,xgreyscale);
//.size databuffer
dbuffer:=bnewlen(aw*ah);
dbufferlen:=dbuffer.len;
app__fasttimer;//fasttimer - 07jul2021
//cache 16bit rows
if not a.lock then goto skipend;
xrows24:=a.prows24;
//header -> now supports dual data streams: normal and bold for a total of 512 combined stored characters - 17apr2020
xlen:=1544;
xdata.setlen(xlen);
xdata.pbytes[0]:=71;//G - header (0..3)
xdata.pbytes[1]:=70;//F
xdata.pbytes[2]:=35;//#
xdata.pbytes[3]:=low__aorb(51,52,xgreyscale);//3 - version 3.0 (monochrome) or 4 - version 4.0 (greyscale)
//.store height in header (4..5) -> overal height
wrd2.val:=xmaxh;
xdata.pbytes[4]:=wrd2.bytes[0];
xdata.pbytes[5]:=wrd2.bytes[1];
//.store height1 in header (6..7) -> distance from top to baseline
wrd2.val:=xmaxh1;//write actual/final value later
xdata.pbytes[6]:=wrd2.bytes[0];
xdata.pbytes[7]:=wrd2.bytes[1];
//decide
case abits of
16:goto detect16;
32:if xgreyscale then goto detect32__greyscale else goto detect32;
else goto skipend;
end;


//detect16 -> all characters (rapid run-length compression) --------------------
detect16:
for p:=0 to 255 do
begin
//.cls entire area of "a" + draw char indented by "xpad" from left to allow boundary overlap scanning - 20apr2020
mis_textrect(a,misrect(0,0,aw,ah),xpad,0,char(p));
app__fasttimer;//fasttimer - 07jul2021
tw:=xws[p];
//.detect left + right boundaries ----------------------------------------------
xleft:=xpad;
xright:=xleft+tw-1;
dw6:=frcrange((xpad div 6)+1,0,awcount6);//scan upto the start of the char or slightly inside
for sy:=0 to (xmaxh-1) do
begin
//.fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

tpointer(ar96):=tpointer(@xrows24[sy]^);

//.detect left boundary
sx:=-1;
for dx:=0 to (dw6-1) do
begin
ac96:=ar96[dx];//6 pixels at once
//.v0
inc(sx);
if (sx<xleft) and (ac96.v0<=xblackok) then xleft:=sx;
//.v2
inc(sx);
if (sx<xleft) and (ac96.v2<=xblackok) then xleft:=sx;
//.v4
inc(sx);
if (sx<xleft) and (ac96.v4<=xblackok) then xleft:=sx;
//.v6
inc(sx);
if (sx<xleft) and (ac96.v6<=xblackok) then xleft:=sx;
//.v8
inc(sx);
if (sx<xleft) and (ac96.v8<=xblackok) then xleft:=sx;
//.v10
inc(sx);
if (sx<xleft) and (ac96.v10<=xblackok) then xleft:=sx;
end;//dx

//.detect right boundary
sx:=aw;
for dx:=(awcount6-1) downto (awcount6-1-dw6) do
begin
ac96:=ar96[dx];//6 pixels at once
//.v10
dec(sx);
if (ac96.v10<=xblackok) and (sx>=xright) then xright:=sx;
//.v8
dec(sx);
if (ac96.v8<=xblackok) and (sx>=xright) then xright:=sx;
//.v6
dec(sx);
if (ac96.v6<=xblackok) and (sx>=xright) then xright:=sx;
//.v4
dec(sx);
if (ac96.v4<=xblackok) and (sx>=xright) then xright:=sx;
//.v2
dec(sx);
if (ac96.v2<=xblackok) and (sx>=xright) then xright:=sx;
//.v0
dec(sx);
if (ac96.v0<=xblackok) and (sx>=xright) then xright:=sx;
end;//dx
end;//dy

//.init for capture
tw:=frcmin((xright-xleft+1),tw);//actual width used -> never go below reported width
xright:=xleft+tw-1;
wrd2.val:=tw;
int4.val:=xlen;
i:=8+(p*6);
xdata.pbytes[i+0]:=wrd2.bytes[0];//character width
xdata.pbytes[i+1]:=wrd2.bytes[1];
xdata.pbytes[i+2]:=int4.bytes[0];//character data start position
xdata.pbytes[i+3]:=int4.bytes[1];
xdata.pbytes[i+4]:=int4.bytes[2];
xdata.pbytes[i+5]:=int4.bytes[3];
//.write pixel sets to datastream -> 16bit -> 1bit converter -> RLE compressor
xcount:=0;
xcounton:=false;
dlen:=0;
int1:=xleft+tw;
dw6:=int1 div 6;
if ((dw6*6)<int1) then inc(dw6);
dw6:=frcrange(dw6,0,awcount6);

for sy:=0 to (xmaxh-1) do
begin
//.fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

tpointer(ar96):=tpointer(@xrows24[sy]^);
bol1:=false;

//.enlarge
if ((dlen+(aw*4))>dbufferlen) then//over-estimated size of buffer should this row need excessive space - worse case and then some - 20apr2020
   begin
   dbuffer.minlen(dbufferlen+(aw*4));
   dbufferlen:=dbuffer.len;
   end;

//.first
if (sy=0) then
   begin
   sx:=-1;
   for dx:=0 to (dw6-1) do
   begin
   ac96:=ar96[dx];//6 pixels at once
   //.v0
   inc(sx);
   if (sx>=xleft) and xfirstset(ac96.v0<=xblackok) then break;
   //.v2
   inc(sx);
   if (sx>=xleft) and xfirstset(ac96.v2<=xblackok) then break;
   //.v4
   inc(sx);
   if (sx>=xleft) and xfirstset(ac96.v4<=xblackok) then break;
   //.v6
   inc(sx);
   if (sx>=xleft) and xfirstset(ac96.v6<=xblackok) then break;
   //.v8
   inc(sx);
   if (sx>=xleft) and xfirstset(ac96.v8<=xblackok) then break;
   //.v10
   inc(sx);
   if (sx>=xleft) and xfirstset(ac96.v10<=xblackok) then break;
   end;//dx
   end;//first

sx:=-1;
for dx:=0 to (dw6-1) do
begin
ac96:=ar96[dx];//6 pixels at once

//.v0
inc(sx);
if (sx>=xleft) and (sx<=xright) then
   begin
   bol2:=(ac96.v0<=xblackok);
   if bol2 then bol1:=true;
   //.store the difference
   if (bol2<>xcounton) then
      begin
      //.3byte datablock => 128..8,388,608
      if (xcount>128) then
         begin
         //one based to zero based -> (129..8,388,608) -> (128..8,387,607)
         dec(xcount);
         //b1 -> (0-127) + (128/mark as 3byte data block)
         int1:=xcount div 65536;
         inc(dlen);dbuffer.pbytes[dlen-1]:=int1+128;
         dec(xcount,int1*65536);
         //b2
         int1:=xcount div 256;
         inc(dlen);dbuffer.pbytes[dlen-1]:=int1;
         dec(xcount,int1*256);
         //b3
         inc(dlen);dbuffer.pbytes[dlen-1]:=xcount;
         end
      //.1byte datablock => 1..128 (0..127)
      else
         begin
         inc(dlen);
         dbuffer.pbytes[dlen-1]:=xcount-1;//1..128 => 0..127 (mark as single byte datablock)
         end;
      //reset
      xcount:=1;
      xcounton:=bol2;
      end
   else inc(xcount);
   end;

//.v2
inc(sx);
if (sx>=xleft) and (sx<=xright) then
   begin
   bol2:=(ac96.v2<=xblackok);
   if bol2 then bol1:=true;
   //.store the difference
   if (bol2<>xcounton) then
      begin
      //.3byte datablock => 128..8,388,608
      if (xcount>128) then
         begin
         //one based to zero based -> (129..8,388,608) -> (128..8,388,607)
         dec(xcount);
         //b1 -> (0-127) + (128/mark as 3byte data block)
         int1:=xcount div 65536;
         inc(dlen);dbuffer.pbytes[dlen-1]:=int1+128;
         dec(xcount,int1*65536);
         //b2
         int1:=xcount div 256;
         inc(dlen);dbuffer.pbytes[dlen-1]:=int1;
         dec(xcount,int1*256);
         //b3
         inc(dlen);dbuffer.pbytes[dlen-1]:=xcount;
         end
      //.1byte datablock => 1..128 (0..127)
      else
         begin
         inc(dlen);
         dbuffer.pbytes[dlen-1]:=xcount-1;//1..128 => 0..127 (mark as single byte datablock)
         end;
      //reset
      xcount:=1;
      xcounton:=bol2;
      end
   else inc(xcount);
   end;

//.v4
inc(sx);
if (sx>=xleft) and (sx<=xright) then
   begin
   bol2:=(ac96.v4<=xblackok);
   if bol2 then bol1:=true;
   //.store the difference
   if (bol2<>xcounton) then
      begin
      //.3byte datablock => 128..8,388,608
      if (xcount>128) then
         begin
         //one based to zero based -> (129..8,388,608) -> (128..8,388,607)
         dec(xcount);
         //b1 -> (0-127) + (128/mark as 3byte data block)
         int1:=xcount div 65536;
         inc(dlen);dbuffer.pbytes[dlen-1]:=int1+128;
         dec(xcount,int1*65536);
         //b2
         int1:=xcount div 256;
         inc(dlen);dbuffer.pbytes[dlen-1]:=int1;
         dec(xcount,int1*256);
         //b3
         inc(dlen);dbuffer.pbytes[dlen-1]:=xcount;
         end
      //.1byte datablock => 1..128 (0..127)
      else
         begin
         inc(dlen);
         dbuffer.pbytes[dlen-1]:=xcount-1;//1..128 => 0..127 (mark as single byte datablock)
         end;
      //reset
      xcount:=1;
      xcounton:=bol2;
      end
   else inc(xcount);
   end;

//.v6
inc(sx);
if (sx>=xleft) and (sx<=xright) then
   begin
   bol2:=(ac96.v6<=xblackok);
   if bol2 then bol1:=true;
   //.store the difference
   if (bol2<>xcounton) then
      begin
      //.3byte datablock => 128..8,388,608
      if (xcount>128) then
         begin
         //one based to zero based -> (129..8,388,608) -> (128..8,388,607)
         dec(xcount);
         //b1 -> (0-127) + (128/mark as 3byte data block)
         int1:=xcount div 65536;
         inc(dlen);dbuffer.pbytes[dlen-1]:=int1+128;
         dec(xcount,int1*65536);
         //b2
         int1:=xcount div 256;
         inc(dlen);dbuffer.pbytes[dlen-1]:=int1;
         dec(xcount,int1*256);
         //b3
         inc(dlen);dbuffer.pbytes[dlen-1]:=xcount;
         end
      //.1byte datablock => 1..128 (0..127)
      else
         begin
         inc(dlen);
         dbuffer.pbytes[dlen-1]:=xcount-1;//1..128 => 0..127 (mark as single byte datablock)
         end;
      //reset
      xcount:=1;
      xcounton:=bol2;
      end
   else inc(xcount);
   end;

//.v8
inc(sx);
if (sx>=xleft) and (sx<=xright) then
   begin
   bol2:=(ac96.v8<=xblackok);
   if bol2 then bol1:=true;
   //.store the difference
   if (bol2<>xcounton) then
      begin
      //.3byte datablock => 128..8,388,608
      if (xcount>128) then
         begin
         //one based to zero based -> (129..8,388,608) -> (128..8,388,607)
         dec(xcount);
         //b1 -> (0-127) + (128/mark as 3byte data block)
         int1:=xcount div 65536;
         inc(dlen);dbuffer.pbytes[dlen-1]:=int1+128;
         dec(xcount,int1*65536);
         //b2
         int1:=xcount div 256;
         inc(dlen);dbuffer.pbytes[dlen-1]:=int1;
         dec(xcount,int1*256);
         //b3
         inc(dlen);dbuffer.pbytes[dlen-1]:=xcount;
         end
      //.1byte datablock => 1..128 (0..127)
      else
         begin
         inc(dlen);
         dbuffer.pbytes[dlen-1]:=xcount-1;//1..128 => 0..127 (mark as single byte datablock)
         end;
      //reset
      xcount:=1;
      xcounton:=bol2;
      end
   else inc(xcount);
   end;

//.v10
inc(sx);
if (sx>=xleft) and (sx<=xright) then
   begin
   bol2:=(ac96.v10<=xblackok);
   if bol2 then bol1:=true;
   //.store the difference
   if (bol2<>xcounton) then
      begin
      //.3byte datablock => 128..8,388,608
      if (xcount>128) then
         begin
         //one based to zero based -> (129..8,388,608) -> (128..8,388,607)
         dec(xcount);
         //b1 -> (0-127) + (128/mark as 3byte data block)
         int1:=xcount div 65536;
         inc(dlen);dbuffer.pbytes[dlen-1]:=int1+128;
         dec(xcount,int1*65536);
         //b2
         int1:=xcount div 256;
         inc(dlen);dbuffer.pbytes[dlen-1]:=int1;
         dec(xcount,int1*256);
         //b3
         inc(dlen);dbuffer.pbytes[dlen-1]:=xcount;
         end
      //.1byte datablock => 1..128 (0..127)
      else
         begin
         inc(dlen);
         dbuffer.pbytes[dlen-1]:=xcount-1;//1..128 => 0..127 (mark as single byte datablock)
         end;
      //reset
      xcount:=1;
      xcounton:=bol2;
      end
   else inc(xcount);
   end;
end;//dx

//.xmaxh1 -> only for chars "A,B,C and D"
if (p>=65) and (p<=68) and bol1 and (sy>=xmaxh1) then xmaxh1:=sy+1;
end;//sy

//.finish character
if (xcount>=1) then
   begin
   //.3byte datablock => 128..8,388,608
   if (xcount>128) then
      begin
      //one based to zero based -> (129..8,388,608) -> (128..8,388,607)
      dec(xcount);
      //b1 -> (0-127) + (128/mark as 3byte data block)
      int1:=xcount div 65536;
      inc(dlen);dbuffer.pbytes[dlen-1]:=int1+128;
      dec(xcount,int1*65536);
      //b2
      int1:=xcount div 256;
      inc(dlen);dbuffer.pbytes[dlen-1]:=int1;
      dec(xcount,int1*256);
      //b3
      inc(dlen);dbuffer.pbytes[dlen-1]:=xcount;
      end
   //.1byte datablock => 1..128 (0..127)
   else
      begin
      inc(dlen);
      dbuffer.pbytes[dlen-1]:=xcount-1;//1..128 => 0..127 (mark as single byte datablock)
      end;
   end;

//.finalise character -> updates "xlen" ready for next character to be tracked and stored - 21aug2019
if (dlen>=1) then
   begin
   xdata.add2(dbuffer,0,dlen-1);
   xlen:=xdata.count;
   end;
end;//p
//.done
goto skipdone;


//detect32 -> all characters (rapid run-length compression) --------------------
detect32:
for p:=0 to 255 do
begin
//.cls entire area of "a" + draw char indented by "xpad" from left to allow boundary overlap scanning - 20apr2020
mis_textrect(a,misrect(0,0,aw,ah),xpad,0,char(p));
app__fasttimer;//fasttimer - 07jul2021
tw:=xws[p];
//.detect left + right boundaries ----------------------------------------------
xleft:=xpad;
xright:=xleft+tw-1;
dw3:=frcrange((xpad div 3)+1,0,awcount3);//scan upto the start of the char or slightly inside
for sy:=0 to (xmaxh-1) do
begin
//.fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

tpointer(ar96):=tpointer(@xrows24[sy]^);

//.detect left boundary
sx:=-1;
for dx:=0 to (dw3-1) do
begin
ac96:=ar96[dx];//3 pixels at once
//.v1
inc(sx);
if (sx<xleft) and (ac96.v1<=xblackok) then xleft:=sx;
//.v5
inc(sx);
if (sx<xleft) and (ac96.v5<=xblackok) then xleft:=sx;
//.v9
inc(sx);
if (sx<xleft) and (ac96.v9<=xblackok) then xleft:=sx;
end;//dx

//.detect right boundary
sx:=aw;
for dx:=(awcount3-1) downto (awcount3-1-dw3) do
begin
ac96:=ar96[dx];//3 pixels at once
//.v9
dec(sx);
if (ac96.v9<=xblackok) and (sx>=xright) then xright:=sx;
//.v5
dec(sx);
if (ac96.v5<=xblackok) and (sx>=xright) then xright:=sx;
//.v1
dec(sx);
if (ac96.v1<=xblackok) and (sx>=xright) then xright:=sx;
end;//dx
end;//dy

//.init for capture
tw:=frcmin((xright-xleft+1),tw);//actual width used -> never go below reported width
xright:=xleft+tw-1;
wrd2.val:=tw;
int4.val:=xlen;
i:=8+(p*6);
xdata.pbytes[i+0]:=wrd2.bytes[0];//character width
xdata.pbytes[i+1]:=wrd2.bytes[1];
xdata.pbytes[i+2]:=int4.bytes[0];//character data start position
xdata.pbytes[i+3]:=int4.bytes[1];
xdata.pbytes[i+4]:=int4.bytes[2];
xdata.pbytes[i+5]:=int4.bytes[3];
//.write pixel sets to datastream -> 16bit -> 1bit converter -> RLE compressor
xcount:=0;
xcounton:=false;
dlen:=0;
int1:=xleft+tw;
dw3:=int1 div 3;
if ((dw3*3)<int1) then inc(dw3);
dw3:=frcrange(dw3,0,awcount3);

for sy:=0 to (xmaxh-1) do
begin
//.fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

tpointer(ar96):=tpointer(@xrows24[sy]^);
bol1:=false;

//.enlarge
if ((dlen+(aw*4))>dbufferlen) then//over-estimated size of buffer should this row need excessive space - worse case and then some - 20apr2020
   begin
   dbuffer.minlen(dbufferlen+(aw*4));
   dbufferlen:=dbuffer.len;
   end;

//.first
if (sy=0) then
   begin
   sx:=-1;
   for dx:=0 to (dw3-1) do
   begin
   ac96:=ar96[dx];//3 pixels at once
   //.v1
   inc(sx);
   if (sx>=xleft) and xfirstset(ac96.v1<=xblackok) then break;
   //.v5
   inc(sx);
   if (sx>=xleft) and xfirstset(ac96.v5<=xblackok) then break;
   //.v9
   inc(sx);
   if (sx>=xleft) and xfirstset(ac96.v9<=xblackok) then break;
   end;//dx
   end;//first

sx:=-1;
for dx:=0 to (dw3-1) do
begin
ac96:=ar96[dx];//3 pixels at once

//.v1
inc(sx);
if (sx>=xleft) and (sx<=xright) then
   begin
   bol2:=(ac96.v1<=xblackok);
   if bol2 then bol1:=true;
   //.store the difference
   if (bol2<>xcounton) then
      begin
      //.3byte datablock => 128..8,388,608
      if (xcount>128) then
         begin
         //one based to zero based -> (129..8,388,608) -> (128..8,388,607)
         dec(xcount);
         //b1 -> (0-127) + (128/mark as 3byte data block)
         int1:=xcount div 65536;
         inc(dlen);dbuffer.pbytes[dlen-1]:=int1+128;
         dec(xcount,int1*65536);
         //b2
         int1:=xcount div 256;
         inc(dlen);dbuffer.pbytes[dlen-1]:=int1;
         dec(xcount,int1*256);
         //b3
         inc(dlen);dbuffer.pbytes[dlen-1]:=xcount;
         end
      //.1byte datablock => 1..128 (0..127)
      else
         begin
         inc(dlen);
         dbuffer.pbytes[dlen-1]:=xcount-1;//1..128 => 0..127 (mark as single byte datablock)
         end;
      //reset
      xcount:=1;
      xcounton:=bol2;
      end
   else inc(xcount);
   end;

//.v5
inc(sx);
if (sx>=xleft) and (sx<=xright) then
   begin
   bol2:=(ac96.v5<=xblackok);
   if bol2 then bol1:=true;
   //.store the difference
   if (bol2<>xcounton) then
      begin
      //.3byte datablock => 128..8,388,608
      if (xcount>128) then
         begin
         //one based to zero based -> (129..8,388,608) -> (128..8,388,607)
         dec(xcount);
         //b1 -> (0-127) + (128/mark as 3byte data block)
         int1:=xcount div 65536;
         inc(dlen);dbuffer.pbytes[dlen-1]:=int1+128;
         dec(xcount,int1*65536);
         //b2
         int1:=xcount div 256;
         inc(dlen);dbuffer.pbytes[dlen-1]:=int1;
         dec(xcount,int1*256);
         //b3
         inc(dlen);dbuffer.pbytes[dlen-1]:=xcount;
         end
      //.1byte datablock => 1..128 (0..127)
      else
         begin
         inc(dlen);
         dbuffer.pbytes[dlen-1]:=xcount-1;//1..128 => 0..127 (mark as single byte datablock)
         end;
      //reset
      xcount:=1;
      xcounton:=bol2;
      end
   else inc(xcount);
   end;

//.v9
inc(sx);
if (sx>=xleft) and (sx<=xright) then
   begin
   bol2:=(ac96.v9<=xblackok);
   if bol2 then bol1:=true;
   //.store the difference
   if (bol2<>xcounton) then
      begin
      //.3byte datablock => 128..8,388,608
      if (xcount>128) then
         begin
         //one based to zero based -> (129..8,388,608) -> (128..8,388,607)
         dec(xcount);
         //b1 -> (0-127) + (128/mark as 3byte data block)
         int1:=xcount div 65536;
         inc(dlen);dbuffer.pbytes[dlen-1]:=int1+128;
         dec(xcount,int1*65536);
         //b2
         int1:=xcount div 256;
         inc(dlen);dbuffer.pbytes[dlen-1]:=int1;
         dec(xcount,int1*256);
         //b3
         inc(dlen);dbuffer.pbytes[dlen-1]:=xcount;
         end
      //.1byte datablock => 1..128 (0..127)
      else
         begin
         inc(dlen);
         dbuffer.pbytes[dlen-1]:=xcount-1;//1..128 => 0..127 (mark as single byte datablock)
         end;
      //reset
      xcount:=1;
      xcounton:=bol2;
      end
   else inc(xcount);
   end;
end;//dx

//.xmaxh1 -> only for chars "A,B,C and D"
if (p>=65) and (p<=68) and bol1 and (sy>=xmaxh1) then xmaxh1:=sy+1;
end;//sy

//.finish character
if (xcount>=1) then
   begin
   //.3byte datablock => 128..8,388,608
   if (xcount>128) then
      begin
      //one based to zero based -> (129..8,388,608) -> (128..8,388,607)
      dec(xcount);
      //b1 -> (0-127) + (128/mark as 3byte data block)
      int1:=xcount div 65536;
      inc(dlen);dbuffer.pbytes[dlen-1]:=int1+128;
      dec(xcount,int1*65536);
      //b2
      int1:=xcount div 256;
      inc(dlen);dbuffer.pbytes[dlen-1]:=int1;
      dec(xcount,int1*256);
      //b3
      inc(dlen);dbuffer.pbytes[dlen-1]:=xcount;
      end
   //.1byte datablock => 1..128 (0..127)
   else
      begin
      inc(dlen);
      dbuffer.pbytes[dlen-1]:=xcount-1;//1..128 => 0..127 (mark as single byte datablock)
      end;
   end;

//.finalise character -> updates "xlen" ready for next character to be tracked and stored - 21aug2019
if (dlen>=1) then
   begin
   xdata.add2(dbuffer,0,dlen-1);
   xlen:=xdata.count;
   end;
end;//p
//.done
goto skipdone;


//xxxxxxxxxxxxxxx//1234567890
//detect32__greyscale -> all characters (rapid run-length compression) --------------------
detect32__greyscale:
for p:=0 to 255 do
begin
//.cls entire area of "a" + draw char indented by "xpad" from left to allow boundary overlap scanning - 20apr2020
mis_textrect(a,misrect(0,0,aw,ah),xpad,0,char(p));
app__fasttimer;//fasttimer - 07jul2021
tw:=xws[p];
//.detect left + right boundaries ----------------------------------------------
xleft:=xpad;
xright:=xleft+tw-1;
dw3:=frcrange((xpad div 3)+1,0,awcount3);//scan upto the start of the char or slightly inside
for sy:=0 to (xmaxh-1) do
begin
//.fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

tpointer(ar96):=tpointer(@xrows24[sy]^);

//.detect left boundary
sx:=-1;
for dx:=0 to (dw3-1) do
begin
ac96:=ar96[dx];//3 pixels at once
//.v1
inc(sx);
if (sx<xleft) and (ac96.v1<255) then xleft:=sx;
//.v5
inc(sx);
if (sx<xleft) and (ac96.v5<255) then xleft:=sx;
//.v9
inc(sx);
if (sx<xleft) and (ac96.v9<255) then xleft:=sx;
end;//dx

//.detect right boundary
sx:=aw;
for dx:=(awcount3-1) downto (awcount3-1-dw3) do
begin
ac96:=ar96[dx];//3 pixels at once
//.v9
dec(sx);
if (ac96.v9<255) and (sx>=xright) then xright:=sx;
//.v5
dec(sx);
if (ac96.v5<255) and (sx>=xright) then xright:=sx;
//.v1
dec(sx);
if (ac96.v1<255) and (sx>=xright) then xright:=sx;
end;//dx
end;//dy

//.init for capture
tw:=frcmin((xright-xleft+1),tw);//actual width used -> never go below reported width
xright:=xleft+tw-1;
wrd2.val:=tw;
int4.val:=xlen;
i:=8+(p*6);
xdata.pbytes[i+0]:=wrd2.bytes[0];//character width
xdata.pbytes[i+1]:=wrd2.bytes[1];
xdata.pbytes[i+2]:=int4.bytes[0];//character data start position
xdata.pbytes[i+3]:=int4.bytes[1];
xdata.pbytes[i+4]:=int4.bytes[2];
xdata.pbytes[i+5]:=int4.bytes[3];
//.write pixel sets to datastream -> 24bit -> 4bit converter -> RLE compressor
xcount:=0;
xcounton:=false;
xval8:=255;//off
xcount8:=0;
dlen:=0;
int1:=xleft+tw;
dw3:=int1 div 3;
if ((dw3*3)<int1) then inc(dw3);
dw3:=frcrange(dw3,0,awcount3);

for sy:=0 to (xmaxh-1) do
begin
//.fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

tpointer(ar96):=tpointer(@xrows24[sy]^);
bol1:=false;

//.enlarge
if ((dlen+(aw*4))>dbufferlen) then//over-estimated size of buffer should this row need excessive space - worse case and then some - 20apr2020
   begin
   dbuffer.minlen(dbufferlen+(aw*4));
   dbufferlen:=dbuffer.len;
   end;

//.first
if (sy=0) then
   begin
   sx:=-1;
   for dx:=0 to (dw3-1) do
   begin
   ac96:=ar96[dx];//3 pixels at once
   //.v1
   inc(sx);
   if (sx>=xleft) then break;
   //.v5
   inc(sx);
   if (sx>=xleft) then break;
   //.v9
   inc(sx);
   if (sx>=xleft) then break;
   end;//dx
   end;//first

sx:=-1;
for dx:=0 to (dw3-1) do
begin
ac96:=ar96[dx];//3 pixels at once
//.v1
inc(sx);
if (sx>=xleft) and (sx<=xright) then xadd8(ac96.v1);
//.v5
inc(sx);
if (sx>=xleft) and (sx<=xright) then xadd8(ac96.v5);
//.v9
inc(sx);
if (sx>=xleft) and (sx<=xright) then xadd8(ac96.v9);
end;//dx

//.xmaxh1 -> only for chars "A,B,C and D"
if (p>=65) and (p<=68) and bol1 and (sy>=xmaxh1) then xmaxh1:=sy+1;
end;//sy

//.finish character
if (xcount8>=1) then xadd8(low__aorb(255,254,xval8=255));//force write of last val by pushing a different val - 13feb2022
   
//.finalise character -> updates "xlen" ready for next character to be tracked and stored - 21aug2019
if (dlen>=1) then
   begin
   xdata.add2(dbuffer,0,dlen-1);
   xlen:=xdata.count;
   end;
end;//p
//.done
goto skipdone;


//finalise ---------------------------------------------------------------------
skipdone:
//.store height1 in header (7..8) -> distance from top to baseline
wrd2.val:=frcmin(xmaxh1,0);
xdata.pbytes[6]:=wrd2.bytes[0];
xdata.pbytes[7]:=wrd2.bytes[1];

//.finalise
xdata.aadd([0,0,0]);//include 3 trailing padding bytes -> helps to simplify and speed up decoder
xdata.setlen(xdata.count);

//successful
result:=true;
skipend:
except;end;
try
freeobj(@a);
bfree(dbuffer);//fixed - 28jan2021
bunlockautofree(xdata);
except;end;
end;
//## low__fromLGF_height ##
function low__fromLGF_height(x:tobject):longint;
var
   wrd2:twrd2;
begin
try
result:=0;
if zzok(x,7065) and (x is tstr8) and ((x as tstr8).count>=1544) then
   begin
   wrd2.bytes[0]:=(x as tstr8).pbytes[4];
   wrd2.bytes[1]:=(x as tstr8).pbytes[5];
   result:=wrd2.val;
   end;
except;end;
end;
//## low__fromLGF_height1 ##
function low__fromLGF_height1(x:tobject):longint;
var
   wrd2:twrd2;
begin
try
result:=0;
if zzok(x,7066) and (x is tstr8) and ((x as tstr8).count>=1544) then
   begin
   wrd2.bytes[0]:=(x as tstr8).pbytes[6];
   wrd2.bytes[1]:=(x as tstr8).pbytes[7];
   result:=wrd2.val;
   end;
except;end;
end;
//## low__fromLGF_charw ##
function low__fromLGF_charw(x:tobject;xindex:longint):longint;
var
   wrd2:twrd2;
   int4:tint4;
   i:longint;
begin
try
result:=0;
if zzok(x,7067) and (x is tstr8) and ((x as tstr8).count>=1544) then
   begin
   //range
   if (xindex<0) then xindex:=0 else if (xindex>255) then xindex:=255;
   //get
   i:=8+(xindex*6);
   wrd2.bytes[0]:=(x as tstr8).pbytes[i+0];//character width
   wrd2.bytes[1]:=(x as tstr8).pbytes[i+1];
   result:=wrd2.val;
   end;
except;end;
end;
//## low__fromLGF_avew ##
procedure low__fromLGF_avew(x:tobject;var xave,xmin,xmax:longint);//11apr2020
var//Always returns 1+ for outputs: xave/xmin/xmax
   xval,p:longint;
   dave:single;
begin
try
//defaults
xave:=1;
xmin:=maxword;
xmax:=1;
//get
for p:=0 to 255 do
begin
xval:=low__fromLGF_charw(x,p);
if (xval<xmin) then xmin:=xval;
if (xval>xmax) then xmax:=xval;
if (p=0) then dave:=xval else dave:=((dave+xval)/2);
end;//p
//set
xmin:=frcmin(xmin,1);//never zero or less
xmax:=frcmin(xmax,1);
xave:=frcmin(frcrange(round(dave),xmin,xmax),1);
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxx//tttttttttttttttttttttttttttttttttttt
//## low__fromLGF_drawchar2432 ##
function low__fromLGF_drawchar2432(x:tobject;xindex,ax,ay,aw,ah,dcolor:longint;xarea,xarea2:trect;ar24:pcolorrows24;ar32:pcolorrows32;xmask:tmask8;xmaskval:longint;xfc:tstr8;xfeather:longint;xbold,xitalic,xunderline,xlink,xstrikeout,xround:boolean;xroundstyle:longint):boolean;//27feb2021, 23jan2020
label//Note: xfeather: minint..0=off, 1=low(LR only), 2=medium(LR+TB), 3=high(LR+TB+heavier)
   drawmasked24,drawmasked32,draw24,draw32,skipdone,skipend;
var//Ultra-rapid, real-time, linear graphic font character drawing system
   //Speed Test1: 5500 characters on a 1250w x 750h screen using "Arial 12/feather=off" in 30-60ms on an Intel Atom 1.44GHz CPU - 21aug2019
   //Speed Test2: 5500 characters on a 1250w x 750h screen using "Arial 12/feather=1" in 156-172ms (50-30ms faster feather) on an Intel Atom 1.44GHz CPU - 17apr2020
   //afc = feather cache (used to draw realtime feather) - 21sep2019
   aptr:tstr8;//pointer only
   a:trect;
   mr8:pcolorrows8;
   wrd2:twrd2;
   int4:tint4;
   dc24:tcolor24;
   dc32:tcolor32;
   xzoom,xlinkstep,xgreyfilter,lx2,rx2,lx,rx,amin,cfeatherpower,p,i,xcount,c,r,g,b,fi1,fi2,fi,int1,int2,xlen,xpos,xstop,sx,sy,dx,dy,dx2,tw,th,th1:longint;
   xbold1,xbold2,ybold1,ybold2,xunderline1,xunderline2,xstrikeout1,xstrikeout2:longint;
   xgreyscale,bol1,xcounton,dlink,dunderline,dstrikeout:boolean;
   xval8:byte;
   //## dc32G ##
   procedure dc32G(sy,sx:longint);//13feb2022
   begin
   if (xval8=255) then exit;
   dc32:=ar32[sy][sx];
   dc32.r:=((int4.r*(255-xval8))+(dc32.r*xval8)) div 255;
   dc32.g:=((int4.g*(255-xval8))+(dc32.g*xval8)) div 255;
   dc32.b:=((int4.b*(255-xval8))+(dc32.b*xval8)) div 255;
   ar32[sy][sx]:=dc32;
   end;
   //## dc32Gon ##
   procedure dc32Gon(sy,sx:longint);//13feb2022
   begin
   dc32.r:=int4.r;
   dc32.g:=int4.g;
   dc32.b:=int4.b;
   ar32[sy][sx]:=dc32;
   end;
   //## dc24G ##
   procedure dc24G(sy,sx:longint);//13feb2022
   begin
   if (xval8=255) then exit;
   dc24:=ar24[sy][sx];
   dc24.r:=((int4.r*(255-xval8))+(dc24.r*xval8)) div 255;
   dc24.g:=((int4.g*(255-xval8))+(dc24.g*xval8)) div 255;
   dc24.b:=((int4.b*(255-xval8))+(dc24.b*xval8)) div 255;
   ar24[sy][sx]:=dc24;
   end;
   //## dc24Gon ##
   procedure dc24Gon(sy,sx:longint);//13feb2022
   begin
   dc24.r:=int4.r;
   dc24.g:=int4.g;
   dc24.b:=int4.b;
   ar24[sy][sx]:=dc24;
   end;
   //## xlinkdot ##
   function xlinkdot:boolean;
   begin
   result:=(dx<>((dx div xlinkstep)*xlinkstep));
   end;
   //## dinits ##
   procedure dinits;
   begin
   dunderline:=xunderline and (dy>=xunderline1) and (dy<=xunderline2);
   dlink:=xlink and (dy>=xunderline1) and (dy<=xunderline2);
   dstrikeout:=xstrikeout and (dy>=xstrikeout1) and (dy<=xstrikeout2);
   end;
begin
try
//defaults
result:=false;
block(xfc);

//check
if zzok(x,7068) and (x is tstr8) then
   begin
   aptr:=(x as tstr8);
   xlen:=aptr.count;
   end
else goto skipend;
if ((ar24=nil) and (ar32=nil)) or (xlen<1544) then goto skipend;
//range
if (xindex<0) then xindex:=0 else if (xindex>255) then xindex:=255;
//check mask
if (xmaskval>=0) then
   begin
   if zznil(xmask,2244) or (xmask.width<aw) or (xmask.height<ah) then xmaskval:=-1;//off - 27apr2021
   if (xmaskval>=0) then mr8:=xmask.prows8;
   end;
//check area
if (xarea.bottom<xarea.top) or (xarea.right<xarea.left) or (xarea.right<0) or (xarea.left>=aw) or (xarea.bottom<0) or (xarea.top>=ah) then exit;
if (xarea2.bottom<xarea2.top) or (xarea2.right<xarea2.left) or (xarea2.right<xarea.left) or (xarea2.left>xarea.right) or (xarea2.bottom<xarea.top) or (xarea2.top>xarea.bottom) then exit;

//init
//.zoom
xzoom:=vizoom;
xlinkstep:=xzoom*2;
//.amin
a:=xarea2;//used for calculating curved cornersretain original copy of "xarea" for calculations and reference
amin:=smallest(low__sum32([a.bottom,-a.top,1]),low__sum32([a.right,-a.left,1]));
//.x
if (xarea.left<xarea2.left) then xarea.left:=xarea2.left;
xarea.left:=frcrange(xarea.left,0,aw-1);
if (xarea.right>xarea2.right) then xarea.right:=xarea2.right;
xarea.right:=frcrange(xarea.right,0,aw-1);
if (xarea.right<xarea.left) then exit;
//.y
if (xarea.top<xarea2.top) then xarea.top:=xarea2.top;
xarea.top:=frcrange(xarea.top,0,ah-1);
if (xarea.bottom>xarea2.bottom) then xarea.bottom:=xarea2.bottom;
xarea.bottom:=frcrange(xarea.bottom,0,ah-1);
if (xarea.bottom<xarea.top) then exit;

//.greyscale
xgreyscale:=(aptr.pbytes[3]=52);//4 = version 4.0 = greyscale (shades of grey) - 13feb2022
case vifeatherf of
0:xgreyfilter:=255;//off
1:xgreyfilter:=84;
2:xgreyfilter:=50;
3:xgreyfilter:=1;
else xgreyfilter:=1;
end;
//.th
wrd2.bytes[0]:=aptr.pbytes[4];
wrd2.bytes[1]:=aptr.pbytes[5];
th:=wrd2.val;
//.th1
wrd2.bytes[0]:=aptr.pbytes[6];
wrd2.bytes[1]:=aptr.pbytes[7];
th1:=wrd2.val;
//.tw
i:=8+(xindex*6);
wrd2.bytes[0]:=aptr.pbytes[i+0];//character width (2/6)
wrd2.bytes[1]:=aptr.pbytes[i+1];
tw:=wrd2.val;
//.xpos
int4.bytes[0]:=aptr.pbytes[i+2];//character data start position (4/6)
int4.bytes[1]:=aptr.pbytes[i+3];
int4.bytes[2]:=aptr.pbytes[i+4];
int4.bytes[3]:=aptr.pbytes[i+5];
xpos:=int4.val+1;
//check
if (tw<1) or (th<1) or (xpos<1) then goto skipend;
//init
//.feather cache
int1:=tw*th;
if (xfeather>=1) then
   begin
   if zznil(xfc,2245) then xfeather:=0//no feather control -> turn off feathering - 02may2020
   else if (int1>xfc.len) then xfc.setlen(2*int1);//over-allow -> faster for next char that requires more data
   end;
case xfeather of
4:cfeatherpower:=4;//lower the value stronger the feather
3:cfeatherpower:=8;
else cfeatherpower:=12;//normal/light feather
end;
//.effects
if xunderline or xlink then//19jun2022, 17apr2020
   begin
   xunderline1:=ay+frcmax(th1+1,th-1);
   xunderline2:=ay+frcmax(th1+frcmin(trunc(th*0.06),1),th-1);
   end;
if xstrikeout then//17apr2020
   begin
   int1:=round(th1*0.3);
   xstrikeout1:=ay+frcmin(th1-int1-trunc(th*0.04),0);
   xstrikeout2:=ay+frcmin(th1-int1,0);
   end;
if xbold then//18apr2020
   begin
   xbold1:=frcrange(trunc(th*0.03),0,10);
   xbold2:=frcrange(trunc(th*0.03),1,10);
   ybold1:=frcrange(trunc(th*0.03),0,10);
   ybold2:=frcrange(trunc(th*0.03),0,10);
   //.must clear feather cache for bold -> since overlapping pixels are wiped out from normal feather tracking - 18apr2020
   if (xfeather>=1) and xfc.notempty then for p:=(xfc.count-1) downto 0 do xfc.pbytes[p]:=0;
   end;
//get
int4.val:=dcolor;
if      (ar32<>nil) then
   begin
   if (xmaskval>=0) then goto drawmasked32 else goto draw32;
   end
else if (ar24<>nil) then
   begin
   if (xmaskval>=0) then goto drawmasked24 else goto draw24;
   end;
//.fail
goto skipend;

//-- draw32 --------------------------------------------------------------------
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//ddddddddddddddddddddddddddddddddddddd
draw32:
dc32.r:=int4.r;
dc32.g:=int4.g;
dc32.b:=int4.b;
dc32.a:=255;
//.start style
xcount:=0;
xcounton:=false;//must be FALSE even for greyscale mode - 13feb2022
xval8:=255;//255=off
if (not xgreyscale) and (xpos<=xlen) then
   begin
   xcounton:=(aptr.pbytes[xpos-1]=0);//invert to start with
   inc(xpos);
   end;

for sy:=0 to (th-1) do
begin
//fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

dy:=ay+sy;
//.corner
low__cornersolid(true,a,amin,dy,xarea.left,xarea.right,xroundstyle,xround,lx,rx);
//.italic
case xitalic of
true:if (sy<th1) then dx:=ax+round((th1-sy)*0.20) else dx:=ax-round((sy-th1)*0.20);
false:dx:=ax;
end;
fi:=sy*tw;
dinits;//19jun2022

for sx:=0 to (tw-1) do
begin
//.get
dec(xcount);
if (xcount<=0) and ((xpos+2)<=xlen) then
   begin
   if xgreyscale then
      begin
      //get
      int1:=aptr.pbytes[xpos-1]; inc(xpos);
      if (int1<=15) then
         begin
         xval8:=int1*17;//0..15 -> x17 -> 0..255
         xcount:=1+aptr.pbytes[xpos-1]; inc(xpos);
         end
      else if (int1<=31) then
         begin
         xval8:=(int1-16)*17;//16..31 -> -16 -> x17 -> 0..255
         int1:=aptr.pbytes[xpos-1]*256;        inc(xpos);
         xcount:=1+(aptr.pbytes[xpos-1]+int1); inc(xpos);
         end;
      //filter
      if (xval8<>255) then xval8:=(xval8 div xgreyfilter)*xgreyfilter;//darkens the anti-alias pixels on some crappy fonts - 13feb2022
      end
   else
      begin
      xcounton:=not xcounton;//invert mode ->>  trans->solid or solid->trans
      int1:=aptr.pbytes[xpos-1];
      //.1byte datablock
      if (int1<128) then
         begin
         xcount:=int1+1;//0..127 -> 1..128
         inc(xpos);
         end
      //.3byte datablock
      else if (int1>=128) then
         begin
         //b1 -> (0-127) + (128/mark as 3byte data block)
         dec(int1,128);//remove marker value of "128"
         int1:=int1*65536;
         //b2
         inc(int1,aptr.pbytes[xpos+0]*256);
         //b3
         inc(int1,aptr.pbytes[xpos+1]);
         //get
         xcount:=int1+1;//0..N -> 1..(N+1)
         inc(xpos,3);
         end;
      end;
   end;

//.set
bol1:=false;
if (dx>=lx) and (dx<=rx) and (dy>=xarea.top) and (dy<=xarea.bottom) then
   begin
   if (xval8<255) then
      begin
      dc32G(dy,dx);
      bol1:=true;
      if xbold then
         begin
         //x
         if (xbold2>=1) then for int2:=-xbold1 to xbold2 do if ((dx+int2)>=lx) and ((dx+int2)<=rx) then
            begin
            if ((dx+int2)>=lx) and ((dx+int2)<=rx) then dc32G(dy,dx+int2);
            if (xfeather>=1) and ((sx+int2)>=0) and ((sx+int2)<tw) then xfc.pbytes[fi+sx+1+int2-1]:=1;
            end;
         //y
         if (ybold2>=1) then for int2:=-ybold2 to ybold1 do if ((dy+int2)>=xarea.top) and ((dy+int2)<=xarea.bottom) then
            begin
            //.corner
            low__cornersolid(true,a,amin,dy+int2,xarea.left,xarea.right,xroundstyle,xround,lx2,rx2);
            //.italic
            case xitalic of
            true:if ((sy+int2)<th1) then dx2:=sx+ax+round((th1-(sy+int2))*0.20) else dx2:=sx+ax-round(((sy+int2)-th1)*0.20);
            false:dx2:=sx+ax;
            end;
            if (dx2>=lx2) and (dx2<=rx2) then dc32G(dy+int2,dx2);
            if (xfeather>=1) and ((sy+int2)>=0) and ((sy+int2)<th) then xfc.pbytes[((sy+int2)*tw)+sx+0]:=1;
            end;
         end;
      end
   else if xcounton then
      begin
      ar32[dy][dx]:=dc32;
      bol1:=true;
      if xbold then
         begin
         //x
         if (xbold2>=1) then for int2:=-xbold1 to xbold2 do if ((dx+int2)>=lx) and ((dx+int2)<=rx) then
            begin
            if ((dx+int2)>=lx) and ((dx+int2)<=rx) then ar32[dy][dx+int2]:=dc32;
            if (xfeather>=1) and ((sx+int2)>=0) and ((sx+int2)<tw) then xfc.pbytes[fi+sx+1+int2-1]:=1;
            end;
         //y
         if (ybold2>=1) then for int2:=-ybold2 to ybold1 do if ((dy+int2)>=xarea.top) and ((dy+int2)<=xarea.bottom) then
            begin
            //.corner
            low__cornersolid(true,a,amin,dy+int2,xarea.left,xarea.right,xroundstyle,xround,lx2,rx2);
            //.italic
            case xitalic of
            true:if ((sy+int2)<th1) then dx2:=sx+ax+round((th1-(sy+int2))*0.20) else dx2:=sx+ax-round(((sy+int2)-th1)*0.20);
            false:dx2:=sx+ax;
            end;
            if (dx2>=lx2) and (dx2<=rx2) then ar32[dy+int2][dx2]:=dc32;
            if (xfeather>=1) and ((sy+int2)>=0) and ((sy+int2)<th) then xfc.pbytes[((sy+int2)*tw)+sx+0]:=1;
            end;
         end;
      end
   else if dunderline then
      begin
      if xgreyscale then dc32Gon(dy,dx) else ar32[dy][dx]:=dc32;
      bol1:=true;
      end
   else if dlink then
      begin
      if xlinkdot then
         begin
         if xgreyscale then dc32Gon(dy,dx) else ar32[dy][dx]:=dc32;
         end;
      bol1:=true;
      end
   else if dstrikeout then
      begin
      if xgreyscale then dc32Gon(dy,dx) else ar32[dy][dx]:=dc32;
      bol1:=true;
      end;
   end;

//.feather
if (xfeather>=1) then
   begin
   if bol1             then xfc.pbytes[fi+sx+0]:=1
   else if (not xbold) then xfc.pbytes[fi+sx+0]:=0;
   end;
//.inc
inc(dx);
end;//sx
end;//sy

//-- feather32 -----------------------------------------------------------------
if (xfeather<1) then goto skipdone;
int1:=tw*th;
for sy:=0 to (th-1) do
begin
//fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

dy:=ay+sy;
//.corner
low__cornersolid(true,a,amin,dy,xarea.left,xarea.right,xroundstyle,xround,lx,rx);
//.italic
case xitalic of
true:if (sy<th1) then dx:=ax+round((th1-sy)*0.20) else dx:=ax-round((sy-th1)*0.20);
false:dx:=ax;
end;
fi:=sy*tw;
fi1:=fi-tw;
fi2:=fi+tw;
for sx:=0 to (tw-1) do
begin
if (xfc.pbytes[fi+sx+0]=0) and (dx>=lx) and (dx<=rx) and (dy>=xarea.top) and (dy<=xarea.bottom) then
   begin
   //init
   bol1:=false;
   //x-1,y+0
   if (not bol1) and (sx>=1) and (xfc.pbytes[fi+sx-1]=1) then bol1:=true;
   //x+1,y+0
   if (not bol1) and (sx<(tw-1)) and (xfc.pbytes[fi+sx+1]=1) then bol1:=true;
   //x+0,y-1
   if (not bol1) and (xfeather>=2) and (sy>=1) and (xfc.pbytes[fi1+sx+0]=1) then bol1:=true;
   //x+0,y+1
   if (not bol1) and (xfeather>=2) and (sy<(th-1)) and (xfc.pbytes[fi2+sx+0]=1) then bol1:=true;
   //get
   if bol1 then
      begin
      //init
      c:=cfeatherpower;
      dc32:=ar32[dy][dx];
      r:=dc32.r*c;
      g:=dc32.g*c;
      b:=dc32.b*c;
      //x-1,y+0
      if ((dx-1)>=0) and (sx>=1) and (xfc.pbytes[fi+sx-1]=1) then
         begin
         inc(c);
         dc32:=ar32[dy][dx-1];
         inc(r,dc32.r);
         inc(g,dc32.g);
         inc(b,dc32.b);
         end;
      //x+1,y+0
      if ((dx+1)<aw) and (sx<(tw-1)) and (xfc.pbytes[fi+sx+1]=1) then
         begin
         inc(c);
         dc32:=ar32[dy][dx+1];
         inc(r,dc32.r);
         inc(g,dc32.g);
         inc(b,dc32.b);
         end;
      //x+0,y-1
      if ((dy-1)>=0) and (sy>=1) and (xfc.pbytes[fi1+sx+0]=1) then
         begin
         inc(c);
         dc32:=ar32[dy-1][dx];
         inc(r,dc32.r);
         inc(g,dc32.g);
         inc(b,dc32.b);
         end;
      //x+0,y+1
      if ((dy+1)<ah) and (sy<(th-1)) and (xfc.pbytes[fi2+sx+0]=1) then
         begin
         inc(c);
         dc32:=ar32[dy+1][dx];
         inc(r,dc32.r);
         inc(g,dc32.g);
         inc(b,dc32.b);
         end;
      //set
      dc32.r:=r div c;
      dc32.g:=g div c;
      dc32.b:=b div c;
      ar32[dy][dx]:=dc32;
      end;//bol1
   end;//xfc
//.inc
inc(dx);
end;//sx
end;//sy
goto skipdone;


//-- drawmasked32 --------------------------------------------------------------
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//ddddddddddddddddddddddddddddddddddddd
drawmasked32:
dc32.r:=int4.r;
dc32.g:=int4.g;
dc32.b:=int4.b;
dc32.a:=255;
//.start style
xcount:=0;
xcounton:=false;
xval8:=255;//255=off
if (not xgreyscale) and (xpos<=xlen) then
   begin
   xcounton:=(aptr.pbytes[xpos-1]=0);//invert to start with
   inc(xpos);
   end;

for sy:=0 to (th-1) do
begin
//fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

dy:=ay+sy;
//.corner
low__cornersolid(true,a,amin,dy,xarea.left,xarea.right,xroundstyle,xround,lx,rx);
//.italic
case xitalic of
true:if (sy<th1) then dx:=ax+round((th1-sy)*0.20) else dx:=ax-round((sy-th1)*0.20);
false:dx:=ax;
end;
fi:=sy*tw;
dinits;//19jun2022

for sx:=0 to (tw-1) do
begin
//.get
dec(xcount);
if (xcount<=0) and ((xpos+2)<=xlen) then
   begin
   if xgreyscale then
      begin
      //get
      int1:=aptr.pbytes[xpos-1]; inc(xpos);
      if (int1<=15) then
         begin
         xval8:=int1*17;//0..15 -> x17 -> 0..255
         xcount:=1+aptr.pbytes[xpos-1]; inc(xpos);
         end
      else if (int1<=31) then
         begin
         xval8:=(int1-16)*17;//16..31 -> -16 -> x17 -> 0..255
         int1:=aptr.pbytes[xpos-1]*256;        inc(xpos);
         xcount:=1+(aptr.pbytes[xpos-1]+int1); inc(xpos);
         end;
      //filter
      if (xval8<>255) then xval8:=(xval8 div xgreyfilter)*xgreyfilter;//darkens the anti-alias pixels on some crappy fonts - 13feb2022
      end
   else
      begin
      xcounton:=not xcounton;//invert mode ->>  trans->solid or solid->trans
      int1:=aptr.pbytes[xpos-1];
      //.1byte datablock
      if (int1<128) then
         begin
         xcount:=int1+1;//0..127 -> 1..128
         inc(xpos);
         end
      //.3byte datablock
      else if (int1>=128) then
         begin
         //b1 -> (0-127) + (128/mark as 3byte data block)
         dec(int1,128);//remove marker value of "128"
         int1:=int1*65536;
         //b2
         inc(int1,aptr.pbytes[xpos+0]*256);
         //b3
         inc(int1,aptr.pbytes[xpos+1]);
         //get
         xcount:=int1+1;//0..N -> 1..(N+1)
         inc(xpos,3);
         end;
      end;
   end;

//.set
bol1:=false;
if (dx>=lx) and (dx<=rx) and (dy>=xarea.top) and (dy<=xarea.bottom) then
   begin
   if (xval8<255) then
      begin
      if (mr8[dy][dx]=xmaskval) then dc32G(dy,dx);
      bol1:=true;
      if xbold then
         begin
         //x
         if (xbold2>=1) then for int2:=-xbold1 to xbold2 do if ((dx+int2)>=lx) and ((dx+int2)<=rx) then
            begin
            if (mr8[dy][dx+int2]=xmaskval) then dc32G(dy,dx+int2);
            if (xfeather>=1) and ((sx+int2)>=0) and ((sx+int2)<tw) then xfc.pbytes[fi+sx+1+int2-1]:=1;
            end;
         //y
         if (ybold2>=1) then for int2:=-ybold2 to ybold1 do if ((dy+int2)>=xarea.top) and ((dy+int2)<=xarea.bottom) then
            begin
            //.corner
            low__cornersolid(true,a,amin,dy+int2,xarea.left,xarea.right,xroundstyle,xround,lx2,rx2);
            //.italic
            case xitalic of
            true:if ((sy+int2)<th1) then dx2:=sx+ax+round((th1-(sy+int2))*0.20) else dx2:=sx+ax-round(((sy+int2)-th1)*0.20);
            false:dx2:=sx+ax;
            end;
            if (dx2>=lx2) and (dx2<=rx2) and (mr8[dy+int2][dx2]=xmaskval) then dc32G(dy+int2,dx2);
            if (xfeather>=1) and ((sy+int2)>=0) and ((sy+int2)<th) then xfc.pbytes[((sy+int2)*tw)+sx+0]:=1;
            end;
         end;
      end
   else if xcounton then
      begin
      if (mr8[dy][dx]=xmaskval) then ar32[dy][dx]:=dc32;
      bol1:=true;
      if xbold then
         begin
         //x
         if (xbold2>=1) then for int2:=-xbold1 to xbold2 do if ((dx+int2)>=lx) and ((dx+int2)<=rx) then
            begin
            if (mr8[dy][dx+int2]=xmaskval) then ar32[dy][dx+int2]:=dc32;
            if (xfeather>=1) and ((sx+int2)>=0) and ((sx+int2)<tw) then xfc.pbytes[fi+sx+1+int2-1]:=1;
            end;
         //y
         if (ybold2>=1) then for int2:=-ybold2 to ybold1 do if ((dy+int2)>=xarea.top) and ((dy+int2)<=xarea.bottom) then
            begin
            //.corner
            low__cornersolid(true,a,amin,dy+int2,xarea.left,xarea.right,xroundstyle,xround,lx2,rx2);
            //.italic
            case xitalic of
            true:if ((sy+int2)<th1) then dx2:=sx+ax+round((th1-(sy+int2))*0.20) else dx2:=sx+ax-round(((sy+int2)-th1)*0.20);
            false:dx2:=sx+ax;
            end;
            if (dx2>=lx2) and (dx2<=rx2) and (mr8[dy+int2][dx2]=xmaskval) then ar32[dy+int2][dx2]:=dc32;
            if (xfeather>=1) and ((sy+int2)>=0) and ((sy+int2)<th) then xfc.pbytes[((sy+int2)*tw)+sx+0]:=1;
            end;
         end;
      end
   else if dunderline then
      begin
      if (mr8[dy][dx]=xmaskval) then
         begin
         if xgreyscale then dc32Gon(dy,dx) else ar32[dy][dx]:=dc32;
         end;
      bol1:=true;
      end
   else if dlink then
      begin
      if xlinkdot and (mr8[dy][dx]=xmaskval) then
         begin
         if xgreyscale then dc32Gon(dy,dx) else ar32[dy][dx]:=dc32;
         end;
      bol1:=true;
      end
   else if dstrikeout then
      begin
      if (mr8[dy][dx]=xmaskval) then
         begin
         if xgreyscale then dc32Gon(dy,dx) else ar32[dy][dx]:=dc32;
         end;
      bol1:=true;
      end;
   end;
//.feather
if (xfeather>=1) then
   begin
   if bol1             then xfc.pbytes[fi+sx+0]:=1
   else if (not xbold) then xfc.pbytes[fi+sx+0]:=0;
   end;
//.inc
inc(dx);
end;//sx
end;//sy

//-- feather32 -----------------------------------------------------------------
if (xfeather<1) then goto skipdone;
int1:=tw*th;
for sy:=0 to (th-1) do
begin
//fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

dy:=ay+sy;
//.corner
low__cornersolid(true,a,amin,dy,xarea.left,xarea.right,xroundstyle,xround,lx,rx);
//.italic
case xitalic of
true:if (sy<th1) then dx:=ax+round((th1-sy)*0.20) else dx:=ax-round((sy-th1)*0.20);
false:dx:=ax;
end;
fi:=sy*tw;
fi1:=fi-tw;
fi2:=fi+tw;
for sx:=0 to (tw-1) do
begin
if (xfc.pbytes[fi+sx+0]=0) and (dx>=lx) and (dx<=rx) and (dy>=xarea.top) and (dy<=xarea.bottom) and (mr8[dy][dx]=xmaskval) then//20may2020
   begin
   //init
   bol1:=false;
   //x-1,y+0
   if (not bol1) and (sx>=1) and (xfc.pbytes[fi+sx-1]=1) then bol1:=true;
   //x+1,y+0
   if (not bol1) and (sx<(tw-1)) and (xfc.pbytes[fi+sx+1]=1) then bol1:=true;
   //x+0,y-1
   if (not bol1) and (xfeather>=2) and (sy>=1) and (xfc.pbytes[fi1+sx+0]=1) then bol1:=true;
   //x+0,y+1
   if (not bol1) and (xfeather>=2) and (sy<(th-1)) and (xfc.pbytes[fi2+sx+0]=1) then bol1:=true;
   //get
   if bol1 then
      begin
      //init
      c:=cfeatherpower;
      dc32:=ar32[dy][dx];
      r:=dc32.r*c;
      g:=dc32.g*c;
      b:=dc32.b*c;
      //x-1,y+0
      if ((dx-1)>=0) and (sx>=1) and (xfc.pbytes[fi+sx-1]=1) then
         begin
         inc(c);
         dc32:=ar32[dy][dx-1];
         inc(r,dc32.r);
         inc(g,dc32.g);
         inc(b,dc32.b);
         end;
      //x+1,y+0
      if ((dx+1)<aw) and (sx<(tw-1)) and (xfc.pbytes[fi+sx+1]=1) then
         begin
         inc(c);
         dc32:=ar32[dy][dx+1];
         inc(r,dc32.r);
         inc(g,dc32.g);
         inc(b,dc32.b);
         end;
      //x+0,y-1
      if ((dy-1)>=0) and (sy>=1) and (xfc.pbytes[fi1+sx+0]=1) then
         begin
         inc(c);
         dc32:=ar32[dy-1][dx];
         inc(r,dc32.r);
         inc(g,dc32.g);
         inc(b,dc32.b);
         end;
      //x+0,y+1
      if ((dy+1)<ah) and (sy<(th-1)) and (xfc.pbytes[fi2+sx+0]=1) then
         begin
         inc(c);
         dc32:=ar32[dy+1][dx];
         inc(r,dc32.r);
         inc(g,dc32.g);
         inc(b,dc32.b);
         end;
      //set
      dc32.r:=r div c;
      dc32.g:=g div c;
      dc32.b:=b div c;
      ar32[dy][dx]:=dc32;
      end;//bol1
   end;//xfc
//.inc
inc(dx);
end;//sx
end;//sy
goto skipdone;


//-- draw24 --------------------------------------------------------------------
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//ddddddddddddddddddddddddddddddddddddd
draw24:
dc24.r:=int4.r;
dc24.g:=int4.g;
dc24.b:=int4.b;
//.start style
xcount:=0;
xcounton:=false;
xval8:=255;//255=off
if (not xgreyscale) and (xpos<=xlen) then
   begin
   xcounton:=(aptr.pbytes[xpos-1]=0);//invert to start with
   inc(xpos);
   end;

for sy:=0 to (th-1) do
begin
//fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

dy:=ay+sy;
//.corner
low__cornersolid(true,a,amin,dy,xarea.left,xarea.right,xroundstyle,xround,lx,rx);
//.italic
case xitalic of
true:if (sy<th1) then dx:=ax+round((th1-sy)*0.20) else dx:=ax-round((sy-th1)*0.20);
false:dx:=ax;
end;
fi:=sy*tw;
dinits;//19jun2022

for sx:=0 to (tw-1) do
begin
//.get
dec(xcount);
if (xcount<=0) and ((xpos+2)<=xlen) then
   begin
   if xgreyscale then
      begin
      //get
      int1:=aptr.pbytes[xpos-1]; inc(xpos);
      if (int1<=15) then
         begin
         xval8:=int1*17;//0..15 -> x17 -> 0..255
         xcount:=1+aptr.pbytes[xpos-1]; inc(xpos);
         end
      else if (int1<=31) then
         begin
         xval8:=(int1-16)*17;//16..31 -> -16 -> x17 -> 0..255
         int1:=aptr.pbytes[xpos-1]*256;        inc(xpos);
         xcount:=1+(aptr.pbytes[xpos-1]+int1); inc(xpos);
         end;
      //filter
      if (xval8<>255) then xval8:=(xval8 div xgreyfilter)*xgreyfilter;//darkens the anti-alias pixels on some crappy fonts - 13feb2022
      end
   else
      begin
      xcounton:=not xcounton;//invert mode ->>  trans->solid or solid->trans
      int1:=aptr.pbytes[xpos-1];
      //.1byte datablock
      if (int1<128) then
         begin
         xcount:=int1+1;//0..127 -> 1..128
         inc(xpos);
         end
      //.3byte datablock
      else if (int1>=128) then
         begin
         //b1 -> (0-127) + (128/mark as 3byte data block)
         dec(int1,128);//remove marker value of "128"
         int1:=int1*65536;
         //b2
         inc(int1,aptr.pbytes[xpos+0]*256);
         //b3
         inc(int1,aptr.pbytes[xpos+1]);
         //get
         xcount:=int1+1;//0..N -> 1..(N+1)
         inc(xpos,3);
         end;
      end;
   end;

//.set
bol1:=false;
if (dx>=lx) and (dx<=rx) and (dy>=xarea.top) and (dy<=xarea.bottom) then
   begin
   if (xval8<255) then
      begin
      dc24G(dy,dx);
      bol1:=true;
      if xbold then
         begin
         //x
         if (xbold2>=1) then for int2:=-xbold1 to xbold2 do if ((dx+int2)>=lx) and ((dx+int2)<=rx) then
            begin
            dc24G(dy,dx+int2);
            if (xfeather>=1) and ((sx+int2)>=0) and ((sx+int2)<tw) then xfc.pbytes[fi+sx+0+int2]:=1;
            end;
         //y
         if (ybold2>=1) then for int2:=-ybold2 to ybold1 do if ((dy+int2)>=xarea.top) and ((dy+int2)<=xarea.bottom) then
            begin
            //.corner
            low__cornersolid(true,a,amin,dy+int2,xarea.left,xarea.right,xroundstyle,xround,lx2,rx2);
            //.italic
            case xitalic of
            true:if ((sy+int2)<th1) then dx2:=sx+ax+round((th1-(sy+int2))*0.20) else dx2:=sx+ax-round(((sy+int2)-th1)*0.20);
            false:dx2:=sx+ax;
            end;
            if (dx2>=lx2) and (dx2<=rx2) then dc24G(dy+int2,dx2);
            if (xfeather>=1) and ((sy+int2)>=0) and ((sy+int2)<th) then xfc.pbytes[((sy+int2)*tw)+sx+0]:=1;
            end;
         end;
      end
   else if xcounton then
      begin
      ar24[dy][dx]:=dc24;
      bol1:=true;
      if xbold then
         begin
         //x
         if (xbold2>=1) then for int2:=-xbold1 to xbold2 do if ((dx+int2)>=lx) and ((dx+int2)<=rx) then
            begin
            ar24[dy][dx+int2]:=dc24;
            if (xfeather>=1) and ((sx+int2)>=0) and ((sx+int2)<tw) then xfc.pbytes[fi+sx+0+int2]:=1;
            end;
         //y
         if (ybold2>=1) then for int2:=-ybold2 to ybold1 do if ((dy+int2)>=xarea.top) and ((dy+int2)<=xarea.bottom) then
            begin
            //.corner
            low__cornersolid(true,a,amin,dy+int2,xarea.left,xarea.right,xroundstyle,xround,lx2,rx2);
            //.italic
            case xitalic of
            true:if ((sy+int2)<th1) then dx2:=sx+ax+round((th1-(sy+int2))*0.20) else dx2:=sx+ax-round(((sy+int2)-th1)*0.20);
            false:dx2:=sx+ax;
            end;
            if (dx2>=lx2) and (dx2<=rx2) then ar24[dy+int2][dx2]:=dc24;
            if (xfeather>=1) and ((sy+int2)>=0) and ((sy+int2)<th) then xfc.pbytes[((sy+int2)*tw)+sx+0]:=1;
            end;
         end;
      end
   else if dunderline then
      begin
      if xgreyscale then dc24Gon(dy,dx) else ar24[dy][dx]:=dc24;
      bol1:=true;
      end
   else if dlink then
      begin
      if xlinkdot then
         begin
         if xgreyscale then dc24Gon(dy,dx) else ar24[dy][dx]:=dc24;
         end;
      bol1:=true;
      end
   else if dstrikeout then
      begin
      if xgreyscale then dc24Gon(dy,dx) else ar24[dy][dx]:=dc24;
      bol1:=true;
      end;
   end;
//.feather
if (xfeather>=1) then
   begin
   if bol1             then xfc.pbytes[fi+sx+0]:=1
   else if (not xbold) then xfc.pbytes[fi+sx+0]:=0;
   end;
//.inc
inc(dx);
end;//sx
end;//sy

//-- feather24 -----------------------------------------------------------------
if (xfeather<1) then goto skipdone;
int1:=tw*th;
for sy:=0 to (th-1) do
begin
//fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

dy:=ay+sy;
//.corner
low__cornersolid(true,a,amin,dy,xarea.left,xarea.right,xroundstyle,xround,lx,rx);
//.italic
case xitalic of
true:if (sy<th1) then dx:=ax+round((th1-sy)*0.20) else dx:=ax-round((sy-th1)*0.20);
false:dx:=ax;
end;
fi:=sy*tw;
fi1:=fi-tw;
fi2:=fi+tw;
for sx:=0 to (tw-1) do
begin
if (xfc.pbytes[fi+sx+0]=0) and (dx>=lx) and (dx<=rx) and (dy>=xarea.top) and (dy<=xarea.bottom) then
   begin
   //init
   bol1:=false;
   //x-1,y+0
   if (not bol1) and (sx>=1) and (xfc.pbytes[fi+sx-1]=1) then bol1:=true;
   //x+1,y+0
   if (not bol1) and (sx<(tw-1)) and (xfc.pbytes[fi+sx+1]=1) then bol1:=true;
   //x+0,y-1
   if (not bol1) and (xfeather>=2) and (sy>=1) and (xfc.pbytes[fi1+sx+0]=1) then bol1:=true;
   //x+0,y+1
   if (not bol1) and (xfeather>=2) and (sy<(th-1)) and (xfc.pbytes[fi2+sx+0]=1) then bol1:=true;
   //get
   if bol1 then
      begin
      //init
      c:=cfeatherpower;
      dc24:=ar24[dy][dx];
      r:=dc24.r*c;
      g:=dc24.g*c;
      b:=dc24.b*c;
      //x-1,y+0
      if ((dx-1)>=0) and (sx>=1) and (xfc.pbytes[fi+sx-1]=1) then
         begin
         inc(c);
         dc24:=ar24[dy][dx-1];
         inc(r,dc24.r);
         inc(g,dc24.g);
         inc(b,dc24.b);
         end;
      //x+1,y+0
      if ((dx+1)<aw) and (sx<(tw-1)) and (xfc.pbytes[fi+sx+1]=1) then
         begin
         inc(c);
         dc24:=ar24[dy][dx+1];
         inc(r,dc24.r);
         inc(g,dc24.g);
         inc(b,dc24.b);
         end;
      //x+0,y-1
      if ((dy-1)>=0) and (sy>=1) and (xfc.pbytes[fi1+sx+0]=1) then
         begin
         inc(c);
         dc24:=ar24[dy-1][dx];
         inc(r,dc24.r);
         inc(g,dc24.g);
         inc(b,dc24.b);
         end;
      //x+0,y+1
      if ((dy+1)<ah) and (sy<(th-1)) and (xfc.pbytes[fi2+sx+0]=1) then
         begin
         inc(c);
         dc24:=ar24[dy+1][dx];
         inc(r,dc24.r);
         inc(g,dc24.g);
         inc(b,dc24.b);
         end;
      //set
      dc24.r:=r div c;
      dc24.g:=g div c;
      dc24.b:=b div c;
      ar24[dy][dx]:=dc24;
      end;//bol1
   end;//xfc
//.inc
inc(dx);
end;//sx
end;//sy
goto skipdone;

//-- drawmasked24 --------------------------------------------------------------
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//ddddddddddddddddddddddddddddddddddddd
drawmasked24:
dc24.r:=int4.r;
dc24.g:=int4.g;
dc24.b:=int4.b;
//.start style
xcount:=0;
xcounton:=false;
xval8:=255;//255=off
if (not xgreyscale) and (xpos<=xlen) then
   begin
   xcounton:=(aptr.pbytes[xpos-1]=0);//invert to start with
   inc(xpos);
   end;

for sy:=0 to (th-1) do
begin
//fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

dy:=ay+sy;
//.corner
low__cornersolid(true,a,amin,dy,xarea.left,xarea.right,xroundstyle,xround,lx,rx);
//.italic
case xitalic of
true:if (sy<th1) then dx:=ax+round((th1-sy)*0.20) else dx:=ax-round((sy-th1)*0.20);
false:dx:=ax;
end;
fi:=sy*tw;
dinits;//19jun2022

for sx:=0 to (tw-1) do
begin
//.get
dec(xcount);
if (xcount<=0) and ((xpos+2)<=xlen) then
   begin
   if xgreyscale then
      begin
      //get
      int1:=aptr.pbytes[xpos-1]; inc(xpos);
      if (int1<=15) then
         begin
         xval8:=int1*17;//0..15 -> x17 -> 0..255
         xcount:=1+aptr.pbytes[xpos-1]; inc(xpos);
         end
      else if (int1<=31) then
         begin
         xval8:=(int1-16)*17;//16..31 -> -16 -> x17 -> 0..255
         int1:=aptr.pbytes[xpos-1]*256;        inc(xpos);
         xcount:=1+(aptr.pbytes[xpos-1]+int1); inc(xpos);
         end;
      //filter
      if (xval8<>255) then xval8:=(xval8 div xgreyfilter)*xgreyfilter;//darkens the anti-alias pixels on some crappy fonts - 13feb2022
      end
   else
      begin
      xcounton:=not xcounton;//invert mode ->>  trans->solid or solid->trans
      int1:=aptr.pbytes[xpos-1];
      //.1byte datablock
      if (int1<128) then
         begin
         xcount:=int1+1;//0..127 -> 1..128
         inc(xpos);
         end
      //.3byte datablock
      else if (int1>=128) then
         begin
         //b1 -> (0-127) + (128/mark as 3byte data block)
         dec(int1,128);//remove marker value of "128"
         int1:=int1*65536;
         //b2
         inc(int1,aptr.pbytes[xpos+0]*256);
         //b3
         inc(int1,aptr.pbytes[xpos+1]);
         //get
         xcount:=int1+1;//0..N -> 1..(N+1)
         inc(xpos,3);
         end;
      end;
   end;
   
//.set
bol1:=false;
if (dx>=lx) and (dx<=rx) and (dy>=xarea.top) and (dy<=xarea.bottom) then
   begin
   if (xval8<255) then
      begin
      if (mr8[dy][dx]=xmaskval) then dc24G(dy,dx);
      bol1:=true;
      if xbold then
         begin
         //x
         if (xbold2>=1) then for int2:=-xbold1 to xbold2 do if ((dx+int2)>=lx) and ((dx+int2)<=rx) then
            begin
            if (mr8[dy][dx+int2]=xmaskval) then dc24G(dy,dx+int2);
            if (xfeather>=1) and ((sx+int2)>=0) and ((sx+int2)<tw) then xfc.pbytes[fi+sx+0+int2]:=1;
            end;
         //y
         if (ybold2>=1) then for int2:=-ybold2 to ybold1 do if ((dy+int2)>=xarea.top) and ((dy+int2)<=xarea.bottom) then
            begin
            //.corner
            low__cornersolid(true,a,amin,dy+int2,xarea.left,xarea.right,xroundstyle,xround,lx2,rx2);
            //.italic
            case xitalic of
            true:if ((sy+int2)<th1) then dx2:=sx+ax+round((th1-(sy+int2))*0.20) else dx2:=sx+ax-round(((sy+int2)-th1)*0.20);
            false:dx2:=sx+ax;
            end;
            if (dx2>=lx2) and (dx2<=rx2) and(mr8[dy+int2][dx2]=xmaskval) then dc24G(dy+int2,dx2);
            if (xfeather>=1) and ((sy+int2)>=0) and ((sy+int2)<th) then xfc.pbytes[((sy+int2)*tw)+sx+0]:=1;
            end;
         end;
      end
   else if xcounton then
      begin
      if (mr8[dy][dx]=xmaskval) then ar24[dy][dx]:=dc24;
      bol1:=true;
      if xbold then
         begin
         //x
         if (xbold2>=1) then for int2:=-xbold1 to xbold2 do if ((dx+int2)>=lx) and ((dx+int2)<=rx) then
            begin
            if (mr8[dy][dx+int2]=xmaskval) then ar24[dy][dx+int2]:=dc24;
            if (xfeather>=1) and ((sx+int2)>=0) and ((sx+int2)<tw) then xfc.pbytes[fi+sx+0+int2]:=1;
            end;
         //y
         if (ybold2>=1) then for int2:=-ybold2 to ybold1 do if ((dy+int2)>=xarea.top) and ((dy+int2)<=xarea.bottom) then
            begin
            //.corner
            low__cornersolid(true,a,amin,dy+int2,xarea.left,xarea.right,xroundstyle,xround,lx2,rx2);
            //.italic
            case xitalic of
            true:if ((sy+int2)<th1) then dx2:=sx+ax+round((th1-(sy+int2))*0.20) else dx2:=sx+ax-round(((sy+int2)-th1)*0.20);
            false:dx2:=sx+ax;
            end;
            if (dx2>=lx2) and (dx2<=rx2) and(mr8[dy+int2][dx2]=xmaskval) then ar24[dy+int2][dx2]:=dc24;
            if (xfeather>=1) and ((sy+int2)>=0) and ((sy+int2)<th) then xfc.pbytes[((sy+int2)*tw)+sx+0]:=1;
            end;
         end;
      end
   else if dunderline then
      begin
      if (mr8[dy][dx]=xmaskval) then
         begin
         if xgreyscale then dc24Gon(dy,dx) else ar24[dy][dx]:=dc24;
         end;
      bol1:=true;
      end
   else if dlink then
      begin
      if xlinkdot and (mr8[dy][dx]=xmaskval) then
         begin
         if xgreyscale then dc24Gon(dy,dx) else ar24[dy][dx]:=dc24;
         end;
      bol1:=true;
      end
   else if dstrikeout then
      begin
      if (mr8[dy][dx]=xmaskval) then
         begin
         if xgreyscale then dc24Gon(dy,dx) else ar24[dy][dx]:=dc24;
         end;
      bol1:=true;
      end;
   end;
//.feather
if (xfeather>=1) then
   begin
   if bol1             then xfc.pbytes[fi+sx+0]:=1
   else if (not xbold) then xfc.pbytes[fi+sx+0]:=0;
   end;
//.inc
inc(dx);
end;//sx
end;//sy

//-- feather24 -----------------------------------------------------------------
if (xfeather<1) then goto skipdone;
int1:=tw*th;
for sy:=0 to (th-1) do
begin
//fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

dy:=ay+sy;
//.corner
low__cornersolid(true,a,amin,dy,xarea.left,xarea.right,xroundstyle,xround,lx,rx);
//.italic
case xitalic of
true:if (sy<th1) then dx:=ax+round((th1-sy)*0.20) else dx:=ax-round((sy-th1)*0.20);
false:dx:=ax;
end;
fi:=sy*tw;
fi1:=fi-tw;
fi2:=fi+tw;
for sx:=0 to (tw-1) do
begin
if (xfc.pbytes[fi+sx+0]=0) and (dx>=lx) and (dx<=rx) and (dy>=xarea.top) and (dy<=xarea.bottom) and (mr8[dy][dx]=xmaskval) then
   begin
   //init
   bol1:=false;
   //x-1,y+0
   if (not bol1) and (sx>=1) and (xfc.pbytes[fi+sx-1]=1) then bol1:=true;
   //x+1,y+0
   if (not bol1) and (sx<(tw-1)) and (xfc.pbytes[fi+sx+1]=1) then bol1:=true;
   //x+0,y-1
   if (not bol1) and (xfeather>=2) and (sy>=1) and (xfc.pbytes[fi1+sx+0]=1) then bol1:=true;
   //x+0,y+1
   if (not bol1) and (xfeather>=2) and (sy<(th-1)) and (xfc.pbytes[fi2+sx+0]=1) then bol1:=true;
   //get
   if bol1 then
      begin
      //init
      c:=cfeatherpower;
      dc24:=ar24[dy][dx];
      r:=dc24.r*c;
      g:=dc24.g*c;
      b:=dc24.b*c;
      //x-1,y+0
      if ((dx-1)>=0) and (sx>=1) and (xfc.pbytes[fi+sx-1]=1) then
         begin
         inc(c);
         dc24:=ar24[dy][dx-1];
         inc(r,dc24.r);
         inc(g,dc24.g);
         inc(b,dc24.b);
         end;
      //x+1,y+0
      if ((dx+1)<aw) and (sx<(tw-1)) and (xfc.pbytes[fi+sx+1]=1) then
         begin
         inc(c);
         dc24:=ar24[dy][dx+1];
         inc(r,dc24.r);
         inc(g,dc24.g);
         inc(b,dc24.b);
         end;
      //x+0,y-1
      if ((dy-1)>=0) and (sy>=1) and (xfc.pbytes[fi1+sx+0]=1) then
         begin
         inc(c);
         dc24:=ar24[dy-1][dx];
         inc(r,dc24.r);
         inc(g,dc24.g);
         inc(b,dc24.b);
         end;
      //x+0,y+1
      if ((dy+1)<ah) and (sy<(th-1)) and (xfc.pbytes[fi2+sx+0]=1) then
         begin
         inc(c);
         dc24:=ar24[dy+1][dx];
         inc(r,dc24.r);
         inc(g,dc24.g);
         inc(b,dc24.b);
         end;
      //set
      dc24.r:=r div c;
      dc24.g:=g div c;
      dc24.b:=b div c;
      ar24[dy][dx]:=dc24;
      end;//bol1
   end;//xfc
//.inc
inc(dx);
end;//sx
end;//sy
goto skipdone;


//successful
skipdone:
result:=true;
skipend:
except;end;
try;bunlockautofree(xfc);except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//ttttttttttttttttttttttttt
//## low__tab ##
function low__tab(xtab,xcolindex,xfontheight:longint;var xcolalign,xcolcount,xcoltrim,xcolwidth,xtotalwidth,x1,x2:longint):boolean;//23feb2021
var
   dw1,dw2,dw3:longint;
   xratio:extended;
   //## xtab12 ##
   procedure xtab12(sw1,sw2,sa1,sa2:longint);//2 column tab template
   begin
   //init
   dw1:=trunc(sw1*xratio);
   dw2:=trunc(sw2*xratio);
   //get
   xcoltrim:=trunc(2*xratio);
   xcolalign:=taL;
   xcolcount:=2;
   case xcolindex of
   0:begin
      xcolalign:=sa1;
      xcolwidth:=dw1;
      x1:=0;
      x2:=(dw1-1);
      end;
   1:begin
      xcolalign:=sa2;
      xcolwidth:=dw2;
      x1:=dw1;
      x2:=x1+dw2-1;
      end;
   end;//case
   xtotalwidth:=dw1+dw2;
   result:=(xcolindex>=0) and (xcolindex<xcolcount);
   //.x1 + x2
   if not result then
      begin
      x1:=xtotalwidth;
      x2:=xtotalwidth;
      end;
   end;
   //## xtab13 ##
   procedure xtab13(sw1,sw2,sw3,sa1,sa2,sa3,xsep:longint);//2 column tab template
   begin
   //init
   dw1:=trunc(sw1*xratio);
   dw2:=trunc(sw2*xratio);
   dw3:=trunc(sw3*xratio);
   //get
   xcoltrim:=trunc(2*xratio);
   xcolalign:=taL;
   xcolcount:=3;
   case xcolindex of
   0:begin
      xcolalign:=sa1;
      xcolwidth:=dw1;
      x1:=0;
      x2:=(dw1-1);
      end;
   1:begin
      xcolalign:=sa2;
      xcolwidth:=dw2;
      x1:=dw1;
      x2:=x1+dw2-1;
      end;
   2:begin
      xcolalign:=sa3;
      xcolwidth:=dw3;
      x1:=dw1+dw2;
      x2:=x1+dw3-1;
      end;
   end;//case
   x2:=frcmin(x2-xsep,x1);
   xtotalwidth:=dw1+dw2+dw3;
   result:=(xcolindex>=0) and (xcolindex<xcolcount);
   //.x1 + x2
   if not result then
      begin
      x1:=xtotalwidth;
      x2:=xtotalwidth;
      end;
   end;
begin//Note: xcoltrim=white space in pixels on left and right boundaries of column not to be written on (visiual gap) - 23feb2021
try
//defaults
result:=false;
xcolalign:=taL;//left
xcolcount:=0;
xcoltrim:=0;
xcolwidth:=0;
xtotalwidth:=0;
x1:=0;
x2:=0;
xratio:=(xfontheight/tbFontheight);//height is locked to "14px" above
if (xratio<1) then xratio:=1;
//range
if (xcolindex<0) then xcolindex:=0;
if (xfontheight<8) then xfontheight:=8;
//get
case xtab of
tbNone:;
tbL100_L    :xtab12(100,1000,taL,taL);//05oct2022
tbL100_L120 :xtab12(100,120,taL,taL);
tbL100_L500 :xtab12(100,500,taL,taL);
tbL100_R120 :xtab12(100,120,taL,taR);
tbL120_L120_L300 :xtab13(120,120,300,taL,taL,taL,10);
tbL120_R120_L300 :xtab13(120,120,300,taL,taR,taL,10);
tbL250_L300: xtab12(250,300,taL,taL);
tbL250_L400: xtab12(250,400,taL,taL);
tbL250_R100_L300: xtab13(250,100,300,taL,taR,taL,10);
end;//case
except;end;
end;
//## low__fromLGF_textwidth ##
function low__fromLGF_textwidth(x,xtext:tobject):longint;
begin
try;result:=low__fromLGF_textwidthTAB(tbnone,x,xtext);except;end;
end;
//## low__fromLGF_textwidthTAB ##
function low__fromLGF_textwidthTAB(xtab:longint;x,xtext:tobject):longint;
var
   p,xcolalign,xcolcount,xcoltrim,xcolwidth,x1,x2:longint;
begin
try
//defaults
result:=0;
//check
if zznil(x,2246) or zznil(xtext,2247) then exit;
if (x as tstr8).empty or (xtext as tstr8).empty then exit;
//no tabs
if (xtab=tbnone) then
   begin
   for p:=1 to (xtext as tstr8).count do inc(result,low__fromLGF_charw(x,(xtext as tstr8).pbytes[p-1]));
   end
else low__tab(xtab,0,low__fromLGF_height(x),xcolalign,xcolcount,xcoltrim,xcolwidth,result,x1,x2);
except;end;
end;
//## low__fromLGF_textwidth2 ##
function low__fromLGF_textwidth2(x:tobject;xtext:string):longint;
begin
try;result:=low__fromLGF_textwidthTAB2(tbnone,x,xtext);except;end;
end;
//## low__fromLGF_textwidthTAB2 ##
function low__fromLGF_textwidthTAB2(xtab:longint;x:tobject;xtext:string):longint;
var
   p,xlen,xcolalign,xcolcount,xcoltrim,xcolwidth,x1,x2:longint;
begin
try
//defaults
result:=0;
//check
if zznil(x,2247) or (xtext='') then exit;
if (x as tstr8).empty then exit;
//get
xlen:=length(xtext);
//no tabs
if (xtab=tbnone) then
   begin
   for p:=0 to (xlen-1) do inc(result,low__fromLGF_charw(x,byte(xtext[p+stroffset])));
   end
else low__tab(xtab,0,low__fromLGF_height(x),xcolalign,xcolcount,xcoltrim,xcolwidth,result,x1,x2);
except;end;
end;
//## low__fromLGF_drawtext2432 ##
function low__fromLGF_drawtext2432(x,xtext:tobject;ax,ay,aw,ah,dcolor:longint;xarea,xarea2:trect;ar24:pcolorrows24;ar32:pcolorrows32;xmask:tmask8;xmaskval:longint;xfc:tstr8;xfeather:longint;xbold,xitalic,xunderline,xlink,xstrikeout,xround:boolean;xroundstyle:longint):boolean;
begin
try;result:=low__fromLGF_drawtext2432TAB(tbnone,x,xtext,ax,ay,aw,ah,dcolor,xarea,xarea2,ar24,ar32,xmask,xmaskval,xfc,xfeather,xbold,xitalic,xunderline,xlink,xstrikeout,xround,xroundstyle);except;end;
end;
//## low__fromLGF_drawtext2432TAB ##
function low__fromLGF_drawtext2432TAB(xtab:longint;x,xtext:tobject;ax,ay,aw,ah,dcolor:longint;xarea,xarea2:trect;ar24:pcolorrows24;ar32:pcolorrows32;xmask:tmask8;xmaskval:longint;xfc:tstr8;xfeather:longint;xbold,xitalic,xunderline,xlink,xstrikeout,xround:boolean;xroundstyle:longint):boolean;//23feb2021
label
   donone,dotabs,skipdone,skipend;
var
   tw,sx,lfontheight,lcolindex,xlen,vw,di,i,lp,p,pmax,xcolalign,xcolcount,xcoltrim,xcolwidth,xtotalwidth,x1,x2:longint;
   bol1,bol2:boolean;
   sv,v:byte;
   xcolarea:trect;
begin
try
//defaults
result:=false;
if zzok(x,7070) and (x is tstr8) then block(x as tstr8);
if zzok(xtext,7071) and (xtext is tstr8) then block(xtext as tstr8);
block(xfc);

//check
if zznil(x,2248) or (not (x is tstr8)) then goto skipend;
if zznil(xtext,2249) or (not (xtext is tstr8)) or ((xtext as tstr8).count<=0) then goto skipdone;
//init
xlen:=(xtext as tstr8).count;
if (xtab=tbnone) then goto donone else goto dotabs;
//get

//-- No Tabs -------------------------------------------------------------------
donone:
bol1:=true;
try
for p:=0 to (xlen-1) do
begin
v:=(xtext as tstr8).pbytes[p];
vw:=low__fromLGF_charw(x,v);
if not low__fromLGF_drawchar2432(x,v,ax,ay,aw,ah,dcolor,xarea,xarea2,ar24,ar32,xmask,xmaskval,xfc,xfeather,xbold,xitalic,xunderline,xlink,xstrikeout,xround,xroundstyle) then
   begin
   bol1:=false;
   break;
   end;
inc(ax,vw);
end;//p
except;end;
if bol1 then goto skipdone else goto skipend;


//-- Use Tabs ------------------------------------------------------------------
dotabs:
bol1:=true;
sx:=ax;
tw:=0;
lp:=0;
lcolindex:=0;
lfontheight:=low__fromLGF_height(x);
try
for p:=0 to (xlen-1) do
begin
v:=(xtext as tstr8).pbytes[p];
if (v<>ss9) and (xcolalign=taC) then inc(tw,low__fromLGF_charw(x,v));
if (v=ss9) or (p>=(xlen-1)) then
   begin
   if not low__tab(xtab,lcolindex,lfontheight,xcolalign,xcolcount,xcoltrim,xcolwidth,xtotalwidth,x1,x2) then bol1:=false;
   if bol1 then
      begin
      //.xcolarea
      xcolarea.left:=frcrange(sx+x1+xcoltrim,xarea.left,xarea.right);
      xcolarea.right:=frcrange(sx+x2-xcoltrim,xarea.left,xarea.right);
      xcolarea.top:=xarea.top;
      xcolarea.bottom:=xarea.bottom;
      //.xcolalign
      case xcolalign of
      taC:ax:=sx+x1+(xcolwidth-tw) div 2;//center
      taR:ax:=sx+x2-xcoltrim;//right
      else ax:=sx+x1+xcoltrim;//left
      end;//case
      //get
      pmax:=(p-low__insint(1,v=ss9));
      for i:=lp to pmax do//last char adjust if "v=ss9" then don't include this last char - 23feb2021
      begin
      if (xcolalign=taR) then di:=pmax-(i-lp) else di:=i;
      sv:=(xtext as tstr8).pbytes[di];
      vw:=low__fromLGF_charw(x,sv);
      if (xcolalign=taR) then dec(ax,vw);
      if not low__fromLGF_drawchar2432(x,sv,ax,ay,aw,ah,dcolor,xcolarea,xarea2,ar24,ar32,xmask,xmaskval,xfc,xfeather,xbold,xitalic,xunderline,xlink,xstrikeout,xround,xroundstyle) then
         begin
         bol1:=false;
         break;
         end;
      if (xcolalign=taL) or (xcolalign=taC) then inc(ax,vw);
      end;//i
      end;
   if not bol1 then break;
   //reset
   if (v=ss9) then inc(lcolindex);
   lp:=p+1;
   tw:=0;
   end;
end;//p
except;end;
if bol1 then goto skipdone else goto skipend;

skipdone:
//successful
result:=true;
skipend:
except;end;
try
if zzok(x,7400) and (x is tstr8) then bunlockautofree(x as tstr8);
if zzok(xtext,7400) and (xtext is tstr8) then bunlockautofree(xtext as tstr8);
bunlockautofree(xfc);//fixed - 10oct2020 -> was block(xfc)
except;end;
end;
//## low__fromLGF_drawtext2432TAB2 ##
function low__fromLGF_drawtext2432TAB2(xtab:longint;x,xtext:tobject;ax,ay,aw,ah,dcolor:longint;xarea,xarea2:trect;s:tobject;xmask:tmask8;xmaskval:longint;xfc:tstr8;xfeather:longint;xbold,xitalic,xunderline,xlink,xstrikeout,xround:boolean;xroundstyle:longint):boolean;//23feb2021
var
   sr24:pcolorrows24;
   sr32:pcolorrows32;
begin
try
result:=false;
case misb(s) of
24:result:=misrows24(s,sr24) and low__fromLGF_drawtext2432TAB(xtab,x,xtext,ax,ay,aw,ah,dcolor,xarea,xarea2,sr24,nil,xmask,xmaskval,xfc,xfeather,xbold,xitalic,xunderline,xlink,xstrikeout,xround,xroundstyle);
32:result:=misrows32(s,sr32) and low__fromLGF_drawtext2432TAB(xtab,x,xtext,ax,ay,aw,ah,dcolor,xarea,xarea2,nil,sr32,xmask,xmaskval,xfc,xfeather,xbold,xitalic,xunderline,xlink,xstrikeout,xround,xroundstyle);
end;
except;end;
end;

//-- font support --------------------------------------------------------------
//## low__haveprinter ##
function low__haveprinter:boolean;//03DEC2009 - safely check if we have a default printer, raises no error or "SPOOL32 error" on a Win98 machine
var
  defprinter:array[0..79] of char;
begin
try
//defaults
result:=false;
//get
fillchar(defprinter,sizeof(defprinter),#0);
getprofilestring('windows','device','',defprinter,sizeof(defprinter)-1);
//set - If default printer exists: "Canon LASER SHOT LBP-1120,winspool,USB001", else nothing ""
if (defprinter[0]<>#0) then result:=true;
except;end;
end;
//## low__fontlist ##
procedure low__fontlist(x:tstr8);//26mar2022
begin
try;low__fontlist2(x,true,true);except;end;
end;
//##  low__fontlist2 ##
procedure low__fontlist2(x:tstr8;xscreen,xprinter:boolean);//26mar2022
var
   a:tdynamicstring;
   p,acount:longint;
   xok:boolean;
   v:string;
   //## xfilter ##
   function xfilter(x:string):string;
   begin
   try
   low__remchar(x,#13);
   low__remchar(x,#10);
   low__remchar(x,#9);
   low__remchar(x,#0);
   result:=x;
   except;end;
   end;
begin
try
//defaults
xok:=false;
a:=nil;
//check
if not block(x) then exit;
//init
x.clear;
a:=tdynamicstring.create;
acount:=0;

//SCREEN
try
if xscreen then
   begin
   for p:=0 to (screen.fonts.count-1) do
   begin
   v:=xfilter(screen.fonts.strings[p]);
   if (v<>'') then
      begin
      a.value[acount]:=v;
      inc(acount);
      end;
   end;//p
   end;
except;end;

//PRINTER
try
if xprinter and low__haveprinter then//avoid any printer related errors due to the face a LOCAL printer is NOT installed - 26mar2022
   begin
   for p:=0 to (printer.fonts.count-1) do
   begin
   v:=xfilter(printer.fonts.strings[p]);
   if (v<>'') then
      begin
      a.value[acount]:=v;
      inc(acount);
      end;
   end;//p
   end;
except;end;

//remove duplicates and sort
a.text:=low__remdup2(a.text,true,true);

//set
for p:=0 to (a.count-1) do x.sadd(a.svalue[p]+#10);

//successful
xok:=true;
except;end;
try
if (xscreen or xprinter) and (x<>nil) and ((not xok) or (x.len<=0)) then
   begin
   x.sadd('Arial'+#10);
   x.sadd('Courier New'+#10);
   x.sadd('System'+#10);
   end;
except;end;
try
freeobj(@a);
bunlockautofree(x);
except;end;
end;
//## low__findfontname2 ##
function low__findfontname2(xname,xsysname,xsysname2:string;var xoutname:string):boolean;//05feb2022
begin
try
//defaults
result:=false;
//filter
if low__comparetext(xname,'$fontname') then
   begin
   xname:=low__udv(xsysname,'Arial');
   result:=true;
   end
else if low__comparetext(xname,'$fontname2') then
   begin
   xname:=low__udv(xsysname2,siFontname2_deffont);
   result:=true;
   end;
//init
xoutname:=xname;
//get
if (xname='') or low__comparetext(strcopy1(xname,1,8),'$claude.') then
   begin
   xoutname:='Arial';
   result:=true;
   end;
except;end;
end;
//## low__findfontname ##
function low__findfontname(xname:string;var xoutname:string):boolean;
begin
try;result:=low__findfontname2(xname,vifontname,vifontname2,xoutname);except;end;
end;
//## low__findfontnameb ##
function low__findfontnameb(xname:string):string;
begin
try;low__findfontname2(xname,vifontname,vifontname2,result);except;end;
end;
//## low__font0 ##
function low__font0(xname:string;xsize:longint):longint;
begin
try;low__font('make','',xname,xsize,vifeatherf>=1,false,0,result);except;end;
end;
//## low__font1 ##
function low__font1(xname:string;xsize:longint;xbold:boolean):longint;
begin
try;low__font('make','',xname,xsize,vifeatherf>=1,xbold,0,result);except;end;
end;
//## low__font2 ##
function low__font2(xsysname,xname:string;xsize:longint;xbold:boolean):longint;
begin
try
case (xsysname<>'') of
true:low__font('sysmake',xsysname,xname,xsize,vifeatherf>=1,xbold,0,result);
false:low__font('make',xsysname,xname,xsize,vifeatherf>=1,xbold,0,result);
end;
except;end;
end;
//## low__font3 ##
function low__font3(xsysname:string):longint;
begin
try;low__font('sysfind',xsysname,'',0,vifeatherf>=1,false,-1,result);except;end;
end;
//## low__fontdata ##
function low__fontdata(xindex:longint):longint;
begin
try;low__font('datacheck','','',0,vifeatherf>=1,false,xindex,result);except;end;
end;
//## low__fontmaxh ##
function low__fontmaxh(xindex:longint):longint;
begin
try;result:=low__fromLGF_height(sysfont_data[low__fontdata(xindex)]);except;end;
end;
//## low__fonttextwidth ##
function low__fonttextwidth(xindex:longint;xtext:tobject):longint;
begin
try;result:=low__fromLGF_textwidthTAB(tbnone,sysfont_data[low__fontdata(xindex)],xtext);except;end;
end;
//## low__fonttextwidthTAB ##
function low__fonttextwidthTAB(xtab,xindex:longint;xtext:tobject):longint;
begin
try;result:=low__fromLGF_textwidthTAB(xtab,sysfont_data[low__fontdata(xindex)],xtext);except;end;
end;
//## low__fonttextwidth2 ##
function low__fonttextwidth2(xindex:longint;xtext:string):longint;
begin
try;result:=low__fromLGF_textwidthTAB2(tbnone,sysfont_data[low__fontdata(xindex)],xtext);except;end;
end;
//## low__fonttextwidthTAB2 ##
function low__fonttextwidthTAB2(xtab,xindex:longint;xtext:string):longint;
begin
try;result:=low__fromLGF_textwidthTAB2(xtab,sysfont_data[low__fontdata(xindex)],xtext);except;end;
end;
//## low__fontavew ##
function low__fontavew(xindex:longint):longint;
begin
try;result:=sysfont_avew[low__fontdata(xindex)];except;end;
end;
//## low__fontcount ##
function low__fontcount:longint;
var
   p:longint;
begin
try
result:=0;
for p:=0 to high(sysfont_dref) do if (sysfont_data[p].count>=1) then inc(result);
except;end;
end;
//## low__fontbytes ##
function low__fontbytes:longint;
var
   p:longint;
begin
try
result:=0;
for p:=0 to high(sysfont_dref) do if (sysfont_data[p].count>=1) then inc(result,sysfont_data[p].count);
except;end;
end;
//## low__font ##
function low__font(sstyle,ssysname,sname:string;xsize:longint;xgrey,xbold:boolean;xval:longint;var xoutval:longint):boolean;//05feb2022
label
   skipend;
const
   xsyslast=3;
   xtimeout=60000;//1 minute
   xminsize=5;
   xdefsize=8;
   xdefname='$fontname';
var
   dref:tstr8;
   p,int1,int2:longint;
   xtime:comp;
   xstyle,xsysname,xname,e:string;
   //## xsame ##
   function xsame(s,d:tstr8):boolean;//fixed the missed comparison of "Arial" and "Arial Black" by failing to detected lengths - 26mar2022
   begin
   try
   result:=true;
   if (s=nil) or (d=nil)                                               then result:=false
   else if s.empty or d.empty or (s.count<>d.count) or (not s.same(d)) then result:=false;
   except;end;
   end;
   //## xave ##
   procedure xave(p:longint);
   begin
   if (p>=0) and (p<=high(sysfont_dref)) then low__fromlgf_avew(sysfont_data[p],sysfont_avew[p],sysfont_minw[p],sysfont_maxw[p]);
   end;
   //## xdataref ##
   procedure xdataref(x:tstr8);
      //## xbol ##
      function xbol(x:boolean):byte;
      begin
      if x then result:=1 else result:=0;
      end;
   begin
   if zznil(x,2249) then exit;
   if (xname='')                       then xname:=xdefname;
   if (xsize=0)                        then xsize:=xdefsize;//Special Note: xsize=-1..minint=font as a height rather than a size -> allowed - 11apr2020
   if (xsize>=0) and (xsize<xminsize)  then xsize:=xminsize;
   //.name converter for "Default" and "Default 2"
   if low__comparetext(xname,'$fontname') or low__comparetext(xname,'$fontname2') then low__findfontname2(xname,vifontname,vifontname2,xname);//05feb2022
   x.clear;
   x.addbyt1(xbol(xbold));//0
   x.addint4(xsize);//1..4
   x.addbol1(xgrey);//5 - 13feb2022
   x.addstr(low__lowercase(xname));//6..N
   end;
   //## xmakefromdref ##
   function xmakefromdref(p:longint):boolean;
   var
      e:string;
   begin
   result:=false;
   if (p>=0) and (p<=high(sysfont_dref)) and (sysfont_dref[p].count>=7) then
      begin
      xbold        :=(sysfont_data[p].pbytes[0]=1);//0
      xsize        :=sysfont_data[p].int4[1];//1..4
//yyyy xgrey        :=sysfont_data[p].int4[5];//5..5
      xname        :=sysfont_data[p].str[6,sysfont_data[p].count];//6..N
      low__toLGF(xname,xsize,xgrey,xbold,sysfont_data[p],e);
      xave(p);
      sysfont_time[p]:=ms64+xtimeout;
      result:=true;
      end;
   end;
begin
try
//defaults
result:=false;
xoutval:=0;
dref:=nil;

//init
xstyle:=sstyle;
xsysname:=ssysname;
xname:=sname;
xstyle:=low__lowercase(xstyle);

//get
//.sysfind + syscreate
if (xstyle='sysfind') or (xstyle='sysmake') then//create only if not already set
   begin
   //filter
   if (xsysname<>'') then xsysname:=low__lowercase(xsysname);
   //init
   if      (xsysname='root')  then xoutval:=0
   else if (xsysname='fn')    then xoutval:=1//vinormal fn
   else if (xsysname='fb')    then xoutval:=2//vinormal fb
   else                            xoutval:=xsyslast;//used to store an unknown system font
   //decide
   if (xstyle='sysfind') then
      begin
      result:=(xoutval<xsyslast);
      goto skipend;
      end;
   //input override
   if (xoutval=0) then//root system font -> always "arial/8"
      begin
      xname:=xdefname;
      xsize:=xdefsize;
      xbold:=false;
      end;
   //create
   dref:=bnew;
   xdataref(dref);
   //was: if sysfont_data[xoutval].empty or (not dref.same(sysfont_dref[xoutval])) then
   if not xsame(sysfont_data[xoutval],dref) then
      begin
      sysfont_dref[xoutval].replace:=dref;
      low__toLGF(xname,xsize,xgrey,xbold,sysfont_data[xoutval],e);
      xave(xoutval);
      end;
   sysfont_time[xoutval]:=ms64+xtimeout;//Note: a system font never times out actually -> set just to be consistent
   //set
   result:=true;
   end
//.make
else if (xstyle='make') then
   begin
   //init
   dref:=bnew;
   xdataref(dref);
   //find existing
   //was: for p:=0 to high(sysfont_dref) do if (sysfont_dref[p].count>=1) and (dref.same(sysfont_dref[p])) then
   for p:=0 to high(sysfont_dref) do if (sysfont_dref[p].count>=1) and xsame(dref,sysfont_dref[p]) then
      begin
      //.recreate fontdata if it's been timed out
      if sysfont_data[p].empty then
         begin
         case (p<=xsyslast) of
         true:xmakefromdref(p);//system fonts cannot be modified from a user level proc "make" -> so reuse system font's dref info for font data creation - 10apr2020
         false:low__toLGF(xname,xsize,xgrey,xbold,sysfont_data[p],e);
         end;//case
         xave(p);
         end;
      xoutval:=p;
      result:=true;
      goto skipend;
      end;

   //find oldest non-system font
   xtime:=max64;
   int1:=-1;
   for p:=(xsyslast+1) to high(sysfont_dref) do if (sysfont_time[p]<xtime) then
      begin
      xtime:=sysfont_time[p];
      int1:=p;
      end;//p
   if (int1=-1) then int1:=xsyslast+1;//should never be required

   //add
   sysfont_dref[int1].replace:=dref;//fixed - 12may2020
   low__toLGF(xname,xsize,xgrey,xbold,sysfont_data[int1],e);
   xave(int1);
   sysfont_time[int1]:=ms64+xtimeout;
   xoutval:=int1;
   result:=true;
   end
//.datacheck -> checks to see if font's data has been wiped by a timeout trigger, if so, recreate font data from "dref" - 10apr2020
else if (xstyle='datacheck') then
   begin
   xoutval:=frcrange(xval,0,high(sysfont_dref));
   if sysfont_dref[xoutval].notempty then
      begin
      result:=sysfont_data[xoutval].notempty;
      if (not result) then result:=xmakefromdref(xoutval);
      end;
   end
//.timeouts checker
else if (xstyle='timeouts') then
   begin
   xtime:=ms64;
   for p:=(xsyslast+1) to high(sysfont_dref) do if sysfont_data[p].notempty and (xtime>sysfont_time[p]) then sysfont_data[p].clear;
   end
//.error
else showerror('Undefined font directive "'+xstyle+'"');

skipend:
except;end;
try;freeobj(@dref);except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//fffffffffffffffffffffffffff
//## low__syszoom ##
procedure low__syszoom(var aw,ah:longint);
begin
try
aw:=aw*vizoom;
ah:=ah*vizoom;
except;end;
end;
//## low__syszoomlimit ##
function low__syszoomlimit:longint;//15apr2021
var
   int1:longint;
begin
try
//defaults
result:=4;
int1:=frcrange(vibordersize__temp-32,0,72);
//restrict upper zoom limit based on screen resolution -> any screen with a size of 480 or less (width or height) is resrticted to 2x max. zoom - 15apr2021
case smallest(misscreenw-int1,misscreenh-int1) of
minint..480:result:=2;
481..800   :result:=3;
end;//case
except;end;
end;

//-- draw support --------------------------------------------------------------
//## tepext ##
function tepext(xfilenameORext:string):longint;
var
   bol1:boolean;
begin
try;result:=tepext3(xfilenameORext,tepXXX20,bol1);except;end;
end;
//## tepext2 ##
function tepext2(xfilenameORext:string;xdeftep:longint):longint;
var
   bol1:boolean;
begin
try;result:=tepext3(xfilenameORext,xdeftep,bol1);except;end;
end;
//## tepext3 ##
function tepext3(xfilenameORext:string;xdeftep:longint;var xfound:boolean):longint;
var
   n:string;
   //## xset ##
   procedure xset(x:longint);
   begin
   result:=x;
   xfound:=true;
   end;
begin
try
//defaults
result:=xdeftep;
xfound:=false;
//get
n:=lowercase__readfileext(xfilenameORext);

//.images
if       (n='bmp') or (n='vbmp') or (n='wmf') or (n='emf') or (n='jpg') or (n='jpeg') or (n='jpgt') or (n='jif') or (n='lig') or (n='gif') then xset(tepBMP20)
else if  (n='ico') or (n='yuv') or (n='gr8') or (n='bw1') or (n='b04') or (n='b12') or (n='ppm') or (n='pgm') or (n='pbm') or (n='xbm') then xset(tepBMP20)
else if  (n='tea') or (n='teb') or (n='tem') or (n='tep') or (n='tec') or (n='teh') or (n='t24') or (n='atep') or (n='omi') or (n='san') or (n='can') or (n='ean') or (n='aan') or (n='aas') or (n='raw24') then xset(tepBMP20)
else if (n='png') or (n='abr') then xset(tepBMP20)//30dec2021
else if (n='cur') or (n='ani') then xset(tepCUR20)//24may2022
//.music
else if (n='wav') or (n='mp1') or (n='mp2') or (n='mp3') or (n='wma') then xset(tepWMA20)
else if (n='mid') or (n='midi') or (n='rmi') then xset(tepMID20)//20feb2021
//.playlist
else if (n='m3u') then xset(tepNotes20)//20mar2022

//.videos

//.documents
else if (n='c2v') then xset(tepC2V20)
else if (n='c2p') then xset(tepC2P20)
else if (n='ini') then xset(tepTXT20)//24jan2022
else if (n='txt') then xset(tepTXT20)
else if (n='bwd') then xset(tepBWD20)
else if (n='bwp') then xset(tepBWP20)
else if (n='rtf') then xset(tepRTF20)//22jun2022
else if (n='htm') then xset(tepHTM20)//30dec2021
else if (n='html') then xset(tepHTM20)//30dec2021
else if (n='xml') then xset(tepXML20)//30dec2021
else if (n='footnote') then xset(tepTXT20)//21mar2022
else if (n='cscript') then xset(tepCUR20)//17may2022
else if (n='sfef')    then xset(tepSFEF20)//05oct2022

//.programs
else if (n='exe') then xset(tepEXE20)
else if (n='bat') then xset(tepXXX20)
//.schemes
else if (n='bcs') then xset(tepBCS20)
//.redirects
else if (n='r')   then xset(tepR20)//30dec2021
//.archives
else if (n='zip') then xset(tepZIP20)
else if (n='7z')  then xset(tep7Z20)
//.other
else if (n='alarms')    then xset(tepClock20)//08mar2022
else if (n='reminders') then xset(tepAlert20)//09mar2022

//.filter groups - 10mar2021
else if (n=feallimgs) then xset(tepBMP20)
else if (n=feallcurs) then xset(tepCUR20)//24may2022
else if (n=feallcurs2) then xset(tepCUR20)//24may2022
else if (n=fealljpgs) then xset(tepBMP20)//03sep2021
else if (n=fealldocs) then xset(tepBWP20);//26sep2022

except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//wwwwwwwwwwwwwwwwwwwwwwwwwww
//## low__tepdata ##
function low__tepdata(xname:string;var xdata:tstr8;var xw,xh:longint;var e:string):boolean;//07jan2022
label//xname="saveas20.tep" or "saveas20.png" or "saveas20.jpg"
   skipend;
var
   a:tbasicimage;
   i:longint;
   dformat:string;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
a:=nil;
xw:=0;
xh:=0;
//check
if not block(xdata) then exit;
//init
xdata.clear;
dformat:=low__udv(readfileext(xname,false),'png');
xname:=remlastext(low__extractfilename(xname));
//get
if (xname='') or (not tepfindbyname(xname,i)) then
   begin
   e:='TEP not found "'+xname+'"';
   goto skipend;
   end;
//set
a:=misimg32(1,1);
if not low__teatoimg(tepfind2(i),a,xw,xh) then goto skipend;
if not mistodata(a,xdata,'png',e) then goto skipend;
//successful
result:=true;
skipend:
except;end;
try
bunlockautofree(xdata);
freeobj(@a);
except;end;
end;
//## tepfindbyname ##
function tepfindbyname(xname:string;var xindex:longint):boolean;
label
   skipend,skipdone;
   //## nok ##
   function nok(n:string;nindex:longint):boolean;
   begin
   result:=(n=xname);
   if result then xindex:=nindex;
   end;
begin
try
//defaults
result:=false;
xindex:=0;
//init
xname:=low__lowercase(xname);
//find
//.variable size teps
if      nok('on',tepOn) then goto skipdone
else if nok('off',tepoff) then goto skipdone
else if nok('up',tepup) then goto skipdone
else if nok('down',tepdown) then goto skipdone
else if nok('left',tepleft) then goto skipdone
else if nok('right',tepright) then goto skipdone
else if nok('min',tepmin) then goto skipdone
else if nok('nor',tepnor) then goto skipdone
else if nok('max',tepmax) then goto skipdone
else if nok('clo',tepclo) then goto skipdone
else if nok('inf',tepinf) then goto skipdone
else if nok('maximise',tepmax) then goto skipdone
else if nok('helphint',tephelphint) then goto skipdone
else if nok('bullet',tepbullet) then goto skipdone
else if nok('sep',tepsep) then goto skipdone
//.standard "20" size teps
else if nok('fnew20',tepfnew20) then goto skipdone//23mar2022
else if nok('new20',tepnew20) then goto skipdone
else if nok('home20',tephome20) then goto skipdone
else if nok('yesblank20',tepyesblank20) then goto skipdone
else if nok('yes20',tepyes20) then goto skipdone
else if nok('ok20',tepok20) then goto skipdone
else if nok('open20',tepopen20) then goto skipdone
else if nok('save20',tepsave20) or nok('saveas20',tepsave20) then goto skipdone
else if nok('disk20',tepdisk20) then goto skipdone
else if nok('close20',tepclose20) then goto skipdone
else if nok('hide20',tephide20) then goto skipdone
else if nok('undo20',tepundo20) then goto skipdone
else if nok('redo20',tepredo20) then goto skipdone
else if nok('cut20',tepcut20) then goto skipdone
else if nok('copy20',tepcopy20) then goto skipdone
else if nok('paste20',teppaste20) then goto skipdone
else if nok('selectall20',tepselectall20) then goto skipdone
else if nok('frame20',tepframe20) then goto skipdone
else if nok('blank20',tepBlank20) then goto skipdone
else if nok('clock20',tepClock20) then goto skipdone
else if nok('alert20',tepAlert20) then goto skipdone
else if nok('bell20',tepBell20) then goto skipdone//14mar2022
else if nok('sonnerie20',tepSonnerie20) then goto skipdone//14mar2022
else if nok('left20',tepLeft20) then goto skipdone//27feb2022
else if nok('right20',tepRight20) then goto skipdone
else if nok('top20',tepTop20) then goto skipdone
else if nok('bottom20',tepBottom20) then goto skipdone
else if nok('back20',tepBack20) then goto skipdone//23mar2022
else if nok('forw20',tepForw20) then goto skipdone
else if nok('power20',tepPower20) then goto skipdone
else if nok('encrypt20',tepAddL20) then goto skipdone
else if nok('decrypt20',tepSubL20) then goto skipdone
else if nok('wine20',tepwine20) then goto skipdone
else if nok('upper20',tepupper20) then goto skipdone
else if nok('lower20',teplower20) then goto skipdone
else if nok('name20',tepname20) then goto skipdone
else if nok('eye20',tepeye20) then goto skipdone
else if nok('stop20',tepstop20) then goto skipdone
else if nok('play20',tepplay20) then goto skipdone
else if nok('rec20',teprec20) then goto skipdone
else if nok('rewind20',teprewind20) then goto skipdone
else if nok('fastforward20',tepfastforward20) then goto skipdone
else if nok('vol20',tepvol20) then goto skipdone
else if nok('options20',tepoptions20) then goto skipdone
else if nok('nav20',tepnav20) then goto skipdone
else if nok('max20',tepmax20) then goto skipdone
else if nok('ontop20',tepontop20) then goto skipdone//11sep2021
else if nok('less20',tepless20) then goto skipdone
else if nok('more20',tepmore20) then goto skipdone
else if nok('bw20',tepbw20) then goto skipdone
else if nok('help20',tephelp20) then goto skipdone
else if nok('helpbanner',tephelpbanner) then goto skipdone
else if nok('helpdoc20',tephelpdoc20) then goto skipdone
else if nok('book20',tepbook20) then goto skipdone
else if nok('settings20',tepsettings20) then goto skipdone
else if nok('um20',tepum20) then goto skipdone
else if nok('about20',tepabout20) then goto skipdone
else if nok('be20',tepbe20) then goto skipdone
else if nok('refresh20',teprefresh20) then goto skipdone
else if nok('folder20',tepfolder20) then goto skipdone
else if nok('color20',tepcolor20) then goto skipdone
else if nok('colors20',tepcolors20) then goto skipdone
else if nok('colormatrix20',tepcolormatrix20) then goto skipdone
else if nok('colorpal20',tepcolorpal20) then goto skipdone
else if nok('colorhistory20',tepcolorhistory20) then goto skipdone
else if nok('font20',tepfont20) then goto skipdone
else if nok('desktop20',tepdesktop20) then goto skipdone
else if nok('programs20',tepprograms20) then goto skipdone
else if nok('menu20',tepmenu20) then goto skipdone
else if nok('invert20',tepinvert20) then goto skipdone
else if nok('prev20',tepprev20) then goto skipdone
else if nok('next20',tepnext20) then goto skipdone
else if nok('fav20',tepfav20) then goto skipdone
else if nok('upone20',tepupone20) then goto skipdone
else if nok('newfolder20',tepnewfolder20) then goto skipdone
else if nok('add20',tepadd20) then goto skipdone
else if nok('addl20',tepaddl20) then goto skipdone
else if nok('sub20',tepsub20) then goto skipdone
else if nok('subl20',tepsubl20) then goto skipdone
else if nok('panel20',tepPanel20) then goto skipdone
else if nok('edit20',tepedit20) then goto skipdone
else if nok('favedit20',tepfavedit20) then goto skipdone
else if nok('favadd20',tepfavadd20) then goto skipdone
else if nok('tick20',teptick20) then goto skipdone
else if nok('untick20',tepuntick20) then goto skipdone
else if nok('ticktwo20',tepticktwo20) then goto skipdone
else if nok('unticktwo20',tepunticktwo20) then goto skipdone
else if nok('up20',tepup20) then goto skipdone
else if nok('cd20',tepcd20) then goto skipdone
else if nok('removable20',tepremovable20) then goto skipdone
else if nok('folderimage20',tepfolderimage20) then goto skipdone
else if nok('startmenu20',tepstartmenu20) then goto skipdone
else if nok('schemes20',tepschemes20) then goto skipdone
else if nok('screen20',tepscreen20) or nok('preview20',tepscreen20) then goto skipdone//26aug2021
else if nok('wrap20',tepwrap20) then goto skipdone
else if nok('xxx20',tepxxx20) then goto skipdone
else if nok('bmp20',tepbmp20) then goto skipdone
else if nok('wma20',tepwma20) then goto skipdone
else if nok('c2v20',tepc2v20) then goto skipdone
else if nok('c2p20',tepc2p20) then goto skipdone
else if nok('ini20',teptxt20) then goto skipdone
else if nok('txt20',teptxt20) then goto skipdone
else if nok('exe20',tepexe20) then goto skipdone
else if nok('zip20',tepzip20) then goto skipdone
else if nok('7z20',tep7z20) then goto skipdone
else if nok('htm20',tephtm20) then goto skipdone
else if nok('bwd20',tepbwd20) then goto skipdone
else if nok('bwp20',tepbwp20) then goto skipdone
else if nok('rtf20',teprtf20) then goto skipdone
else if nok('mid20',tepmid20) then goto skipdone
else if nok('sfef20',tepsfef20) then goto skipdone//05oct2022
else if nok('bcs20',tepbcs20) then goto skipdone
else if nok('notes20',tepnotes20) then goto skipdone//20mar2022
else if nok('r20',tepr20)     then goto skipdone
else if nok('xml20',tepxml20) then goto skipdone
else if nok('unknown20',tepunknown20) then goto skipdone
else if nok('zoom20',tepzoom20) then goto skipdone
else if nok('sizeto20',tepsizeto20) then goto skipdone
else if nok('icon20',tepicon20) then goto skipdone
//.large images -> 32x32px
else if nok('icon32',tepicon32) then goto skipdone
else if nok('info32',tepinfo32) then goto skipdone
else if nok('query32',tepquery32) then goto skipdone
else if nok('error32',teperror32) then goto skipdone
else if nok('color32',tepcolor32) then goto skipdone
else if nok('folderimage32',tepfolderimage32) then goto skipdone
else if nok('newfolder32',tepnewfolder32) then goto skipdone
//.error not found
else goto skipend;
//successul
skipdone:
result:=true;
skipend:
except;end;
end;
//## tepfound ##
function tepfound(xindex:longint):boolean;
var
   xdata:tlistptr;
begin
try;result:=tepfind(xindex,xdata);except;end;
end;
//## tepfind ##
function tepfind(xindex:longint;var xdata:tlistptr):boolean;
begin
try;result:=tepfind3(xindex,xdata,false);except;end;
end;
//## tepfind3 ##
function tepfind3(xindex:longint;var xdata:tlistptr;xmusthavedata:boolean):boolean;//16sep2022
  //## m ##
  procedure m(const x:array of byte);//map array to pointer record
  begin
  xdata:=low__maplist(x);
  end;
begin
try
//defaults
result:=false;
xdata.count:=0;
xdata.bytes:=nil;
//get
case xindex of
tepNone:;
//.system images -> no fixed width or height
tepOn         :m(tep_on);
tepOff        :m(tep_off);
tepUp         :m(tep_up);
tepDown       :m(tep_down);
tepLeft       :m(tep_left);
tepRight      :m(tep_right);
tepMin        :m(tep_min);
tepNor        :m(tep_nor);
tepNormal     :m(tep_nor);
tepMax        :m(tep_max);
tepClo        :m(tep_clo);
tepInf        :m(tep_inf);//29aug2020
tepMaximise   :m(tep_max);
tepHelphint   :m(tep_helphint);
tepBullet     :m(tep_bullet);//15may2021
tepSep        :m(tep_sep);//15may2021

//.standard images -> fixed height of 20px
tepNew20      :m(tep_new20);
tepHome20     :m(tep_home20);
tepYesBLANK20 :m(tep_yesblank20);//03jun2021
tepYes20      :m(tep_yes20);
tepOK20       :m(tep_yes20);
tepOpen20     :m(tep_open20);
tepSave20     :m(tep_save20);
tepDisk20     :m(tep_disk20);
tepClose20    :m(tep_close20);
tepUndo20     :m(tep_undo20);
tepRedo20     :m(tep_redo20);
tepCut20      :m(tep_cut20);
tepCopy20     :m(tep_copy20);
tepPaste20    :m(tep_paste20);
tepSelectAll20:m(tep_selectall20);
tepBlank20    :m(tep_blank20);//03mar2022
tepClock20    :m(tep_clock20);//03mar2022
tepAlert20    :m(tep_alert20);//09mar2022
tepBell20     :m(tep_bell20);//14mar2022
tepSonnerie20 :m(tep_sonnerie20);//14mar2022
tepLeft20     :m(tep_left20);//27feb2022
tepRight20    :m(tep_right20);
tepTop20      :m(tep_top20);
tepBottom20   :m(tep_bottom20);
tepFrame20    :m(tep_frame20);
tepWine20     :m(tep_wine20);
tepUpper20    :m(tep_upper20);
tepLower20    :m(tep_lower20);
tepName20     :m(tep_name20);
tepEye20      :m(tep_eye20);
tepStop20     :m(tep_stop20);
tepPlay20     :m(tep_play20);
tepRec20      :m(tep_rec20);
tepRewind20   :m(tep_rewind20);
tepFastForward20:m(tep_fastforward20);
tepVol20      :m(tep_vol20);
tepoptions20  :m(tep_options20);
tepNav20      :m(tep_nav20);
tepMax20      :m(tep_max20);
tepOntop20    :m(tep_ontop20);
tepLess20     :m(tep_less20);
tepMore20     :m(tep_more20);
tepBW20       :m(tep_bw20);
tepHelp20     :m(tep_help20);
tepHelpBanner :m(tep_helpbanner);///07jan2022
tepHelpdoc20  :m(tep_helpdoc20);
tepBook20     :m(tep_book20);
tepSettings20 :m(tep_settings20);
tepUM20       :m(tep_um20);
tepAbout20    :m(tep_about20);
tepBE20       :m(tep_be20);
tepRefresh20  :m(tep_refresh20);
tepFolder20   :m(tep_folder20);
tepColor20    :m(tep_color20);
tepColors20   :m(tep_colors20);
tepColormatrix20:m(tep_colormatrix20);
tepColorPal20 :m(tep_colorpal20);//02mar2021
tepColorHistory20:m(tep_colorhistory20);//19mar2021
tepFont20     :m(tep_font20);
tepDesktop20  :m(tep_desktop20);
tepPrograms20 :m(tep_programs20);
tepMenu20     :m(tep_menu20);
tepInvert20   :m(tep_invert20);
tepPrev20     :m(tep_prev20);
tepNext20     :m(tep_next20);
tepFav20      :m(tep_fav20);
tepUpone20    :m(tep_upone20);
tepNewfolder20:m(tep_newfolder20);
tepAdd20      :m(tep_add20);
tepAddL20     :m(tep_addl20);
tepSub20      :m(tep_sub20);
tepSubL20     :m(tep_subl20);
tepPanel20    :m(tep_panel20);//05jul2022
tepEdit20     :m(tep_edit20);
tepFavedit20  :m(tep_favedit20);
tepFavAdd20   :m(tep_favadd20);
tepTick20     :m(tep_tick20);//25mar2021
tepUntick20   :m(tep_untick20);
tepUp20       :m(tep_up20);
tepCD20       :m(tep_cd20);
tepRemovable20:m(tep_removable20);
tepFolderimage20:m(tep_folderimage20);
tepStartmenu20:m(tep_startmenu20);
tepSchemes20  :m(tep_schemes20);//07apr2021
tepZoom20     :m(tep_zoom20);
tepSizeto20   :m(tep_sizeto20);
tepTicktwo20  :m(tep_ticktwo20);//07jun2021
tepUnticktwo20:m(tep_unticktwo20);
tepTickthree20:m(tep_tickthree20);//07jun2021
tepUntickthree20:m(tep_untickthree20);
tepScreen20   :m(tep_screen20);
tepWrap20     :m(tep_wrap20);//18dec2021
tepNotes20    :m(tep_notes20);//20mar2022
tepFNew20     :m(tep_fnew20);//23mar2022
tepBack20     :m(tep_back20);//23mar2022
tepForw20     :m(tep_forw20);
tepPower20    :m(tep_power20);

//.file format teps
tepXXX20       :m(tep_xxx20);
tepBMP20       :m(tep_bmp20);
tepWMA20       :m(tep_wma20);
tepC2P20       :m(tep_c2p20);
tepC2V20       :m(tep_c2v20);
tepINI20       :m(tep_txt20);//hasn't got it's own specific image yet - 24jan2022
tepTXT20       :m(tep_txt20);
tepCUR20       :m(tep_cur20);//24may2022
tepEXE20       :m(tep_exe20);
tepZIP20       :m(tep_zip20);
tep7Z20        :m(tep_zip20);
tepXML20       :m(tep_xml20);
tepHTM20       :m(tep_htm20);
tepBWD20       :m(tep_bwd20);
tepBWP20       :m(tep_bwp20);
tepRTF20       :m(tep_rtf20);
tepMID20       :m(tep_mid20);
tepBCS20       :m(tep_color20);
tepR20         :m(tep_r20);
tepHide20      :m(tep_hide20);
tepIcon20      :m(program_icon20h);
tepSFEF20      :m(tep_sfef20);

//.large images -> 32x32px
tepIcon32           :m(program_icon32h);
tepIcon32b          :m(program_icon32hB);
tepIcon32c          :m(program_icon32hC);
tepIcon32d          :m(program_icon32hD);
tepInfo32           :m(tep_info32);
tepQuery32          :m(tep_query32);
tepError32          :m(tep_error32);
tepColor32          :m(tep_color32);//26feb2021
tepFolderimage32    :m(tep_folderimage32);//13apr2021
tepNewfolder32      :m(tep_newfolder32);//14apr2021

//.dynamically allocated teps - max of 20w x 20h - 06apr2021
tepSysstart20..tepSysstop20:tep__find20(xindex,xdata);

//.fallback image
else           m(tep_unknown20);
end;//case
except;end;
try;result:=(xdata.count>=low__aorb(1,2,xmusthavedata)) and (xdata.bytes<>nil);except;end;
end;
//## tepfind2 ##
function tepfind2(xindex:longint):tlistptr;
begin
try;tepfind(xindex,result);except;end;
end;
//## tepinfosys ##
function tepinfosys(xindex:longint;var aw,ah:longint;var xtransparent,xsyscolors:boolean):boolean;//14mar2021
begin
try;result:=tepinfo(xindex,true,aw,ah,xtransparent,xsyscolors);except;end;
end;
//## tepinfo ##
function tepinfo(xindex:longint;xsyszoom:boolean;var aw,ah:longint;var xtransparent,xsyscolors:boolean):boolean;
var
   xdata:tlistptr;
begin
try;result:=tepinfo2(xindex,xsyszoom,xdata,aw,ah,xtransparent,xsyscolors);except;end;
end;
//## tepinfo2 ##
function tepinfo2(xindex:longint;xsyszoom:boolean;var adata:tlistptr;var aw,ah:longint;var xtransparent,xsyscolors:boolean):boolean;
var
   xSOD,xversion,xval1,xval2:longint;
begin
try
//defaults
result:=false;
adata.count:=0;
adata.bytes:=nil;
aw:=0;
ah:=0;
xtransparent:=true;
xsyscolors:=true;
//find
if not tepfind(xindex,adata) then exit;
//get
if not low__teainfo(adata,xsyszoom,aw,ah,xSOD,xversion,xval1,xval2,xtransparent,xsyscolors) then exit;
//successful
result:=true;
except;end;
end;
//## tepdraw ##
function tepdraw(xindex:longint;xsyszoom:boolean;dx,dy,dc,dc2:longint;xarea,xarea2:trect;d:tobject;xfocus,xgrey,xround:boolean;xroundstyle:longint):boolean;
var
   xdata:tlistptr;
begin
try;result:=tepfind(xindex,xdata) and tepdraw2(xdata,xsyszoom,dx,dy,dc,dc2,xarea,xarea2,d,xfocus,xgrey,xround,xroundstyle);except;end;
end;
//## tepdraw2 ##
function tepdraw2(var xdata:tlistptr;xsyszoom:boolean;dx,dy,dc,dc2:longint;xarea,xarea2:trect;d:tobject;xfocus,xgrey,xround:boolean;xroundstyle:longint):boolean;
begin
try;result:=low__teadraw(false,xsyszoom,dx,dy,dc,dc2,xarea,xarea2,d,xdata,xfocus,xgrey,xround,xroundstyle);except;end;
end;
//## compress ##
function low__compress(x:tstr8;var e:string):boolean;
begin
try;result:=low__compress2(x,e,true,true);except;end;
end;
//## decompress ##
function low__decompress(x:tstr8;var e:string):boolean;
begin
try;result:=low__compress2(x,e,false,true);except;end;
end;
//## low__compress2 ##
function low__compress2(x:tstr8;var e:string;xcompress,xfast:boolean):boolean;//05feb2021
label
   skipdone,skipend;
var
   strm:TZStreamRec;
   tmp,p:pdlbyte;
   i,v2,v,incBY,ip,xlen,tmpLEN:longint;
   v8:byte;
begin
try
//defaults
result:=false;
e:=gecOutOfMemory;
tmp:=nil;
p:=nil;
//check
if not block(x) then exit else xlen:=x.len;
if (xlen<=0) then goto skipdone;
//init
v:=0;
v2:=0;

//get
fillchar(strm,sizeof(strm),0);
strm.zalloc:=zlibAllocMem;
strm.zfree:=zlibFreeMem;

case xcompress of
true:begin//compress
   tmpLEN:=((xlen+(xlen div 10)+12)+255) and not 255;
   incBY:=256;
   end;
false:begin//decompress
   incBY:=(xlen+255) and not 255;
   tmpLEN:=incBY;
   end;
end;//case
getmem(tmp,tmpLEN);
//set
strm.next_in:=x.pbytes;//pchar(x);
strm.avail_in:=x.len;//length(x);
strm.next_out:=tmp;
strm.avail_out:=incBY;
//.init
if xcompress then v:=deflateInit_(strm,low__aorb(Z_BEST_COMPRESSION,Z_BEST_SPEED,xfast),zlib_version,sizeof(strm)) else v:=inflateInit_(strm,zlib_version,sizeof(strm));
if (v<0) then goto skipend;
try
//.work
while true do
begin
//.get
if xcompress then v:=deflate(strm,z_FINISH) else v:=inflate(strm,z_FINISH);
if (v=Z_STREAM_END) or (v<0) then break;
//.set
if (strm.avail_out=0) then
   begin
   //.inc
   p:=tmp;
   inc(tmpLEN,incBY);
   reallocmem(tmp,tmpLEN);
   strm.next_out:=pchar(longint(tmp)+(longint(strm.next_out)-longint(p)));//xxxxxxxxxx pointer//??????????????
   strm.avail_out:=incBY;
   end;//if
end;//whilte
finally
if xcompress then v2:=deflateEnd(strm) else v2:=inflateEnd(strm);
end;
if (v<0) or (v2<0) then goto skipend;
//.get
reallocmem(tmp,strm.total_out);
tmpLEN:=strm.total_out;
//.fill data
x.setlen(tmplen);
if (tmplen>=1) then
   begin
   //was: for i:=0 to (tmplen-1) do x.pbytes[i]:=tmp[i];
   //faster - 22apr2022
   for i:=0 to (tmplen-1) do
   begin
   v8:=tmp[i];
   x.pbytes[i]:=v8;
   end;//p
   end;

//successful
skipdone:
result:=true;
skipend:
except;end;
try;freemem(tmp,0);except;end;
try
if (not result) and zzok(x,7072) then x.clear;
bunlockautofree(x);
except;end;
end;

//## tbasicprg1 ################################################################
//## create ##
constructor tbasicprg1.create;//01jan2021
begin
if not app__initing then showerror('[000] Init failed');//this happens when we forget to put "app__init" in the "Project Source" and override Delphi's standard program msg loop - 01jan2021
if (system_program=nil) then system_program:=self;
satinc(satBasicprg,1);
zzadd(self);
application.title:=low__programname;//08mar2021
inherited create;
end;
//## createfinish ##
procedure tbasicprg1.createfinish;
begin
try
//nil
except;end;
end;
//## destroy ##
destructor tbasicprg1.destroy;
begin
if (system_program=self) then system_program:=nil;//24jul2021
inherited destroy;
satinc(satBasicprg,-1);
end;
//## xloadsettings ##
procedure tbasicprg1.xloadsettings;
begin

end;
//## xsavesettings ##
procedure tbasicprg1.xsavesettings;
begin

end;
//## getsystem ##
function tbasicprg1.getsystem:tbasicsystem;
begin
try;result:=nil;showerror('No system');except;end;
end;

//## tbasicprg2 ################################################################
//## create ##
constructor tbasicprg2.create(xminsysver:longint;xhost:tobject;dwidth,dheight:longint);
begin
//self
inherited create;
//range
dwidth:=frcmax(dwidth,frcmin(trunc((programinit_screensizelimit_pert/100)*misworkw),1));
dheight:=frcmax(dheight,frcmin(trunc((programinit_screensizelimit_pert/100)*misworkh),1));
//system
irootwin:=nil;
isystem:=nil;
isystem:=tbasicsystem.create(xminsysver,xhost,dwidth,dheight);
//.system help colors - Claude support - 26aug2020
//sys_help_text2    :=low__rgb(120,153,187);
//sys_help_header2  :=low__rgb(27,47,199);
//sys_help_bgcolor  :=low__rgb(255,255,255);

//.irootwin
irootwin:=isystem.nfullwin;
if irootwin.xhavehead then irootwin.xhead.setfocus else irootwin.setfocus;
//.sysprogram
sysprogram:=self;
end;
//## createfinish ##
procedure tbasicprg2.createfinish;
begin
try
low__showhelp(vihelp_show);//24jul2021
except;end;
end;
//## destroy ##
destructor tbasicprg2.destroy;
begin
try
if (self=sysprogram) then sysprogram:=nil;
freeobj(@isystem);
inherited destroy;
except;end;
end;
//## getsystem ##
function tbasicprg2.getsystem:tbasicsystem;
begin
try;result:=isystem;except;end;
end;
//## xstarttimer ##
procedure tbasicprg2.xstarttimer;
begin
try;isystem.ontimer:=__ontimer;except;end;
end;
//## __ontimer ##
procedure tbasicprg2.__ontimer(sender:tobject);
begin
//nil
end;

//## tobjectex #################################################################
//## create ##
constructor tobjectex.create;
begin
satinc(satObjectex,1);
zzadd(self);
inherited create;
end;
//## destroy ##
destructor tobjectex.destroy;
begin
inherited destroy;
satinc(satObjectex,-1);
//Note: zzdel() is fired during "freeobj()" - 04may2021
end;


{//was:
//## tbasicthreadstop ##########################################################
//## create ##
constructor tbasicthreadstop.create;
begin
satinc(satThread,1);
zzadd(self);
//self
ivcl_waiting   :=false;
istopping      :=false;
istopped       :=false;
idestroying    :=false;
inherited create(true);//create suspended
inherited freeonterminate:=false;
priority       :=tpNormal;
//m64
ims64init:=false;//ms64init;
ims64LAST:=0;//ms64LAST;
ims64OFFSET:=0;//ms64OFFSET;
//xcreate
xcreate;
//start
if suspended then resume;
end;
//## xcreate ##
procedure tbasicthreadstop.xcreate;
begin
//nil
end;
//## destroy ##
destructor tbasicthreadstop.destroy;
begin
try
if idestroying then exit else idestroying:=true;
xdestroy;
inherited destroy;
xdestroy2;
except;end;
try
zzdel(self);
satinc(satThread,-1);
except;end;
end;
//## xdestroy ##
procedure tbasicthreadstop.xdestroy;
begin
//nil
end;
//## xdestroy2 ##
procedure tbasicthreadstop.xdestroy2;
begin
//nil
end;
//## muststop ##
procedure tbasicthreadstop.muststop;
begin
try
if not istopping then
   begin
   istopping:=true;
   if suspended then inherited resume;
   end;
except;end;
end;
//## mustfree ##
procedure tbasicthreadstop.mustfree;
begin
try
imustfree:=true;
muststop;
except;end;
end;
//## m64 ##
function tbasicthreadstop.m64:comp;//64bit millisecond system timer, 01-SEP-2006
var//64bit system timer, replaces "gettickcount" with range of 49.7 days,
   //now with new range of 29,247 years.
   //Note: Must be called atleast once every 49.7 days, or it will loose track so
   //      system timer should call this routine regularly.
   i4:tint4;
   tmp:comp;
begin
try
//defaults
result:=0;
//get
//.get
i4.val:=gettickcount;
//INTEGER -> CURRENCY (0..4billion)
//#1
result:=i4.bytes[0];
//#2
tmp:=i4.bytes[1];
result:=result+(tmp*256);
//#3
tmp:=i4.bytes[2];
result:=result+(tmp*256*256);
//#4
tmp:=i4.bytes[3];
result:=result+(tmp*256*256*256);
//#5
if (not ims64init) then
   begin
   ims64OFFSET:=0;
   ims64LAST:=result;
   ims64init:=true;
   end;//end of if
//# thread safe - allow a large difference margin (10 minutes) so close calling
//# threads won't corrupt (increment falsely) the offset var.
if ((result+600000)<ims64LAST) then ims64OFFSET:=ims64OFFSET+ims64LAST;
//lastv
ims64LAST:=result;
//#6
result:=result+ims64OFFSET;
except;end;
end;
{}//xxxxxxxxxxxxxxxxxxxxxxxx//yyyyyyyyyyyyyyyy


//multimedia support -----------------------------------------------------------
{$ifdef mm}
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//rrrrrrrrrrrrrrrrrrrrrrrrrrrrr
//## mm_midi ##
function mm_midi:tbasicmidi;
begin
try
result:=mmsys_midi;
if zznil(result,4500) then
   begin
   mmsys_midi:=tbasicmidi.create;
   result:=mmsys_midi;
   end;
except;end;
end;
//## mm_chimes ##
function mm_chimes:tbasicchimes;
begin
try
result:=mmsys_chimes;
if zznil(result,4500) then
   begin
   mmsys_chimes:=tbasicchimes.create;
   result:=mmsys_chimes;
   end;
except;end;
end;
//## mm_wave ##
function mm_wave:taudiobasic;
begin
try
result:=mmsys_wave;
if zznil(result,4501) then
   begin
   mmsys_wave:=taudiobasic.create;
   result:=mmsys_wave;
   end;
except;end;
end;
//## mm_mm ##
function mm_mm:tmm;
begin
try
result:=mmsys_mm;
if zznil(result,4501) then
   begin
   mmsys_mm:=tmm.create;
   result:=mmsys_mm;
   end;
except;end;
end;
//## low__getvol ##
function low__getvol:longint;//0..100% - 29mar2021,07OCT2010
var//Note: Returns the lowest volume value from WAVE only, as under Win10 MIDI_MAPPER levels aren't adjusted by Volume Mixer whereas WAVE_MAPPER are - 30mar2021
   int1,v:longint;
   a:tint4;
   woc:twaveoutcaps;
   moc:tmidioutcaps;
   ok:boolean;
begin
try
//defaults
result:=0;
ok:=false;
v:=maxword;
a.val:=0;
//wave
if (waveoutgetdevcaps(wave_mapper,@woc,sizeof(woc))=MMSYSERR_NOERROR) and ((woc.dwSupport and WAVECAPS_VOLUME)=WAVECAPS_VOLUME) then
   begin
   ok:=true;
   waveOutGetVolume(wave_mapper,@int1);
   a.val:=int1;
   if ((woc.dwSupport and WAVECAPS_LRVOLUME)=WAVECAPS_LRVOLUME) then
      begin//stereo
      if (a.wrds[0]<v) then v:=a.wrds[0];//left
      if (a.wrds[1]<v) then v:=a.wrds[1];//right
      end
   else
      begin//mono -> one ch has volume other is zero
      v:=a.wrds[0]+a.wrds[1];
      end;
   end;

//midi
//Note: Can't use MIDI volume levels as a guide to system volume level as Win10 doesn't set them via Volume Mixer when the slider is shifted (midi can use multi-output cards) - 31mar2021
//      Do not use as of yet.
{
if (midioutgetdevcaps(midi_mapper,@moc,sizeof(moc))=MMSYSERR_NOERROR) and ((moc.dwSupport and MIDICAPS_VOLUME)=MIDICAPS_VOLUME) then
   begin
   ok:=true;
   midiOutGetVolume(midi_mapper,@int1);
   a.val:=int1;
   if ((woc.dwSupport and MIDICAPS_LRVOLUME)=MIDICAPS_LRVOLUME) then
      begin//stereo
      if (a.wrds[0]<v) then v:=a.wrds[0];//left
      if (a.wrds[1]<v) then v:=a.wrds[1];//right
      end
   else
      begin//mono -> one ch has volume other is zero
      v:=a.wrds[0]+a.wrds[1];
      end;
   end;
{}
//set
if ok then result:=frcrange(round((100*v)/maxword),0,100);//0..100%

//extend range
case viwine of
true:result:=mmsys_mid_basevol;//linux -> no separate midi/wave volume handler -> so we do it all - 23mar2022
false:if (result>=100) then result:=100+frcrange(mmsys_mid_basevol-100,0,100) else mmsys_mid_basevol:=100;//windows
end;//case

except;end;
end;
//## low__setvol ##
procedure low__setvol(x:longint);//0..100% - 29mar2021, 07OCT2010
var
   a:tint4;
   woc:twaveoutcaps;
   moc:tmidioutcaps;
   v,int1:longint;
begin
try
//range
case viwine of
true :mmsys_mid_basevol:=frcrange(x,  0,200);//linux
false:mmsys_mid_basevol:=frcrange(x,100,200);//windows
end;

a.wrds[0]:=frcrange(frcrange(x,0,100)*round(maxword/100),0,maxword);//left
a.wrds[1]:=a.wrds[0];//right
//wave
if (waveoutgetdevcaps(wave_mapper,@woc,sizeof(woc))=MMSYSERR_NOERROR) and ((woc.dwSupport and WAVECAPS_VOLUME)=WAVECAPS_VOLUME) then
   begin
   waveOutSetVolume(wave_mapper,a.val);
   end;
//midi
int1:=mid_deviceindex-1;
if (midioutgetdevcaps(int1,@moc,sizeof(moc))=MMSYSERR_NOERROR) and ((moc.dwSupport and MIDICAPS_VOLUME)=MIDICAPS_VOLUME) then
   begin
   midiOutSetVolume(int1,a.val);
   end;
except;end;
end;
//## to32bit ##
function to32bit(x:string):longint;//29AUG2007
var
   a:tint4;
   p:longint;
begin
try
//defaults
result:=0;
if (length(x)<4) then exit;
//get
a.bytes[0]:=ord(x[1]);
a.bytes[1]:=ord(x[2]);
a.bytes[2]:=ord(x[3]);
a.bytes[3]:=ord(x[4]);
//set
result:=a.val;
except;end;
end;
//## from32bit ##
function from32bit(x:longint):string;//29AUG2007
var
   a:tint4;
begin
try
//defaults
a.val:=x;
result:='####';
//set
result[1]:=char(a.bytes[0]);
result[2]:=char(a.bytes[1]);
result[3]:=char(a.bytes[2]);
result[4]:=char(a.bytes[3]);
except;end;
end;
//## midiOutOpen ##
function midiOutOpen(lphMidiOut:PHMIDIOUT; uDeviceID: UINT; dwCallback, dwInstance, dwFlags: DWORD): MMRESULT;
begin
try
result:=_midiOutOpen(lphMidiOut,uDeviceID,dwCallback,dwInstance,dwFlags);
if (result=0) then satinc(satMidiopen,1);
except;end;
end;
//## midiOutClose ##
function midiOutClose(hMidiOut: HMIDIOUT): MMRESULT;
begin
try
result:=_midiOutClose(hMidiOut);
if (result=0) then satinc(satMidiopen,-1);
except;end;
end;
//## midiOutShortMsg2 ##
function midiOutShortMsg2(hMidiOut:HMIDIOUT;xmsg,xval1,xval2,xval3:byte):MMRESULT;
var
   a:tint4;
begin
try
a.bytes[0]:=xmsg;
a.bytes[1]:=xval1;
a.bytes[2]:=xval2;
a.bytes[3]:=xval3;
result:=midiOutShortMsg(hMidiOut,a.val);
except;end;
end;
{
//## midiOutData2 ##
function midiOutData2(hMidiOut:HMIDIOUT;xdata:array of byte):boolean;
var
   a:tmidihdr;
   adata:array[0..999] of byte;
   p,alen:longint;
   xwait64:comp;
begin
try
//defaults
result:=false;
alen:=0;
//check
if (hMidiOut=0) or (low(xdata)<>0) then exit;
//fill
for p:=0 to frcmax(high(xdata),high(adata)) do
begin
adata[p]:=xdata[p];
alen:=p+1;
end;
//init
fillchar(a,sizeof(a),#0);
a.lpData:=@adata;
a.dwBufferLength:=alen;
a.dwFlags:=0;
if (0=midiOutPrepareHeader(hMidiOut,@a,sizeof(a))) then
   begin
   try
   if (0=midiOutLongMsg(hMidiOut,@a,sizeof(a))) then
      begin
      //wait
      xwait64:=ms64+30000;//wait max of 30 seconds
      while true do
      begin
      if (hMidiOut=0) or (ms64>=xwait64) or (MIDIERR_STILLPLAYING<>midiOutUnprepareHeader(hMidiOut,@a,sizeof(a))) then break;
      sleep(10);
      end;//loop
      end
   else midiOutUnprepareHeader(hMidiOut,@a,sizeof(a));
   //successful
   result:=true;
   except;end;
   end;
except;end;
end;
{
//## midioutflush ##
function midioutflush(xhandle:hmidiout;xstyle:longint):boolean;
begin
try
//get
case frcrange(xstyle,0,3) of
1:midiOutData2(xhandle,[$F0, $41, $10, $42, $12, $40, $00, $7F, $00, $41, $F7]);//GS_reset
2:midiOutData2(xhandle,[$F0, $43, $10, $4C, $00, $00, $7E, $00, $F7]);//XG_reset
3:midiOutData2(xhandle,[$F0, $7E, $7F, $09, $03, $F7]);//GM2_reset
else midiOutData2(xhandle,[$F0, $7E, $7F, $09, $01, $F7]);//GM_reset
end;
//-- reference -- 15apr2021
//  GM_Reset: array[1..6] of byte = ($F0, $7E, $7F, $09, $01, $F7); // = GM_On
//  GS_Reset: array[1..11] of byte = ($F0, $41, $10, $42, $12, $40, $00, $7F, $00, $41, $F7);
//  XG_Reset: array[1..9] of byte = ($F0, $43, $10, $4C, $00, $00, $7E, $00, $F7);
//  GM2_On: array[1..6] of byte = ($F0, $7E, $7F, $09, $03, $F7);  // = GM2_Reset
//  GM2_Off: array[1..6] of byte = ($F0, $7E, $7F, $09, $02, $F7); // switch to GS
//  GS_Off: array[1..11] of byte = ($F0, $41, $10, $42, $12, $40, $00, $7F, $7F, $42, $F7); // = Exit GS Mode
//  SysExMasterVolume: array[1..8] of byte = ($F0, $7F, $7F, $04, $01, $0, $0, $F7);
except;end;
end;
{}
//## midioutflush ##
function midioutflush(xhandle:hmidiout):boolean;
var//Note: Takes about 140ms to execute - 26may2021
   p,p2:byte;
   xcount:longint;
   //## xsend ##
   function xsend(xmsg,xval1,xval2,xval3:byte):boolean;
   begin
   try
   result:=(xhandle<>0) and (0=midiOutShortMsg2(xhandle,xmsg,xval1,xval2,xval3));
   inc(xcount);
   if (xcount>=1000) then
      begin
      xcount:=0;
      sleep(20);
      end;
   except;end;
   end;
begin
try
//defaults
result:=false;
xcount:=0;
//check
if (xhandle=0) then exit;

//controller messages
for p:=$b0 to $bf do
begin
//.main
xsend(p,123,0,0);//all sound off
xsend(p,120,0,0);//all sound off
xsend(p,121,0,0);//reset all controllers to their default states
//.msb
xsend(p,7,64,0);//channel volume
xsend(p,8,64,0);//balance
xsend(p,10,64,0);//pan
//.lsb
xsend(p,39,64,0);//channel volume
xsend(p,40,64,0);//balance
xsend(p,42,64,0);//pan
//.switches
xsend(p,64,0,0);//Sustain On/Off
xsend(p,65,0,0);//Portamento On/Off
xsend(p,66,0,0);//Sostenuto On/Off
xsend(p,67,0,0);//Soft Pedal On/Off
xsend(p,68,0,0);//Legato On/Off
xsend(p,69,0,0);//Hold 2 On/Off
end;//p

//instruments
for p:=$c0 to $cf do
begin
xsend(p,0,0,0);//voice or instrument
end;
{}

//successful
result:=true;
except;end;
end;
{}//xxxxxxxxxxx

//-- Low level midi note storage procs for use with "tstr8" - 14feb2021 --------------------------------
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//mmmmmmmmmmmmmmmmmmmmmmm
//## low__makemid ##
function low__makemid(x:string;var xdata:tstr8;var e:string):boolean;//make a simple, single track midi - 15nov2022, 16mar2022
label//Example usage:  "0i14 50n98 150n99 200n97 180n96 100n94 200n94 200n94 100n96 100n96 100n96 100n96 100n96 100n96 1000e 200n80 200n90 100n80 100n90 200n80 200n90" or "0i14 0n90 1000e0" or "0i14 0s-10 0n90 1000e0"
   skipend;
const
   xtempo_ms=500;
var
   a:twrd2;
   b:tint4;
   xnotes:array[0..127] of longint;
   xdelayshift,xnoteshift,dtracklen,xBPM,i,p,xlen,lp2,lp,xpos,xvol,xtime:longint;
   n:char;
   t,v,vbig,vint:longint;
   bol1,xonce:boolean;
   //## xnext ##
   function xnext:boolean;
   label
      redo,skipone,skipend;
   var
      a:longint;
   begin
   try
   //defaults
   result:=false;
   t:=0;
   n:='?';
   v:=0;
   vbig:=0;
   vint:=0;
   lp2:=lp;
   //get
   redo:
   a:=ord(x[xpos-1+stroffset]);
   if (a>=33) and ((a<48) or (a>57)) and (a<>45) then lp2:=xpos;
   if (a=10) or (a=13) or (a=32) or (a=44) then
      begin
      if (lp=lp2) then
         begin
         lp:=xpos+1;
         lp2:=lp;
         goto skipone;
         end;
      //get
      t:=frcmin(strint(strcopy1(x,lp,lp2-lp)),0);
      n:=strcopy1(x+'?',lp2,1)[1];
      v:=frcrange(strint(strcopy1(x,lp2+1,xpos-lp2-1)),0,127);
      vbig:=frcmin(strint(strcopy1(x,lp2+1,xpos-lp2-1)),0);
      vint:=strint(strcopy1(x,lp2+1,xpos-lp2-1));//15nov2022
      //reset
      inc(xpos);
      lp:=xpos;
      lp2:=lp;
      result:=true;
      goto skipend;
      end;
   //.loop
   skipone:
   inc(xpos);
   if (xpos<=xlen) then goto redo;
   skipend:
   except;end;
   end;
   //## tadd ##
   procedure tadd(xms:longint);//adds delta tick delay
   var
      v1,v2,v3,v4,xticks:longint;
   begin
   try
   //range
   if (xms>=1) and (xdelayshift<>0) then inc(xms,round(xms*(xdelayshift/100)));//15nov2022
   xms:=frcrange(xms,0,30000);
   //convert
   xticks:=trunc((xms*xBPM)/xtempo_ms);
   //get
   //.v1
   v1:=xticks div (128*128*128);
   dec(xticks,v1*(128*128*128));
   //.v2
   v2:=xticks div (128*128);
   dec(xticks,v2*(128*128));
   //.v3
   v3:=xticks div 128;
   dec(xticks,v3*128);
   //.v4
   v4:=xticks;
   //set
   //.4b var-len
   if (v1>=1) then
      begin
      xdata.addbyt1(v1+128);//the 128 is to mark this as PART of the variable length number, only the last byte falls in the range 0..127 (never 128+)
      xdata.addbyt1(v2+128);
      xdata.addbyt1(v3+128);
      xdata.addbyt1(v4);
      end
   //.3b var-len
   else if (v2>=1) then
      begin
      xdata.addbyt1(v2+128);
      xdata.addbyt1(v3+128);
      xdata.addbyt1(v4);
      end
   //.2b var-len
   else if (v3>=1) then
      begin
      xdata.addbyt1(v3+128);
      xdata.addbyt1(v4);
      end
   //.1b var-len
   else
      begin
      xdata.addbyt1(v4);
      end;
   except;end;
   end;
   //## iadd ##
   procedure iadd(xinstrument:longint);
   begin
   //range
   xinstrument:=frcrange(xinstrument,0,127);
   //get
   tadd(t);
   xdata.aadd([$C0,byte(xinstrument)]);
   end;
   //## nadd ##
   procedure nadd(xnote,xvol:longint);
   begin
   //range
   xnote:=frcrange(xnote,0,127);
   xvol :=frcrange(xvol ,0,127);
   //get
   tadd(t);
   case (xvol>=1) of
   true:xdata.aadd([$90,byte(xnote),byte(xvol)]);//note on
//   false:xdata.aadd([$90,byte(xnote),0]);//note off
   false:xdata.aadd([$80,byte(xnote),64]);//note off
   end;//case
   end;
   //## vadd ##
   procedure vadd(xvol:longint);
   begin
   //range
   xvol :=frcrange(xvol ,0,127);
   //get
   tadd(t);
   xdata.aadd([$B0,$07,byte(xvol)]);//channel volume
   end;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
if not block(xdata) then exit;
//init
xnoteshift:=0;
xdelayshift:=0;
xBPM:=1000;//120;
xdata.clear;
for p:=0 to high(xnotes) do xnotes[p]:=0;
xvol:=127;
xtime:=0;
xpos:=1;
lp:=1;
lp2:=1;
if (x<>'') then x:=x+#10;//enforce trailing return code
xlen:=length(x);
xonce:=true;
//check
if (xlen<=0) then goto skipend;

//get
xdata.aadd([uuM,uuT,llh,lld]);
xdata.aadd([0,0,0,6]);
xdata.aadd([0,0]);//format 0 - single track
xdata.aadd([0,1]);//track count = 1
a.val:=xBPM;
xdata.aadd([a.bytes[1],a.bytes[0]]);//timeDiv
xdata.aadd([uuM,uuT,llr,llk]);//start track
xdata.aadd([0,0,0,0]);//track length - fill with proper value later - 16mar2022
dtracklen:=xdata.len;//remember where to write track length

while true do
begin
//.next
if not xnext then break;

//.instrument
if (n='i') then
   begin
   iadd(v);
   if xonce then vadd(xvol);//full volume
   end
//.volume
else if (n='v') then xvol:=frcrange(v,0,127)
//.note shift up/down
else if (n='s') then
   begin
   xnoteshift:=frcrange(vint,-127,127);
   t:=0;
   end
//.delay shift up/down
else if (n='f') then
   begin
   xdelayshift:=vint;//percentage to increase or decrease timing delay by, 0=off, 100=add 100% more delay, -100=take away all delay
   t:=0;
   end
//.note on/off
else if (n='n') then
   begin
   v:=frcrange(v+xnoteshift,0,127);//15nov2022
   xnotes[v]:=xvol;
   nadd(v,xvol);//note on OR off
   end
//.note off
else if (n='x') then
   begin
   v:=frcrange(v+xnoteshift,0,127);//15nov2022
   xnotes[v]:=0;
   nadd(v,0);//note off
   end
//.fade down to zero
else if (n='d') then
   begin
   vbig:=frcmin(vbig,5);
   for i:=20 downto 0 do
   begin
   t:=frcmin(round(vbig/20),1);
   vadd(round(127*(i/20)));//on
   end;//i
   end
//.fade up from zero
else if (n='u') then
   begin
   vbig:=frcmin(vbig,5);
   for i:=0 to 20 do
   begin
   t:=frcmin(round(vbig/20),1);
   vadd(round(127*(i/20)));//on
   end;//i
   end
//.end
else if (n='e') then break;
end;
//.finalise -> turn off all active notes
for p:=0 to high(xnotes) do
begin
if (xnotes[p]>=1) then
   begin
//   nadd(p,1);
   nadd(p,0);//note off
   t:=0;//only require the time delay for the 1st note, all the others follow on immedately afterwards - 16mar2022
   end;
end;//p
//.write "end of track"
tadd(t);
xdata.aadd([$FF,$2F,$00]);

//successful
result:=true;
skipend:

//.write track len back into track header - 16mar2022
if ((xdata.len-dtracklen)>=1) then
   begin
   b.val:=xdata.len-dtracklen;
   xdata.byt1[dtracklen-4]:=b.bytes[3];
   xdata.byt1[dtracklen-3]:=b.bytes[2];
   xdata.byt1[dtracklen-2]:=b.bytes[1];
   xdata.byt1[dtracklen-1]:=b.bytes[0];
   end;
except;end;
try;bunlockautofree(xdata);except;end;
end;
//## low__txttomid ##
function low__txttomid(x,xtext:tstr8;var e:string):boolean;
label
   skipend;
const
   maxms=999999999;
   maxtick=(127*128*128*128) + (127*128*128) + (127*128) + 127;
   xtickrate=120;//120 beats per minute
   xtempo=500000;//default tempo is 500K uSEC
   xtempo_ms=500;
   //modes
   mnoteon=0;
   mnoteoff=1;
   mchannel=2;
   mvelocity=3;
   mdelay=4;
   mtrack=5;//optional
var
   a,aoutdata:tstr8;
   aout:array[0..255] of tstr8;
   aouttime:array[0..255] of longint;//reference only
   xtotaltime,xtrackcount,alen,p,xmode,xchannel,xvelocity,xdelay,xtrack:longint;
   byt1:byte;
   dval:array[0..19] of longint;//stores digits of a number e.g. "127" in order into the array to be constructed into a 32bit number once all digits have been read in - 18feb2021
   dcount:longint;
   //## ainit2 ##
   procedure ainit2(xtrack:longint);
   begin//Note: "xtrack" is internal var, not current track - 18feb2021
   xtrack:=frcrange(xtrack,0,high(aout));
   if zznil(aout[xtrack],4501) then aout[xtrack]:=bnew;
   end;
   //## ainit ##
   procedure ainit;
   begin
   ainit2(xtrack);
   end;
   //## xdef ##
   procedure xdef;
   begin
   xmode:=mnoteon;
   xchannel:=0;
   xvelocity:=64;
   xdelay:=0;
   xtrack:=0;//0..255
   dcount:=0;
   end;
   //## xadddelta ##
   procedure xadddelta(xtrack,xms:longint);
   var//Note: assumes "xtickrate" 96 ticks per quarter note (or 384 ticks / second / 1,000 ms)
      v1,v2,v3,v4,xticks:longint;
   begin
   try
   //range
   xtrack:=frcrange(xtrack,0,high(aout));
   xms:=frcrange(xms,0,maxms);
   //aouttime
   inc(aouttime[xtrack],xms);
   //convert
   //xticks:=frcrange(round((xms/250)*xtickrate),0,maxtick);

   xticks:=trunc((xms*xtickrate)/frcmin(xtempo_ms,1));
   //get
   //.v1
   v1:=xticks div (128*128*128);
   dec(xticks,v1*(128*128*128));
   //.v2
   v2:=xticks div (128*128);
   dec(xticks,v2*(128*128));
   //.v3
   v3:=xticks div 128;
   dec(xticks,v3*128);
   //.v4
   v4:=xticks;
   //set
   //.4b var-len
   if (v1>=1) then
      begin
      ainit2(xtrack);
      aout[xtrack].addbyt1(v1+128);//the 128 is to mark this as PART of the variable length number, only the last byte falls in the range 0..127 (never 128+)
      aout[xtrack].addbyt1(v2+128);
      aout[xtrack].addbyt1(v3+128);
      aout[xtrack].addbyt1(v4);
      end
   //.3b var-len
   else if (v2>=1) then
      begin
      ainit2(xtrack);
      aout[xtrack].addbyt1(v2+128);
      aout[xtrack].addbyt1(v3+128);
      aout[xtrack].addbyt1(v4);
      end
   //.2b var-len
   else if (v3>=1) then
      begin
      ainit2(xtrack);
      aout[xtrack].addbyt1(v3+128);
      aout[xtrack].addbyt1(v4);
      end
   //.1b var-len
   else
      begin
      ainit2(xtrack);
      aout[xtrack].addbyt1(v4);
      end;
   except;end;
   end;
   //## xuseval ##
   procedure xuseval;//if there is a value in the "dval" list then build it into a 32bit number and apply it to the current mode
   var
      xnote,vmultiplier,v,dc,p:longint;
   begin
   try
   //check
   if (dcount<=0) then exit;
   //get
   v:=0;
   vmultiplier:=1;
   dc:=0;
   for p:=(dcount-1) downto 0 do//read from right-to-left to convert into decimal, a maximum of 9 digits to be read so it never exceeds the 32bit number limit, e.g. largest number is "999,999,999"
   begin
   inc(v,dval[p]*vmultiplier);
   vmultiplier:=vmultiplier*10;//1 -> 10, 100, 1000, 10000, etc
   inc(dc);
   if (dc>=9) then break;//stop at this point -> else number MAY end up exceeding 32bit range of 2,100,000,000
   end;//p
   //set
   case xmode of
   mnoteon:begin//note on -> 3 bytes "9n note velocity"
      v:=frcrange(v,0,127);
      ainit;
      xadddelta(xtrack,xdelay);//ms -> var-len delta ticks
      aout[xtrack].addbyt1($90+xchannel);//note on + channel -> $90..$9F (ch0..15)
      aout[xtrack].addbyt1(v);//note: 0..127
      aout[xtrack].addbyt1(xvelocity);//default for equipment withou velocity sensors is 64, and ZERO (0) has special "note off" meaning for running status - 18feb2021
      end;
   mnoteoff:begin//note off -> 3 bytes "9n note velocity"
      v:=frcrange(v,0,127);
      ainit;
      xadddelta(xtrack,xdelay);//ms -> var-len delta ticks
      aout[xtrack].addbyt1($80+xchannel);//note on + channel -> $90..$9F (ch0..15)
      aout[xtrack].addbyt1(v);//note: 0..127
      aout[xtrack].addbyt1(xvelocity);//default for equipment withou velocity sensors is 64
      end;
   mchannel:xchannel:=frcrange(v,0,15);
   mvelocity:xvelocity:=frcrange(v,0,127);
   mdelay:xdelay:=frcrange(v,0,maxms);
   mtrack:xtrack:=frcrange(v,0,high(aout));
   end;
   //clear
   dcount:=0;
   except;end;
   end;
   //## xsetmode ##
   procedure xsetmode(x:byte);
   begin
   xuseval;
   xmode:=x;
   dcount:=0;
   end;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
a:=nil;
for p:=0 to high(aout) do
begin
aout[p]:=nil;
aouttime[p]:=0;
end;//p
aoutdata:=nil;
xtotaltime:=0;
//lock
block(x);
block(xtext);

//check
if zznil(x,4012) or zznil(xtext,4013) then goto skipend;

//init
a:=bnew;
aoutdata:=bnew;
x.clear;
alen:=xtext.len;
if (alen<=0) then goto skipend;

//filter
for p:=0 to (alen-1) do
begin
byt1:=xtext.byt1[p];
case byt1 of
lln,llo,llc,llv,lld,llt,nn0..nn9,ssDot,ssSpace:a.addbyt1(byt1);
uuN,uuO,uuC,uuV,uuD,uuT:a.addbyt1(byt1+vvUppertolower);//convert uppercase to lowercase
end;//case
end;
alen:=a.len;
if (alen<=0) then goto skipend;

//get
xdef;
for p:=0 to (alen-1) do
begin
byt1:=a.byt1[p];
case byt1 of
lln:xsetmode(mnoteon);//note on
llo:xsetmode(mnoteoff);//note off
llc:xsetmode(mchannel);//channel
llv:xsetmode(mvelocity);//velocity
lld:xsetmode(mdelay);//delay
llt:xsetmode(mtrack);//track
nn0..nn9:begin//value
   if (dcount<=high(dval)) then
      begin
      dval[dcount]:=byt1-nn0;//0..9
      inc(dcount);
      end;
   end;
ssSpace:xuseval;
ssDot:begin//end of midi
   xuseval;
   break;
   end;
end;//case
end;//p
//.finalise
xuseval;

//set - build midi file
//.write tracks
xtrackcount:=0;
for p:=0 to high(aout) do if zzok(aout[p],4502) and (aout[p].len>=1) then
   begin
   inc(xtrackcount);
   //time - reference only
   if (aouttime[p]>xtotaltime) then xtotaltime:=aouttime[p];
   //insert EOT -> end of track -> <delatticks> + "FF 2F 00" -> uses current delay so notes can finishing playing if track hasn't been finished off properly - 18feb2021
   xadddelta(p,xdelay);
   aout[p].addbyt1($FF);
   aout[p].addbyt1($2F);
   aout[p].addbyt1($00);
   //track header
   aoutdata.aadd([uuM,uuT,llr,llk]);
   //track length
   aoutdata.addint4R(aout[p].len);
   //track data
   aoutdata.add(aout[p]);
   end;
//.write midi header
x.aadd([uuM,uuT,llh,lld]);
//.32bit number check.4R
x.addint4R(6);
//.write formattype.2R + trackcount.2R + tickrate.2R
x.addwrd2R(low__insint(1,xtrackcount>=2));//0=single track, 1=multi-track, 2=we don't support
x.addwrd2R(xtrackcount);
x.addwrd2R(xtickrate);//for us we use ticks always for simplicity
//.write all tracks data
x.add(aoutdata);
//successful
result:=true;
skipend:
except;end;
try;if (not result) and zzok(x,4503) then x.clear;except;end;
try
bfree(a);
bfree(aoutdata);
for p:=0 to high(aout) do bfree(aout[p]);
bunlockautofree(x);
bunlockautofree(xtext);
except;end;
end;
//## low__midcount ##
function low__midcount(x:tstr8):longint;
begin
try
result:=0;
if zzok(x,4504) then result:=x.len div 12;
except;end;
try;if (x<>nil) then bautofreeb(x);except;end;
end;
//## low__midbytes ##
function low__midbytes(x:tstr8):longint;
begin
try
result:=0;
if zzok(x,4505) then result:=x.len;
except;end;
try;if (x<>nil) then bautofreeb(x);except;end;
end;
//## low__midtime ##
function low__midtime(x:tstr8):longint;
var
   i:longint;
   xmsg,xval1,xval2,xval3:byte;
   xtimeuSEC:comp;
begin
try
result:=0;
if block(x) then
   begin
   i:=low__midcount(x);
   if (i>=1) then
      begin
      low__midget(x,i-1,xtimeuSEC,xmsg,xval1,xval2,xval3);
      //was:   result:=trunc(xtimeuSEC/1000.0);
      result:=low__div32(xtimeuSEC,1000);
      end;
   end;
except;end;
try;bunlockautofree(x);except;end;
end;
//## low__midget ##
function low__midget(x:tstr8;xindex:longint;var xtimeuSEC:comp;var xmsg,xval1,xval2,xval3:byte):boolean;
var
   xpos:longint;
   a:tint4;
begin
try
//defaults
result:=false;
xtimeuSEC:=0;
xmsg :=0;
xval1:=0;
xval2:=0;
xval3:=0;
//init
if (xindex<0) then xpos:=0 else xpos:=xindex*12;
//get
if zzok(x,4506) and (xpos>=0) and ((xpos+11)<x.len) then
   begin
   xtimeuSEC:=x.cmp8[xpos+0];
   a.val:=x.int4[xpos+8];
   xmsg :=a.bytes[0];
   xval1:=a.bytes[1];
   xval2:=a.bytes[2];
   xval3:=a.bytes[3];
   result:=true;
   end;
except;end;
try;if (x<>nil) then bautofreeb(x);except;end;
end;
//## low__midset ##
function low__midset(x:tstr8;xindex:longint;xtimeuSEC:comp;xmsg,xval1,xval2,xval3:byte):boolean;
var
   xpos:longint;
   a:tint4;
begin
try
//defaults
result:=false;
//init
if (xindex<0) then xpos:=0 else xpos:=xindex*12;
//get
if zzok(x,4507) then
   begin
   //init
   a.bytes[0]:=xmsg;
   a.bytes[1]:=xval1;
   a.bytes[2]:=xval2;
   a.bytes[3]:=xval3;
   //get
   x.cmp8[xpos+0]:=xtimeuSEC;
   x.int4[xpos+8]:=a.val;
   result:=true;
   end;
except;end;
try;if (x<>nil) then bautofreeb(x);except;end;
end;
//## low__midadd ##
function low__midadd(x:tstr8;xtimeuSEC:comp;xmsg,xval1,xval2,xval3:byte):boolean;
begin
try;result:=low__midset(x,low__midcount(x),xtimeuSEC,xmsg,xval1,xval2,xval3);except;end;
end;

//## tbasicmidi ################################################################
//xxxxxxxxxxxxxxxxxxxxxxxxxxxx//mmmmmmmmmmmmmmmmmmmmmmmmmm
//## mmsys__simpletimer__proc ##
function mmsys__simpletimer__proc(lpParam:pointer):dword; stdcall;
label
   skipend;
var
   msg:tmsg;
   msgreturn:longbool;
   xusetimer,xmuststop,xusertimerEnabled:boolean;
   xslowcls64,xref64:comp;
   xslowcount,xinterval,int1,xslot:longint;
   str1:string;
   //## xevent ##
   procedure xevent;
   begin
   //.lag tracker
   systhread__synclag(xslot,timeGettime);
   //.need to reply to an external "push" request - 08oct2021
   if systhread__mustreply(xslot,int1,str1) then
      begin
      xusertimerEnabled:=(int1<>0);
      systhread__reply(xslot,1,'Done');
      end;
   //.timer event
   if xusertimerEnabled then
      begin
      //debug: if (debug_junk3<maxint) then inc(debug_junk3) else debug_junk3:=0;//xxxxxxxxxxxxxxxxxxx
      if (mmsys_midi<>nil) then mmsys_midi.threadtimer(nil);
      end;
   //.throttle back to a slower mode WHEN not using FAST - 05mar2022
   if not systhread__fast(xslot) then sleep(100);
   end;
begin
try
//slot
xslot:=longint(lpparam);
//wait for thread start signal
while true do
begin
if systhread_ready[xslot] then break;
sleep(10);
end;

//init
xmuststop:=false;
xusetimer:=systhread_usingtimer[xslot];
xinterval:=frcmin(systhread_timerms[xslot],1);
SetThreadPriority(systhread_handle[xslot], THREAD_PRIORITY_TIME_CRITICAL);//this thread is full speed
xusertimerEnabled:=true;
xref64:=0;
xslowcls64:=0;
xslowcount:=0;
timeBeginPeriod(frcmax(2*xinterval,30));//fast GLOBAL OS based timer - apply
//excute thread code
repeat
if xusetimer then
   begin
   msgreturn:=getmessage(msg,0,0,0);
   if (msg.message=WM_MULTIMEDIA_TIMER) then xevent;
   //.windows messages
   translateMessage(msg);
   dispatchMessage(msg);
   //.check interval stability - 05mar2022
   if (xref64<>0) and xusertimerEnabled and systhread__fast(xslot) then
      begin
      if (ms64FAST>=xref64) and (xslowcount<maxint) then
         begin
         inc(xslowcount,1);
         if (ms64FAST>=xslowcls64) then
            begin
            xslowcount:=0;
            xslowcls64:=ms64FAST+10000
            end;
         if (xslowcount>=50) then//50 timing failures in 10sec period before switching over to sleep.timer instead - 05mar2022
            begin
            xusetimer:=false;
            systhread__stoptimer(xslot);
//            setthreadpriority(systhread_handle[xslot],THREAD_PRIORITY_TIME_CRITICAL);//Correct as of 05mar2022
            end;
         end;
      end;
   //.ref64
   if (xinterval<=5) then xref64:=low__add64(ms64FAST,xinterval+10);
   end
else
   begin
   sleep(xinterval);
   xevent;
   end;
until (xusetimer and (longint(msgreturn)<=0)) or xmuststop or systhread_muststop[xslot];

//done
skipend:
except;end;
try
//fast GLOBAL OS based timer - release
timeEndPeriod(frcmax(2*xinterval,30));//fast GLOBAL OS based timer - apply
//delete timer
systhread__stoptimer(xslot);
//thread is finished
systhread_running[xslot]:=false;
result:=0;
exitthread(0);
except;end;
end;
//## create ##
constructor tbasicmidi.create;
var
   p:longint;
begin
try
//self
inherited create;
//internal
oautostop      :=false;//22feb2022
ithreadtimerbusy:=false;
itimereventbusy:=false;
ithreadignore  :=false;
ipdobusy       :=false;
iresetvol      :=0;
ilag           :=0;
ilastlag       :=0;
ilagref        :=0;
iref1000       :=0;
isysthreadSLOT :=-1;
itimer100      :=ms64;
itimer500      :=ms64;
imustplaydata  :=false;
imustplayfile  :=false;
ivol           :=100;
ivol2          :=100;//03mar2022
inewvol        :=-1;//off - 03mar2022
inewvol2       :=-1;//off
ichangedidB    :=0;
iphandle       :=0;
ipos64         :=ms64FAST;//high speed millisecond counter
ipos           :=0;
ilen           :=0;
ibytes         :=0;//memory in use
imidbytes      :=0;//size of mid file
imidformat     :=0;
imidtracks     :=0;
imustopen      :=0;
imuststop      :=false;
imustplay      :=false;
iplaying       :=false;
inewstyle      :=-1;
inewpos        :=-1;
inewpertpos    :=-1;
inewspeed      :=-1;
inewspeed2     :=-1;
inewdeviceindex:=-1;//off
ideviceindex   :=0;//midi mapper -> midi inside a thread show no volumne control!!!!!!!
idisablenotes  :=false;
ikeepopen      :=false;
iloop          :=false;
ispeed         :=100;//100=normal speed
ispeed2        :=100;//100=normal speed - an internal/behind the scenes version that works in tandum with "speed"
ilastspeed     :=ispeed;
ilastspeed2    :=ispeed2;
istyle         :=0;//GM
iid            :=0;
ilastid        :=-1;
iopenref       :=ms64;
for p:=0 to high(ilistdata) do ilistdata[p]:=nil;
ilyrics        :=bnew;//24feb2022
ilyricsref     :=bnew;
flush;
//external init
idata         :=bnew;//used for delayed "open" caching of user midi data
idata2        :=bnew;//used for delayed "open" caching of user midi data
ifilename     :='';
//timer
low__timerset(self,__ontimer,20);//faster response time - 16mar2022
//safe thread system - 19feb2022
systhread__start(@mmsys__simpletimer__proc,1,ms64FAST,isysthreadSLOT);//now pure realtime mode for process and thread - 25mar2022, 19feb2022, 16oct2021
//was: systhread__start(@mmsys__simpletimer__proc,1,isysthreadSLOT);//19feb2022, 16oct2021
//was: systhread__start(@mmsys__simpletimer__proc,0,isysthreadSLOT);//19feb2022, 16oct2021
except;end;
end;
//## destroy ##
destructor tbasicmidi.destroy;//02mar2022
var
   p:longint;
begin
try
//disconnect thread - 02mar2022
systhread__stop(isysthreadSLOT);
//timer
low__timerdel(self,__ontimer);//disconnect our timer event from the system timer
//vars
iplaying:=false;
resetvols;
ilen:=0;
close;
//was here: systhread__stop(isysthreadSLOT);
//controls
for p:=0 to high(ilistdata) do freeobj(@ilistdata[p]);
bfree(ilyrics);//24feb2022
bfree(ilyricsref);
bfree(idata);
bfree(idata2);
//satinc(satMidi,-1);
//self
inherited destroy;
except;end;
end;
//## usingtimer ##
function tbasicmidi.usingtimer:boolean;
begin
try;result:=systhread_usingtimer[isysthreadSLOT];except;end;
end;
//## resetlag ##
procedure tbasicmidi.resetlag;
begin
try
ilagref:=0;
ilastlag:=0;
ilag:=0;
except;end;
end;
//## synclag ##
procedure tbasicmidi.synclag;
var
   tmp64,xms64:comp;
begin
try
xms64:=ms64FAST;
if (ilagref=0) then tmp64:=0 else tmp64:=xms64-ilagref;
if (tmp64>ilastlag) then ilastlag:=tmp64;
ilagref:=xms64;
if (xms64>=iref1000) then
   begin
   iref1000:=xms64+1000;
   ilag:=ilastlag;
   ilastlag:=0;
   end;
except;end;
end;
//## setvol ##
procedure tbasicmidi.setvol(x:longint);
begin
try;inewvol:=frcrange(x,0,200);except;end;
end;
//## setvol2 ##
procedure tbasicmidi.setvol2(x:longint);
begin
try;inewvol2:=frcrange(x,0,200);except;end;
end;
//## setspeed ##
procedure tbasicmidi.setspeed(x:longint);
begin
try;inewspeed:=frcrange(x,10,1000);except;end;
end;
//## setspeed2 ##
procedure tbasicmidi.setspeed2(x:longint);
begin
try;inewspeed2:=frcrange(x,10,1000);except;end;
end;
//## setstyle ##
procedure tbasicmidi.setstyle(x:longint);
begin
try;inewstyle:=frcrange(x,0,3);except;end;
end;
//## setdeviceindex ##
procedure tbasicmidi.setdeviceindex(x:longint);
begin//0=midi_mapper, 1=device #0, 2=device #1
try;inewdeviceindex:=frcrange(x,0,1025);except;end;
end;
//## getpos ##
function tbasicmidi.getpos:longint;
begin
try;result:=frcrange(ipos,0,ilen);except;end;
end;
//## getpertpos ##
function tbasicmidi.getpertpos:double;
begin
try;result:=low__makepertD0(ipos,ilen);except;end;
end;
//## __ontimer ##
procedure tbasicmidi.__ontimer(sender:tobject);
begin
try;__ontimerevent(sender,false);except;end;
end;
//## threadtimer ##
procedure tbasicmidi.threadtimer(sender:tobject);
begin
try
//check
if ithreadtimerbusy then exit else ithreadtimerbusy:=true;
//play notes
if iplaying then
   begin
   //was: moretime; <- not thread safe, uses ms64 instead of ms64FAST - 21feb2022
   syncpos;//required
   pdo;//2(true);
   end;
except;end;
try;ithreadtimerbusy:=false;except;end;
end;
//## __ontimerevent ##
procedure tbasicmidi.__ontimerevent(sender:tobject;xfast:boolean);//._ontimer
label
   skipend,redo;
var
   str1,e:string;
   p,int1,int2,int3:longint;
   bol1:boolean;
   //## xpause ##
   procedure xpause;//special note: stops the high-speed timer from playing notes permitting a gentle note reset/volume reset/open etc - 21feb2022
   var
      int1:longint;
      str1:string;
   begin
   //check - already locked
   if ithreadignore then exit else ithreadignore:=true;
   //make thread wait
   systhread__push(isysthreadSLOT,0,'',int1,str1);
   end;
begin
try
//lock
if itimereventbusy then exit else itimereventbusy:=true;


//slow -------------------------------------------------------------------------
//.itimer100
if (ms64>itimer100) then
   begin
   //iresetvol
   if (iresetvol<100) then iresetvol:=frcrange(iresetvol+25,0,100);

   //external support
   if imustplayfile then
      begin
      imustplayfile:=false;
      //open
      xpause;
      moretime;
      if not low__fromfile(ifilename,idata,e) then idata.clear;
      xplaydata;
      //play
      moretime;
      setpos(0);
      syncpos;
      restart;//does a "xresetvols"
//      iresetvol:=100;//start at full power at beginning of track - 22feb2022
      moretime;
      imustplay:=true;
      imustopen:=0;//do AFTER xopen has fired -> syncs with "canopen" and "open()" procs - 14feb2021
      //realtime support - 25mar2022
      app__realtime;
      end;

   //external support
   if imustplaydata then
      begin
      imustplaydata:=false;
      //open
      xpause;
      moretime;
      //.idata2 -> idata
      idata.clear;
      idata.add(idata2);
      idata2.clear;
      xplaydata;
      //play
      moretime;
      setpos(0);
      syncpos;
      restart;//does a "xresetvols"
//      iresetvol:=100;//start at full power at beginning of track - 22feb2022
      moretime;
      imustplay:=true;
      imustopen:=0;//do AFTER xopen has fired -> syncs with "canopen" and "open()" procs - 14feb2021
      //realtime support - 25mar2022
      app__realtime;
      end;

   //inc pos
   if iplaying and (ilen>=1) and canclose then
      begin
      syncpos;
      end;

   //! Important ! -> Open midi stream only when we have a "thread.synchonized" timer event,
   //                 all thread.non-synchronized timer events only read tstr8 data and thus do
   //                 not need to sync critical pointer/object data and handles with the
   //                 system or our debug tracking system when processing new data or resizing
   //                 existing data - 06may2021
   //mustopen
   if (imustopen>=2) then
      begin
      xpause;
      moretime;
      xplaydata;
      setpos(0);
      syncpos;
      restart;//does a "xresetvols"
      moretime;
      case imustopen of
      2:;//open only
      3:imustplay:=true;
      end;//case
      imustopen:=0;//do AFTER xopen has fired -> syncs with "canopen" and "open()" procs - 14feb2021
      //realtime support - 25mar2022
      app__realtime;
      end;

   //newspeed
   if (inewspeed>=0) or (inewspeed2>=0) then
      begin
      xpause;
      int1:=ipos;
      if (inewspeed>=0)  then int2:=frcrange(inewspeed ,10,1000) else int2:=ispeed;
      if (inewspeed2>=0) then int3:=frcrange(inewspeed2,10,1000) else int3:=ispeed2;//03mar2022
      inewspeed:=-1;//off
      inewspeed2:=-1;//off
      if (ispeed<>int2) or (ispeed2<>int3) then
         begin
         ispeed:=int2;
         ispeed2:=int3;
         setpos(frcrange(int1,0,ilen));
         syncpos;
         restart;
         end;
      end;

   //newpertpos - 06mar2022
   if (inewpertpos>=0) then
      begin
      inewpos:=frcrange(round(ilen*inewpertpos) div 100,0,frcmin(ilen-1,0));
      inewpertpos:=-1;//off
      end;

   //newpos
   if (inewpos>=0) or (inewstyle>=0) or (inewdeviceindex>=0) then
      begin
      //init
      xpause;
      bol1:=false;
      //pos
      int1:=inewpos;
      inewpos:=-1;//off
      if (int1>=0) and (ipos<>int1) then
         begin
         setpos(frcrange(int1,0,ilen));
         syncpos;
         bol1:=true;
         end;
      //style
      int1:=inewstyle;
      inewstyle:=-1;
      if (int1>=0) and (istyle<>int1) then
         begin
         istyle:=int1;
         bol1:=true;
         end;
      //deviceindex
      int1:=inewdeviceindex;
      inewdeviceindex:=-1;//off
      if (int1>=0) and (ideviceindex<>int1) then
         begin
         ideviceindex:=int1;
         if canclose then close;
         autoopen;
         setpos(frcrange(ipos,0,ilen));//tell system to cycle through to this point - 18apr2021
         bol1:=true;
         end;
      //restart
      if bol1 then
         begin
         restart;
         end;
      end;

   //muststop
   if imuststop then
      begin
      xpause;
      imuststop:=false;
      iplaying:=false;
      resetvols;
      end;

   //mustplay
   if imustplay then
      begin
      xpause;
      imustplay:=false;
      iplaying:=true;
      moretime;
      autoopen;
      setpos(frcrange(ipos,0,ilen));
      restart;
      end;

   //newvol - 03mar2022
   if (inewvol>=0) then
      begin
      ivol:=frcrange(inewvol,0,200);
      inewvol:=-1;
      end;

   //newvol2 - 03mar2022
   if (inewvol2>=0) then
      begin
      ivol2:=frcrange(inewvol2,0,200);
      inewvol2:=-1;
      end;

   //auto-close
   if (not iplaying) and (not ikeepopen) and canclose and (ms64>=iopenref) then
      begin
      xpause;
      close;
      end;

   //auto-open
   if (ikeepopen or iplaying) and canopen then
      begin
      xpause;
      open;
      end;

   //loop
   if iplaying and iloop and (ilen>=1) and (ipos>=ilen) then
      begin
      xpause;
      setpos(0);
      syncpos;
      restart;
//      iresetvol:=100;//start at full power at beginning of track - 22feb2022
      end;

   //automatic stop
   if iplaying and (not seeking) and ((ilen<=0) or (ipos>=ilen)) and oautostop then//fixed 10mar2021
      begin
      xpause;
      iplaying:=false;
      resetvols;
      end;

   //moretime
   if iplaying then
      begin
      moretime;
      //realtime support - 25mar2022
      app__realtime;
      end;

   //thread speed - FAST - 05mar2022
   if iplaying then systhread__setfast(isysthreadSLOT,ms64FAST+5000);

   //reset -> faster response times when running FAST or TURBO modes -> for Harmony etc - 16mar2022
   if app__turboOK or app__fastOK then itimer100:=ms64 else itimer100:=ms64+100;
   end;

skipend:
except;end;
try
//unpause
if ithreadignore then
   begin
   //fade-in special case:
   if (ipos<=0) then iresetvol:=100;//start at full power at beginning of track - 22feb2022
   //reset playback lag
   resetlag;
   //re-enable high-speed timer - 21feb2022
   try;systhread__push(isysthreadSLOT,1,'',int1,str1);except;end;
   //off
   ithreadignore:=false;
   end;
itimereventbusy:=false;
except;end;
end;
//## msgssent ##
function tbasicmidi.msgssent:longint;
var
   p:longint;
begin
try
result:=0;
if (ilistlimit>=1) then
   begin
   for p:=0 to (ilistlimit-1) do if (ilistcount[p]>=1) and (ilistpos[p]>=1) then inc(result,ilistpos[p]);
   end;
except;end;
end;
//## seeking ##
function tbasicmidi.seeking:boolean;//true=midi is in process of updating "pos" to new value, false=read to set new pos - 30mar2021
begin
result:=(inewpos>=0) or (inewstyle>=0) or (inewdeviceindex>=0) or (imustopen>=1) or imustplaydata or imustplayfile or (inewspeed>=0) or (inewspeed2>=0);//02mar2022
end;
//## moretime ##
procedure tbasicmidi.moretime;
begin
iopenref:=ms64+5000;
end;
//## get ##
function tbasicmidi.get(xindex,xmsgindex:longint;var xtimems:longint;var xmsg,xval1,xval2,xval3:byte):boolean;
var
   xpos:longint;
   a:tcmp8;
begin
try
//defaults
result:=false;
xtimems:=0;
xmsg :=0;
xval1:=0;
xval2:=0;
xval3:=0;
//check
if (xindex<0) or (xindex>high(ilistdata)) or (ilistdata[xindex]=nil) then exit;
//init
if (xmsgindex<0) then xpos:=0 else xpos:=xmsgindex*12;
//get
if (ilistdata[xindex].len>=1) and (xpos>=0) and ((xpos+11)<ilistdata[xindex].len) then
   begin
   //comp(8)
   a.bytes[0]:=ilistdata[xindex].pbytes[xpos+0];
   a.bytes[1]:=ilistdata[xindex].pbytes[xpos+1];
   a.bytes[2]:=ilistdata[xindex].pbytes[xpos+2];
   a.bytes[3]:=ilistdata[xindex].pbytes[xpos+3];
   a.bytes[4]:=ilistdata[xindex].pbytes[xpos+4];
   a.bytes[5]:=ilistdata[xindex].pbytes[xpos+5];
   a.bytes[6]:=ilistdata[xindex].pbytes[xpos+6];
   a.bytes[7]:=ilistdata[xindex].pbytes[xpos+7];
   xtimems:=low__div32(a.val,1000);//convert from usec to ms - 18may2021
   //int(4)
   xmsg :=ilistdata[xindex].pbytes[xpos+8];
   xval1:=ilistdata[xindex].pbytes[xpos+9];
   xval2:=ilistdata[xindex].pbytes[xpos+10];
   xval3:=ilistdata[xindex].pbytes[xpos+11];
   //successful
   result:=true;
   end;
except;end;
end;
//## pdo ##
procedure tbasicmidi.pdo;
label//Special Note: iresetvol allows for a gentle fading in to full volume and avoids any sudden loud notes - 21feb2022
   skipend,redo;
var
   xmore:boolean;
   int1,xvol,rvol,xmaxp,xsongms32,xtimems32,p:longint;
   xmsg,xval1,xval2,xval3:byte;
   a:tint4;
begin
try
//check
if (ilistlimit<=0) or (iphandle=0) then exit;
if ipdobusy then exit else ipdobusy:=true;
//range
xmaxp:=ilistlimit-1;
if (xmaxp>high(ilistdata)) then xmaxp:=high(ilistdata);
//reset vol -> gently fade volume back up to 100% after a "resetvols" - 21feb2022
rvol:=iresetvol;
if (rvol<0) then rvol:=0 else if (rvol>100) then rvol:=100;
//.vol -> 3 separate volume levels generate a final, single volume level - 23mar2022
int1:=mmsys_mid_basevol;
if (int1<0) then int1:=0 else if (int1>200) then int1:=200;
xvol:=(ivol*ivol2*int1) div 10000;//note: close to 32bit upper math limit
if (xvol>200) then xvol:=200;
//init
//was: xsonguSEC:=trunc(ipos*1000.0);//current song position in "ms" -> "uSEC"
xsongms32:=ipos;
synclag;
//get
for p:=0 to xmaxp do
begin
redo:

//was:
//if (ilistcount[p]>=1) and (ilistpos[p]<ilistcount[p]) and get(p,ilistpos[p],xtimems32,xmsg,xval1,xval2,xval3) then
if (ilistcount[p]>=1) and (ilistpos[p]<ilistcount[p]) and get(p,ilistpos[p],xtimems32,xmsg,xval1,xval2,xval3) then
   begin
   //get
   if (xtimems32<xsongms32) or ((not idisablenotes) and (xtimems32<=xsongms32)) then
      begin
      //inc
      inc(ilistpos[p]);
      //disable notes
      if idisablenotes and (xmsg>=$80) and (xmsg<=$9F) then goto redo;//skip over all NOTE ON and NOTE OFF msgs
      //get
      if (iphandle<>0) then
         begin
         if (xvol<>100) or (rvol<>100) then
            begin
            case xmsg of//3b messages - note off / note on
            $80..$9F:if (xval2>=1) then xval2:=byte(frcrange(round(longint(xval2)*(xvol/100)*(rvol/100)),1,127));
            end;
            end;
         a.bytes[0]:=xmsg;
         a.bytes[1]:=xval1;
         a.bytes[2]:=xval2;
         a.bytes[3]:=xval3;
         if (0<>MidiOutShortMsg(iphandle,a.val)) then break;//break on error - 18apr2021
         end;
      //loop
      goto redo;
      end;
   end;
end;//p
skipend:
except;end;
try;ipdobusy:=false;except;end;
end;
//## resetvols ##
procedure tbasicmidi.resetvols;
begin
iresetvol:=20;//hush playback of notes for first Xms so a gradual fade-in of full volume can be achieved
midioutflush(iphandle);
end;
//## canplaymidi ##
function tbasicmidi.canplaymidi:boolean;
begin
result:=(imustopen=0);
end;
//## playfile ##
function tbasicmidi.playfile(x:string):boolean;
begin
try
result:=false;
ifilename:=x;
imustplayfile:=true;
result:=true;
except;end;
end;
//## playdata ##
function tbasicmidi.playdata(x:tstr8):boolean;
begin
try
result:=false;
idata2.clear;//fixed - 02mar2022
if block(x) then idata2.add(x);
imustplaydata:=true;
result:=true;
except;end;
try;bunlockautofree(x);except;end;//15nov2022
end;
//## canopen ##
function tbasicmidi.canopen:boolean;
begin
result:=(iphandle=0);
end;
//## canclose ##
function tbasicmidi.canclose:boolean;
begin
result:=(iphandle<>0);
end;
//## open ##
procedure tbasicmidi.open;
var
   int1:longint;
begin
try
moretime;
if (iphandle=0) then openhandle;
resetvols;
moretime;
except;end;
end;
//## close ##
procedure tbasicmidi.close;
begin
try
if (iphandle<>0) then closehandle;
iphandle:=0;
except;end;
end;
//## autoopen ##
procedure tbasicmidi.autoopen;
begin
if (ikeepopen or iplaying) and canopen then open;
end;
//## setnewpos ##
procedure tbasicmidi.setnewpos(x:longint);
begin
try;inewpos:=frcrange(x,0,ilen);except;end;
end;
//## setnewpertpos ##
procedure tbasicmidi.setnewpertpos(x:double);
begin
try
//range
if (x<0) then x:=0 else if (x>100) then x:=100;
//get
inewpertpos:=x;
except;end;
end;
//## setpos ##
procedure tbasicmidi.setpos(x:longint);
var
   xnewpos,xspeed:comp;
begin
try
xnewpos:=frcrange(x,0,ilen);
xspeed:=low__div64( low__mult64(frcrange(ispeed,10,1000),frcrange(ispeed2,10,1000)) ,100);//combine both speeds together to arrive at one final speed - 03mar2022
//was: ipos64:=-(((xnewpos*100)/xspeed)-ms64FAST);
ipos64:=-(low__div64(low__mult64(xnewpos,100),xspeed)-ms64FAST);//use ms64FAST for high speed millisecond counter - 30sep2021
except;end;
end;
//## syncpos ##
procedure tbasicmidi.syncpos;
var
   cmp1:comp;
begin
try
//get
cmp1:=low__sub64(ms64FAST,ipos64);
//speed adjust
//was: if (ispeed>=1) then cmp1:=trunc(cmp1*(ispeed/100));
if (ispeed>=1) or (ispeed2>=1) then cmp1:=low__div64( low__mult64(cmp1, low__div64(low__mult64(ispeed,ispeed2),100)) ,100);//combine both speeds together
//set
if (cmp1<0) then cmp1:=0
else if (cmp1>ilen) then cmp1:=ilen;
ipos:=trunc(cmp1);//timer synced
except;end;
end;
//## restart ##
procedure tbasicmidi.restart;
var
   p:longint;
begin//Re-syncs midi playback at the new location
try
moretime;
idisablenotes:=true;
//stop all sound
resetvols;
//start tracks from beginning
if (ilistlimit>=1) then for p:=0 to (ilistlimit-1) do ilistpos[p]:=0;
//run notes through midi interface up to the point where we want to start
pdo;//do here whilst high-speed timer has been paused (__ontimer->xwait) because fade in of "iresetvol" may already climb back up to 100% BEFORE the paused high-speed timer restarts execution due to communication lag betweeen US the host and the timer - 21feb2022
except;end;
try;idisablenotes:=false;except;end;
end;
//## canstop ##
function tbasicmidi.canstop:boolean;
begin
result:=(ilen>=1) and iplaying;
end;
//## stop ##
procedure tbasicmidi.stop;
begin
if canstop then imuststop:=true;
end;
//## canplay ##
function tbasicmidi.canplay:boolean;
begin
result:=(ilen>=1) and (not iplaying);
end;
//## play ##
procedure tbasicmidi.play;
begin
moretime;
if canplay then imustplay:=true;
end;
//## flush ##
procedure tbasicmidi.flush;
var
   p:longint;
begin
try
for p:=0 to high(ilistdata) do
begin
if (ilistdata[p]<>nil) then ilistdata[p].clear;
ilistpos[p]:=0;
ilistcount[p]:=0;
end;//p
ilyrics.clear;
ilyricsref.clear;
ilistlimit:=0;
ipos:=0;
ilen:=0;//no midi song loaded -> nothing to play
ibytes:=0;
imidbytes:=0;
except;end;
end;
//## closehandle ##
procedure tbasicmidi.closehandle;
begin
try
if (iphandle<>0) then
   begin
   midioutreset(iphandle);
   midiOutClose(iphandle);
   end;
except;end;
end;
//## openhandle ##
procedure tbasicmidi.openhandle;//must be in VCL thread for it to work on ALL machines - 19may2021
begin
try;midioutopen(@iphandle,UINT(ideviceindex-1),0,0,callback_null);except;end;
end;
//## lcount ##
function tbasicmidi.lcount:longint;
begin
try;result:=ilyricsref.len div 12;except;end;
end;
//## lfind ##
function tbasicmidi.lfind(xpos:longint;xshowsep:boolean):string;//find lyrics - 24feb2022
var//note: xpos=milliseconds 0..(len-1)
   xlist:pdllongint;
   acount,alen,apos,p,dp:longint;
   xlast,str1:string;
   //## xneeddash ##
   function xneeddash(x:byte):boolean;
   begin
   case x of
   65..90,97..122,48..57:result:=true;
   else result:=false;
   end;//case
   end;
begin
try
//defaults
result:='';
//range
//if (xmaxlen<=0) then xmaxlen:=100;
xpos:=frcrange(xpos,0,frcmin(ilen-1,0));
dp:=-1;//not found
acount:=lcount;
//get
xlist:=ilyricsref.core;//high-speed access
for p:=0 to (acount-1) do
begin
if (xpos>=xlist[p*3]) then dp:=p;
end;//p
//check
if (dp=-1) then exit;
//set
xlast:='';
for p:=(dp-2) to (dp+10) do
begin
if (p>=0) and (p<acount) then
   begin
   apos:=ilyricsref.int4[(p*12)+4];
   alen:=ilyricsref.int4[(p*12)+8];
   if (apos>=0) and (alen>=1) then
      begin
      str1:=ilyrics.str[apos,alen];
      if (p>=(dp-1)) then result:=result+low__insstr('-',xshowsep and xneeddash(strbyte1x(str1,1)) and xneeddash(strbyte1x(xlast,length(xlast))))+str1;
      xlast:=str1;
      end;
   end;
end;
//filter
if (result<>'') then
   begin
   swapchars(result,#9,#32);
   swapchars(result,#10,#32);
   swapchars(result,#13,#32);
   end;
except;end;
end;
//## xplaydata ##
procedure tbasicmidi.xplaydata;
label
   skipone,skiptrack,skipdone,skipend;
var
   xdata:tstr8;
   llastms,xtimediv,xtempo,xtmp,mlen,xdatlen,xdatpos,xdatend,xlistcount,int1,int2,p:longint;
   xformat,xtrackcount:word;
   xref,xtickcount,xprevtimeuSEC,xtimeuSEC,xprevtotaluSEC,xtotaluSEC:comp;//high-resolution time tracker - 18feb2021
   xtimeuSEC_test:extended;
   xtimeformat:twrd2;
   xcasiopackets,xresult,bol1:boolean;
   wrd2:word;
   xrunningstatus,xmsg,mtype,byt1,byt2,byt3,byt4,byt5:byte;
   xint4:tint4;
   str1:string;
   //track1 tick-tempo mapper
   xtickcount8:tstr8;//tickcount at which tempo changes
   xticktemp4:tstr8;//tempo values
   xcount8:longint;
   xlist8:pdlcomp;
   xlist4:pdllongint;
   //## setdatpos ##
   procedure setdatpos(x:longint);
   begin
   try;xdatpos:=frcrange(x,0,xdata.len-1);except;end;
   end;
   //## xsame ##
   function xsame(x:array of byte):boolean;
   begin
   try
   result:=xdata.asame3(xdatpos,x,false);//30mar2021
   inc(xdatpos,sizeof(x));
   except;end;
   end;
   //## xsame_autoinc ##
   function xsame_autoinc(x:array of byte):boolean;//auto inc if a match
   begin
   try
   result:=xdata.asame3(xdatpos,x,false);//30mar2021
   if result then inc(xdatpos,sizeof(x));
   except;end;
   end;
   //## xfindval1 ##
   function xfindval1(xpos:longint;var x:byte):boolean;
   begin
   try
   result:=false;
   x:=0;
   if zzok(xdata,4510) and (xpos>=0) and (xpos<xdatlen) and (xpos<=xdatend) then
      begin
      x:=xdata.byt1[xpos];
      result:=true;
      end;
   except;end;
   end;
   //## xval1 ##
   function xval1(var x:byte):boolean;
   begin
   try
   result:=false;
   x:=0;
   if zzok(xdata,4510) and (xdatpos>=0) and (xdatpos<xdatlen) and (xdatpos<=xdatend) then
      begin
      x:=xdata.byt1[xdatpos];
      inc(xdatpos,1);
      result:=true;
      end;
   except;end;
   end;
   //## xval2 ##
   function xval2(var x:word):boolean;
   begin
   try
   result:=false;
   x:=0;
   if zzok(xdata,4511) and (xdatpos>=0) and ((xdatpos+1)<xdatlen) and ((xdatpos+1)<=xdatend) then
      begin
      x:=xdata.wrd2[xdatpos];
      inc(xdatpos,2);
      result:=true;
      end;
   except;end;
   end;
   //## xval2R ##
   function xval2R(var x:word):boolean;//???????????????????????
   begin
   try
   result:=false;
   x:=0;
   if zzok(xdata,4510) and (xdatpos>=0) and ((xdatpos+1)<xdatlen) and ((xdatpos+1)<=xdatend) then
      begin
      x:=xdata.wrd2R[xdatpos];
      inc(xdatpos,2);
      result:=true;
      end;
   except;end;
   end;
   //## xval4 ##
   function xval4(var x:longint):boolean;
   begin
   try
   result:=false;
   x:=0;
   if zzok(xdata,4511) and (xdatpos>=0) and ((xdatpos+3)<xdatlen) and ((xdatpos+3)<=xdatend) then
      begin
      x:=xdata.int4[xdatpos];
      inc(xdatpos,4);
      result:=true;
      end;
   except;end;
   end;
   //## xval4R ##
   function xval4R(var x:longint):boolean;//?????????????????????
   begin
   try
   result:=false;
   x:=0;
   if zzok(xdata,4512) and (xdatpos>=0) and ((xdatpos+3)<xdatlen) and ((xdatpos+3)<=xdatend) then
      begin
      x:=xdata.int4R[xdatpos];
      inc(xdatpos,4);
      result:=true;
      end;
   except;end;
   end;
   //## xvarlen ##
   function xvarlen(var x:longint):boolean;
   var//Supports: 1-4 variable width length
      vc,v1,v2,v3,v4:byte;
   begin
   try
   //defaults
   result:=false;
   x:=0;
   //get
   vc:=0;
   if xval1(v1) then
      begin
      inc(vc);
      if (v1>=128) and xval1(v2) then
         begin
         inc(vc);
         if (v2>=128) and xval1(v3) then
            begin
            inc(vc);
            if (v3>=128) and xval1(v4) then inc(vc);//v4
            end;//v3
         end;//v2
      end;//v1
   //set
   case vc of
   1:x:=v1;
   2:x:=((v1-128)*128)+v2;
   3:x:=((v1-128)*128*128)+((v2-128)*128)+v3;
   4:x:=((v1-128)*128*128*128)+((v2-128)*128*128)+((v3-128)*128)+v4;
   end;

   //successful
   if (x<0) then x:=0;
   result:=(vc>=1) and (vc<=4);
   except;end;
   end;
   //## xaddtempo ##
   procedure xaddtempo(xtickcount:comp;xtempo:longint);
   var
      xcount:longint;
   begin
   try
   if (xtempo<1) then xtempo:=1;
   xcount:=xtickcount8.len div 8;
   xtickcount8.cmp8[xcount*8]:=xtickcount;
   xticktemp4.int4[xcount*4]:=xtempo;
   except;end;
   end;
   //## xaddms ##
   procedure xaddms;//supports single tempo, simple non-overlapping tempo usage, and complex overlapping tempo usage (where a note starts with one tempo and finishes with another or several tempos) - 22feb2022
   var
      p,i,t:longint;
   begin
   //check
   if (int1<=0) then exit;

   //no tempo entries -> use default tempo
   if (xcount8<=0) then
      begin
      xtickcount:=xtickcount+int1;
      xtimeuSEC:=xtimeuSEC+round((xtempo/xtimediv)*int1);
      exit;
      end;

   //tick range does NOT overlap tempo boundaries so do it all at ONCE - 23feb2022
   for i:=0 to (xcount8-1) do
   begin
   if ((xtickcount+1)>=xlist8[i]) and ( (i>=(xcount8-1)) or ((xtickcount+int1)<xlist8[i+1]) ) then
      begin
      xtickcount:=xtickcount+int1;
      xtimeuSEC:=xtimeuSEC+round((xlist4[i]/xtimediv)*int1);
      exit;
      end;
   end;//i

   //tick range overlaps one or MORE tempo boundaries (ranges over several tempo values) - 23feb2022
   for p:=0 to (int1-1) do
   begin
   xtickcount:=xtickcount+1;
   t:=xtempo;
   //.scan thru tempo list
   for i:=0 to (xcount8-1) do if (xtickcount>=xlist8[i]) then t:=xlist4[i] else break;
   xtimeuSEC:=xtimeuSEC+round((t/xtimediv));
   end;//p
   end;
   //## ladd ##
   procedure ladd(xpos,xlen:longint);
   var
      xms,xcount:longint;
   begin
   try
   //check
   if (xlen<=0) then exit;
   //init
   xcount:=ilyricsref.len div 12;
   xms:=low__div32(xtimeuSEC,1000);
   //get
   if (xms>llastms) then
      begin
      ilyricsref.int4[(xcount*12)+0]:=xms;
      ilyricsref.int4[(xcount*12)+4]:=ilyrics.len;
      ilyricsref.int4[(xcount*12)+8]:=xlen;
      end;
   ilyrics.add3(xdata,xpos,xlen);
   except;end;
   end;
begin
try
//defaults
xresult     :=false;
xdatlen     :=0;
xdatpos     :=0;
xdatend     :=maxint;
xdata       :=nil;
xlistcount  :=-1;
xtickcount8 :=nil;
xticktemp4  :=nil;
xtimediv    :=120;
xtotaluSEC  :=0;//overall length of midi in uSEC
xcount8     :=0;//set at start of track 1 (xlistcount=1 when format=1)
llastms     :=-1;//none

//stop threadtimer
//was: systhread__push(isysthreadSLOT,0,'',int1,str1);

//flush
flush;

//check
if not block(idata) then goto skipend;

//copy "tmp" to "dat"
xdata:=bnew;
xdata.add(idata);
xdatlen:=xdata.len;
idata.clear;
xtickcount8:=bnew;
xticktemp4:=bnew;

//get
//.riff ".rmi" file wrapper support -> RIFF wrapper packs ".mid" file inside with a 20 byte preceeding header structure in format "RIFF.4+len.4+RMIDdata+len.4+<midi file in full>" = OK = 30mar2021
if xsame_autoinc([uuR,uuI,uuF,uuF]) then
   begin
   if not xval4(int1) then goto skipend;
   xdatlen:=xdatpos+int1;//include what we have read so far + all that is to come still + BUT exclude any trailing junk - 30mar2021
   if not xsame([uuR,uuM,uuI,uuD]) then goto skipend;
   if not xsame([lld,lla,llt,lla]) then goto skipend;
   if not xval4(int1) then goto skipend;
   end;

//.main midi header
if not xsame([uuM,uuT,llh,lld]) then goto skipend;

//.32bit number check
if (not xval4R(int1)) or (int1<>6) then goto skipend;//must be "6" -> 32bit number handling check - 15feb2021

//.format
if not xval2R(xformat) then goto skipend;
if not xval2R(xtrackcount) then goto skipend;
if not xval2R(xtimeformat.val) then goto skipend;
if (xformat<0) or (xformat>2) then goto skipend;//should always be 0,1 or 2(rarely used)
if (xtrackcount<=0) then goto skipend;

//.convert time into ms for easy system processing -> bit15 decides time format -> false=normal "ticks", true=SMTPE
case (15 in xtimeformat.bits) of
false:xtimediv:=frcmin(xtimeformat.val,1);
true:begin//time is in ms
   //This time format is NOT supported by us as yet - 27mar2021
   goto skipend;

   //this works diffently as there is NO TEMPO adjustments in this type of type format -> all absolute MS/FRAME based delta timing
   xtimeformat.val:=(15 xor xtimeformat.val);
   end;
end;//case

//read all tracks --------------------------------------------------------------
while true do
begin
//.reset end limiter
xdatend:=maxint;
//.check
if ((xlistcount+1)>=xtrackcount) then goto skipdone;
//.track header
bol1:=xsame([uuM,uuT,llr,llk]);
//.track length
if not xval4R(int1) then goto skipend;
if (not bol1) or (int1<1) then goto skiptrack;//skip over unknown chunk types, we support "MTrk" chunks only -> all others are jumped over - 16feb2021
//.list count -> each list stores a full track
inc(xlistcount);
if (xlistcount>high(ilistdata)) then goto skipdone;//too many lists
if zznil(ilistdata[xlistcount],4016) then
   begin
   ilistdata[xlistcount]:=bnew;
   ilistdata[xlistcount].otestlock1:=true;
   end
else ilistdata[xlistcount].clear;//04may2021

//read track -------------------------------------------------------------------
//Important Note:
//calculate Delta Tick Value => current.tempo / timeDive => uSec per Delta Tick (correct as of 22feb2022)
//example: tempo=500,000 (60 bpm) and timeDiv=120 then delta.tick.usec = 500,000/120 = 8,333 usec = 8.3 ms - correct!
//init
xtempo:=500000;//500K = default tempo value FOR EACH track of a multi-track midi too -> uSec per quarter note -> 120 BPM (beats per minute musical notation = (120/60) * 0.25 (quarter note) * 1,000,000 usec = 500,000 usec OK) - 18feb2021
xtickcount:=0;//track tickcount (overall number of ticks on the track BEFORE tempo)
xtimeuSEC:=0;//track microseconds with TEMPO applied
xtimeuSEC_test:=0;
xdatend:=xdatpos+(int1-1);//limit HOW much this track can read
xrunningstatus:=0;//on=128..255
xcasiopackets:=false;//24feb2022
//.rapid access to tickcount/tempo cache - 23feb2022
if (xlistcount>=1) and (xformat>=1) then
   begin
   xcount8:=xtickcount8.len div 8;
   xlist8:=xtickcount8.core;
   xlist4:=xticktemp4.core;
   end;

//get
while true do
begin
//.prev
xprevtimeuSEC:=xtimeuSEC;
xprevtotaluSEC:=xtotaluSEC;

//.$F7 - casio stop
if xcasiopackets then
   begin
   if not xval1(byt1) then goto skipend;
   if (byt1=$F7) then xcasiopackets:=false;
   goto skipone;
   end;

//.delta time (variable length number)
if xvarlen(int1) then
   begin
   //inc ms
   case (xlistcount>=1) and (xformat>=1) of
   true:xaddms;
   false:begin
      xtimeuSEC:=xtimeuSEC+round((xtempo/xtimediv)*int1);//single track -> tempo inline with notes so no need to cache in a tempo map
      xtickcount:=xtickcount+int1;
      end;
   end;//case

   //xtotaluSEC
   if (xtimeuSEC>xtotaluSEC) then xtotaluSEC:=xtimeuSEC;
   end
else goto skipend;

//.xmsg
if not xval1(xmsg) then goto skipend;

//.use runningstatus WHENEVER a message drops into the range "0..127" -> most robust and simple method - 24feb2022
if (xmsg<=127) and (xrunningstatus>=128) then
   begin
   dec(xdatpos,1);//shift back up one byte - 17feb2021
   xmsg:=xrunningstatus;
   end;

//.decide
case xmsg of
//- MIDI events ----------------------------------------------------------------
$00..$7F:begin//** Important: the 0..127 range are NOTES that are running AFTER a NOTE ON/NOTE OFF etc and are using a "running status" shortcut that means that don't have to include the status byte of "Note ON" or "Note Off" again
   //ignored -> running status switches to below $80..$EF
   end;
$80..$BF,$E0..$EF:begin//3b messages - note off -> note on -> polyphonic pressure -> controller ->  -> pitch bend messages
   if not xval1(byt1) then goto skipend;
   if not xval1(byt2) then goto skipend;
   low__midadd(ilistdata[xlistcount],xtimeuSEC,xmsg,byt1,byt2,0);//stores values "asis"
   end;
$C0..$DF:begin//2b messages - program change -> channel pressure
   if not xval1(byt1) then goto skipend;
   low__midadd(ilistdata[xlistcount],xtimeuSEC,xmsg,byt1,0,0);//stores values "asis"
   end;

//- System Exclusive messages --------------------------------------------------
$F0:begin//F0 length message - ignore: skip over these
   if not xvarlen(mlen) then goto skipend;
   inc(xdatpos,mlen);
   if (mlen>=1) and xfindval1(xdatpos-1,byt1) and (byt1<>$F7) then xcasiopackets:=true;
   end;

//- Escape sequences -----------------------------------------------------------
$F7:begin//F7 length bytes - ignore: skip over these
   if not xvarlen(mlen) then goto skipend;
   inc(xdatpos,mlen);
   end;

//- Meta events ----------------------------------------------------------------
$FF:begin//meta-events "FF type length data"
   //init
   if not xval1(mtype) then goto skipend;
   if not xvarlen(mlen) then goto skipend;
   xtmp:=xdatpos+mlen;//remember this value -> allows for below to pull values and adjust "xdatpos" without worrying about losing the final endpoint
   //get
   case mtype of
   $03:;//track name
   $05:ladd(xdatpos,mlen);//lyrics
   $20:begin
      //ignore
      end;
   $21:begin//Midi Port
      //ignore
      end;
   $2F:begin//end of track (required) -> "FF 2F 00"
      low__midadd(ilistdata[xlistcount],xprevtimeuSEC,xmsg,mtype,0,0);//stores values "asis"
      xtotaluSEC:=xprevtotaluSEC;//exclude this from the total time count
      break;
      end;
   $51:begin//tempo -> "FF 51 03 tt tt tt"
      xval1(byt1);
      xval1(byt2);
      xval1(byt3);
      if (xlistcount<=0) then
         begin
         xtempo:=frcmin((byt1*256*256)+(byt2*256)+byt3,1);
         if (xformat>=1) then xaddtempo(xtickcount,xtempo);//add tempo to tempo mapper
         end;
      end;
   $54:begin//SMPTE offset -> "FF 54 05 hr mn se fr ff"
      //we don't support this yet
      end;
   $58:begin//time signature -> "FF 58 04 nn dd cc bb"
      //safe to ignore
      end;
   $59:begin//key signature -> "FF 59 02 sf mi"
      //safe to ignore
      end;
   $F0:;
   $7F:begin//sequencer specific event -> "FF 7F length data"
      //safe to ignore
      end;
   end;
   //inc past data
   xdatpos:=xtmp;
   end;
end;//case

//.running status -> keep very simple -> ANY note bases messages "$80..$EF" updates the runningstatus AND is retained no matter WHAT and is simply used whenever a message drops into the range of "0..127" - this works for "james blunt youre beautiful.mid" which expects runningstatus to work EVEN through multiple meta events - 24feb2022
case xmsg of
$80..$EF:xrunningstatus:=xmsg;
end;

skipone:
end;//while -> end of track


//sync tracker handlers
ilistcount[xlistcount]:=low__midcount(ilistdata[xlistcount]);

//detect last usable list
if ((xlistcount+1)>=ilistlimit) then ilistlimit:=xlistcount+1;

skiptrack:
end;//while -> end of all tracks

//successful
skipdone:
xresult:=true;
skipend:
//bytes
if (ilistlimit>=1) then
   begin
   int1:=0;
   for p:=0 to frcmax(ilistlimit-1,high(ilistdata)) do if (ilistcount[p]>=1) and zzok(ilistdata[p],4513) then inc(int1,ilistdata[p].len);
   ibytes:=int1;
   end;
except;end;
try
bfree(xdata);
bfree(xtickcount8);
bfree(xticktemp4);
except;end;
try
//sync system
ilen:=low__div32(xtotaluSEC,1000);//uSEC -> milliseconds
imidformat:=low__insint(xformat,xresult);
imidtracks:=low__insint(frcmin(ilistlimit-low__insint(1,imidformat=1),0),xresult);//for information purposes only - "format #1 we don't count track #0" - 24feb2021
imidbytes:=xdatlen;//always return size of midi datastream error or no error - 29mar2021
//.msgs
int1:=0;
if (ilistlimit>=1) then
   begin
   for p:=0 to frcmax(ilistlimit-1,high(ilistdata)) do if (ilistcount[p]>=1) then inc(int1,ilistcount[p]);
   end;
imidmsgs:=int1;
except;end;
try
bunlockautofree(idata);
//start threadtimer
//was: systhread__push(isysthreadSLOT,1,'',int1,str1);
except;end;
end;

//## tbasicchimes ##############################################################
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//ccccccccccccccccccc
//## create ##
constructor tbasicchimes.create;
var
   p:longint;
begin
//self
inherited create;

//need MM -> midi support to function
need_mm;

//vars
ivol:=100;
iplaying:=false;
imuststop:=false;
imustplay:=-1;//off
iworklist:='';
iworkindex:=0;
iworkmins:=0;
iworkpos:=0;
iworkcount:=1;
iwork0:=true;
iwork15:=true;
iwork30:=true;
iwork45:=true;
iworktest:=false;
ipausenote64:=0;
ibuzzer:=0;//off
ibuzzer2:=0;
ibuzzerpaused:=false;

//clear
icount:=0;
inumberfrom1:=0;
inumberfrom2:=0;
inumberfrom3:=0;
ibuzzercount:=0;
for p:=0 to high(iname) do
begin
iname[p]   :='';
iintro[p]  :=nil;
idong[p]   :=nil;
idong2[p]  :=nil;
itemp[p]   :=nil;
iintroX[p] :='';
idongX[p]  :='';
idong2X[p] :='';
end;//p

//init
xinitChimes;
//timer
low__timerset(self,_ontimer,30);
end;
//## destroy ##
destructor tbasicchimes.destroy;//02mar2022
var
   p:longint;
begin
try
//timer
low__timerdel(self,_ontimer);//disconnect our timer event from the system timer
//vars
for p:=0 to high(iname) do
begin
bfree(iintro[p]);
bfree(idong[p]);
bfree(idong2[p]);
bfree(itemp[p]);
end;//p
//.buzzers
for p:=low(ibuzzers) to high(ibuzzers) do bfree(ibuzzers[p]);
//self
inherited destroy;
except;end;
end;
//## setbuzzer ##
procedure tbasicchimes.setbuzzer(x:longint);
begin
try;ibuzzer:=frcrange(x,0,chm_buzzercount);except;end;
end;
//## findbuzzerlabel ##
function tbasicchimes.findbuzzerlabel(x:longint):string;
begin
try
//defaults
result:='';
//range
x:=frcrange(x,0,high(ibuzzers));
if (x<low(ibuzzerlabels)) then result:='None' else result:=ibuzzerlabels[x];
except;end;
end;
//## addbuzzer ##
function tbasicchimes.addbuzzer(xlabel,xdata:string;xmiddata:array of byte):boolean;
label
   redo;
var
   p,xlabelcount:longint;
   dlabel:string;
   xok:boolean;
begin
try
//defaults
result:=false;
xlabelcount:=1;
//check
if (ibuzzercount<0) then ibuzzercount:=0;
if (ibuzzercount>=high(ibuzzers)) then exit;
//find existing
redo:
dlabel:=xlabel+low__insstr(#32+inttostr(xlabelcount),xlabelcount>=2);
for p:=1 to frcmax(ibuzzercount,high(ibuzzerlabels)) do
begin
if low__comparetext(ibuzzerlabels[p],dlabel) then
   begin
   inc(xlabelcount);
   goto redo;
   end;
end;//p
//get
if (ibuzzercount<high(ibuzzers)) then
   begin
   inc(ibuzzercount);
   setbuzzerdata(ibuzzercount,dlabel,xdata,xmiddata);
   end;
except;end;
end;
//## setbuzzerdata ##
procedure tbasicchimes.setbuzzerdata(x:longint;xlabel,xdata:string;xmiddata:array of byte);
var//x: 0=off, 1..9=buzzer data
   a:tstr8;
   e:string;
begin
try
//defaults
a:=nil;
//range
x:=frcrange(x,0,high(ibuzzers));
if (x<low(ibuzzers)) then exit;
//init
if (ibuzzers[x]=nil) then ibuzzers[x]:=bnew;
ibuzzers[x].clear;
//get
if (sizeof(xmiddata)<4) then
   begin
   a:=bnew;
   low__makemid(xdata,a,e);
   ibuzzers[x].add(a);
   end
else ibuzzers[x].aadd(xmiddata);
//set
ibuzzerlabels[x]:=low__udv(xlabel,inttostr(x));
except;end;
try;bfree(a);except;end;
end;
//## setvol ##
procedure tbasicchimes.setvol(x:longint);
begin
try;ivol:=frcrange(x,0,100);except;end;
end;
//## xinitChimes ##
procedure tbasicchimes.xinitChimes;
const

//Air.mid - 0=intro, 1=single dong, 2=double dong (ships bells)
mid__0air:array[0..121] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,7,53,121,0,255,47,0,77,84,114,107,0,0,0,67,0,255,33,1,0,0,192,14,0,176,7,127,0,144,83,100,120,83,0,0,88,100,120,88,0,0,89,100,130,104,84,100,120,84,0,0,89,0,0,83,100,120,83,0,0,81,100,120,81,0,0,83,100,120,83,0,0,84,100,131,96,84,0,0,255,47,0);

mid__1air:array[0..90] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,7,53,121,0,255,47,0,77,84,114,107,0,0,0,36,0,255,33,1,0,0,192,14,0,176,7,127,0,144,84,100,120,88,100,120,84,0,120,88,0,0,84,100,131,96,84,0,0,255,47,0);

mid__2air:array[0..0] of byte=(
0);


//Air 2.mid - 0=intro, 1=single dong, 2=double dong (ships bells)
mid__0air_2:array[0..121] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,7,53,121,0,255,47,0,77,84,114,107,0,0,0,67,0,255,33,1,0,0,192,14,0,176,7,127,0,144,83,100,120,83,0,0,88,100,120,88,0,0,89,100,130,104,84,100,120,84,0,0,89,0,0,83,100,120,83,0,0,81,100,120,81,0,0,83,100,120,83,0,0,84,100,131,96,84,0,0,255,47,0);

mid__1air_2:array[0..78] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,7,53,121,0,255,47,0,77,84,114,107,0,0,0,24,0,255,33,1,0,0,192,14,0,176,7,127,0,144,84,100,131,96,84,0,0,255,47,0);

mid__2air_2:array[0..85] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,7,53,121,0,255,47,0,77,84,114,107,0,0,0,31,0,255,33,1,0,0,192,14,0,176,7,127,0,144,84,100,129,112,84,0,120,84,100,131,96,84,0,0,255,47,0);


//Charm.mid - 0=intro, 1=single dong, 2=double dong (ships bells)
mid__0charm:array[0..100] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,11,113,176,0,255,47,0,77,84,114,107,0,0,0,46,0,255,33,1,0,0,192,14,0,176,7,127,0,176,10,63,0,144,79,100,120,79,0,0,86,100,120,86,0,0,83,100,120,83,0,0,79,100,131,96,79,0,0,255,47,0);

mid__1charm:array[0..82] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,11,113,176,0,255,47,0,77,84,114,107,0,0,0,28,0,255,33,1,0,0,192,14,0,176,7,127,0,176,10,63,0,144,83,100,130,124,83,0,0,255,47,0);

mid__2charm:array[0..131] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,16,4,6,8,0,255,89,2,0,0,0,255,81,3,5,184,216,0,255,47,0,77,84,114,107,0,0,0,77,0,255,33,1,0,0,255,3,12,84,117,98,117,108,97,114,45,66,101,108,108,0,192,14,0,176,7,127,0,176,10,63,0,176,101,0,0,100,0,0,6,24,0,224,0,64,0,176,10,63,0,144,83,100,30,83,0,129,22,83,100,122,176,123,0,0,120,0,131,124,144,83,0,0,255,47,0);


//Cheerful.mid - 0=intro, 1=single dong, 2=double dong (ships bells)
mid__0cheerful:array[0..168] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,6,2,24,8,0,255,89,2,0,0,0,255,81,3,11,113,176,0,255,47,0,77,84,114,107,0,0,0,114,0,255,33,1,0,0,255,3,7,67,114,121,115,116,97,108,0,192,98,0,176,7,127,0,176,10,64,0,176,101,0,0,100,0,0,6,24,0,224,0,64,0,176,10,64,0,144,100,99,60,100,0,0,93,99,60,93,0,0,100,99,60,100,0,0,88,99,60,88,0,0,100,99,60,100,0,0,83,99,60,83,0,0,93,99,60,93,0,0,96,99,60,96,0,0,100,99,129,112,176,123,0,0,120,0,130,104,144,100,0,0,255,47,0);

mid__1cheerful:array[0..115] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,3,2,24,8,0,255,89,2,0,0,0,255,81,3,9,39,192,0,255,47,0,77,84,114,107,0,0,0,61,0,255,33,1,0,0,255,3,7,67,114,121,115,116,97,108,0,192,98,0,176,7,127,0,176,10,64,0,176,101,0,0,100,0,0,6,24,0,224,0,64,0,144,100,100,130,105,176,123,0,0,120,0,120,144,100,0,0,255,47,0);

mid__2cheerful:array[0..0] of byte=(
0);


//Elegance.mid - 0=intro, 1=single dong, 2=double dong (ships bells)
mid__0elegance_2:array[0..291] of byte=(
77,84,104,100,0,0,0,6,0,1,0,3,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,3,169,128,0,255,47,0,77,84,114,107,0,0,0,116,0,255,33,1,0,0,255,3,16,69,108,101,99,116,114,105,99,32,80,105,97,110,111,32,50,0,192,5,0,176,7,127,0,176,10,64,0,176,101,0,0,100,0,0,6,24,0,224,0,64,0,176,10,64,0,144,110,127,120,110,0,0,103,99,120,103,0,0,100,99,120,100,0,0,103,99,120,103,0,0,107,99,120,107,0,0,105,99,120,105,0,0,107,99,120,107,0,0,108,99,129,112,108,0,130,106,176,123,0,0,120,0,0,255,47,0,77,84,114,107,0,0,0,113,0,255,33,1,0,0,255,3,7,67,114,121,115,116,97,108,0,193,98,0,177,7,27,0,177,10,64,0,177,101,0,0,100,0,0,6,24,0,225,0,64,0,177,10,64,0,145,100,127,120,100,0,0,83,99,120,83,0,0,79,99,120,79,0,0,83,99,120,83,0,0,86,127,0,53,127,120,53,0,0,86,0,0,84,127,120,84,0,0,86,127,120,86,0,0,88,127,129,112,88,0,130,106,177,123,0,0,120,0,0,255,47,0);

mid__1elegance_2:array[0..307] of byte=(
77,84,104,100,0,0,0,6,0,1,0,5,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,3,169,128,0,255,47,0,77,84,114,107,0,0,0,39,0,255,33,1,0,0,255,3,7,83,116,97,102,102,32,54,0,195,0,0,179,7,100,0,179,10,32,131,98,179,123,0,0,120,0,0,255,47,0,77,84,114,107,0,0,0,69,0,255,33,1,0,0,255,3,16,69,108,101,99,116,114,105,99,32,80,105,97,110,111,32,50,0,192,5,0,176,7,126,0,176,10,64,0,176,101,0,0,100,0,0,6,24,0,224,0,64,0,144,110,127,130,104,110,0,122,176,123,0,0,120,0,0,255,47,0,77,84,114,107,0,0,0,60,0,255,33,1,0,0,255,3,7,67,114,121,115,116,97,108,0,193,98,0,177,7,28,0,177,10,64,0,177,101,0,0,100,0,0,6,24,0,225,0,64,0,145,100,127,130,104,100,0,122,177,123,0,0,120,0,0,255,47,0,77,84,114,107,0,0,0,61,0,255,33,1,0,0,255,3,7,67,101,108,101,115,116,97,0,194,8,0,178,7,89,0,178,10,64,0,146,127,127,0,178,101,0,0,100,0,0,6,24,0,226,0,64,130,104,146,127,0,122,178,123,0,0,120,0,0,255,47,0);

mid__2elegance_2:array[0..277] of byte=(
77,84,104,100,0,0,0,6,0,1,0,4,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,7,83,0,0,255,47,0,77,84,114,107,0,0,0,75,0,255,33,1,0,0,255,3,16,69,108,101,99,116,114,105,99,32,80,105,97,110,111,32,50,0,192,5,0,176,7,127,0,176,10,64,0,176,101,0,0,100,0,0,6,24,0,224,0,64,0,144,110,127,120,110,0,0,110,127,120,110,0,129,113,176,123,0,0,120,0,0,255,47,0,77,84,114,107,0,0,0,66,0,255,33,1,0,0,255,3,7,67,114,121,115,116,97,108,0,193,98,0,177,7,28,0,177,10,64,0,177,101,0,0,100,0,0,6,24,0,225,0,64,0,145,100,127,120,100,0,0,100,127,120,100,0,129,113,177,123,0,0,120,0,0,255,47,0,77,84,114,107,0,0,0,66,0,255,33,1,0,0,255,3,7,67,101,108,101,115,116,97,0,194,8,0,178,7,89,0,178,10,64,0,178,101,0,0,100,0,0,6,24,0,226,0,64,0,146,127,127,120,127,0,0,127,127,120,127,0,129,113,178,123,0,0,120,0,0,255,47,0);


//Fallows.mid - 0=intro, 1=single dong, 2=double dong (ships bells)
mid__0fallows:array[0..128] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,9,39,192,0,255,47,0,77,84,114,107,0,0,0,74,0,255,33,1,0,0,195,14,0,179,7,127,0,179,10,63,0,147,41,100,120,43,100,120,41,0,0,45,100,120,43,0,120,45,0,0,41,100,129,112,40,100,129,112,40,0,0,41,0,0,38,100,129,112,38,0,0,40,100,129,112,40,0,0,41,100,131,96,41,0,0,255,47,0);

mid__1fallows:array[0..100] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,9,39,192,0,255,47,0,77,84,114,107,0,0,0,46,0,255,33,1,0,0,195,14,0,179,7,127,0,179,10,63,0,147,41,100,120,41,0,0,43,100,120,43,0,0,41,100,120,41,0,0,40,100,131,96,40,0,0,255,47,0);

mid__2fallows:array[0..125] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,9,39,192,0,255,47,0,77,84,114,107,0,0,0,71,0,255,33,1,0,0,195,14,0,179,7,127,0,179,10,63,0,147,41,100,120,41,0,0,43,100,120,43,0,0,41,100,120,41,0,0,40,100,131,96,40,0,0,41,100,120,41,0,0,43,100,120,43,0,0,41,100,120,41,0,0,40,100,131,96,40,0,0,255,47,0);


//Fallows 2.mid - 0=intro, 1=single dong, 2=double dong (ships bells)
mid__0fallows_2:array[0..128] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,9,39,192,0,255,47,0,77,84,114,107,0,0,0,74,0,255,33,1,0,0,195,14,0,179,7,127,0,179,10,63,0,147,41,100,120,43,100,120,41,0,0,45,100,120,43,0,120,45,0,0,41,100,129,112,40,100,129,112,40,0,0,41,0,0,38,100,129,112,38,0,0,40,100,129,112,40,0,0,41,100,131,96,41,0,0,255,47,0);

mid__1fallows_2:array[0..82] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,9,39,192,0,255,47,0,77,84,114,107,0,0,0,28,0,255,33,1,0,0,195,14,0,179,7,127,0,179,10,63,0,147,41,100,130,104,41,0,0,255,47,0);

mid__2fallows_2:array[0..89] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,9,39,192,0,255,47,0,77,84,114,107,0,0,0,35,0,255,33,1,0,0,195,14,0,179,7,127,0,179,10,63,0,147,41,100,129,112,41,0,120,41,100,132,88,41,0,0,255,47,0);


//Fields Of Reflection.mid - 0=intro, 1=single dong, 2=double dong (ships bells)
mid__0fields_of_reflection:array[0..185] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,4,147,224,0,255,47,0,77,84,114,107,0,0,0,131,0,255,33,1,0,0,195,98,0,179,7,127,0,179,10,63,0,147,55,100,120,60,100,120,55,0,0,59,100,120,60,0,120,59,0,0,55,100,129,112,59,100,129,112,59,0,0,55,0,0,60,100,129,112,60,0,0,62,100,129,112,62,0,0,60,100,120,60,0,0,59,100,120,59,0,0,60,100,120,60,0,120,59,100,129,112,59,0,0,57,100,131,96,57,0,0,60,100,120,60,0,0,59,100,120,59,0,0,57,100,129,112,60,100,120,60,0,120,57,0,0,55,100,136,56,55,0,0,255,47,0);

mid__1fields_of_reflection:array[0..107] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,4,147,224,0,255,47,0,77,84,114,107,0,0,0,53,0,255,33,1,0,0,195,98,0,179,7,127,0,179,10,63,0,147,55,100,120,60,100,120,55,0,0,59,100,120,60,0,120,59,0,0,57,100,129,112,57,0,0,55,100,137,48,55,0,0,255,47,0);

mid__2fields_of_reflection:array[0..140] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,4,147,224,0,255,47,0,77,84,114,107,0,0,0,86,0,255,33,1,0,0,195,98,0,179,7,127,0,179,10,63,0,147,55,100,120,60,100,120,55,0,0,59,100,120,60,0,120,59,0,0,57,100,129,112,57,0,0,55,100,129,112,55,0,131,96,55,100,120,60,100,120,55,0,0,59,100,120,60,0,120,59,0,0,57,100,129,112,57,0,0,55,100,139,32,55,0,0,255,47,0);


//Fields Of Reflection 2.mid - 0=intro, 1=single dong, 2=double dong (ships bells)
mid__0fields_of_reflection_2:array[0..185] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,4,147,224,0,255,47,0,77,84,114,107,0,0,0,131,0,255,33,1,0,0,195,98,0,179,7,127,0,179,10,63,0,147,55,100,120,60,100,120,55,0,0,59,100,120,60,0,120,59,0,0,55,100,129,112,59,100,129,112,59,0,0,55,0,0,60,100,129,112,60,0,0,62,100,129,112,62,0,0,60,100,120,60,0,0,59,100,120,59,0,0,60,100,120,60,0,120,59,100,129,112,59,0,0,57,100,131,96,57,0,0,60,100,120,60,0,0,59,100,120,59,0,0,57,100,129,112,60,100,120,60,0,120,57,0,0,55,100,136,56,55,0,0,255,47,0);

mid__1fields_of_reflection_2:array[0..82] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,4,147,224,0,255,47,0,77,84,114,107,0,0,0,28,0,255,33,1,0,0,195,98,0,179,7,127,0,179,10,63,0,147,55,100,139,32,55,0,0,255,47,0);

mid__2fields_of_reflection_2:array[0..90] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,4,147,224,0,255,47,0,77,84,114,107,0,0,0,36,0,255,33,1,0,0,195,98,0,179,7,127,0,179,10,63,0,147,55,100,129,112,55,0,129,112,55,100,139,32,55,0,0,255,47,0);


//Harmony.mid - 0=intro, 1=single dong, 2=double dong (ships bells)
mid__0harmony:array[0..100] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,6,2,24,8,0,255,89,2,0,0,0,255,81,3,9,39,192,0,255,47,0,77,84,114,107,0,0,0,46,0,255,33,1,0,0,192,9,0,176,7,127,0,176,10,63,0,144,47,127,120,47,0,0,45,127,120,45,0,0,50,127,120,50,0,0,47,127,131,96,47,0,0,255,47,0);

mid__1harmony:array[0..88] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,9,39,192,0,255,47,0,77,84,114,107,0,0,0,34,0,255,33,1,0,0,192,9,0,176,7,127,0,176,10,63,0,144,43,127,120,47,127,120,43,0,130,104,47,0,0,255,47,0);

mid__2harmony:array[0..0] of byte=(
0);


//Melody.mid - 0=intro, 1=single dong, 2=double dong (ships bells)
mid__0melody:array[0..132] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,3,2,24,8,0,255,89,2,0,0,0,255,81,3,4,147,224,0,255,47,0,77,84,114,107,0,0,0,78,0,255,33,1,0,0,192,14,0,176,7,127,0,144,71,100,120,71,0,0,67,100,120,67,0,0,71,100,120,71,0,0,74,100,120,74,0,0,71,100,120,71,0,0,69,100,120,69,0,0,72,100,120,72,0,0,74,100,120,74,0,0,71,100,120,71,0,0,72,100,133,80,72,0,0,255,47,0);

mid__1melody:array[0..90] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,4,147,224,0,255,47,0,77,84,114,107,0,0,0,36,0,255,33,1,0,0,192,14,0,176,7,127,0,144,72,100,120,72,0,0,76,100,120,76,0,0,74,100,133,80,74,0,0,255,47,0);

mid__2melody:array[0..0] of byte=(
0);


//Melody 2.mid - 0=intro, 1=single dong, 2=double dong (ships bells)
mid__0melody_2:array[0..132] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,3,2,24,8,0,255,89,2,0,0,0,255,81,3,4,147,224,0,255,47,0,77,84,114,107,0,0,0,78,0,255,33,1,0,0,192,14,0,176,7,127,0,144,71,100,120,71,0,0,67,100,120,67,0,0,71,100,120,71,0,0,74,100,120,74,0,0,71,100,120,71,0,0,69,100,120,69,0,0,72,100,120,72,0,0,74,100,120,74,0,0,71,100,120,71,0,0,72,100,131,96,72,0,0,255,47,0);

mid__1melody_2:array[0..124] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,3,2,24,8,0,255,89,2,0,0,0,255,81,3,9,39,192,0,255,47,0,77,84,114,107,0,0,0,70,0,255,33,1,0,0,255,3,12,84,117,98,117,108,97,114,45,66,101,108,108,0,192,14,0,176,7,127,0,176,10,64,0,144,74,100,0,176,101,0,0,100,0,0,6,24,0,224,0,64,0,176,10,64,131,96,144,74,0,2,176,123,0,0,120,0,0,255,47,0);

mid__2melody_2:array[0..133] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,3,2,24,8,0,255,89,2,0,0,0,255,81,3,9,39,192,0,255,47,0,77,84,114,107,0,0,0,79,0,255,33,1,0,0,255,3,12,84,117,98,117,108,97,114,45,66,101,108,108,0,192,14,0,176,7,127,0,176,10,64,0,144,74,100,0,176,101,0,0,100,0,0,6,24,0,224,0,64,0,176,10,64,61,144,74,0,129,51,74,100,129,114,176,123,0,0,120,0,129,110,144,74,0,0,255,47,0);


//Peaceful Pleasantries.mid - 0=intro, 1=single dong, 2=double dong (ships bells)
mid__0peaceful_pleasantries:array[0..102] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,7,2,24,8,0,255,89,2,0,0,0,255,81,3,9,39,192,0,255,47,0,77,84,114,107,0,0,0,48,0,255,33,1,0,0,192,14,0,176,7,127,0,144,88,100,60,88,0,0,84,100,60,84,0,0,83,100,60,83,0,60,86,100,60,86,0,60,81,100,131,96,81,0,0,255,47,0);

mid__1peaceful_pleasantries:array[0..78] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,9,39,192,0,255,47,0,77,84,114,107,0,0,0,24,0,255,33,1,0,0,192,14,0,176,7,127,0,144,86,100,131,96,86,0,0,255,47,0);

mid__2peaceful_pleasantries:array[0..104] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,5,22,21,0,255,47,0,77,84,114,107,0,0,0,50,0,255,33,1,0,0,255,3,12,84,117,98,117,108,97,114,45,66,101,108,108,0,192,14,0,176,7,127,0,176,10,64,0,144,86,100,61,86,0,59,86,100,132,88,86,0,0,255,47,0);


//Succession.mid - 0=intro, 1=single dong, 2=double dong (ships bells)
mid__0succession:array[0..168] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,3,2,24,8,0,255,89,2,0,0,0,255,81,3,18,79,128,0,255,47,0,77,84,114,107,0,0,0,114,0,255,33,1,0,0,192,14,0,176,7,127,15,144,64,100,15,64,0,0,71,100,15,71,0,0,77,100,15,77,0,0,74,100,15,74,0,0,84,100,15,84,0,0,77,100,15,77,0,0,89,100,15,89,0,0,77,100,15,77,0,0,91,100,15,91,0,0,74,100,15,74,0,0,71,100,15,71,0,0,67,100,15,67,0,0,74,100,15,74,0,0,86,100,15,86,0,0,83,100,15,83,0,0,72,100,129,112,72,0,0,255,47,0);

mid__1succession:array[0..103] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,32,0,255,88,4,3,2,24,8,0,255,89,2,0,0,0,255,81,3,18,79,128,48,255,81,3,18,79,128,0,255,47,0,77,84,114,107,0,0,0,42,0,255,33,1,0,0,192,14,0,176,7,127,15,144,72,100,15,72,0,0,86,100,15,86,0,0,83,100,15,83,0,2,71,100,129,112,71,0,0,255,47,0);

mid__2succession:array[0..0] of byte=(
0);


//Succession 2.mid - 0=intro, 1=single dong, 2=double dong (ships bells)
mid__0succession_2:array[0..168] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,3,2,24,8,0,255,89,2,0,0,0,255,81,3,18,79,128,0,255,47,0,77,84,114,107,0,0,0,114,0,255,33,1,0,0,192,14,0,176,7,127,15,144,64,100,15,64,0,0,71,100,15,71,0,0,77,100,15,77,0,0,74,100,15,74,0,0,84,100,15,84,0,0,77,100,15,77,0,0,89,100,15,89,0,0,77,100,15,77,0,0,91,100,15,91,0,0,74,100,15,74,0,0,71,100,15,71,0,0,67,100,15,67,0,0,74,100,15,74,0,0,86,100,15,86,0,0,83,100,15,83,0,0,72,100,129,112,72,0,0,255,47,0);

mid__1succession_2:array[0..85] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,32,0,255,88,4,3,2,24,8,0,255,89,2,0,0,0,255,81,3,18,79,128,48,255,81,3,15,66,64,0,255,47,0,77,84,114,107,0,0,0,24,0,255,33,1,0,0,192,14,0,176,7,127,0,144,71,100,129,112,71,0,0,255,47,0);

mid__2succession_2:array[0..91] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,32,0,255,88,4,3,2,24,8,0,255,89,2,0,0,0,255,81,3,18,79,128,48,255,81,3,15,66,64,0,255,47,0,77,84,114,107,0,0,0,30,0,255,33,1,0,0,192,14,0,176,7,127,3,144,71,100,117,71,100,3,71,0,129,109,71,0,0,255,47,0);


//Tinkle.mid - 0=intro, 1=single dong, 2=double dong (ships bells)
mid__0tinkle:array[0..171] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,18,79,128,0,255,47,0,77,84,114,107,0,0,0,117,0,255,33,1,0,0,195,112,0,179,7,127,0,179,10,63,0,147,112,100,29,112,0,1,115,100,29,115,0,1,119,100,29,119,0,1,122,100,29,122,0,5,112,100,29,112,0,1,115,100,29,115,0,1,119,100,29,119,0,1,122,100,26,112,100,3,122,0,26,112,0,1,115,100,29,115,0,1,119,100,29,119,0,1,122,100,29,122,0,31,122,100,30,122,0,0,119,100,30,119,0,0,115,100,30,115,0,0,112,100,120,112,0,0,255,47,0);

mid__1tinkle:array[0..81] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,18,79,128,0,255,47,0,77,84,114,107,0,0,0,27,0,255,33,1,0,0,195,112,0,179,7,127,0,179,10,63,0,147,112,100,120,112,0,0,255,47,0);

mid__2tinkle:array[0..87] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,18,79,128,0,255,47,0,77,84,114,107,0,0,0,33,0,255,33,1,0,0,195,112,0,179,7,127,0,179,10,63,0,147,112,100,120,112,0,0,112,100,120,112,0,0,255,47,0);


//Westminster.mid - 0=intro, 1=single dong, 2=double dong (ships bells)
mid__0westminster:array[0..125] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,11,113,176,0,255,47,0,77,84,114,107,0,0,0,71,0,255,33,1,0,0,192,14,0,176,7,127,0,176,10,63,5,144,69,100,120,69,0,0,65,100,120,65,0,0,67,100,120,67,0,0,60,100,130,104,60,0,0,60,100,120,60,0,0,67,100,120,67,0,0,69,100,115,65,100,5,69,0,131,91,65,0,0,255,47,0);

mid__1westminster:array[0..82] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,9,39,192,0,255,47,0,77,84,114,107,0,0,0,28,0,255,33,1,0,0,192,14,0,176,7,127,0,176,10,63,0,144,60,100,131,96,60,0,0,255,47,0);

mid__2westminster:array[0..89] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,9,39,192,0,255,47,0,77,84,114,107,0,0,0,35,0,255,33,1,0,0,195,14,0,179,7,127,0,179,10,63,0,147,60,100,129,112,60,0,0,60,100,131,96,60,0,0,255,47,0);


//Westminster 2.mid - 0=intro, 1=single dong, 2=double dong (ships bells)
mid__0westminster_2:array[0..125] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,9,39,192,0,255,47,0,77,84,114,107,0,0,0,71,0,255,33,1,0,0,192,9,0,176,7,127,0,176,10,63,5,144,69,100,120,69,0,0,65,100,120,65,0,0,67,100,120,67,0,0,60,100,130,104,60,0,0,60,100,120,60,0,0,67,100,120,67,0,0,69,100,115,65,100,5,69,0,131,91,65,0,0,255,47,0);

mid__1westminster_2:array[0..82] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,9,39,192,0,255,47,0,77,84,114,107,0,0,0,28,0,255,33,1,0,0,192,9,0,176,7,127,0,176,10,63,0,144,69,100,131,96,69,0,0,255,47,0);

mid__2westminster_2:array[0..89] of byte=(
77,84,104,100,0,0,0,6,0,1,0,2,0,120,77,84,114,107,0,0,0,25,0,255,88,4,4,2,24,8,0,255,89,2,0,0,0,255,81,3,9,39,192,0,255,47,0,77,84,114,107,0,0,0,35,0,255,33,1,0,0,192,9,0,176,7,127,0,176,10,63,0,144,69,100,129,112,69,0,0,69,100,131,96,69,0,0,255,47,0);


//Dong pattern files - i=intro, s=single dong, d=double dong (ships bells)
txt__tnormal:array[0..292] of byte=(
47,47,110,111,114,109,97,108,32,99,104,105,109,101,115,32,116,101,109,112,108,97,116,101,13,10,116,101,115,116,58,32,105,32,115,115,32,115,115,32,115,115,13,10,49,53,58,32,115,13,10,51,48,58,32,115,13,10,52,53,58,32,115,13,10,48,49,48,48,58,32,105,32,115,13,10,48,50,48,48,58,32,105,32,115,115,13,10,48,51,48,48,58,32,105,32,115,115,32,115,13,10,48,52,48,48,58,32,105,32,115,115,32,115,115,13,10,48,53,48,48,58,32,105,32,115,115,32,115,115,32,115,13,10,48,54,48,48,58,32,105,32,115,115,32,115,115,32,115,115,13,10,48,55,48,48,58,32,105,32,115,115,32,115,115,32,115,115,32,115,13,10,48,56,48,48,58,32,105,32,115,115,32,115,115,32,115,115,32,115,115,13,10,48,57,48,48,58,32,105,32,115,115,32,115,115,32,115,115,32,115,115,32,115,13,10,49,48,48,48,58,32,105,32,115,115,32,115,115,32,115,115,32,115,115,32,115,115,13,10,49,49,48,48,58,32,105,32,115,115,32,115,115,32,115,115,32,115,115,32,115,115,32,115,13,10,48,48,48,48,58,32,105,32,115,115,32,115,115,32,115,115,32,115,115,32,115,115,32,115,115,13,10);


txt__tonly_dongs:array[0..282] of byte=(
47,47,110,111,114,109,97,108,32,99,104,105,109,101,115,32,119,105,116,104,111,117,116,32,105,110,116,114,111,39,115,32,116,101,109,112,108,97,116,101,13,10,116,101,115,116,58,32,115,115,32,115,115,32,115,115,13,10,49,53,58,32,115,13,10,51,48,58,32,115,13,10,52,53,58,32,115,13,10,48,49,48,48,58,32,115,13,10,48,50,48,48,58,32,115,115,13,10,48,51,48,48,58,32,115,115,32,115,13,10,48,52,48,48,58,32,115,115,32,115,115,13,10,48,53,48,48,58,32,115,115,32,115,115,32,115,13,10,48,54,48,48,58,32,115,115,32,115,115,32,115,115,13,10,48,55,48,48,58,32,115,115,32,115,115,32,115,115,32,115,13,10,48,56,48,48,58,32,115,115,32,115,115,32,115,115,32,115,115,13,10,48,57,48,48,58,32,115,115,32,115,115,32,115,115,32,115,115,32,115,13,10,49,48,48,48,58,32,115,115,32,115,115,32,115,115,32,115,115,32,115,115,13,10,49,49,48,48,58,32,115,115,32,115,115,32,115,115,32,115,115,32,115,115,32,115,13,10,48,48,48,48,58,32,115,115,32,115,115,32,115,115,32,115,115,32,115,115,32,115,115,13,10);


txt__tships_bells__british_royal:array[0..572] of byte=(
47,47,115,104,105,112,115,32,98,101,108,108,115,32,45,32,66,114,105,116,105,115,104,32,82,111,121,97,108,44,32,102,114,111,109,32,49,55,57,55,32,100,117,101,32,116,111,32,97,32,109,117,116,105,110,121,32,111,110,32,116,104,101,32,100,111,103,32,119,97,116,99,104,32,111,102,32,53,32,98,101,108,108,115,32,116,104,105,115,32,119,97,115,32,114,101,109,111,118,101,100,32,110,101,118,101,114,32,97,103,97,105,110,32,116,111,32,98,101,32,114,117,110,103,13,10,116,101,115,116,58,32,100,32,100,32,100,32,115,13,10,48,48,51,48,58,32,115,13,10,48,49,48,48,58,32,100,13,10,48,49,51,48,58,32,100,115,13,10,48,50,48,48,58,32,100,100,13,10,48,50,51,48,58,32,100,100,32,115,13,10,48,51,48,48,58,32,100,100,32,100,13,10,48,51,51,48,58,32,100,100,32,100,115,13,10,48,52,48,48,58,32,100,100,32,100,100,13,10,48,52,51,48,58,32,115,13,10,48,53,48,48,58,32,100,13,10,48,53,51,48,58,32,100,115,13,10,48,54,48,48,58,32,100,100,13,10,48,54,51,48,58,32,100,100,32,115,13,10,48,55,48,48,58,32,100,100,32,100,13,10,48,55,51,48,58,32,100,
100,32,100,115,13,10,48,56,48,48,58,32,100,100,32,100,100,13,10,48,56,51,48,58,32,115,13,10,48,57,48,48,58,32,100,13,10,48,57,51,48,58,32,100,115,13,10,49,48,48,48,58,32,100,100,13,10,49,48,51,48,58,32,100,100,32,115,13,10,49,49,48,48,58,32,100,100,32,100,13,10,49,49,51,48,58,32,100,100,32,100,115,13,10,48,48,48,48,58,32,100,100,32,100,100,13,10,47,47,100,111,103,32,119,97,116,99,104,32,45,32,102,105,118,101,32,98,101,108,108,32,34,100,100,32,115,34,32,114,101,109,111,118,101,100,32,100,117,101,32,116,111,32,105,116,32,98,101,105,110,103,32,117,115,101,100,32,105,110,32,97,32,109,117,110,116,105,110,121,32,105,110,32,97,114,111,117,110,100,32,49,55,57,55,13,10,49,54,51,48,58,32,115,13,10,49,55,48,48,58,32,100,13,10,49,55,51,48,58,32,100,115,13,10,49,56,48,48,58,32,100,100,13,10,49,56,51,48,58,32,115,13,10,49,57,48,48,58,32,100,13,10,49,57,51,48,58,32,100,115,13,10,50,48,48,48,58,32,100,100,32,100,100,13,10);


txt__tships_bells__standard:array[0..304] of byte=(
47,47,115,104,105,112,115,32,98,101,108,108,115,32,45,32,115,116,97,110,100,97,114,100,13,10,116,101,115,116,58,32,100,32,100,32,100,32,115,13,10,48,48,51,48,58,32,115,13,10,48,49,48,48,58,32,100,13,10,48,49,51,48,58,32,100,115,13,10,48,50,48,48,58,32,100,100,13,10,48,50,51,48,58,32,100,100,32,115,13,10,48,51,48,48,58,32,100,100,32,100,13,10,48,51,51,48,58,32,100,100,32,100,115,13,10,48,52,48,48,58,32,100,100,32,100,100,13,10,48,52,51,48,58,32,115,13,10,48,53,48,48,58,32,100,13,10,48,53,51,48,58,32,100,115,13,10,48,54,48,48,58,32,100,100,13,10,48,54,51,48,58,32,100,100,32,115,13,10,48,55,48,48,58,32,100,100,32,100,13,10,48,55,51,48,58,32,100,100,32,100,115,13,10,48,56,48,48,58,32,100,100,32,100,100,13,10,48,56,51,48,58,32,115,13,10,48,57,48,48,58,32,100,13,10,48,57,51,48,58,32,100,115,13,10,49,48,48,48,58,32,100,100,13,10,49,48,51,48,58,32,100,100,32,115,13,10,49,49,48,48,58,32,100,100,32,100,13,10,49,49,51,48,58,32,100,100,32,100,115,13,10,48,48,48,48,58,32,100,100,32,100,100,13,10);

var
   int1,p:longint;
   str1:string;
   //## xaddBells3 ##
   procedure xaddBells3(xname:string;xnote:longint);//09nov2022
   begin
   xnote:=frcrange(xnote,0,127);
   xaddBells2(0, xname, '0i14 0n'+inttostr(xnote)+' 1500x0 1500d500', '0i14 0n'+inttostr(xnote)+' 333x80 0n'+inttostr(xnote)+' 333x80 1000x80' );
   end;
   //## xaddBells4 ##
   procedure xaddBells4(xname,xstyle:string;xinstrument,xnote:longint);//09nov2022
   var
      v1,v2:string;
   begin
   //init
   xstyle:=low__lowercase(xstyle);
   xinstrument:=frcrange(xinstrument,0,127);
   xnote:=frcrange(xnote,0,127);
   //get
   if (xstyle='fog') then
      begin
      v1:='0i'+inttostr(xinstrument)+' 0n'+inttostr(xnote)+' 500x0 1500d2000';
      v2:='0i'+inttostr(xinstrument)+' 0n'+inttostr(xnote)+' 666x'+inttostr(xnote)+' 0n'+inttostr(xnote)+' 666x'+inttostr(xnote)+' 1000x'+inttostr(xnote);
      end
   else if (xstyle='mid') then
      begin
      v1:='0i'+inttostr(xinstrument)+' 0n'+inttostr(xnote)+' 1500x0 1500d500';
      v2:='0i'+inttostr(xinstrument)+' 0n'+inttostr(xnote)+' 400x'+inttostr(xnote)+' 0n'+inttostr(xnote)+' 400x'+inttostr(xnote)+' 1000x'+inttostr(xnote);
      end
   else if (xstyle='bell') then
      begin
      v1:='0i'+inttostr(xinstrument)+' 0n'+inttostr(xnote)+' 500x0 0d2000';
      v2:='0i'+inttostr(xinstrument)+' 0n'+inttostr(xnote)+' 500x0 0n'+inttostr(xnote)+' 0d1000 0x'+inttostr(xnote);
      end
   else
      begin
      v1:='0i'+inttostr(xinstrument)+' 0n'+inttostr(xnote)+' 1500x0 1500d500';
      v2:='0i'+inttostr(xinstrument)+' 0n'+inttostr(xnote)+' 333x'+inttostr(xnote)+' 0n'+inttostr(xnote)+' 333x'+inttostr(xnote)+' 1000x'+inttostr(xnote);
      end;
   //set
   xaddBells2(0,xname,v1,v2);
   end;
   //## xaddSonnerie4 ##
   procedure xaddSonnerie4(xname,xstyle:string;xgap,xinstrument,xnote,xnote2:longint);
   var
      v1,v2:string;
   begin
   //init
   xstyle:=low__lowercase(xstyle);
   xinstrument:=frcrange(xinstrument,0,127);
   xnote:=frcrange(xnote,0,127);
   xnote2:=frcrange(xnote2,0,127);
   xgap:=frcrange(xgap,0,5000);
   //get
//xaddSonnerie2(400,'Twinkle 2' , '0i9 0n80 333x80 333x80', '0i9 0n70 250x70 0n80 250x80 0n70 333x70 600x70');
   if (xstyle='faster') then
      begin
      v1:='0i'+inttostr(xinstrument)+' 0n'+inttostr(xnote)+' 333x'+inttostr(xnote)+' 333x'+inttostr(xnote);
      v2:='0i'+inttostr(xinstrument)+' 0n'+inttostr(xnote2)+' 250x'+inttostr(xnote2)+' 0n'+inttostr(xnote)+' 250x'+inttostr(xnote)+' 0n'+inttostr(xnote2)+' 333x'+inttostr(xnote2)+' 600x'+inttostr(xnote2);//fast double beat
      end
   else if (xstyle='faster2') then
      begin
      v1:='0i'+inttostr(xinstrument)+' 0n'+inttostr(xnote)+' 333x'+inttostr(xnote)+' 333x'+inttostr(xnote);
      v2:='0i'+inttostr(xinstrument)+' 0n'+inttostr(xnote)+' 250x'+inttostr(xnote)+' 0n'+inttostr(xnote2)+' 250x'+inttostr(xnote2)+' 0n'+inttostr(xnote)+' 333x'+inttostr(xnote)+' 600x'+inttostr(xnote);//fast double beat
      end
   else if (xstyle='faster3') then
      begin
      v1:='0i'+inttostr(xinstrument)+' 0n'+inttostr(xnote)+' 333x'+inttostr(xnote)+' 333x'+inttostr(xnote);
      v2:='0i'+inttostr(xinstrument)+' 0n'+inttostr(xnote2)+' 250x'+inttostr(xnote2)+' 0n'+inttostr(xnote)+' 250x'+inttostr(xnote)+' 600x'+inttostr(xnote2);//fast double beat
      end
   else if (xstyle='') then
      begin
      v1:='0i'+inttostr(xinstrument)+' 0n'+inttostr(xnote)+' 400x'+inttostr(xnote)+' 400x'+inttostr(xnote);
      v2:='0i'+inttostr(xinstrument)+' 0n'+inttostr(xnote)+' 150x'+inttostr(xnote)+' 0n'+inttostr(xnote)+' 150x'+inttostr(xnote)+' 0n'+inttostr(xnote2)+' 150x'+inttostr(xnote2)+' 0n'+inttostr(xnote2)+' 150x'+inttostr(xnote2)+' 650x'+inttostr(xnote2);//fast double beat
      end;
   //set
   xaddSonnerie2(400,xname,v1,v2);
   end;
begin
try

//Melodic Chimes --------------------------------------------------------------
xaddTitle('Melody');//15nov2022, was: 'Melodic' - 14nov2022, 12nov2022
inumberfrom1:=icount;
xaddStandard( 'None' , [0] , [0]);

xaddStandard( 'Air' , mid__0air , mid__1air );
xaddStandard( 'Air 2' , mid__0air_2 , mid__1air_2  );
xaddStandard( 'Charm'    , mid__0charm , mid__1charm );
xaddStandard2( 'Charm 2' , '0i14 50n80 700n88 700n84 700n80 2000e0' , '0i14 0n80 200n80 400n84 1400x84' );
xaddStandard2( 'Charm 3' , '0i14 0f10 50n80 700n88 700n84 700n80 2000e0' , '0i14 0f50 30n80 200n80 400n84 1600x84' );
xaddStandard2( 'Charm 4' , '0i14 0s10 0f10 50n80 700n88 700n84 700n80 2000e0' , '0i14 0s10 0f50 30n80 200n80 400n84 1600x84' );

xaddStandard( 'Cheerful' , mid__0cheerful , mid__1cheerful );

xaddStandard2( 'Chirpy'   ,'0i10 100n100 300n101 100n100 300n103 300n103 100n103 100n101 100n101 100n100 100n100 100n101 100n103 100n105 100n103 100n101 100n101100n100 100n100 100n100 1500e0', '0i10 100n100 100n100 300n101 100n100 100n100 100n101100n100 300n101 1000e0' );
xaddStandard2( 'Chirpy 2' ,'0i10 100n100 300n101 100n100 300n103 300n103 100n103 100n101 100n101 100n100 100n100 100n101 100n103 100n105 100n103 100n101 100n101100n100 100n100 100n100 1500e0', '0i10 100n100 100n100 300n101 100n100 100n100 100n101100n100 300n101 2000e0' );
xaddStandard2( 'Chirpy 3' ,'0i9 100n100 300n101 100n100 300n103 300n103 100n103 100n101 100n101 100n100 100n100 100n101 100n103 100n105 100n103 100n101 100n101100n100 100n100 100n100 1500e0', '0i9 100n100 100n100 300n101 100n100 100n100 100n101100n100 300n101 1000e0' );
xaddStandard2( 'Chirpy 4' ,'0i9 100n100 300n101 100n100 300n103 300n103 100n103 100n101 100n101 100n100 100n100 100n101 100n103 100n105 100n103 100n101 100n101100n100 100n100 100n100 1500e0', '0i9 100n100 100n100 300n101 100n100 100n100 100n101100n100 300n101 2000e0' );

xaddStandard2( 'Dignified'   , '0i14 100n70 100n70 1000n68 100n68 1000n71 100n71 1000n68 100n68 3000e0', '0i14 0n68 3000e0' );
xaddStandard2( 'Dignified 2' , '0i14 100n70 100n70 1000n68 100n68 1000n71 100n71 1000n68 100n68 3000e0', '0i14 0n68 120n68 3000e0' );
xaddStandard2( 'Dignified 3' , '0i14 100n70 100n70 1000n68 100n68 1000n71 100n71 1000n68 100n68 3000e0', '0i14 0n68 70n68 120n68 3000e0' );
xaddStandard2( 'Dignified 4' , '0i14 0s-10 100n70 100n70 1000n68 100n68 1000n71 100n71 1000n68 100n68 3000e0', '0i14 0s-10 0n68 3000e0' );
xaddStandard2( 'Dignified 5' , '0i14 0s-10 100n70 100n70 1000n68 100n68 1000n71 100n71 1000n68 100n68 3000e0', '0i14 0s-10 0n68 70n68 120n68 3000e0' );
xaddStandard2( 'Dignified 6' , '0i14 0s20 100n70 100n70 1000n68 100n68 1000n71 100n71 1000n68 100n68 3000e0', '0i14 0s20 0n68 3000e0' );
xaddStandard2( 'Dignified 7' , '0i14 0s20 100n70 100n70 1000n68 100n68 1000n71 100n71 1000n68 100n68 3000e0', '0i14 0s20 0n68 70n68 120n68 3000e0' );

xaddStandard( 'Elegance' , mid__0elegance_2 , mid__1elegance_2 );
xaddStandard( 'Fallows' , mid__0fallows , mid__1fallows );
xaddStandard( 'Fallows 2' , mid__0fallows_2 , mid__1fallows_2 );


xaddStandard2('Festive','0i14 0s-10 0f50 0n99 100x99 0n100 100x100 0n99 100x99 0n100 100x100 0n99 200x99 0n100 100x100 0n99 100x99 0n100 200x100 0n99 100x99 0n100 1800x100','0i14 0s-10 0f50 0n99 100x99 0n100 100x100 0n99 100x99 0n100 1800x100');
xaddStandard2('Festive 2','0i14 0s-8 0f40 0n99 100x99 0n100 100x100 0n99 100x99 0n100 100x100 0n99 200x99 0n100 100x100 0n99 100x99 0n100 200x100 0n99 100x99 0n100 1800x100','0i14 0s-8 0f40 0n99 100x99 0n100 100x100 0n99 100x99 0n100 1800x100');
xaddStandard2('Festive 3','0i11 0s-7 0f40 0n99 100x99 0n100 100x100 0n99 100x99 0n100 100x100 0n99 200x99 0n100 100x100 0n99 100x99 0n100 200x100 0n99 100x99 0n100 1800x100','0i11 0s-7 0f40 0n99 100x99 0n100 100x100 0n99 100x99 0n100 1800x100');

xaddStandard( 'Fields Of Reflection' , mid__0fields_of_reflection , mid__1fields_of_reflection );
xaddStandard( 'Fields Of Reflection 2' , mid__0fields_of_reflection_2 , mid__1fields_of_reflection_2 );

xaddStandard2( 'Firmly' ,   '0i14 0n85 200x85 0n85 200x85 0n88 200x88 0n88 200x88 0n80 2000x80', '0i14 0n80 1000x80' );
xaddStandard2( 'Firmly 2' , '0i14 0n85 200x85 0n85 200x85 0n88 200x88 0n88 200x88 0n80 2000x80', '0i14 0n88 2000x88' );
xaddStandard2( 'Firmly 3' , '0i14 0n85 200x85 0n85 200x85 0n88 200x88 0n88 200x88 0n80 2000x80', '0i14 0n80 2000x80' );
xaddStandard2( 'Firmly 4' , '0i14 0n85 200x85 0n85 200x85 0n88 200x88 0n88 200x88 0n80 2000x80', '0i14 0n79 700x79 0n80 2000x80' );
xaddStandard2( 'Firmly 5' , '0i14 0n85 200x85 0n85 200x85 0n88 200x88 0n88 200x88 0n80 3000x80', '0i14 0n85 200x85 0n85 200x85 0i14 0n80 200x80 0n80 2000x80' );
xaddStandard2( 'Firmly 6' , '0i14 0n85 200x85 0n85 200x85 0n88 200x88 0n88 200x88 0n80 3000x80', '0i14 0n85 200x85 0n85 200x85 0n85 200x85 0n85 200x85 0n80 2000x80' );
xaddStandard2( 'Firmly 7' , '0i14 0n85 200x85 0n85 200x85 0n88 200x88 0n88 200x88 0n80 3000x80', '0i14 0n85 200x85 0n83 200x83 0n85 200x85 0n83 200x83 0n80 2000x80' );
xaddStandard2( 'Firmly 8' , '0i14 0n85 200x85 0n85 200x85 0n88 200x88 0n88 200x88 0n80 3000x80', '0i14 0n88 200x88 0n88 200x88 0n80 2000x80' );
xaddStandard2( 'Firmly 9' , '0i14 0n85 200x85 0n85 200x85 0n88 200x88 0n88 200x88 0n80 3000x80', '0i14 0n88 200x88 0n88 200x88 0n92 4000x92' );
xaddStandard2( 'Firmly 10' , '0i14 0s-10 0n85 200x85 0n85 200x85 0n88 200x88 0n88 200x88 0n80 3000x80', '0i14 0s-10 0n88 200x88 0n88 200x88 0n80 2000x80' );
xaddStandard2( 'Firmly 11' , '0i14 0s-20 0n85 200x85 0n85 200x85 0n88 200x88 0n88 200x88 0n80 3000x80', '0i14 0s-20 0n88 200x88 0n88 200x88 0n80 3000x80' );
xaddStandard2( 'Firmly 12' , '0i14 0s-30 0n85 200x85 0n85 200x85 0n88 200x88 0n88 200x88 0n80 3000x80', '0i14 0s-30 0n88 200x88 0n88 200x88 0n80 3000x80' );
xaddStandard2( 'Firmly 13' , '0i14 0s10 0n85 200x85 0n85 200x85 0n88 200x88 0n88 200x88 0n80 3000x80', '0i14 0s10 0n88 200x88 0n88 200x88 0n92 4000x92' );

xaddStandard( 'Harmony' , mid__0harmony , mid__1harmony );
xaddStandard( 'Melody' , mid__0melody , mid__1melody );
xaddStandard( 'Melody 2' , mid__0melody_2 , mid__1melody_2 );

xaddStandard( 'Peaceful Pleasantries'    , mid__0peaceful_pleasantries , mid__1peaceful_pleasantries );
xaddStandard3( 'Peaceful Pleasantries 2' , '', '0i14 0f100 50n86 100n86 100x86 0n90 100x90 0n86 1000x86', mid__0peaceful_pleasantries , [0] );

xaddStandard( 'Succession' , mid__0succession , mid__1succession );
xaddStandard( 'Succession 2' , mid__0succession_2 , mid__1succession_2 );
xaddStandard3( 'Succession 3' , '', '0i14 0n71 150n74 150n72 2000e0', mid__0succession_2 , [0] );

xaddStandard2( 'Suspense' , '0i14 0n92 100x92 0n91 100x91 0n90 100x90 0n89 100x89 0n90 100x90 0n92 100x92 0n89 100x89 0n89 100x89 0n87 100x87 0n89 100x89 0n89 100x89 0n89 100x89 0n92 2000x92', '0i14 0n90 100x90 0n90 100x90 0n90 800x90' );
xaddStandard2( 'Suspense 2' , '0i14 0n92 100x92 0n91 100x91 0n90 100x90 0n89 100x89 0n90 100x90 0n92 100x92 0n89 100x89 0n89 100x89 0n87 100x87 0n89 100x89 0n89 100x89 0n89 100x89 0n92 2000x92', '0i14 0n90 100x90 0n90 100x90 0n90 1800x90' );
xaddStandard2( 'Suspense 3' , '0i14 0n92 100x92 0n91 100x91 0n90 100x90 0n89 100x89 0n90 100x90 0n92 100x92 0n89 100x89 0n89 100x89 0n87 100x87 0n89 100x89 0n89 100x89 0n89 100x89 0n92 2000x92', '0i14 0n90 100x90 0n95 100x95 0n89 1800x90' );

xaddStandard( 'Tinkle' , mid__0tinkle , mid__1tinkle );
xaddStandard2( 'Twinkle'   , '0i9 0f10 0n100 100x100 0n105 100x105 0n108 100x108 0n103 100x103 0n105 100x105 0n100 2000x100', '0i9 0n105 100x105 0n105 100x105 0n100 1800x100' );
xaddStandard2( 'Twinkle 2' , '0i9 0f20 0n100 100x100 0n105 100x105 0n108 100x108 0n103 100x103 0n105 100x105 0n100 2000x100', '0i9 0n105 100x105 0n105 100x105 0n100 3000x100' );
xaddStandard2( 'Twinkle 3' , '0i9 0f10 0n100 100x100 0n105 100x105 0n105 100x105 0n105 100x105 0n105 100x105 0n100 2000x100', '0i9 0n105 100x105 0n105 100x105 0n100 1800x100' );

xaddStandard( 'Westminster' , mid__0westminster , mid__1westminster );
xaddStandard( 'Westminster 2' , mid__0westminster_2 , mid__1westminster_2 );



//Ships Bells Chimes -----------------------------------------------------------
xaddTitle('Ships Bells');
inumberfrom2:=icount;

xaddBells4('Foggy','fog',48,40);
xaddBells4('Foggy 2','fog',48,50);

xaddBells4('High Bells','bell',4,100);
xaddBells4('High Bells 2','bell',4,102);
xaddBells4('High Bells 3','bell',4,104);
xaddBells4('High Bells 4','bell',4,106);
xaddBells4('High Bells 5','bell',4,108);
xaddBells4('High Bells 6','bell',4,110);

xaddBells4('Low Bells','',14,70);
xaddBells4('Low Bells 2','',14,71);
xaddBells4('Low Bells 3','',14,72);
xaddBells4('Low Bells 4','',14,74);
xaddBells4('Low Bells 5','',14,76);
xaddBells4('Low Bells 6','',14,78);
xaddBells4('Low Bells 7','',14,80);

xaddBells4('Solemn','',14,60);
xaddBells4('Solemn 2'  ,'fog',14,60);
xaddBells4('Solemn 3','fog',14,62);
xaddBells4('Solemn 4','fog',14,64);

xaddBells4('Tubular','mid',8,70);
xaddBells4('Tubular 2','mid',8,71);
xaddBells4('Tubular 3','mid',8,72);
xaddBells4('Tubular 4','mid',8,74);
xaddBells4('Tubular 5','mid',8,76);
xaddBells4('Tubular 6','mid',8,78);
xaddBells4('Tubular 7','mid',8,80);

xaddBells3('Zing',101);
xaddBells3('Zing 2',103);
xaddBells3('Zing 3',105);
xaddBells3('Zing 4',107);


//Sonnerie Chimes --------------------------------------------------------------
xaddTitle('Sonnerie');
inumberfrom3:=icount;
//.sonnerie -> Note: As of 16mar2022 rapid fire midis like these are used to construct a complete midi housing the entire chiming sequence for ultra-smooth chiming for switch note changes - 16mar2022
//was: xaddSonnerie2(400,'Twinkle' , '0i9 0n100 400x100 400x100', '0i9 0n100 150x100 0n100 150x100 0n105 150x105 0n105 150x105 650x105');//fast double beat
xaddSonnerie4('Bells','faster',400,9,80,70);
xaddSonnerie4('Bells 2','faster',400,9,90,95);
xaddSonnerie4('Bells 3','faster2',400,9,95,97);
xaddSonnerie4('Bells 4','faster3',400,9,95,99);

xaddSonnerie4('Tubular','faster',400,8,88,99);
xaddSonnerie4('Tubular 2','faster2',400,8,88,99);
xaddSonnerie4('Tubular 3','faster3',400,8,88,99);

xaddSonnerie4('Twinkle'  ,'faster',400,9,100,105);
xaddSonnerie4('Twinkle 2','faster2',400,9,100,105);
xaddSonnerie4('Twinkle 3','faster3',400,9,100,105);

xaddSonnerie4('Zing'    ,'faster' ,400,14,102,103);
xaddSonnerie4('Zing 2'  ,'faster2',400,14,102,103);
xaddSonnerie4('Zing 3'  ,'faster3',400,14,102,103);
xaddSonnerie4('Zing 4'  ,'faster' ,400,14,106,107);
xaddSonnerie4('Zing 5'  ,'faster2',400,14,106,107);
xaddSonnerie4('Zing 6'  ,'faster3',400,14,106,107);

{was:
xaddSonnerie4('Zing'    ,'faster' ,400,14,110-4,112-4);
xaddSonnerie4('Zing 2'  ,'faster2',400,14,110-4,112-4);
xaddSonnerie4('Zing 3'  ,'faster3',400,14,110-4,112-4);
xaddSonnerie4('Zing 4'  ,'faster' ,400,14,114-6,116-8);
xaddSonnerie4('Zing 5'  ,'faster2',400,14,114-6,116-8);
xaddSonnerie4('Zing 6'  ,'faster3',400,14,114-6,116-8);
{}

//Buzzer Chimes ----------------------------------------------------------------
addbuzzer('Attention','0i14 0n99 100x99 0n100 100x100 0n99 100x99 0n100 100x100 0n99 100x99 0n100 100x100 0n99 100x99 0n100 100x100 0n99 100x99 0n100 500x100',[0]);
addbuzzer('Attention','0i14 0n99 100x99 0n100 100x100 0n99 100x99 0n100 100x100 0n99 100x99 0n100 100x100 0n99 100x99 0n100 100x100 0n99 100x99 0n100 1500x100',[0]);
addbuzzer('Attention','0i14 0n99 100x99 0n100 100x100 0n99 100x99 0n100 100x100 0n99 100x99 0n100 100x100 0n99 100x99 0n100 100x100 0n99 100x99 0n100 4000x100',[0]);

//.double
str1:='Double';
addbuzzer(str1,'0i14 0n90 1000x90 0n92 2000x92',[0]);
addbuzzer(str1,'0i14 0n80 500x80 0n70 2000x75',[0]);
addbuzzer(str1,'0i14 0n80 500x80 0n70 4000x75',[0]);
addbuzzer(str1,'0i14 0n60 500x60 0n62 1500x62',[0]);
addbuzzer(str1,'0i15 0n80 500x80 0n78 1500x78',[0]);
addbuzzer(str1,'0i15 0n80 500x80 0n78 500x78',[0]);
addbuzzer(str1,'0i10 0n80 500x80 0n78 500x78',[0]);
addbuzzer(str1,'0i14 0n90 200x90 0n91 500x91',[0]);
addbuzzer(str1,'0i14 0s-10 0n90 200x90 0n91 500x91',[0]);
addbuzzer(str1,'0i14 0s-20 0n90 200x90 0n91 500x91',[0]);

addbuzzer('Low Dong','',mid__1westminster);
addbuzzer('Low Dong','0i14 0n60 4000x60',[0]);

addbuzzer('Melody','',mid__1air);
addbuzzer('Melody','',mid__1melody);
addbuzzer('Melody','',mid__1succession);
addbuzzer('Melody','',mid__0peaceful_pleasantries);
addbuzzer('Melody','0i14 0n85 200x85 0n85 200x85 0n88 200x88 0n88 200x88 0n80 2000x80',[0]);

str1:='Quadruple';
addbuzzer(str1,'0i14 0n85 200x85 0n87 200x87 0n89 200x89 0n91 1300x91',[0]);
addbuzzer(str1,'0i14 0n85 200x85 0n82 200x82 0n80 200x80 0n91 1300x91',[0]);
addbuzzer(str1,'0i14 0n85 100x85 0n87 100x87 0n89 100x89 0n91 1300x91',[0]);
addbuzzer(str1,'0i14 0n85 100x85 0n87 100x87 0n89 100x89 0n91 4000x91',[0]);

addbuzzer(str1,'0i14 0s-10 0n85 200x85 0n87 200x87 0n89 200x89 0n91 2300x91',[0]);
addbuzzer(str1,'0i14 0s-10 0n85 200x85 0n82 200x82 0n80 200x80 0n91 2300x91',[0]);
addbuzzer(str1,'0i14 0s-10 0n85 100x85 0n87 100x87 0n89 100x89 0n91 2300x91',[0]);
addbuzzer(str1,'0i14 0s-10 0n85 100x85 0n87 100x87 0n89 100x89 0n91 5000x91',[0]);

addbuzzer(str1,'0i14 0s-20 0n85 200x85 0n87 200x87 0n89 200x89 0n91 2300x91',[0]);
addbuzzer(str1,'0i14 0s-20 0n85 200x85 0n82 200x82 0n80 200x80 0n91 2300x91',[0]);
addbuzzer(str1,'0i14 0s-20 0n85 100x85 0n87 100x87 0n89 100x89 0n91 2300x91',[0]);
addbuzzer(str1,'0i14 0s-20 0n85 100x85 0n87 100x87 0n89 100x89 0n91 5000x91',[0]);

//.single
str1:='Single';
addbuzzer(str1,'0i14 0n90 700e0',[0]);
addbuzzer(str1,'0i14 0n90 1200e0',[0]);
addbuzzer(str1,'0i14 0n90 3000e0',[0]);
addbuzzer(str1,'0i14 0n88 700e0',[0]);
addbuzzer(str1,'0i14 0n88 1200e0',[0]);
addbuzzer(str1,'0i14 0n88 3000e0',[0]);
addbuzzer(str1,'0i14 0n85 1200e0',[0]);
addbuzzer(str1,'0i14 0n82 1500e0',[0]);
addbuzzer(str1,'0i14 0n80 1500e0',[0]);
addbuzzer(str1,'0i14 0n75 2000e0',[0]);
addbuzzer(str1,'0i14 0n70 2000e0',[0]);
addbuzzer(str1,'0i14 0n65 2000e0',[0]);
addbuzzer(str1,'0i14 0n60 2000e0',[0]);
addbuzzer(str1,'0i14 0n55 2000e0',[0]);
addbuzzer(str1,'0i14 0n50 2000e0',[0]);


addbuzzer('Suspense'    ,'0i14 0n92 100x92 0n91 100x91 0n90 100x90 0n89 100x89 0n90 100x90 0n92 100x92 0n89 100x89 0n89 100x89 0n87 100x87 0n89 100x89 0n89 100x89 0n89 100x89 0n92 2000x92',[0]);
addbuzzer('Suspense' , '0i14 0s2 0n92 100x92 0n91 100x91 0n90 100x90 0n89 100x89 0n90 100x90 0n92 100x92 0n89 100x89 0n89 100x89 0n87 100x87 0n89 100x89 0n89 100x89 0n89 100x89 0n92 2000x92',[0]);
addbuzzer('Suspense' , '0i14 0n90 100x90 0n90 100x90 0n90 1800x90',[0]);

addbuzzer('Tinkle' , '',mid__0tinkle);

str1:='Triple';
addbuzzer(str1,'0i14 0n80 500x80 0n82 500x82 0n84 1300x84',[0]);
addbuzzer(str1,'0i14 0n80 100x80 0n82 100x82 0n87 1300x87',[0]);
addbuzzer(str1,'0i14 0n80 100x80 0n82 100x82 0n84 700x84',[0]);

addbuzzer(str1,'0i14 0s-10 0n80 500x80 0n82 500x82 0n84 1300x84',[0]);
addbuzzer(str1,'0i14 0s-10 0n80 100x80 0n82 100x82 0n87 1300x87',[0]);
addbuzzer(str1,'0i14 0s-10 0n80 100x80 0n82 100x82 0n84 700x84',[0]);

addbuzzer(str1,'0i14 0s-20 0n80 500x80 0n82 500x82 0n84 1300x84',[0]);
addbuzzer(str1,'0i14 0s-20 0n80 100x80 0n82 100x82 0n87 1300x87',[0]);
addbuzzer(str1,'0i14 0s-20 0n80 100x80 0n82 100x82 0n84 700x84',[0]);

except;end;
end;
//## getchiming ##
function tbasicchimes.getchiming:boolean;
begin//covers seeking, worklist setup and playing of chimes - 02mar2022
try;result:=(imustplay>=0) or (iworklist<>'') or iplaying;except;end;
end;
//## chimingpert ##
function tbasicchimes.chimingpert:double;
begin
try;if (iworkcount=1) and iplaying then result:=low__makepertD0(mid_pos+1,mid_len+1) else result:=low__makepertD0(iworkpos,iworkcount+1);except;end;
end;
//## canstop ##
function tbasicchimes.canstop:boolean;
begin
try;result:=(not imuststop) and chiming;except;end;
end;
//## stop ##
procedure tbasicchimes.stop;
begin
try;imuststop:=true;except;end;
end;
//## mustplayname ##
function tbasicchimes.mustplayname(xname:string;xmins:longint):boolean;
var
   int1:longint;
begin
try;findname(xname,int1);result:=mustplayindex(int1,xmins);except;end;
end;
//## mustplayindex ##
function tbasicchimes.mustplayindex(xindex,xmins:longint):boolean;
var
   h23,m59,int1:longint;
begin
try
result:=false;
xindex:=frcrange(xindex,0,frcmin(icount-1,0));
h23:=xmins div 60;
m59:=xmins-(h23*60);
result:=(xindex>=1) and ((m59=0) or (m59=15) or (m59=30) or (m59=45));
except;end;
end;
//## canplay ##
function tbasicchimes.canplay:boolean;
begin
try;result:=(icount>=1) and mid_ok;except;end;
end;
//## playname ##
procedure tbasicchimes.playname(xname:string;xmins:longint;x0,x15,x30,x45,xtest:boolean);
var
   int1:longint;
begin
try;findname(xname,int1);playindex(int1,xmins,x0,x15,x30,x45,xtest);except;end;
end;
//## playname3 ##
procedure tbasicchimes.playname3(xname:string;xmins:longint;n0,n15,n30,n45,b0,s0,s15,s30,s45,xtest:boolean);
var
   int1:longint;
begin
try
findname(xname,int1);
case istyle[int1] of
chmsStandard:playindex(int1,xmins,n0,n15,n30,n45,xtest);
chmsBells   :playindex(int1,xmins,b0,true,true,true,xtest);
chmsSonnerie:playindex(int1,xmins,s0,s15,s30,s45,xtest);
end;//case
except;end;
end;
//## playname2 ##
procedure tbasicchimes.playname2(xname:string);
var
   int1:longint;
begin
try;findname(xname,int1);playindex2(int1);except;end;
end;
//## playindex ##
procedure tbasicchimes.playindex(xindex,xmins:longint;x0,x15,x30,x45,xtest:boolean);
begin
try
iworkmins:=xmins;
iwork0 :=x0;
iwork15:=x15;
iwork30:=x30;
iwork45:=x45;
iworktest:=xtest;
imustplay:=frcrange(xindex,0,frcmin(icount-1,0));
except;end;
end;
//## playindex2 ##
procedure tbasicchimes.playindex2(xindex:longint);
begin
try;imustplay:=frcrange(xindex,0,frcmin(icount-1,0));except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxx//cccccccccccccccc
//## _ontimer ##
procedure tbasicchimes._ontimer(sender:tobject);
label
   redo,dobuzzer;
var
   xworkindex,int1:longint;
   v:string;
   a:tstr8;
   //## mok ##
   function mok(x:tstr8;var xout:tstr8):boolean;
   begin
   result:=(x<>nil) and (x.len>=2);//1 or less is considered an empty or NIL midi - 02mar2022
   xout:=x;
   end;
   //## xstop ##
   procedure xstop;
   begin
   mid_stop;
   mid_setpos(-1);//required in-order for midi playback to recommence properly - 02mar2022
   end;
   //## xplay ##
   procedure xplay(x:tstr8);
   begin
   mid_stop;
   if (x<>nil) and (x.len>=2) then mid_playmidi(x);
   mid_setpos(-1);//required in-order for midi playback to recommence properly - 02mar2022
   end;
   //## xresetSpecials ##
   procedure xresetSpecials;
   begin
   ipausenote64:=0;
   mid_setspeed2(100);
   mid_setvol2(ivol);//13mar2022
   end;
   //## wval ##
   function wval:string;//variable length worklist value - 16mar2022
   var
      p:longint;
   begin
   result:='';
   if (iworklist<>'') then
      begin
      for p:=1 to length(iworklist) do if (iworklist[p-1+stroffset]='/') then
         begin
         result:=strcopy1(iworklist,1,p-1);
         strdel1(iworklist,1,p);
         break;
         end;
      end;
   end;
begin
try
//check
if (ibuzzer2>=1) and (not ibuzzerpaused) then goto dobuzzer;

//muststop
if imuststop or (imustplay>=0) then//note: stop current playback before starting a new playback - 02mar2022
   begin
   xstop;
   iplaying:=false;
   iworklist:='';
   iworkpos:=0;
   iworkcount:=1;
   xresetSpecials;
   if ibuzzerpaused then mid_setvol2(20);//start soft and grow louder
   imuststop:=false;
   end;

//mustplay
if (imustplay>=0) then
   begin
   iplaying:=true;
   xresetSpecials;
   iworkindex:=imustplay;//chime to play
   findworklist(iworkindex,iworkmins,iwork0,iwork15,iwork30,iwork45,iworktest,iworklist);//even a empty list will proceed onto the "playback" handler below for consistent AND predictable execution - 03mar2022
   iworkpos:=0;
   iworkcount:=frcmin(length(iworklist),1);
   imustplay:=-1;//off
   end;

//playback
//yyyyyyy (system_program as tbasicprg2).rootwin.xhead.caption:=bnc(app__fastOK)+bnc(app__turboOK)+'<<'+ms64str;//xxxxxxxxxxxxxxx
if iplaying then
   begin
   //.ultra-fast timing - 16mar2022
   app__turbo;
   //.realtime chime vol sync - 13mar2022
   if (ivol<>mid_vol2) then mid_setvol2(ivol);
   //.continue
   xworkindex:=iworkindex;
   if ((ipausenote64=0) or (ms64>=ipausenote64)) and (not mid_seeking) and mid_canplaymidi and (not imuststop) and ((mid_pos>=mid_len) or (not mid_playing)) then
      begin
redo:
      //.playback finished -> stop playback system
      if (iworklist='') then imuststop:=true
      else
         begin
         //init
         v:=low__lowercase(strcopy1(iworklist,1,1));
         strdel1(iworklist,1,1);
         iworkpos:=frcrange(iworkpos+1,0,iworkcount);//07mar2022
         //get
         if (v='i') then
            begin
            if mok(iintro[xworkindex],a) then xplay(a) else goto redo;
            end
         else if (v='s') then
            begin
            if mok(idong[xworkindex],a) then xplay(a) else goto redo;
            end
         else if (v='d') then
            begin
            if mok(idong2[xworkindex],a) then xplay(a) else goto redo;
            end
         else if (v='g') then//variable length gap
            begin
            int1:=frcrange(strint(wval),0,5000);//0-5s
            ipausenote64:=low__add64(ms64,(int1*10000) div frcmin(mid_speed*mid_speed2,1));
            end
         else if (v='t') then//a multi-part chiming sequence as one large TEMP midi
            begin
            if mok(itemp[xworkindex],a) then xplay(a) else goto redo;
            end
         else if (v='a') or (v='b') or (v='c') then
            begin
            //init
            if      (v='a') then int1:=300
            else if (v='b') then int1:=600
            else if (v='c') then int1:=900
            else                 int1:=300;
            //get
            ipausenote64:=low__add64(ms64,(int1*10000) div frcmin(mid_speed*mid_speed2,1));
            end
         else if (v='0') then mid_setspeed2(100)
         else if (v='1') then mid_setspeed2(110)
         else if (v='2') then mid_setspeed2(120)
         else if (v='3') then mid_setspeed2(130)
         else if (v='4') then mid_setspeed2(140)
         else if (v='5') then mid_setspeed2(150)
         else if (v='6') then mid_setspeed2(160)
         else if (v='7') then mid_setspeed2(170)
         else if (v='8') then mid_setspeed2(180)
         else if (v='9') then mid_setspeed2(190)
         else goto redo;
         end;
      end;
   end;

//mustbuzzer + buzzer - Special Note: Playback of above chime takes priority over buzzer, it will interrupt the buzzer and then recommence buzzer when chime completes - 03mar2022
dobuzzer:

//.stop buzzer
if (ibuzzer=0) and (ibuzzer2<>ibuzzer) and ( (iplaying or ibuzzerpaused) or ((not mid_seeking) and mid_canplaymidi and ((mid_pos>=mid_len) or (not mid_playing))) ) then
   begin
   if not iplaying then
      begin
      xstop;
      xresetSpecials;
      end;
   ibuzzerpaused:=false;
   ibuzzer2:=0;
   end
//.start buzzeer
else if (ibuzzer>=1) and (ibuzzer2<>ibuzzer) and (not iplaying) and (not imuststop) and (imustplay<0) and (not mid_seeking) and mid_canplaymidi then
   begin
   xstop;
   xresetSpecials;
   mid_setvol2(20);//start soft and grow louder
   ibuzzerpaused:=false;
   ibuzzer2:=ibuzzer;
   end;

//.play buzzer
if (ibuzzer2>=1) and (not mid_seeking) and mid_canplaymidi and ((mid_pos>=mid_len) or (not mid_playing)) then
   begin
   if iplaying or imuststop or (imustplay>=0) then
      begin
      ibuzzerpaused:=true;
      end
   else
      begin
      ibuzzerpaused:=false;
      if (mid_vol2<100) then mid_setvol2(frcmax(mid_vol2+5,100));
      //.play specific buzzer
      if (ibuzzer2>=1) then
         begin
         int1:=frcrange(ibuzzer2,low(ibuzzers),high(ibuzzers));
         xplay(ibuzzers[int1]);
         end;
      end;
   end;
except;end;
end;
//## xgrabfiles ##
procedure tbasicchimes.xgrabfiles;//grabs mid/txt files from old chimerdata2015 folder and converts into Delphi code ready for inclusion in the "gossdat" unit - 02mar202
//*** *** disable below code before releasing program *** ***
begin
{
var
   a,b,c,d:tstr8;
   p:longint;
   xfolder:string;
   //## xreadfiles ##
   function xreadfiles(xmask:string;xmid3:boolean):boolean;
   label
      skipend;
   var
      xstyle,xtep,p:longint;
      xsize:comp;
      nn,n0,n1,n2,dext,dname,e,xname,xlabel:string;
      //## xcleanname ##
      function xcleanname(x:string):string;//trailing "ii => 2" and "i => nil"
      var
         xlen,p:longint;
         v:string;
      begin
      try
      //defaults
      result:=x;
      xlen:=length(result);
      //get
      if (xlen>=2) then
         begin
         for p:=length(result) downto frcmin(length(result)-3,1) do
         begin
         if (strbyte1x(result,p)=32) then
            begin
            v:=low__lowercase(strcopy1(result,p,xlen));
            if (v=' ii') then v:=' 2' else v:='';
            result:=strcopy1(result,1,p-1)+v;
            break;
            end;
         end;//p
         end;
      except;end;
      end;
      //## xadd ##
      function xadd(n:string;var xcodename:string):boolean;
      var
         dext,dname:string;
      begin
      try
      //defaults
      xcodename:='';
      //get
      if not low__fromfile(xfolder+n,b,e) then
         begin
         b.clear;
         b.aadd([0]);
         end;
      //set
      dext:=lowercase__readfileext(n);
      dname:=swapcharsb(xcleanname(remlastext(n)),#32,'_');
      //.codename
      xcodename:=low__lowercase(dext+'__'+dname);
      xcodename:=low__remcharb(xcodename,'-');
      //.add
      c.sadd(xcodename+b.textarray+rcode+rcode);
      //successful
      result:=true;
      except;end;
      end;
   begin
   try
   //defaults
   result:=false;
   //get
   low__navlist(a,nlName,xfolder,xmask,'',false,false,true);
   for p:=0 to maxint do
   begin
   case low__navget(a,p,xstyle,xtep,xsize,xname,xlabel) of
   true:begin
      if xmid3 then
         begin
         //nice name      //low__asname(
         nn:=xcleanname(remlastext(xname));
         nn:=low__asname(strcopy1(nn,2,length(nn)));

         c.sadd('//'+nn+'.mid - 0=intro, 1=single dong, 2=double dong (ships bells)'+rcode);
         //0 - intro
         xadd(xname,n0);
         //1 - single dong
         xadd('1'+strcopy1(xname,2,length(xname)),n1);
         //2 - double dong (Ships Bells)
         xadd('2'+strcopy1(xname,2,length(xname)),n2);
         c.sadd(rcode);//blank line
         //addchime code
         d.sadd('xadd( '''+nn+''' , '+n0+' , '+n1+' , '+n2+' );'+rcode);
         end
      else
         begin
         xadd(xname,nn);
         c.sadd(rcode);//blank line
         end;
      end;
   false:break;
   end;
   end;//p
   //successful
   result:=true;
   skipend:
   except;end;
   end;
begin
try
//defaults
a:=nil;
b:=nil;
c:=nil;
d:=nil;

//init
a:=bnew;
b:=bnew;
c:=bnew;
d:=bnew;
xfolder:='c:\123blaiz\EasyReadClock\chimerdata2015\';

//files
xreadfiles('0*.mid',true);
c.sadd('//Dong pattern files - i=intro, s=single dong, d=double dong (ships bells)'+rcode);
xreadfiles('t*.txt',false);

except;end;
try
//copy to clipboard
clipboard.astext:=c.text+rcode+rcode+d.text;
//free
bfree(a);
bfree(b);
bfree(c);
bfree(d);
except;end;
{}//*** *** disable above code before releasing program *** ***
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//ccccccccccccccccccc
//## findworklist ##
function tbasicchimes.findworklist(xindex,xmins:longint;x0,x15,x30,x45,xtest:boolean;var xworklist:string):boolean;
label//Note: x0=intro or not etc - 15mar20222
   skipend;
var
   dstyle,xstyle,p,h,h12,m:longint;
   v,n23,n12:string;
   xmustdong2:boolean;
   //## xset ##
   function xset(x:string):boolean;
   begin
   result:=true;//pass-thru
   xworklist:=x;
   end;
   //## xset2 ##
   function xset2(x:string;xuse:boolean):boolean;
   begin
   result:=true;//pass-thru
   if xuse then xworklist:=x;
   end;
   //## ms ##
   function ms(xcount:longint):string;//make single dong
   var
      p:longint;
   begin
   result:='';
   if (xcount>=1) then for p:=1 to (xcount) do result:=result+'s';
   end;
   //## md ##
   function md(xcount:longint):string;//make double dong
   var
      p:longint;
   begin
   result:='';
   if (xcount>=1) then for p:=1 to (xcount) do result:=result+'d';
   end;
   //## mgap ##
   function mgap(xms:longint):string;//make MS gap
   begin
   result:='';
   if (xms>=1) then result:='g'+inttostr(xms)+'/';//terminator symbol
   end;
   //## h112 ##
   function h112:longint;//always returns 1 to 12
   begin
   result:=h12;
   if (result=0) then result:=12;
   end;
   //## mSonnerie ##
   function mSonnerie(xgap,xcount1,xcount2:longint;xdong,xdong2:string;var xtemp:tstr8):string;
   var
      p:longint;
      e,str1:string;
   begin
   try
   //defaults
   result:='t';
   //check
   if (xtemp=nil) then xtemp:=bnew;
   //range
   xcount1:=frcmin(xcount1,0);
   xcount2:=frcmin(xcount2,0);
   xgap:=frcrange(xgap,0,5000);//0-5s
   //init
   xtemp.clear;
   //get
   str1:='';
   if (xcount1>=1) then
      begin
      //get
      for p:=1 to xcount1 do str1:=str1+xdong+#32;
      end;
   if (xcount2>=1) then
      begin
      //gap
      if (xcount1>=1) and (xgap>=1) then str1:=str1+'0x0 '+inttostr(xgap)+'x0 ';//2 note-off's will cause a silent delay
      //get
      for p:=1 to xcount2 do str1:=str1+xdong2+#32;
      end;
   //set
   xtemp.clear;
   low__makemid(str1,xtemp,e);
   except;end;
   end;
begin//note: xindex=chime index, xstyle=melody, standard, ships, ships - british, sonneque, xmins=total mins 0..1439 (1 whole day), xtest=return test sequence instead of current time
try
//defaults
result:=false;
xworklist:='';
xmustdong2:=false;
//check
xindex:=frcrange(xindex,0,high(iname));
if (xindex=0) then goto skipend;//1st chime name is "None" - e.g. No Chiming - 04mar2022
//init
xstyle:=istyle[xindex];
//test
if xtest then
   begin
   case xstyle of
   chmsStandard   :xmins:=420;//"0700"
   chmsBells      :xmins:=1170;//"1930"
   chmsSonnerie   :xmins:=low__aorb(465,420,x0 or (not x45));//"0745" or "0700"
   end;//case
   end;
//range
xmins:=frcrange(xmins,0,1439);
h:=frcrange(xmins div 60,0,23);//0..23
h12:=h;
if (h12>12) then h12:=frcrange(h12-12,0,11);//0..11
m:=frcrange(xmins-(h*60),0,59);//0..59
n23:=low__digpad11(h,2)+low__digpad11(m,2);
n12:=low__digpad11(h12,2)+low__digpad11(m,2);
//init
if (xstyle=chmsTitle)          then goto skipend//can't play a title!
else if (xstyle=chmsStandard)  then dstyle:=low__aorb(0,1,x0)//intro+dongs OR dongs only
else if (xstyle=chmsBells)     then dstyle:=low__aorb(2,3,x0)//ships bells OR british royal
else if (xstyle=chmsSonnerie)  then dstyle:=low__aorb(4,5,x0)//grande sonnerie OR petite sonnerie
else                                goto skipend;

//get
//.melody + dongs
if (dstyle=0) then
   begin
   if      (m=15)       then xset2('s',x15)
   else if (m=30)       then xset2('s',x30)
   else if (m=45)       then xset2('s',x45)
   else if (m=0)        then xset('i'+ms(h112));//0 - o'clock
   end
//.dongs only
else if (dstyle=1) then
   begin
   if      (m=15)       then xset2('s',x15)
   else if (m=30)       then xset2('s',x30)
   else if (m=45)       then xset2('s',x45)
   else if (m=0)        then xset(ms(h112));//0 - o'clock
   end
//ships bells - standard
else if (dstyle=2) then
   begin
   xmustdong2:=true;
   if      (n12='0030') then xset('s')
   else if (n12='0100') then xset('d')
   else if (n12='0130') then xset('ds')
   else if (n12='0200') then xset('dd')
   else if (n12='0230') then xset('dd s')
   else if (n12='0300') then xset('dd d')
   else if (n12='0330') then xset('dd ds')
   else if (n12='0400') then xset('dd dd')
   else if (n12='0430') then xset('s')
   else if (n12='0500') then xset('d')
   else if (n12='0530') then xset('ds')
   else if (n12='0600') then xset('dd')
   else if (n12='0630') then xset('dd s')
   else if (n12='0700') then xset('dd d')
   else if (n12='0730') then xset('dd ds')
   else if (n12='0800') then xset('dd dd')
   else if (n12='0830') then xset('s')
   else if (n12='0900') then xset('d')
   else if (n12='0930') then xset('ds')
   else if (n12='1000') then xset('dd')
   else if (n12='1030') then xset('dd s')
   else if (n12='1100') then xset('dd d')
   else if (n12='1130') then xset('dd ds')
   else if (n12='0000') then xset('dd dd');
   end
//ships bells - British Royal, from 1797 due to a mutiny on the dog watch of 5 bells this was removed never again to be rung
else if (dstyle=3) then
   begin
   xmustdong2:=true;
   //dog watch - five bell "dd s" removed due to it being used in a muntiny in around 1797
   if      (n23='1630') then xset('s')
   else if (n23='1700') then xset('d')
   else if (n23='1730') then xset('ds')
   else if (n23='1800') then xset('dd')
   else if (n23='1830') then xset('s')
   else if (n23='1900') then xset('d')
   else if (n23='1930') then xset('ds')
   else if (n23='2000') then xset('dd dd')
   //.fallback to standard ships bells
   else if (n12='0030') then xset('s')
   else if (n12='0100') then xset('d')
   else if (n12='0130') then xset('ds')
   else if (n12='0200') then xset('dd')
   else if (n12='0230') then xset('dd s')
   else if (n12='0300') then xset('dd d')
   else if (n12='0330') then xset('dd ds')
   else if (n12='0400') then xset('dd dd')
   else if (n12='0430') then xset('s')
   else if (n12='0500') then xset('d')
   else if (n12='0530') then xset('ds')
   else if (n12='0600') then xset('dd')
   else if (n12='0630') then xset('dd s')
   else if (n12='0700') then xset('dd d')
   else if (n12='0730') then xset('dd ds')
   else if (n12='0800') then xset('dd dd')
   else if (n12='0830') then xset('s')
   else if (n12='0900') then xset('d')
   else if (n12='0930') then xset('ds')
   else if (n12='1000') then xset('dd')
   else if (n12='1030') then xset('dd s')
   else if (n12='1100') then xset('dd d')
   else if (n12='1130') then xset('dd ds')
   else if (n12='0000') then xset('dd dd')
   end
//Grande Sonnerie -> hour dongs + quarterly double-triple dongs (low to high) every 15 minutes (0=hour dongs, 15=(hour dongs) + 1 dong, 30=(hour dongs) + 2 dongs, 45=(hour dongs) + 3 dongs)
else if (dstyle=4) then//Grande Sonnerie
   begin
   //.use built-in pre-built midi files
   if (idongX[xindex]='') then
      begin
      if      (m=15)   then xset2(ms(h112)+mgap(igap[xindex])+md(1),x15)//15
      else if (m=30)   then xset2(ms(h112)+mgap(igap[xindex])+md(2),x30)//30
      else if (m=45)   then xset2(ms(h112)+mgap(igap[xindex])+md(3),x45)//45
      else if (m=0)    then xset(ms(h112));//0 - o'clock
      end
   //.dynamically create a single midi with all chimes etc in one - 16mar2022
   else
      begin
      if      (m=15)   then xset2(mSonnerie(igap[xindex],h112,1,idongX[xindex],idong2X[xindex],itemp[xindex]),x15)
      else if (m=30)   then xset2(mSonnerie(igap[xindex],h112,2,idongX[xindex],idong2X[xindex],itemp[xindex]),x30)
      else if (m=45)   then xset2(mSonnerie(igap[xindex],h112,3,idongX[xindex],idong2X[xindex],itemp[xindex]),x45)
      else if (m=0 )   then xset2(mSonnerie(igap[xindex],h112,0,idongX[xindex],idong2X[xindex],itemp[xindex]),true);
      end;
   end
//Petite Sonnerie -> hour dongs on the our AND only quarterly double-triple dongs (low to high) every 15 minutes (0=hour dongs, 15=1 dong, 30=2 dongs, 45=3 dongs)
else if (dstyle=5) then
   begin
   //.use built-in pre-built midi files
   if (idongX[xindex]='') then
      begin
      if      (m=15)   then xset2(md(1),x15)//15
      else if (m=30)   then xset2(md(2),x30)//30
      else if (m=45)   then xset2(md(3),x45)//45
      else if (m=0)    then xset(ms(h112));//0 - o'clock
      end
  else
   //.dynamically create a single midi with all chimes etc in one - 16mar2022
     begin
     if      (m=15)   then xset2(mSonnerie(igap[xindex],0,1,idongX[xindex],idong2X[xindex],itemp[xindex]),x15)
     else if (m=30)   then xset2(mSonnerie(igap[xindex],0,2,idongX[xindex],idong2X[xindex],itemp[xindex]),x30)
     else if (m=45)   then xset2(mSonnerie(igap[xindex],0,3,idongX[xindex],idong2X[xindex],itemp[xindex]),x45)
     else if (m=0 )   then xset2(mSonnerie(igap[xindex],h112,0,idongX[xindex],idong2X[xindex],itemp[xindex]),true);
     end;
  end;

//no double dong support -> make a double dong out of TWO fast SINGLE dongs -> chime does not support Double Dong (dong2) -> so we must confiure the worklist to modify the playback of a single dong to simulate a double dong - 04mar2022
if xmustdong2 and (xworklist<>'') and ((idong2[xindex]=nil) or (idong2[xindex].len<2)) then
   begin
   //init
   v:=xworklist;
   xworklist:='';
   //get
   for p:=1 to length(v) do
   begin
   if (strcopy1(v,p,1)='d') then xworklist:=xworklist+'9ss0a'//speed up to 190%, then do a Dong, and another Dong, then revert speed down to 100% (normal) and wait 600ms
   else                          xworklist:=xworklist+strcopy1(v,p,1);
   end;//p
   end;

skipend:
except;end;
try
result:=(xworklist<>'');
except;end;
end;
//## info ##
function tbasicchimes.info(xindex:longint;var xname:string;var xstyle,xtep:longint;var xintro,xdong,xdong2:tstr8):boolean;
begin
try
//defaults
result:=(xindex>=0) and (xindex<high(iname)) and (xindex<icount);
xname:='';
xstyle:=0;
xtep:=tepNone;
xintro:=nil;
xdong:=nil;
xdong2:=nil;
//check
if not result then exit;
//get
xname  :=iname[xindex];
xstyle :=istyle[xindex];
xtep   :=itep[xindex];
xintro :=iintro[xindex];
xdong  :=idong[xindex];
xdong2 :=idong2[xindex];
//successful
result:=true;
except;end;
end;
//## findname ##
function tbasicchimes.findname(xname:string;var xindex:longint):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
xindex:=0;
//check
if (icount<=0) then exit;
//find
for p:=0 to (icount-1) do
begin
if low__comparetext(xname,iname[p]) then
   begin
   xindex:=p;
   result:=true;
   break;
   end;
end;//p
except;end;
end;
//## xaddTitle ##
procedure tbasicchimes.xaddTitle(xname:string);
var
   i:longint;
begin
try
if not findname(xname,i) then
   begin
   //get
   if (icount>high(iname)) then exit;//at capacity
   i:=icount;
   inc(icount);
   //set - new
   iname[i]   :=xname;
   istyle[i]  :=0;//title
   itep[i]    :=tepNone;
   igap[i]    :=0;
   end;
except;end;
end;
//## xaddStandard ##
procedure tbasicchimes.xaddStandard(xname:string;xintro,xdong:array of byte);
begin
try;xadd(0,'m:'+xname,xintro,xdong,[0],chmsStandard,low__aorb(tepBlank20,tepMid20,(sizeof(xintro)>=2) or (sizeof(xdong)>=2)));except;end;
end;
//## xaddStandard2 ##
procedure tbasicchimes.xaddStandard2(xname,xintro,xdong:string);
begin
try;xadd2(0,'m:'+xname,[0],[0],[0],xintro,xdong,'',chmsStandard,low__aorb(tepBlank20,tepMid20,(length(xintro)>=2) or (length(xdong)>=2)));except;end;
end;
//## xaddStandard3 ##
procedure tbasicchimes.xaddStandard3(xname,xintro,xdong:string;aintro,adong:array of byte);//15nov2022
begin
try;xadd2(0,'m:'+xname,aintro,adong,[0],xintro,xdong,'',chmsStandard,low__aorb(tepBlank20,tepMid20,(length(xintro)>=2) or (length(xdong)>=2) or (sizeof(aintro)>=2) or (sizeof(adong)>=2)));except;end;
end;
//## xaddBells ##
procedure tbasicchimes.xaddBells(xname:string;xdong,xdong2:array of byte);
begin
try;xadd(0,'b:'+xname,[0],xdong,xdong2,chmsBells,tepBell20);except;end;
end;
//## xaddBells2 ##
procedure tbasicchimes.xaddBells2(xgap:longint;xname,xdong,xdong2:string);
begin
try;xadd2(xgap,'b:'+xname,[0],[0],[0],'',xdong,xdong2,chmsBells,tepBell20);except;end;
end;
//## xaddSonnerie ##
procedure tbasicchimes.xaddSonnerie(xgap:longint;xname:string;xdong,xdong2:array of byte);
begin
try;xadd(xgap,'s:'+xname,[0],xdong,xdong2,chmsSonnerie,tepSonnerie20);except;end;
end;
//## xaddSonnerie2 ##
procedure tbasicchimes.xaddSonnerie2(xgap:longint;xname,xdong,xdong2:string);
begin
try;xadd2(xgap,'s:'+xname,[0],[0],[0],'',xdong,xdong2,chmsSonnerie,tepSonnerie20);except;end;
end;
//## xadd ##
procedure tbasicchimes.xadd(xgap:longint;xname:string;xintro,xdong,xdong2:array of byte;xstyle,xtep:longint);
begin
try;xadd2(xgap,xname,xintro,xdong,xdong2,'','','',xstyle,xtep);except;end;
end;
//## xadd2 ##
procedure tbasicchimes.xadd2(xgap:longint;xname:string;xintro,xdong,xdong2:array of byte;sintro,sdong,sdong2:string;xstyle,xtep:longint);
label//Note: sintro, sdong and sdong2 are alternative input formats in the simple midi format "low__makemid()"
   skipend;
var
   i:longint;
   //## xset ##
   procedure xset(x:tstr8;xdata:array of byte;xdata2:string);
   var
      a:tstr8;
      e:string;
   begin
   try
   //defaults
   a:=nil;
   //check
   if (x=nil) or ((sizeof(xdata)<2) and (xdata2='')) then exit;
   //init
   a:=bnew;
   //get
   if (sizeof(xdata)>=2) then a.aadd(xdata) else low__makemid(xdata2,a,e);
   //decompress "x"
   if (a.len>=1) then
      begin
      x.clear;
      x.add(a);
      end;
   except;end;
   try;bfree(a);except;end;
   end;
begin
try
//init
if not findname(xname,i) then
   begin
   //get
   if (icount>high(iname)) then exit;//at capacity
   i:=icount;
   inc(icount);
   //set - new
   iname[i]   :=xname;
   istyle[i]  :=frcrange(xstyle,1,3);
   igap[i]    :=frcrange(xgap,0,10000);//0-10sec
   itep[i]    :=xtep;
   if (iintro[i]=nil) then iintro[i]:=bnew;
   if (idong[i]=nil)  then idong[i]:=bnew;
   if (idong2[i]=nil) then idong2[i]:=bnew;
   end;
//check
if (i<0) or (i>high(iname)) then goto skipend;
//get
if (sizeof(xintro)>=2) or (sintro<>'') then
   begin
   xset(iintro[i],xintro,sintro);
   iintroX[i]:=sintro;
   end;
if (sizeof(xdong)>=2)  or (sdong<>'')  then
   begin
   xset(idong[i] ,xdong,sdong);
   idongX[i]:=sdong;
   end;
if (sizeof(xdong2)>=2) or (sdong2<>'') then
   begin
   xset(idong2[i],xdong2,sdong2);
   idong2X[i]:=sdong2;
   end;
skipend:
except;end;
end;

//## tsnd32 ####################################################################
//## snd_waveheaderlen ##
function snd_waveheaderlen:longint;
begin
try;result:=58;except;end;
end;
//## snd_waveheader ##
function snd_waveheader(format:string;datalen:longint;xoutpos:longint;xout:tstr8):boolean;
var
   _size,_samples,_avebs,_blockalign,_len,_hz,_bit,_ch:tint4;
   //## xadd ##
   procedure xadd(xval:byte);
   begin
   xout.byt1[xoutpos]:=xval;
   inc(xoutpos);
   end;
begin
try
//defaults
result:=false;
//check
if (xout=nil) then exit;
//range
xoutpos:=frcmin(xoutpos,0);
//get
snd_fromformat(format,_hz.val,_bit.val,_ch.val);
_len.val:=datalen-8;
_blockalign.val:=(_ch.val*_bit.val) div 8;
_avebs.val:=_hz.val*_blockalign.val;
_samples.val:=datalen div nozero(1100048,_blockalign.val);
_size.val:=_samples.val*_blockalign.val;
//set

xadd(82);
xadd(73);
xadd(70);
xadd(70);

xadd(_len.bytes[0]);
xadd(_len.bytes[1]);
xadd(_len.bytes[2]);
xadd(_len.bytes[3]);//a: filesize-8 [5..8]

xadd(87);
xadd(65);
xadd(86);
xadd(69);
xadd(102);
xadd(109);
xadd(116);
xadd(32);
xadd(18);
xadd(0);
xadd(0);
xadd(0);

//.wave sub header [21..34..36 = 14+2 = 16 bytes]
xadd(1);
xadd(0);//PCM format

xadd(_ch.bytes[0]);
xadd(_ch.bytes[1]);//#2#0+//Number of channels

xadd(_hz.bytes[0]);
xadd(_hz.bytes[1]);
xadd(_hz.bytes[2]);
xadd(_hz.bytes[3]);//Samples per second

xadd(_avebs.bytes[0]);
xadd(_avebs.bytes[1]);
xadd(_avebs.bytes[2]);
xadd(_avebs.bytes[3]);//Ave. bytes per second

xadd(_blockalign.bytes[0]);
xadd(_blockalign.bytes[1]);//Block align

xadd(_bit.bytes[0]);
xadd(_bit.bytes[1]);//bits per sample

//.other main RIFF header information
xadd(0);
xadd(0);
xadd(102);//[37..39]

xadd(97);
xadd(99);
xadd(116);
xadd(4);
xadd(0);
xadd(0);
xadd(0);//[40..46]

xadd(_samples.bytes[0]);
xadd(_samples.bytes[1]);
xadd(_samples.bytes[2]);
xadd(_samples.bytes[3]);//v2: total samples [47..50]

//[51..54] = "data"
xadd(100);
xadd(97);
xadd(116);
xadd(97);

//[55..58] = "data len"
xadd(_size.bytes[0]);
xadd(_size.bytes[1]);
xadd(_size.bytes[2]);
xadd(_size.bytes[3]);//v3: "total samples" x "number of channels" x "bytes per sample" [55..58]
except;end;
end;
//## snd_toformat ##
function snd_toformat(xhz,xbits,xchs:longint):string;
begin
try;result:=inttostr(snd_safehz(xhz))+#32+inttostr(snd_safebits(xbits))+#32+inttostr(snd_safechs(xchs));except;end;
end;
//## setformat ##
function snd_fromformat(x:string;var xhz,xbits,xchs:longint):boolean;
var
   p,lp,vc,v:integer;
begin//Input: "8/11/12/16/22/24/32/44/48" "8/16" "1/2", e.g. "44 16 2" for CD quality
try
//defaults
result:=false;
xhz:=8000;
xbits:=8;
xchs:=1;
//filter
x:=x+#32;
vc:=1;
lp:=1;
for p:=1 to length(x) do
begin
if (strcopy1(x,p,1)=#32) then
   begin
   //get
   v:=strint(strcopy1(x,lp,p-lp));
   case vc of
   1:xhz:=snd_safehz(v);
   2:xbits:=snd_safebits(v);
   3:begin
      xchs:=snd_safechs(v);
      result:=true;
      end;
   end;
   //inc
   lp:=p+1;
   inc(vc);
   end;
end;//p
except;end;
end;
//## snd_safechs ##
function snd_safechs(x:longint):longint;
begin
try
case x of
minint..1:x:=1;
2:        x:=2;
else      x:=1;
end;
result:=x;
except;end;
end;
//## snd_safebits ##
function snd_safebits(x:longint):longint;
begin
try
case x of
minint..8:x:=8;
9..16:    x:=16;
17..24:   x:=24;
else      x:=16;
end;
result:=x;
except;end;
end;
//## snd_safekhz ##
function snd_safekhz(x:longint):longint;
begin
try
case x of
minint..8:x:=8;
9..11:    x:=11;
12:       x:=12;
13..16:   x:=16;
17..22:   x:=22;
23..24:   x:=24;
25..32:   x:=32;
33..44:   x:=44;
45..48:   x:=48;
49..96:   x:=96;
else      x:=48;
end;
result:=x;
except;end;
end;
//## snd_safehz ##
function snd_safehz(x:longint):longint;
begin
try
case x of
minint..8000:x:= 8000;
8001 ..11025:x:=11025;
11026..12000:x:=12000;
12001..16000:x:=16000;
16001..22050:x:=22050;
22051..24000:x:=24000;
24001..32000:x:=32000;
32001..44100:x:=44100;
44101..48000:x:=48000;
48001..96000:x:=96000;
else         x:=48000;
end;
result:=x;
except;end;
end;
//## snd_tokhz ##
function snd_tokhz(xfromHZ:longint):longint;
begin
try
case snd_safehz(xfromHZ) of
8000 :result:=8;
11025:result:=11;
12000:result:=12;
16000:result:=16;
22050:result:=22;
24000:result:=24;
32000:result:=32;
44100:result:=44;
48000:result:=48;
96000:result:=96;
else  result:=48;
end;//case
except;end;
end;
//## snd_tohz ##
function snd_tohz(xfromKHZ:longint):longint;
begin
try
case snd_safekhz(xfromKHZ) of
8: result:=8000;
11:result:=11025;
12:result:=12000;
16:result:=16000;
22:result:=22050;
24:result:=24000;
32:result:=32000;
44:result:=44100;
48:result:=48000;
96:result:=96000;
else result:=48000;
end;//case
except;end;
end;
//## snd_validkhz ##
function snd_validkhz(x:longint):boolean;
begin
try;result:=(x=snd_safekhz(x));except;end;
end;
//## snd_validhz ##
function snd_validhz(x:longint):boolean;
begin
try;result:=(x=snd_safehz(x));except;end;
end;
//## nsnd32 ##
function nsnd32:tsnd32;
begin
try
result:=nil;
result:=tsnd32.create;
except;end;
end;
//## fsnd32 ##
procedure fsnd32(var x:tsnd32);
begin
try;if zzok(x,3) then freeobj(@x);except;end;
end;
//## create ##
constructor tsnd32.create;
begin
inherited create;
ibits:=0;
ikhz:=0;
ihz:=0;
iid:=0;
icore:=bnew;
ivmax:=nil;//optional - 21jul2021
ilastvmaxid:=-1;
ilen:=0;
iincby:=10000;//10,000 x 4(int32) = 40K
make44_16;
end;
//## destroy ##
destructor tsnd32.destroy;
begin
try
bfree(icore);
bfree(ivmax);
inherited destroy;
except;end;
end;
//## getvmax ##
function tsnd32.getvmax(x:longint):longint;
label
   redo;
var
   xdiv,xslotsAms,v,vc,i,p,xfrom,xto:longint;
begin
try
//defaults
result:=0;
//remap
if (ilastvmaxid<>iid) then
   begin
   //init
   if (ivmax=nil) then ivmax:=bnew;
   ilastvmaxid:=iid;
   xslotsAms:=round(ihz/1000);
   case ibits of
   16:xdiv:=129;
   else xdiv:=1;
   end;
   //get
   for p:=(ilen-1) downto 0 do
   begin
   xfrom:=p-(xslotsAms div 2);
   xto:=p+(xslotsAms div 2);
   i:=xfrom;
   v:=0;
   vc:=0;
redo:
   if (i>=0) and (i<ilen) then
      begin
      inc(v,pv[i] div xdiv);
      inc(vc);
      end;
   //inc
   inc(i);
   if (i<=xto) then goto redo;
   //set
   if (vc>=1) then v:=v div vc;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   ivmax.byt1[p]:=v;
   end;//p
   end;
//get
if (x>=0) and (x<ilen) then result:=ivmax.byt1[x];
except;end;
end;
//## xincid ##
procedure tsnd32.xincid;
begin
try;low__iroll(iid,1);except;end;
end;
//## getlen100 ##
function tsnd32.getlen100:longint;
begin
try;result:=round(len/100);except;end;
end;
//## setlen100 ##
procedure tsnd32.setlen100(x:longint);
begin
try;len:=round((ihz/100)*frcmin(x,0));except;end;
end;
//## setparams ##
procedure tsnd32.setparams(xkhz,xbits,xlen:longint);
begin
try
//range
xkhz:=snd_safekhz(xkhz);
xbits:=snd_safebits(xbits);
xlen:=frcmin(xlen,0);
//get
if (xkhz<>ikhz) or (xbits<>ibits) or (ilen<>xlen) then
   begin
   ikhz:=xkhz;
   ihz:=snd_tohz(xkhz);
   ibits:=xbits;
   ilen:=xlen;
   icore.setlen(xlen*4);
   xincid;
   end;
except;end;
end;
//## make96_16 ##
procedure tsnd32.make96_16;
begin
try;setparams(96,16,ilen);except;end;
end;
//## make48_16 ##
procedure tsnd32.make48_16;
begin
try;setparams(44,16,ilen);except;end;
end;
//## make44_16 ##
procedure tsnd32.make44_16;
begin
try;setparams(44,16,ilen);except;end;
end;
//## make22_16 ##
procedure tsnd32.make22_16;
begin
try;setparams(22,16,ilen);except;end;
end;
//## setkhz ##
procedure tsnd32.setkhz(x:longint);
begin
try;setparams(x,ibits,ilen);except;end;
end;
//## sethz ##
procedure tsnd32.sethz(x:longint);
begin
try;setparams(snd_tokhz(x),ibits,ilen);except;end;
end;
//## setbits ##
procedure tsnd32.setbits(x:longint);
begin
try;setparams(ikhz,x,ilen);except;end;
end;
//## setincby ##
procedure tsnd32.setincby(x:longint);
begin
try;iincby:=frcmin(x,1);except;end;
end;
//## clear ##
procedure tsnd32.clear;
begin
try;len:=0;except;end;
end;
//## getbytes ##
function tsnd32.getbytes:longint;
begin
try;result:=(ilen*4);except;end;
end;
//## setlen ##
procedure tsnd32.setlen(x:longint);
begin
try;setparams(ikhz,ibits,x);except;end;
end;
//## minlen ##
function tsnd32.minlen(x:longint):boolean;
begin
try
result:=false;
if (x<=ilen) then
   begin
   result:=true;
   exit;
   end
else
   begin
   setparams(ikhz,ibits,frcmin(x,ilen));
   result:=icore.minlen((ilen+iincby)*4);
   end;
except;end;
end;
//## getms ##
function tsnd32.getms:longint;
begin
try;result:=round((ilen/ihz)*1000);except;end;
end;
//## setms ##
procedure tsnd32.setms(x:longint);
begin
try;len:=round((ikhz/1000)*x);except;end;
end;
//## getv ##
function tsnd32.getv(xpos:longint):longint;
begin
result:=0;
if (xpos>=0) and (xpos<ilen) then result:=icore.pints4[xpos];//faster - 13jul2021
//was: if (xpos>=0) and (xpos<ilen) then result:=icore.int4[xpos*4];
end;
//## setv ##
procedure tsnd32.setv(xpos,xval:longint);
begin
if (xpos<0) then xpos:=0;
if (xpos>=ilen) and (not minlen(xpos+1)) then exit;
if (xpos>=0) and (xpos<ilen) then
   begin
   if (icore.pints4[xpos]<>xval) then xincid;
   icore.pints4[xpos]:=xval;//faster - 13jul2021
   //was: if (xpos>=0) and (xpos<ilen) then icore.int4[xpos*4]:=xval;
   end;
end;
//## getpv ##
function tsnd32.getpv(xpos:longint):longint;
begin
result:=getv(xpos);
if (result<0) then result:=-result;
end;
//## setpv ##
procedure tsnd32.setpv(xpos,xval:longint);
begin
if (xval<0) then xval:=-xval;
setv(xpos,xval);
end;
//## getnv ##
function tsnd32.getnv(xpos:longint):longint;
begin
result:=getv(xpos);
if (result>0) then result:=-result;
end;
//## setnv ##
procedure tsnd32.setnv(xpos,xval:longint);
begin
if (xval>0) then xval:=-xval;
setv(xpos,xval);
end;
//## add96 ##
function tsnd32.add96(x:tstr8;xfrom,xlen,xpower255:longint;xasms:boolean;var e:string):boolean;
begin
try;result:=xadd(x,96000,xfrom,xlen,xpower255,xasms,e);except;end;
end;
//## add48 ##
function tsnd32.add48(x:tstr8;xfrom,xlen,xpower255:longint;xasms:boolean;var e:string):boolean;
begin
try;result:=xadd(x,48000,xfrom,xlen,xpower255,xasms,e);except;end;
end;
//## add44 ##
function tsnd32.add44(x:tstr8;xfrom,xlen,xpower255:longint;xasms:boolean;var e:string):boolean;
begin
try;result:=xadd(x,44100,xfrom,xlen,xpower255,xasms,e);except;end;
end;
//## add22 ##
function tsnd32.add22(x:tstr8;xfrom,xlen,xpower255:longint;xasms:boolean;var e:string):boolean;
begin
try;result:=xadd(x,22050,xfrom,xlen,xpower255,xasms,e);except;end;
end;
//## xadd ##
function tsnd32.xadd(x:tstr8;dhz,xfrom,xlen,xpower255:longint;xasms:boolean;var e:string):boolean;
label
   more,redo,skipend;
var
   scount,dcount,dpos,dfrom,spos,slen,sfrom,sto:longint;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
//check
if zznil(x,17) then exit;
//range
dhz:=snd_safehz(dhz);
xpower255:=frcrange(xpower255,0,255);
//init
slen:=x.len div 2;
sfrom:=xfrom;
sto:=xfrom+xlen-1;
if xasms then
   begin
   sfrom:=round(xfrom*(dhz/1000));
   sto:=round((xfrom+xlen)*(dhz/1000));
   end;
sto:=frcmax(sto,slen-1);
//check
if (slen<=0) or (sto<0) then
   begin
   result:=true;
   goto skipend;
   end;
//get
spos:=sfrom;
dfrom:=ilen;
dpos:=dfrom;//start position
redo:
if (spos>sto) then
   begin
   result:=true;
   goto skipend;
   end
else if (spos>=0) then
   begin
   scount:=round((spos-sfrom+1)*(ihz/dhz));
more:
   if (dpos>=0) then
      begin
      if (xpower255<=0) then val[dpos]:=val[dpos]
      else if (xpower255>=255) then val[dpos]:=smallint(x.wrd2[spos*2])
      else val[dpos]:=round( (val[dpos]*((255-xpower255)/255)) + ((xpower255/255)*smallint(x.wrd2[spos*2])) );
      end;
   //.inc
   inc(dpos);
   inc(dcount);
   if (dcount<scount) then goto more;
   end;
//inc
inc(spos);
goto redo;

//successful
result:=true;
skipend:
except;end;
try;xincid;except;end;
end;
//## add ##
function tsnd32.add(x:tsnd32;xfrom,xlen,xpower255:longint;xasms:boolean;var e:string):boolean;
label
   redo,skipend;
var
   dpos,spos,slen,sfrom,sto:longint;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
//check
if zznil(x,17) or (x=self) or (x.hz<>ihz) then exit;
//range
xpower255:=frcrange(xpower255,0,255);
//init
slen:=x.len;
sfrom:=xfrom;
sto:=xfrom+xlen-1;
if xasms then
   begin
   sfrom:=round(xfrom*(ihz/1000));
   sto:=round((xfrom+xlen)*(ihz/1000));
   end;
//check
if (slen<=0) then
   begin
   result:=true;
   goto skipend;
   end;
//get
spos:=sfrom;
dpos:=ilen;//start position
redo:
if (spos>=slen) then
   begin
   result:=true;
   goto skipend;
   end
else if (spos>=0) then
   begin
   if (dpos>=0) then
      begin
      if (xpower255<=0) then val[dpos]:=val[dpos]
      else if (xpower255>=255) then val[dpos]:=x.val[spos]
      else val[dpos]:=round( (val[dpos]*((255-xpower255)/255)) + ((xpower255/255)*x.val[spos]) );
      end;
   //inc
   inc(dpos);
   end;
//inc
inc(spos);
goto redo;

//successful
result:=true;
skipend:
except;end;
try;xincid;except;end;
end;
//## pull96 ##
function tsnd32.pull96(x:tstr8;xfrom,xlen:longint;xasms:boolean;var e:string):boolean;
begin
try;result:=xpull(x,96000,xfrom,xlen,xasms,e);except;end;
end;
//## pull48 ##
function tsnd32.pull48(x:tstr8;xfrom,xlen:longint;xasms:boolean;var e:string):boolean;
begin
try;result:=xpull(x,48000,xfrom,xlen,xasms,e);except;end;
end;
//## pull44 ##
function tsnd32.pull44(x:tstr8;xfrom,xlen:longint;xasms:boolean;var e:string):boolean;
begin
try;result:=xpull(x,44100,xfrom,xlen,xasms,e);except;end;
end;
//## pull22 ##
function tsnd32.pull22(x:tstr8;xfrom,xlen:longint;xasms:boolean;var e:string):boolean;
begin
try;result:=xpull(x,22050,xfrom,xlen,xasms,e);except;end;
end;
//## xpull ##
function tsnd32.xpull(x:tstr8;dhz,xfrom,xlen:longint;xasms:boolean;var e:string):boolean;
label
   more,skipend;
var
   scount,dcount,dv,sfrom,sto,dlen,dpos,spos:longint;
   w:twrd2;
   xsameok:boolean;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
//check
if zznil(x,17) then exit;
//check
if (ilen<=0) then
   begin
   result:=true;
   goto skipend;
   end;
//range
dhz:=snd_safehz(dhz);
xsameok:=(dhz=ihz);
//init
scount:=0;
dcount:=0;
dlen:=x.len div 2;
dpos:=dlen;
sfrom:=xfrom;
sto:=xfrom+xlen-1;
if xasms then
   begin
   sfrom:=round(xfrom*(ihz/1000));
   sto:=round((xfrom+xlen)*(ihz/1000));
   end;
sto:=frcmax(sto,ilen-1);
//get
for spos:=sfrom to sto do
begin
if (spos>sto) then break
else if (spos>=0) then
   begin
   dv:=val[spos];
   if (dv<-32768) then dv:=-32768 else if (dv>32767) then dv:=32767;
   w.val:=word(dv);
more:
   scount:=trunc((spos-sfrom)*(dhz/ihz));//Important Note: using "round()" instead causes distortion in 44.1Khz format etc - 13jul2021
   if (dcount<=scount) then
      begin
      x.wrd2[dpos*2]:=w.si;
      inc(dpos);
      inc(dcount);
      goto more;
      end;
   end;
end;//p

//successful
result:=true;
skipend:
except;end;
end;
//## volave ##
function tsnd32.volave:longint;
begin
try;result:=volave2(0,maxint);except;end;
end;
//## volave2 ##
function tsnd32.volave2(xfrom,xlen:longint):longint;
var
   alen,p:longint;
   stotal,scount:comp;
begin
try
//defaults
result:=1;
//get
alen:=ilen;
if (alen>=1) and (xlen>=1) then
   begin
   alen:=ilen;
   stotal:=0;
   scount:=0;
   for p:=xfrom to (xfrom+xlen-1) do
   begin
   if (p>=0) and (p<alen) then
      begin
      stotal:=stotal+pv[p];
      scount:=scount+1;
      if (scount>=1000000) then
         begin
         stotal:=low__div64(stotal,10);
         scount:=low__div64(scount,10);
         end;
      end
   else if (p>=alen) then break;
   end;//p
   //set
   result:=frcmin(restrict32(low__div64(stotal,frcmin64(scount,1))),1);
   end;
except;end;
end;
//## setvolave ##
procedure tsnd32.setvolave(soriginalvolave:longint);
begin
try;setvolave2(0,maxint,soriginalvolave);except;end;
end;
//## setvolave2 ##
procedure tsnd32.setvolave2(xfrom,xlen,soriginalvolave:longint);
var
   alen,p,dvol:longint;
begin
try
alen:=ilen;
if (alen>=1) and (xlen>=1) then
   begin
   soriginalvolave:=frcmin(soriginalvolave,1);
   dvol:=frcmin(volave2(xfrom,xlen),1);
   if (dvol<soriginalvolave) then
      begin
      for p:=xfrom to (xfrom+xlen-1) do
      begin
      if (p>=0) and (p<alen) then val[p]:=round(val[p]*(soriginalvolave/dvol))
      else if (p>=alen) then break;
      end;//p
      end;
   end;
except;end;
try;xincid;except;end;
end;
//## findrange ##
function tsnd32.findrange(var xmin,xmax:longint):boolean;
var
   dv,p:longint;
begin
try
//defaults
result:=false;
xmin:=0;
xmax:=0;
//check
if (ilen<=0) then exit;
//get
xmin:=maxint;
xmax:=minint;
for p:=0 to (ilen-1) do
begin
dv:=val[p];
if (dv<xmin) then xmin:=dv;
if (dv>xmax) then xmax:=dv;
end;//p
//successul
result:=true;
except;end;
end;
//## findrange2 ##
function tsnd32.findrange2(var lmin,lmax,hmin,hmax:longint):boolean;
var
   dv,p:longint;
   lonce,honce:boolean;
begin
try
//defaults
result:=false;
lmin:=0;
lmax:=0;
hmin:=0;
hmax:=0;
honce:=true;
lonce:=true;
//check
if (ilen<=0) then exit;
//get
for p:=0 to (ilen-1) do
begin
dv:=val[p];
//.h
if (dv>0) then
   begin
   if (dv>hmax) then hmax:=dv;
   if honce then
      begin
      hmin:=dv;
      honce:=false;
      end
   else if (dv<hmin) then hmin:=dv;
   end
//.l
else if (dv<0) then
   begin
   if (dv<lmax) then lmax:=dv;
   if lonce then
      begin
      lmin:=dv;
      lonce:=false;
      end
   else if (dv>lmin) then lmin:=dv;
   end;
end;//p
//successul
result:=true;
except;end;
end;
//## findmin ##
function tsnd32.findmin:longint;
var
   int1:longint;
begin
try;findrange(result,int1);except;end;
end;
//## findmax ##
function tsnd32.findmax:longint;
var
   int1:longint;
begin
try;findrange(int1,result);except;end;
end;
//## iszero ##
function tsnd32.iszero(xfrom,xto:longint):boolean;
label
   skipend;
var
   p:longint;
begin
try
//defaults
result:=false;
//check
if (xto<xfrom) then exit;
//range
for p:=xfrom to xto do
begin
if (p>=0) and (p<ilen) then
   begin
   if (val[p]<>0) then goto skipend;
   end;
end;//p
//successful
result:=true;
skipend:
except;end;
end;
//## inrange ##
function tsnd32.inrange(xfrom,xto,xmin,xmax:longint):boolean;
label
   skipend;
var
   dv,p:longint;
begin
try
//defaults
result:=false;
//check
if (xto<xfrom) then exit;
//range
for p:=xfrom to xto do
begin
if (p>=0) and (p<ilen) then
   begin
   dv:=val[p];
   if (dv<xmin) or (dv>xmax) then goto skipend;
   end;
end;//p
//successful
result:=true;
skipend:
except;end;
end;

//-- playlist support ----------------------------------------------------------
//## playlist__onelen ##
function playlist__onelen:longint;
begin
result:=4+(2*playlist__namelen);
end;
//## playlist__onelen ##
function playlist__titlestart:longint;
begin
result:=4;
end;
//## playlist__onelen ##
function playlist__namestart:longint;
begin
result:=260;
end;
//## playlist__namelen ##
function playlist__namelen:longint;
begin
result:=256;
end;
//## playlist__count ##
function playlist__count(x:tstr8):longint;
begin
try
result:=0;
if (x<>nil) then result:=x.len div playlist__onelen;//secs=4, title=512, filename=512
except;end;
end;
//## playlist__getone ##
function playlist__getone(xplaylistfilename:string;x:tstr8;xindex:longint;var xsec:longint;var xtitle,xfilename:string):boolean;
var
   i,xcount,xonelen:longint;
begin
try
//defaults
result:=false;
xsec:=-1;
xtitle:='';
xfilename:='';
//check
xcount:=playlist__count(x);
if (xcount<=0) or (xindex<0) or (xindex>=xcount) then exit;
//get
xonelen  :=playlist__onelen;
i        :=xindex*xonelen;
xsec     :=x.int4[i];//0..3
xtitle   :=x.nullstr[i+playlist__titlestart,playlist__namelen];//4..515
xfilename:=x.nullstr[i+playlist__namestart,playlist__namelen];//516..1027
//convert filename from relative to full filename when "xplaylistfilename<>nil" - 20ar2022
if (xplaylistfilename<>'') then xfilename:=low__readrelative(xfilename,xplaylistfilename);
//successful
result:=true;
except;end;
end;
//## playlist__addone ##
function playlist__addone(xplaylistfilename:string;x:tstr8;xsec:longint;xtitle,xfilename,xmask:string):boolean;
label
   skipend;
var
   xonelen,i:longint;
   xone:tstr8;
   str1:string;
   //## xhasurl ##
   function xhasurl:boolean;
   var
      xlen,p:longint;
   begin
   try
   //defaults
   result:=false;
   //check
   xlen:=length(xfilename);
   if (xlen<=3) then exit;
   //find
   for p:=1 to (xlen-2) do if (xfilename[p-1+stroffset]=':') and (xfilename[p-1+stroffset+1]='/') and (xfilename[p-1+stroffset+2]='/') then
      begin
      result:=true;
      break;
      end;
   except;end;
   end;
   //## xmaketitle ##
   procedure xmaketitle;
   var
      p:longint;
   begin
   try
   //check
   if (xtitle<>'') then exit;
   //check 2
   str1:=xtitle;
   low__remchar(str1,#32);
   low__remchar(str1,#160);
   if (str1<>'') then exit;
   //check 3
   if (xfilename='') then exit;
   //get
   for p:=length(xfilename) downto 1 do
   begin
   if (xfilename[p-1+stroffset]='\') or (xfilename[p-1+stroffset]='/') then
      begin
      xtitle:=strcopy1(xfilename,p+1,length(xfilename));
      break;
      end;
   end;//p
   //fallback
   if (xtitle='') then xtitle:=xfilename;
   except;end;
   end;
begin
try
//defaults
result:=false;
xone:=nil;
//check
if not block(x) then exit;
//get
if (xfilename<>'') and (length(xfilename)<=playlist__namelen) and (not xhasurl) then
   begin
   //check against inclusion mask - 20mar2022
   if (xmask<>'') and (not low__matchmasklist(xfilename,xmask)) then goto skipend;
   //convert exact filename to relative filename when "xplaylistfilename<>nil" - 20mar2022
   if (xplaylistfilename<>'') then xfilename:=low__makerelative(xfilename,xplaylistfilename);//20mar2022
   //init
   xonelen:=playlist__onelen;
   i:=(playlist__count(x)*xonelen);
   xone:=bnew;
   xone.setlen(xonelen);
   xone.fill(0,xonelen-1,0);
   //.in case of empty title fill using "name" part of filename
   xmaketitle;
   //get
   xone.int4[0]:=xsec;//0..3
   xone.str[playlist__titlestart,playlist__namelen]:=xtitle;
   xone.str[playlist__namestart,playlist__namelen]:=xfilename;
   //add
   if not x.owr(xone,i) then goto skipend;
   //successful
   result:=true;
   end;
skipend:
except;end;
try
bunlockautofree(x);
bfree(xone);
except;end;
end;
//## playlist__addall ##
function playlist__addall(xroot,xlistroot:string;x,xlistoffiles:tstr8;xmask:string):boolean;
label
   skipend;
var
   p,xsec,vlen,xpos:longint;
   xline:tstr8;
   v,xtitle:string;
   //## xnoinfo ##
   procedure xnoinfo;
   begin
   xsec:=-1;
   xtitle:='';
   end;
begin
try
//defaults
result:=false;
xline:=nil;
//check
if not low__true2(block(x),block(xlistoffiles)) then goto skipend;
//init
xpos:=0;
xline:=bnew;
xnoinfo;
//get
while true do
begin
if not low__nextline0(xlistoffiles,xline,xpos) then break;
if (xline.count>=1) then
   begin
   //get
   v:=xline.text;
   vlen:=length(v);
   //decide
   if low__comparetext(strcopy1(v,1,8),'#EXTINF:') then
      begin
      xnoinfo;
      v:=strcopy1(v,9,vlen);
      vlen:=length(v);
      if (vlen>=2) then
         begin
         for p:=1 to vlen do if (v[p-1+stroffset]=',') then
            begin
            xsec:=strint(strcopy1(v,1,p-1));
            xtitle:=strcopy1(v,p+1,vlen);
            break;
            end;//p
         end;
      end
   else if (v<>'') then
      begin
      v:=low__readrelative(v,xlistroot);//decode from inbound list
      playlist__addone(xroot,x,xsec,xtitle,v,xmask);//encode to outbound list - 20mar2022
      xnoinfo;
      end;
   end;
end;

//successful
result:=true;
skipend:
except;end;
try
bunlockautofree(x);
bunlockautofree(xlistoffiles);
bfree(xline);
except;end;
end;

//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//## taudiobasic ###############################################################
//## waveOutOpen ##
function waveOutOpen(lphWaveOut: PHWaveOut; uDeviceID: UINT; lpFormat: PWaveFormatEx; dwCallback, dwInstance, dwFlags: DWORD): MMRESULT;
begin
try
result:=_waveOutOpen(lphWaveOut,uDeviceID,lpFormat,dwCallback,dwInstance,dwFlags);
if (result=0) then satinc(satWaveopen,1);
except;end;
end;
//## waveOutClose ##
function waveOutClose(hWaveOut: HWAVEOUT): MMRESULT;
begin
try
result:=_waveOutClose(hWaveOut);
if (result=0) then satinc(satWaveopen,-1);
except;end;
end;
//## waveInOpen ##
function waveInOpen(lphWaveIn: PHWAVEIN; uDeviceID: UINT; lpFormatEx: PWaveFormatEx; dwCallback, dwInstance, dwFlags: DWORD): MMRESULT;
begin
try
result:=_waveInOpen(lphWaveIn,uDeviceID,lpFormatEx,dwCallback,dwInstance,dwFlags);
if (result=0) then satinc(satWaveopen,1);
except;end;
end;
//## waveInClose ##
function waveInClose(hWaveIn: HWAVEIN): MMRESULT;
begin
try
result:=_waveInClose(hWaveIn);
if (result=0) then satinc(satWaveopen,-1);
except;end;
end;
//## create ##
constructor taudiobasic.create;
var
   p:integer;
begin
//self
inherited create;
//options
oplay_timeout:=10000;//10sec
orec_timeout:=10000;//10sec
iphandle:=0;
irhandle:=0;
ipopen:=false;
ipdata:=bnew;
irdata:=bnew;
//vars
for p:=0 to high(ipH) do fillchar(ipH[p],sizeof(ipH[p]),0);
iptime:=ms64;
irtime:=ms64;
isamplems:=250;//250 ms
irsamplems:=250;//250 ms
//defaults
format:='44100 16 2';//play
rformat:='44100 16 1';//record
ipvolume:=100;//26mar2015
irvolume:=100;//26mar2015

//.timer
//low__timerset(self,_ontimer,200);
sysfasttimer2:=_ontimer;
end;
//## destroy ##
destructor taudiobasic.destroy;
var
   tmp:hwnd;
   msref:currency;
begin
try
//timer
//low__timerdel(self,_ontimer);//disconnect our timer event from the system timer
sysfasttimer2:=nil;
//close
ilocked:=true;
//Wait till safe or 30seconds - PREVENT FATAL SHUTDOWN ERRORS - 26JUL2009
//Note: Safe to wait, since we are waiting for "wndproc" to be called by MS and not our
//      own timing system, which would PAUSE/HALT as it is linear in design if this
//      were done.
msref:=ms64+30000;
while true do
begin
if (pcount<=0) or (ms64>msref) then break;
sleep(50);
app__processmessages;//allow system and MS to breath so that WNDPROC can be called by MS
end;//end of if
//close down buffers
paoc;
raoc;
//close down main handle
try
if (ihandle<>0) then
   begin
   tmp:=ihandle;
   ihandle:=0;
   deallocatehwnd(tmp);
   end;//end of if
except;end;
//controls
bfree(ipdata);
bfree(irdata);
//self
inherited destroy;
except;end;
end;
//## setvolume ##
procedure taudiobasic.setvolume(x:integer);
begin//Note: 100%=Normal
try;ipvolume:=frcrange(x,0,1000);except;end;
end;
//## setrvolume ##
procedure taudiobasic.setrvolume(x:integer);
begin//Note: 100%=Normal
try;irvolume:=frcrange(x,0,1000);except;end;
end;
//## pflush ##
procedure taudiobasic.pflush;
begin
try;ipdata.clear;except;end;
end;
//## rflush ##
procedure taudiobasic.rflush;
begin
try;irdata.clear;except;end;
end;
//## pempty ##
function taudiobasic.pempty:boolean;//assume "ipdata" is never entirely empty as audio rounds to nearest block
begin
try;result:=(ipdata.len<10);except;end;
end;
//## rempty ##
function taudiobasic.rempty:boolean;//assume "irdata" is never entirely empty as audio rounds to nearest block
begin
try;result:=(irdata.len<10);except;end;
end;
//## setsamplems ##
procedure taudiobasic.setsamplems(x:integer);
var
   z:string;
begin
try
//range
if (x<1) then x:=250;
//set
if (x<>isamplems) then
   begin
   isamplems:=x;
   z:=iformatstr;
   iformatstr:='';
   format:=z;
   end;//end of if
except;end;
end;
//## setrsamplems ##
procedure taudiobasic.setrsamplems(x:integer);
var
   z:string;
begin
try
//range
if (x<1) then x:=250;
//set
if (x<>irsamplems) then
   begin
   irsamplems:=x;
   z:=irformatstr;
   irformatstr:='';
   rformat:=z;
   end;//end of if
except;end;
end;
//## onems ##
function taudiobasic.onems(xformat:string):longint;//number of bytes for "1 millsecond" of sound - 21JUL2009
var
   xhz,xbits,xchs:longint;
begin//Important Note: Round all figures to integer for stable recording and playback control
try  //                even though we will incorrectly report length/timing figures.
//defaults
result:=8;
//get
snd_fromformat(xformat,xhz,xbits,xchs);
result:=(xhz div 1000)*(xbits div 8)*xchs;
except;end;
end;
//## setformat ##
procedure taudiobasic.setformat(x:string);
var
   xhz,xbits,xchs:integer;
begin//Input: "8/11/12/16/22/24/32/44/48" "8/16" "1/2", e.g. "44 16 2" for CD quality
try
//check
snd_fromformat(x,xhz,xbits,xchs);
if (iformat.nSamplesPerSec=xhz) and (iformat.wBitsPerSample=xbits) and (iformat.nChannels=xchs) then exit;
//get
with iformat do
begin
wFormatTag:=1;//"WAVE_FORMAT_PCM=1"
nSamplesPerSec:=xhz;//44.1Khz
wBitsPerSample:=xbits;//16bit
nChannels:=xchs;//stereo
nBlockAlign:=(nChannels*wBitsPerSample) div 8;
nAvgBytesPerSec:=nSamplesPerSec*nBlockAlign;
cbSize:=sizeof(iformat);
end;
ip16bit:=(iformat.wBitsPerSample=16);
isecsize:=iformat.nAvgBytesPerSec;
//update
iformatmodified:=true;
iformatstr:=inttostr(iformat.nSamplesPerSec)+#32+inttostr(iformat.wBitsPerSample)+#32+inttostr(iformat.nChannels);
isamplesize:=frcmax(isamplems*onems(format),sizeof(taudiobasicbuffer));
isecsize:=(1000 div nozero(1100028,isamplems))*isamplesize;//Important: Use nearest whole number
ipchcount:=iformat.nchannels;
except;end;
end;
//## setrformat ##
procedure taudiobasic.setrformat(x:string);
var
   xhz,xbits,xchs:integer;
begin//Input: "8/11/12/16/22/24/32/44/48" "8/16" "1/2", e.g. "44 16 2" for CD quality
try
//check
snd_fromformat(x,xhz,xbits,xchs);
if (irformat.nSamplesPerSec=xhz) and (irformat.wBitsPerSample=xbits) and (irformat.nChannels=xchs) then exit;
//get
with irformat do
begin
wFormatTag:=1;//"WAVE_FORMAT_PCM=1"
nSamplesPerSec:=xhz;//44.1Khz
wBitsPerSample:=xbits;//16bit
nChannels:=xchs;//stereo
nBlockAlign:=(nChannels*wBitsPerSample) div 8;
nAvgBytesPerSec:=nSamplesPerSec*nBlockAlign;
cbSize:=sizeof(irformat);
end;
ir16bit:=(irformat.wBitsPerSample=16);
//update
irformatmodified:=true;
irformatstr:=inttostr(irformat.nSamplesPerSec)+#32+inttostr(irformat.wBitsPerSample)+#32+inttostr(irformat.nChannels);
irsamplesize:=frcmax(isamplems*onems(rformat),sizeof(taudiobasicbuffer));
irsecsize:=(1000 div nozero(1100029,irsamplems))*irsamplesize;//Important: Use nearest whole number
irchcount:=irformat.nchannels;
except;end;
end;
//## _ontimer ##
procedure taudiobasic._ontimer(sender:tobject);
begin
try
//check
if ilocked then exit;
//state
paoc;
raoc;
//start
if not ipplaying then pdo;
except;end;
end;
//## wkAdjustVolume ##
procedure taudiobasic.wkAdjustVolume(_16bit:boolean;z:tstr8;_vol:integer);//adjust volume
var
   a:shortint;//tbytechar;
   p:integer;
   m:extended;
   v:integer;
begin
try
//check
if not block(z) then exit;
//range
_vol:=frcrange(_vol,0,1000);//100%=Normal, no change
if (_vol=100) then exit;
//get
m:=_vol/100;
for p:=1 to z.len do
begin
//.get
case _16bit of
true:begin//16bit
   a:=shortint(z.bytes1[p]);
   a:=shortint(frcrange(round(a*m),-128,127));
   z.bytes1[p]:=byte(a);
   end;
false:begin//8bit
   v:=z.bytes1[p]-128;
   v:=frcrange(round(v*m),-128,127);
   z.bytes1[p]:=byte(v)+128;
   end;
end;//case
end;//loop
except;end;
try;bunlockautofree(z);except;end;
end;
//## pdo ##
procedure taudiobasic.pdo;
label
   skipend,redo;
var
   z:tstr8;
   count,len,p:integer;
   h:pwavehdr;
   a:paudiobasicbuffer;
begin
try
//defaults
count:=0;
z:=nil;
//check
if iformatmodified or ilocked or (iphandle=0) or (not ipopen) or (ipdata.len<=0) then
   begin
   ipplaying:=false;
   ipmaxV:=0;
   exit;
   end;//end of if
//get
z:=bnew;
redo:
h:=@ipH[ippos];
a:=paudiobasicbuffer(h^.lpData);
z.add3(ipdata,0,isamplesize);
//.adjust volume
if (ipvolume<>100) then wkAdjustVolume(p16bit,z,ipvolume);
//.continue
len:=z.len;
if (len=0) then goto skipend;
for p:=1 to len do a[p-1]:=byte(z.bytes1[p]);
h.dwBufferlength:=len;
//set
if (not iformatmodified) and (not ilocked) and (iphandle<>0) and (0=waveOutWrite(iphandle,h,sizeof(h^))) then
   begin
   //maxV
   ipmaxV:=wkMaxV(p16bit,z);
   //inc
   inc(count);
   inc(ippos);
   if (ippos>high(ipH)) then ippos:=0;
   //set
   ipplaying:=true;
   ipdata.del3(0,len);
   ipcount:=frcrange(ipcount+1,1,20);
   //next
   if (ipcount<=1) and (count<=5) then goto redo;
   end
else
   begin
   ipplaying:=false;
   ipmaxV:=0;
   end;
skipend:
except;end;
try;bfree(z);except;end;
end;
//## handle ##
function taudiobasic.handle:hwnd;
begin
try
if (ihandle=0) then ihandle:=allocatehwnd(wndproc);
result:=ihandle;
except;end;
end;
//## paoc ##
procedure taudiobasic.paoc;//automatic open/close
var
   p:integer;
   ptr:HWAVEOUT;
begin
try
//open
if (not iformatmodified) and (iptime>ms64) and (not ilocked) then
   begin
   if (iphandle=0) and (0=waveOutOpen(@iphandle,0,@iformat,handle,0,WAVE_ALLOWSYNC or CALLBACK_WINDOW)) then
      begin
      //init
      for p:=0 to high(ipH) do
      begin
      fillchar(ipB[p],sizeof(ipB[p]),0);
      ipH[p].lpData:=@ipB[p];
      ipH[p].dwBufferLength:=isamplesize;//keep buffer short and responsive
      ipH[p].dwUser:=$0;
      ipH[p].dwFlags:=$0;
      ipH[p].dwLoops:=$0;
      waveOutPrepareHeader(iphandle,@ipH[p],sizeof(ipH[p]));
      end;//end of loop
      ippos:=0;
      ipcount:=0;
      end;//end of if
   end
//close
else if (iphandle<>0) and (iformatmodified or ilocked or (iptime<=ms64)) then
   begin
   //clear
   ptr:=iphandle;
   iphandle:=0;
   ipopen:=false;
   //buffers
   for p:=0 to high(ipH) do waveOutUnprepareHeader(ptr,@ipH[p],sizeof(ipH[p]));
   ipdata.clear;
   ippos:=0;
   ipcount:=0;
   ipplaying:=false;
   //close
   for p:=1 to 50 do if (0=waveOutClose(ptr)) then break else sleep(200);
   //change format when not playing
   iformatmodified:=false;
   end
else if (iptime<=ms64) then
   begin
   if (ipdata.len>=1) then ipdata.clear;
   end
else iformatmodified:=false;
except;end;
end;
//## wndproc ##
procedure taudiobasic.wndproc(var message:tmessage);
var
   a:pwavehdr;
   b:tstr8;
   p:longint;
begin
try
//check
if (ihandle=0) then exit;
//decide
case message.msg of
MM_WOM_DONE:begin
   ipcount:=frcmin(ipcount-1,0);
   pdo;
   end;
MM_WOM_OPEN:ipopen:=true;//26dec2018
MM_WIM_OPEN:;
MM_WIM_DATA:begin
   //check
   if ilocked then exit;//26JUL2009
   //get
   a:=pointer(message.lparam);
   if (a<>nil) and (a^.dwBytesRecorded>=1) then
      begin
      try
      //get
      b:=bnew;
      b.setlen(a^.dwBytesRecorded);
      for p:=0 to (a^.dwBytesRecorded-1) do b.pbytes[p]:=byte(a^.lpData[p]);
      irmaxV:=wkMaxV(r16bit,b);
      //set
      if (irdata.len<=(irsecsize*5)) then irdata.add(b);
      //reset
      waveInAddBuffer(irhandle,a,sizeof(twavehdr));
      except;end;
      try;bfree(b);except;end;
      end;
   end;//begin
end;//case
except;end;
end;
//## raoc ##
procedure taudiobasic.raoc;//automatic open/close
var
   p:integer;
   ptr:HWAVEIN;
begin
try
//open
if (not irformatmodified) and (irtime>ms64) and (not ilocked) then
   begin
   if (irhandle=0) and (0=waveInOpen(@irhandle,WAVE_MAPPER,@irformat,handle,0,CALLBACK_WINDOW)) then
      begin
      //init
      for p:=0 to high(irH) do
      begin
      fillchar(irB[p],sizeof(irB[p]),0);
      irH[p].lpData:=@irB[p];
      irH[p].dwBufferLength:=irsamplesize;//keep buffer short and responsive
      irH[p].dwUser:=$0;
      irH[p].dwFlags:=$0;
      irH[p].dwLoops:=$0;
      waveInPrepareHeader(irhandle,@irH[p],sizeof(irH[p]));
      waveInAddBuffer(irhandle,@irH[p],sizeof(irH[p]));
      end;//end of loop
      irpos:=0;
      ircount:=0;
      //start recording
      waveInStart(irhandle);
      irrecording:=true;
      end;//end of if
   end
//close
else if (irhandle<>0) and (irformatmodified or ilocked or (irtime<=ms64)) then
   begin
   //clear
   ptr:=irhandle;
   irhandle:=0;
   //stop
   waveInStop(irhandle);
   //buffers
   for p:=0 to high(irH) do waveInUnprepareHeader(ptr,@irH[p],sizeof(irH[p]));
   irdata.clear;
   irpos:=0;
   ircount:=0;
   irrecording:=false;
   //close
   for p:=1 to 50 do if (0=waveInClose(ptr)) then break else sleep(200);
   //change format when not playing
   irformatmodified:=false;
   end
else if (irtime<=ms64) then irdata.clear
else irformatmodified:=false;
except;end;
end;
//## wkMaxV ##
function taudiobasic.wkMaxV(_16bit:boolean;z:tstr8):integer;
var
   dc,tmp,zlen,step,p:integer;
   v:twrd2;
begin
try
//defaults
result:=0;
tmp:=0;
dc:=0;
//check
if not block(z) then exit;
//init
if _16bit then step:=2 else step:=1;
//get
p:=1;
zlen:=z.len;
while true do
begin
//get
v.si:=0;
case step of
1:if ((p+0)<zlen) then
   begin
   v.si:=byte(z.bytes1[p+0])-128;
   tmp:=frcrange(low__posn(round(v.si*1.56)),0,100);//0..100% (half volume/64 = our 100%)
   end;
2:if ((p+1)<zlen) then
   begin
   v.bytes[0]:=z.bytes1[p+0];
   v.bytes[1]:=z.bytes1[p+1];
   tmp:=frcrange(low__posn(v.si div 167),0,100);//0..100% (half  volume/16,000 = our 100%)
   end;
end;//end of case
//set
if (tmp>result) then result:=tmp
else
   begin
   inc(dc);
   if (dc>=30) then
      begin
      dc:=0;
      result:=frcmin(result-1,0);
      end;
   end;
//inc
inc(p,step);
if ((p+1)>zlen) then break;
end;//end of loop
except;end;
try;bunlockautofree(z);except;end;
end;
//## wkFast ##
procedure taudiobasic.wkFast(_16bit:boolean;z:tstr8);
var
   dlen,zlen,step,p:integer;
   v:twrd2;
begin
try
//check
if not block(z) then exit;
//init
if _16bit then step:=2 else step:=1;
//get
p:=1;
zlen:=z.len;
dlen:=1;
while true do
begin
//get
v.si:=0;
case step of
1:if ((p+1)<zlen) then
   begin
   z.bytes1[dlen]:=z.bytes1[p+0];inc(dlen);//l
   z.bytes1[dlen]:=z.bytes1[p+1];inc(dlen);//r
   end;
2:if ((p+3)<zlen) then
   begin
   z.bytes1[dlen]:=z.bytes1[p+0];inc(dlen);//la
   z.bytes1[dlen]:=z.bytes1[p+1];inc(dlen);//lb
   z.bytes1[dlen]:=z.bytes1[p+2];inc(dlen);//ra
   z.bytes1[dlen]:=z.bytes1[p+3];inc(dlen);//rb
   end;
end;//case
//inc
inc(p,step*4);
if ((p+3)>zlen) then break;
end;//end of loop
//shorten
if (dlen<zlen) then z.setlen(dlen);
except;end;
try;bunlockautofree(z);except;end;
end;
//## pushonline ##
function taudiobasic.pushonline:boolean;
begin
try;result:=(iphandle<>0);except;end;
end;
//## pushlen ##
function taudiobasic.pushlen:integer;//amount of data length in push buffer for playback
begin
try;result:=ipdata.len;except;end;
end;
//## canpush ##
function taudiobasic.canpush:boolean;
begin
try;result:=canpushex(2);except;end;
end;
//## canpushex ##
function taudiobasic.canpushex(seconds:integer):boolean;
begin
try;result:=(pushlen<(frcmin(seconds,1)*isecsize));except;end;
end;
//## canpushexMS ##
function taudiobasic.canpushexMS(ms:integer):boolean;
begin
try;result:=(pushlen<frcmin(round((ms/1000)*isecsize),1));except;end;
end;
{//yyyyyyyyyyyy - proc below simulates what 3bit audio sounds like (our own audio compression tests - quality=not bad) - 24aug2014
//## push16BIT ##
procedure taudiobasic.push16BIT(var data:string);
var
   p:integer;
   w:twrd2;
   ok:boolean;
   //## pushval ##
   procedure pushval(var vIN,vREF:smallint);
   var
      vd,y:integer;
      vdINV:boolean;
   begin
   //get
   vd:=vIN-vREF;
   vdINV:=(vd<0);
   if vdINV then vd:=-vd;//this allows us to use ONE RANGE and then swap back to negative number with requiring TWO RANGES - 24aug2014
   //decide
   case vd of
//   0..500:y:=50;//up
//   501..4000:y:=1000;
//   4001..33000:y:=8000;
   0..350:y:=35;
   351..3000:y:=500;
   3001..7000:y:=2000;
   7001..33000:y:=4000;
   end;
   //invert
   case vdINV of
   false:y:=vREF+y;
   true:y:=vREF-y;
   end;
   //set
   vREF:=frcrange(y,-32000,32000);
   vIN:=vREF;
   end;
begin
try
//defaults
ok:=false;
//convert
for p:=1 to (length(data) div 2) do
begin
w.chars[0]:=data[p*2-1];
w.chars[1]:=data[p*2];
case ok of
true:pushval(w.si,ijunkref1);
false:pushval(w.si,ijunkref2);
end;
data[p*2-1]:=w.chars[0];
data[p*2]:=w.chars[1];
ok:=not ok;
end;//p
//in proc below "push()" insert the line "push16BIT(data)" to compress the data and HEAR what it sounds like!
except;end;
end;
{}//yyyyyyyyyyyyy end of audio compression test - 24aug2014
//## push ##
function taudiobasic.push(data:tstr8):boolean;//14apr2017
begin
try
//defaults
result:=false;
//check
if not block(data) then exit;
//get
iptime:=ms64+frcmin(oplay_timeout,5000);//timeout after X milliseconds, range 5000..N - 14apr2017
if (data.len>=1) then
   begin
   ipdata.add(data);
   data.clear;
   //successful
   result:=true;
   end;//end of if
except;end;
try;bunlockautofree(data);except;end;
end;
//## pullonline ##
function taudiobasic.pullonline:boolean;
begin
try;result:=(irhandle<>0);except;end;
end;
//## canpull ##
function taudiobasic.canpull:boolean;
begin
try;result:=pullonline and (irdata.len>=1);except;end;
end;
//## pull ##
function taudiobasic.pull(data:tstr8):boolean;
begin
try
//defaults
result:=false;
//check
if not block(data) then exit;
//get
irtime:=ms64+orec_timeout;//timeout after X milliseconds of inactivity, range 5000..N
data.clear;
data.add(irdata);
irdata.clear;
//.rvolume - 26mar2015
if (irvolume<>100) then wkAdjustVolume(r16bit,data,irvolume);
result:=(data.len>=1);
except;end;
try;bunlockautofree(data);except;end;
end;

//## tmm #######################################################################
//## create ##
constructor tmm.create;
begin//sate: 0=nil, 1=opened, 2=playing, 3=closing
//sdc_inc(sdc_tmm,true);
//self
inherited create;
//defaults
itracknumber:=1;
itrackformat:=false;//if true then media being played (eg CD) uses tracks to play it's data and must use different procs for this
istate:=msFree;
ihandle:=0;
ideviceid:=0;
ifilename:='';
ivalid:=false;
inewposition:=-1;
//timer - fast
low__timerset(self,_ontimer,50);//start timer
end;
//## destroy ##
destructor tmm.destroy;
var
   tmp:hwnd;
begin
//sdc_inc(sdc_tmm,false);
try
//timer
low__timerdel(self,_ontimer);//disconnect our timer event from the system timer
//stop
stop;
//handle
if (ihandle<>0) then
   begin
   //.get
   tmp:=ihandle;
   ihandle:=0;
   //.set
   deallocatehwnd(tmp);
   end;//end of if
//self
inherited destroy;
//sd
except;end;
end;
//## positionBUSY ##
function tmm.positionBUSY:boolean;//we are waiting for "inewposition" to be implemented - 23MAY2013
begin
try;result:=(inewposition>=0);except;end;
end;
//## _ontimer ##
procedure tmm._ontimer(sender:tobject);
label
   skipend;
var
   genparm:tmci_generic_parms;
   playparm:tmci_play_parms;
   ferror:longint;
   int1,_filesize,_from:integer;
   _dt:tdatetime;
   z,e:string;
begin
try
//range
if (istate=msFree) and (inewposition>=0) then inewposition:=-1;//automatic safe reset - 23MAY2013
//.newposition
if ivalid and (istate=msWorking) and (inewposition>=0) and (inewposition>=ilength) then inewposition:=frcmin(ilength-1,-1);
//.position
if ivalid and (istate=msWorking) and (ilength>=0) and (inewposition>=0) then
   begin
   //set
   try
   //soft stop
   fillchar(genparm,sizeof(@genparm),#0);
   genparm.dwCallback:=handle;
   ferror:=mciSendCommand(ideviceid,mci_stop,longint(mci_notify or mci_wait),longint(@genparm));
   //play - new position
   fillchar(playparm,sizeof(playparm),#0);
   playparm.dwCallback:=handle;
   playparm.dwFrom:=itrackstart+frcrange(frcmax(inewposition,ilength-1),0,ilength);
   ferror:=mciSendCommand(ideviceid,mci_play,longint(mci_from or mci_notify),longint(@playparm));
   except;end;
   //reset
   inewposition:=-1;
   end;//end of if
//stop/loop - 01MAY2011
if (oLoop or oAutostop) and ivalid and (istate=msWorking) and (position>=len) then
   begin
   if oLoop then inewposition:=0//start at the begining
   else if oAutostop then stop;//stop playback
   end;
skipend:
except;end;
end;
//## canplay ##
function tmm.canplay:boolean;
begin
try;result:=(istate=msFree) or (istate=msWorking);except;end;
end;
//## getplaying ##
function tmm.getplaying:boolean;
begin
try;result:=(istate<>msFree);except;end;
end;
//## play ##
function tmm.play(x:string;var e:string):boolean;//reinforced, 12AUG2010
label
   skipend;
var
   z:integer;
   s:currency;
   statusparm:tmci_status_parms;
   fflags:longint;
   //## len ##
   function len:longint;
   begin
   try
   //defaults
   result:=0;
   //track ms
   fflags:=mci_Wait or mci_status_Item or mci_track;
   statusparm.dwItem:=mci_status_length;
   statusParm.dwTrack:=longint(itracknumber);
   mciSendCommand(ideviceid,mci_status,fflags,longint(@statusparm));
   if (0=mciSendCommand(ideviceid,mci_status,fflags,longint(@statusparm))) then result:=frcmin(statusparm.dwReturn,0);
   except;end;
   end;//end of if
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
iplayBUSY:=true;
//check
if canplay then
   begin
   //.stop
   stop;
   //.init
   istate:=msHold;
   ivalid:=false;
   end
else exit;//end of if
//process
//.get
iformat:='';//reset - 19MAY2013
ifilename:=x;
if not low__fileexists(x) then
   begin
   e:=gecFileNotFound;
   goto skipend;
   end;//end of if
//.open
if not _open(e) then goto skipend;
istate:=msQueued;
//.length
s:=ms64+5000;
z:=0;
while TRUE do
begin
z:=len;
if (z>=1) then break
else if (ms64>s) then break
end;
ilength:=(z div 10)*10;//round down for CD's last track
if (ilength=0) then goto skipend;
//.trackpos
fflags:=mci_wait or mci_status_item or mci_track;
statusparm.dwItem:=mci_status_position;
statusparm.dwTrack:=longint(itracknumber);
if (0=mciSendCommand(ideviceid,mci_status,fflags,longint(@statusparm))) then itrackstart:=frcmin(statusparm.dwReturn,0) else itrackstart:=0;
//.play
if not _play(e) then goto skipend;
//successful
istate:=msWorking;
ivalid:=true;
result:=true;
skipend:
except;end;
try
inewposition:=-1;//reset
if (not result) then stop;
iplayBUSY:=false;
except;end;
end;
//## canstop ##
function tmm.canstop:boolean;
begin
try;result:=(istate<>msFree) and (not istoplock);except;end;
end;
//## stop ##
procedure tmm.stop;
begin
try
//check
if not canstop then exit;
//process
//.istoplock
istoplock:=true;
//.stop
_stop;
//.free
ivalid:=false;
istate:=msFree;
//.event
low__fireevent(self,onstop);//20feb2022
except;end;
try;istoplock:=false;except;end;
end;
//## _stop ##
procedure tmm._stop;
var
   genparm:tmci_generic_parms;
begin
try
if (ideviceid<>0) then
   begin
   //#1 - soft stop - CDAudio
   fillchar(genparm,sizeof(@genparm),#0);
   genparm.dwCallback:=handle;
   mciSendCommand(ideviceid,mci_stop,longint(mci_notify or mci_wait),longint(@genparm));
   //#2 - close for all others
   genparm.dwCallback:=0;//handle;
   mciSendCommand(ideviceid,mci_close,longint(mci_wait),longint(@genparm));
   ideviceid:=0;
   end;//end of if
except;end;
try
ilength:=0;
inewposition:=-1;//not in use
except;end;
end;
//## _open ##
function tmm._open(var e:string):boolean;
label
   skipone,skipend;
var
   openparm:tmci_open_parms;
   setparm:tmci_set_parms;
   _tracknumber,ferror,fflags:longint;
   ext:string;
begin
try
//defaults
result:=false;
ext:='';
_tracknumber:=1;
//check
e:=gecUnexpectedError;
if (istate<>msHold) then exit;
//process
//.fill
fillchar(openparm,sizeof(openparm),0);
openparm.dwCallback:=0;
//..Note: must convert "long filenames => short filename" since "MCI" can only handle ~125c filenames safely, after this they fail to open/play - 23FEB2008
//..Also: "misc.shortfile" only works for existing filenames (short names accessed from disk system)
if (ifilename<>'') then
   begin
   //.nn smart cache - 26feb2015
   openparm.lpstrElementName:=pchar(low__shortfile(ifilename));
   ext:=readfileext(ifilename,true);
   //.device type
   if (ext='CDA') then
      begin
      openparm.lpstrDeviceType:=pchar('CDAudio');
      _tracknumber:=strint(copy(ifilename,length(ifilename)-5,2));
      end;
   end;
itrackformat:=(string(openparm.lpstrDeviceType)<>'');
itracknumber:=frcmin(_tracknumber,1);
//..flags
fflags:=mci_wait;
if (ifilename<>'') then fflags:=fflags or mci_open_element;
if itrackformat then fflags:=fflags or mci_open_type;//CDA => CDAudio
//.set
ferror:=mciSendCommand(0,mci_open,fflags,longint(@openparm));
skipone:
if (ferror<>0) then
   begin
   e:=gecTaskFailed;
   goto skipend;
   end;//end of if
//successful
ideviceid:=openparm.wdeviceid;
//time format - milliseconds
fillchar(setparm,sizeof(setparm),#0);
setparm.dwTimeFormat:=longint(0);
mciSendCommand(ideviceid,mci_set,longint(mci_set_time_format or mci_wait),longint(@setparm));
//successful
result:=true;
skipend:
except;end;
end;
//## _play ##
function tmm._play(var e:string):boolean;
var
   playparm:tmci_play_parms;
   ferror:longint;
begin
try
//defaults
result:=false;
e:=gecUnexpectedError;
//check
if (istate<>msQueued) then exit;
//set
//.ms
fillchar(playparm,sizeof(playparm),#0);
playparm.dwCallback:=handle;
//Note: XP can't handle playing a short fast midi when "mci_from" flag is specified - a double ding ship's bell fails sometimes to play BOTH DONGS - 29SEP2010
case (itrackstart>=1) of
true:begin
   playparm.dwFrom:=itrackstart;
   ferror:=mciSendCommand(ideviceid,mci_play,longint(mci_from or mci_notify),longint(@playparm));
   end;
false:ferror:=mciSendCommand(ideviceid,mci_play,longint(mci_notify),longint(@playparm));
end;//end of case
//return result
result:=(ferror=0);
except;end;
end;
//## gethandle ##
function tmm.gethandle:hwnd;
begin
try
//get
if (ihandle=0) then ihandle:=allocatehwnd(wndproc);
//set
result:=ihandle;
except;end;
end;
//## getmode ##
function tmm.getmode:tmmodes;
var
   statusparm:tmci_status_parms;
   ferror,fflags:longint;
begin
try
//check
if not ivalid then result:=mmNotReady
else
   begin
   fflags:=mci_wait or mci_status_item;
   statusparm.dwItem:=mci_status_mode;
   ferror:=mciSendCommand(ideviceid,mci_status,fflags,longint(@statusparm));
   result:=tmmodes(statusparm.dwReturn-524);//MCI Mode #s are 524+enum
   end;
except;end;
end;
//## getposition ##
function tmm.getposition:longint;
var
   statusparm:tmci_status_parms;
   ferror,fflags:longint;
begin
try
if not ivalid then result:=0
else
   begin
   fflags:=mci_wait or mci_status_item;
   statusparm.dwItem:=mci_status_position;
   ferror:=mciSendCommand(ideviceid,mci_status,fflags,longint(@statusparm));
   if (ferror=0) then result:=frcmin(statusparm.dwReturn,0) else result:=0;//04JUL2010
   //adjust for track
   result:=frcrange(result-itrackstart,0,ilength);
   end;
except;end;
end;
//## setposition ##
procedure tmm.setposition(x:longint);
begin
try;if (x>=0) then inewposition:=x;except;end;
end;
//## getpertpos ##
function tmm.getpertpos:double;
begin
try;if ivalid then result:=low__makepertD0(position,len) else result:=0;except;end;
end;
//## setnewpertpos ##
procedure tmm.setnewpertpos(x:double);
begin
try
//range
if (x<0) then x:=0 else if (x>100) then x:=100;
//get
inewpertpos:=x;
except;end;
end;
//## wndproc ##
procedure tmm.wndproc(var message:tmessage);
begin
try
//decide
case message.msg of
mm_mcinotify:begin
   case message.wparam of
   mci_notify_aborted,mci_notify_successful,mci_notify_failure:;
   end;//end of case
   end;//end of begin
end;//end of case
except;end;
end;

//## tplaylist #################################################################
//## create ##
constructor tplaylist.create;//20mar2022
begin
try
//self
inherited create;
//vars
iopenfilter:=0;
ilistcoreid:=0;
ilistcoreUNDO:=bnew;
ilistcoreFULL:=bnew;
ilistcore:=bnew;
ilist:=nil;
ilistcoreCANUNDO:=false;
ilistcoreUNDO_itemindex:=0;
ifilenameOPEN:=windrive+'Untitled.m3u';
ifilenameSAVE:=ifilenameOPEN;
ipartmask:='';
ifullmask:='';
except;end;
end;
//## destroy ##
destructor tplaylist.destroy;//20mar2022
begin
try
//vars
list:=nil;//disconnect
bfree(ilistcoreUNDO);
bfree(ilistcoreFULL);
bfree(ilistcore);
//self
inherited destroy;
except;end;
end;
//## xlistitem ##
function tplaylist.xlistitem(sender:tobject;xindex:longint;var xtab,xtep,xtepcolor:longint;var xcaption,xcaplabel,xhelp,xcode2:string;var xcode,xshortcut,xindent:longint;var xflash,xenabled,xtitle,xsep:boolean):boolean;
var
   asec:longint;
   atitle,afilename:string;
begin
try
if listok and (sender=ilist) then
   begin
   playlist__getone('',ilistcore,xindex,asec,atitle,afilename);
   xtep:=tepext2(afilename,tepFNew20);
   xcaplabel:=atitle;
   xcaption:=afilename;
   end;
except;end;
end;
//## listok ##
function tplaylist.listok:boolean;
begin
try;result:=(ilist<>nil);except;end;
end;
//## setlist ##
procedure tplaylist.setlist(x:tbasicmenu);
begin
try
if (x<>ilist) then
   begin
   //disconnect list
   if (x=nil) and listok then ilist.ongetitem:=nil;
   //get
   ilist:=x;
   //connect list and sync
   if listok then
      begin
      ilist.ongetitem:=xlistitem;
      xlistsync;
      end;
   end;
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxx//ppppppppppppppppppp
//## setpartmask ##
procedure tplaylist.setpartmask(x:string);
begin
try;if low__setstr(ipartmask,x) then xmask(true);except;end;
end;
//## setfullmask ##
procedure tplaylist.setfullmask(x:string);
begin
try;ifullmask:=x;except;end;
end;
//## xmask ##
procedure tplaylist.xmask(xforce:boolean);
var
   a:tstr8;
   p,xsec:longint;
   xtitle,xfilename,v:string;
begin
try
//defaults
a:=nil;
//get
v:=ipartmask;
if (v<>ipartmask) or xforce then
   begin
   //init
   ipartmask:=v;
   a:=bnew;
   //get
   for p:=0 to playlist__count(ilistcoreFULL) do
   begin
   playlist__getone('',ilistcoreFULL,p,xsec,xtitle,xfilename);
   playlist__addone('',a,xsec,xtitle,xfilename,ipartmask);
   end;//p
   //set
   ilistcore.clear;
   ilistcore.add(a);//all in one go
   //.inc id
   low__iroll(ilistcoreid,1);
   //.sync with host list
   xlistsync;
   end;
except;end;
try;bfree(a);except;end;
end;
//## xlistsync ##
procedure tplaylist.xlistsync;
begin
try
//check
if not listok then exit;
//get
ilist.makelistx(playlist__count(ilistcore));
ilist.itemindex:=frcrange(ilist.itemindex,0,frcmin(ilist.count-1,0));//20mar2022
except;end;
end;
//## canclear ##
function tplaylist.canclear:boolean;
var
   e:string;
begin
try;result:=xcmd('canclear',e);except;end;
end;
//## clear ##
function tplaylist.clear(var e:string):boolean;
begin
try;result:=xcmd('clear',e);except;end;
end;
//## cannew ##
function tplaylist.cannew:boolean;
var
   e:string;
begin
try;result:=xcmd('cannew',e);except;end;
end;
//## new ##
function tplaylist.new(var e:string):boolean;
begin
try;result:=xcmd('new',e);except;end;
end;
//## cancut ##
function tplaylist.cancut:boolean;
var
   e:string;
begin
try;result:=xcmd('cancut',e);except;end;
end;
//## cut ##
function tplaylist.cut(var e:string):boolean;
begin
try;result:=xcmd('cut',e);except;end;
end;
//## cancopy ##
function tplaylist.cancopy:boolean;
var
   e:string;
begin
try;result:=xcmd('cancopy',e);except;end;
end;
//## copy ##
function tplaylist.copy(var e:string):boolean;
begin
try;result:=xcmd('copy',e);except;end;
end;
//## cancopyall ##
function tplaylist.cancopyall:boolean;
var
   e:string;
begin
try;result:=xcmd('cancopyall',e);except;end;
end;
//## copyall ##
function tplaylist.copyall(var e:string):boolean;
begin
try;result:=xcmd('copyall',e);except;end;
end;
//## canpaste ##
function tplaylist.canpaste:boolean;
var
   e:string;
begin
try;result:=xcmd('canpaste',e);except;end;
end;
//## paste ##
function tplaylist.paste(var e:string):boolean;
begin
try;result:=xcmd('paste',e);except;end;
end;
//## canreplace ##
function tplaylist.canreplace:boolean;
var
   e:string;
begin
try;result:=xcmd('canreplace',e);except;end;
end;
//## replace ##
function tplaylist.replace(var e:string):boolean;
begin
try;result:=xcmd('replace',e);except;end;
end;
//## canopen ##
function tplaylist.canopen:boolean;
var
   e:string;
begin
try;result:=xcmd('canopen',e);except;end;
end;
//## open ##
function tplaylist.open(var e:string):boolean;
begin
try;result:=xcmd('open',e);except;end;
end;
//## cansave ##
function tplaylist.cansave:boolean;
var
   e:string;
begin
try;result:=xcmd('cansave',e);except;end;
end;
//## save ##
function tplaylist.save(var e:string):boolean;
begin
try;result:=xcmd('save',e);except;end;
end;
//## canundo ##
function tplaylist.canundo:boolean;
var
   e:string;
begin
try;result:=xcmd('canundo',e);except;end;
end;
//## undo ##
function tplaylist.undo(var e:string):boolean;
begin
try;result:=xcmd('undo',e);except;end;
end;
//## xfillundo ##
procedure tplaylist.xfillundo;
begin
try
ilistcoreCANUNDO:=true;
if listok then ilistcoreUNDO_itemindex:=ilist.itemindex;
ilistcoreUNDO.clear;
ilistcoreUNDO.add(ilistcoreFULL);
except;end;
end;
//## xundo ##
function tplaylist.xundo(var e:string):boolean;
var
   a:tstr8;
   int1:longint;
begin
try
//defaults
result:=false;
a:=nil;
e:=gecTaskfailed;
//1
a:=bnew;
a.add(ilistcoreUNDO);
int1:=ilistcoreUNDO_itemindex;
//2
ilistcoreUNDO.clear;
ilistcoreUNDO.add(ilistcoreFULL);
if listok then ilistcoreUNDO_itemindex:=ilist.itemindex;
//3
ilistcoreFULL.clear;
ilistcoreFULL.add(a);
xmask(true);
if listok then ilist.itemindex:=int1;
//successful
result:=true;
except;end;
try;bfree(a);except;end;
end;
//## xguiOK ##
function tplaylist.xguiOK:boolean;
begin
try;result:=(system_program<>nil) and (system_program is tbasicprg2) and ((system_program as tbasicprg2).gui<>nil);except;end;
end;
//## xgui ##
function tplaylist.xgui:tbasicsystem;
begin
try
result:=nil;
if xguiOK then result:=(system_program as tbasicprg2).gui;
except;end;
end;
//## xcmd ##
function tplaylist.xcmd(n:string;var e:string):boolean;
begin
try
//defaults
result:=true;
e:=gecTaskfailed;
//init
n:=low__lowercase(n);

//new
if (n='cannew') then result:=true
else if (n='new') then
   begin
   if xcmd('cannew',e) and xguiOK and xgui.popquery('Clear current playlist?') then
      begin
      xfillundo;
      ilistcoreFULL.clear;
      xmask(true);
      end;
   end
//clear
else if (n='canclear') then result:=true
else if (n='clear') then
   begin
   if xcmd('canclear',e) then
      begin
      xfillundo;
      ilistcoreFULL.clear;
      xmask(true);
      end;
   end
//cut
else if (n='cancut') then
   begin
   if listok then result:=(playlist__count(ilistcore)>=1) else result:=(playlist__count(ilistcoreFULL)>=1);
   end
else if (n='cut') then//one
   begin
   result:=xcmd('cancopy',e) and xcopy(false,true,e);
   end
//copy
else if (n='cancopy') then
   begin
   if listok then result:=(playlist__count(ilistcore)>=1) else result:=(playlist__count(ilistcoreFULL)>=1);
   end
else if (n='copy')       then result:=xcmd('cancopy',e) and xcopy(false,false,e)
//copy all
else if (n='cancopyall') then result:=(playlist__count(ilistcore)>=1)
else if (n='copyall')    then result:=xcmd('cancopyall',e) and xcopy(true,false,e)
//paste
else if (n='canpaste')   then result:=low__canpastetxt
else if (n='paste')      then result:=xcmd('canpaste',e) and xpaste(false,e)
//replace
else if (n='canreplace')   then result:=low__canpastetxt
else if (n='replace')      then result:=xcmd('canreplace',e) and xpaste(true,e)
//undo
else if (n='canundo')   then result:=ilistcoreCANUNDO
else if (n='undo')      then result:=xcmd('canundo',e) and xundo(e)
//open
else if (n='canopen')   then result:=true
else if (n='open')      then result:=xcmd('canopen',e) and xopen(e)
//saveas
else if (n='cansave')   then result:=(playlist__count(ilistcoreFULL)>=1)
else if (n='save')      then result:=xcmd('cansave',e) and xsave(e);

except;end;
end;
//## xcopy ##
function tplaylist.xcopy(xall,xcut:boolean;var e:string):boolean;
label
   skipend;
var
   xdata,a:tstr8;
   int1,s,t,p,xsec:longint;
   xtitle,xfilename:string;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
a:=nil;//pointer only
xdata:=nil;
//init
a:=ilistcoreFULL;//the full list behind the scenes list - 20mar2022
s:=0;
t:=frcmin(playlist__count(a)-1,0);
if (not xall) and listok then
   begin
   a:=ilistcore;//the what we see list
   s:=ilist.itemindex;
   t:=s;
   end;
//check
if (playlist__count(a)<=0) then
   begin
   result:=true;
   goto skipend;
   end;
//range
s:=frcrange(s,0,playlist__count(a)-1);
t:=frcrange(t,s,playlist__count(a)-1);
//get
xdata:=bnew;
xdata.sadd('#EXTM3U'+rcode);
for p:=s to t do
begin
playlist__getone('',a,p,xsec,xtitle,xfilename);
xdata.sadd('#EXTINF:'+inttostr(xsec)+','+xtitle+rcode);
xdata.sadd(low__makerelative(xfilename,'')+rcode+rcode);//1 blank line
end;//p
//set
if not low__copytxt(xdata) then goto skipend;
//cut
if xcut then
   begin
   //init
   xdata.clear;
   if listok then int1:=ilist.itemindex else int1:=0;
   //get
   xdata.sadd('#EXTM3U'+rcode);
   for p:=0 to frcmin(playlist__count(a)-1,0) do
   begin
   if (p<>int1) then//omit the currently selected item - 20mar2022
      begin
      playlist__getone('',a,p,xsec,xtitle,xfilename);
      xdata.sadd('#EXTINF:'+inttostr(xsec)+','+xtitle+rcode);
      xdata.sadd(low__makerelative(xfilename,'')+rcode+rcode);//1 blank line
      end;
   end;//p
   //set
   xfillundo;
   xadd(xdata,int1,'',true);
   end;

//successful
result:=true;
skipend:
except;end;
try;bfree(xdata);except;end;
end;
//## xpaste ##
function tplaylist.xpaste(xclear:boolean;var e:string):boolean;
label
   skipend;
var
   a:tstr8;
   int1:longint;
begin
try
//defaults
result:=false;
a:=nil;
e:=gecTaskfailed;
//get
a:=bnew;
if listok then int1:=ilist.itemindex else int1:=0;
if not low__pastetxt(a) then goto skipend;
xfillundo;
if xclear then int1:=0;
if not xadd(a,int1,'',xclear) then goto skipend;//append to existing list
//sucessful
result:=true;
skipend:
except;end;
try;bfree(a);except;end;
end;
//## xaddone ##
function tplaylist.xaddone(xsec:longint;xtitle,xfilename:string):boolean;//now supports "m3u" as well - 27mar2022
var
   a:tstr8;
   e:string;
   int1:longint;
begin
try
//defaults
result:=false;
a:=nil;
//get
if (lowercase__readfileext(xfilename)='m3u') then
   begin
   a:=bnew;
   if listok then int1:=ilist.itemindex else int1:=0;
   if low__fromfile(xfilename,a,e) and (a.len>=1) then result:=xadd(a,int1,xfilename,false);
   end
else result:=playlist__addone('',ilistcoreFULL,xsec,xtitle,xfilename,ifullmask);
except;end;
try;if (a<>nil) then bfree(a);except;end;
end;
//## xadd ##
function tplaylist.xadd(xdata:tstr8;xindex:longint;xauthoritativeFilename:string;xclear:boolean):boolean;
label
   skipend;
var
   e:string;
begin
try
//defaults
result:=false;
//check
if not block(xdata) then exit;
//set
if xclear then ilistcoreFULL.clear;
playlist__addall('',xauthoritativeFilename,ilistcoreFULL,xdata,ifullmask);
xmask(true);
if listok then ilist.itemindex:=frcrange(xindex,0,frcmin(ilist.count-1,0));
//successful
result:=true;
except;end;
try;bunlockautofree(xdata);except;end;
end;
//## xopen ##
function tplaylist.xopen(var e:string):boolean;
var
   int1:longint;
begin
try
if listok then int1:=ilist.itemindex else int1:=0;
result:=xopen2(ifilenameOPEN,int1,true,true,e);
except;end;
end;
//## xopen2 ##
function tplaylist.xopen2(xfilename:string;xindex:longint;xprompt,afillundo:boolean;var e:string):boolean;
label
   skipend;
var
   xdata:tstr8;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
xdata:=nil;
//prompt
if xprompt then
   begin
   ifilenameOPEN:=xfilename;
   if (not xguiok) or (not xgui.popopen(xfilename,iopenfilter,peM3U,'')) then
      begin
      result:=true;
      goto skipend;
      end;
   ifilenameOPEN:=xfilename;
   end;
//get
xdata:=bnew;
if not low__fromfile(xfilename,xdata,e) then goto skipend;
//set
e:=gecTaskfailed;
if afillundo then xfillundo;//fill undo
if not xadd(xdata,xindex,xfilename,true) then goto skipend;
//successful
result:=true;
skipend:
except;end;
try;bfree(xdata);except;end;
end;
//## xsave ##
function tplaylist.xsave(var e:string):boolean;
begin
try;result:=xsave2(ifilenameSAVE,true,e);except;end;
end;
//## xsave2 ##
function tplaylist.xsave2(dfilename:string;xprompt:boolean;var e:string):boolean;
label
   skipend;
var
   xdata:tstr8;
   xtitle,xfilename:string;
   xsec,p,xcount:longint;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
xdata:=nil;
//prompt
if xprompt then
   begin
   ifilenameSAVE:=dfilename;
   if (not xguiok) or (not xgui.popsave(dfilename,peM3U,'')) then
      begin
      result:=true;
      goto skipend;//report no error
      end;
   ifilenameSAVE:=dfilename;
   end;
//init
xdata:=bnew;
//get
//.header
xdata.sadd('#EXTM3U'+rcode);
//.contents
xcount:=playlist__count(ilistcoreFULL);
for p:=0 to (xcount-1) do
begin
playlist__getone('',ilistcoreFULL,p,xsec,xtitle,xfilename);
xdata.sadd('#EXTINF:'+inttostr(xsec)+','+xtitle+rcode);
xdata.sadd(low__makerelative(xfilename,dfilename)+rcode+rcode);//1 blank line
end;//p
//set
if not low__tofile(dfilename,xdata,e) then goto skipend;
//successful
result:=true;
skipend:
except;end;
try;bfree(xdata);except;end;
end;

{$endif}
//end of multimedia support ----------------------------------------------------
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//mmmmmmmmmmmmmmmmmm

//## tbasicimage ###############################################################
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxx//ggggggggggggggggggggggggggggg
//## create ##
constructor tbasicimage.create;//01NOV2011
begin
satinc(satBasicimage,1);
zzadd(self);
inherited create;
//options
misaiclear(ai);
dtransparent:=true;
omovie:=false;
oaddress:='';
ocleanmask32bpp:=false;
rhavemovie:=false;
//vars
istable:=false;
idata:=bnew;
irows:=bnew;
ibits:=0;
iwidth:=0;
iheight:=0;
iprows8 :=nil;
iprows16:=nil;
iprows24:=nil;
iprows32:=nil;
//defaults
setparams(8,1,1);
//enable
istable:=true;
end;
//## destroy ##
destructor tbasicimage.destroy;//28NOV2010
begin
try
//disable
istable:=false;
//controls
iprows8 :=nil;
iprows16:=nil;
iprows24:=nil;
iprows32:=nil;
freeobj(@irows);
freeobj(@idata);
//destroy
inherited destroy;
satinc(satBasicimage,-1);
except;end;
end;
//## copyfrom ##
function tbasicimage.copyfrom(s:tbasicimage):boolean;//09may2022, 09feb2022
label
   skipend;
begin
try
//defaults
result:=false;
//check
if (s=self) then
   begin
   result:=true;
   exit;
   end;
if (s=nil) then exit;
//get
//was: if not low__aicopy(ai,s.ai) then goto skipend;
if not low__aicopy(s.ai,ai) then goto skipend;//09may2022
dtransparent:=s.dtransparent;
omovie:=s.omovie;
oaddress:=s.oaddress;
ocleanmask32bpp:=s.ocleanmask32bpp;
rhavemovie:=s.rhavemovie;
setraw(misb(s),misw(s),mish(s),s.data);
//successful
result:=true;
skipend:
except;end;
end;
//## todata ##
function tbasicimage.todata:tstr8;//19feb2022
label
   skipend;
var
   xresult:boolean;
   v8:tvars8;
   tmp:tstr8;//pointer only
begin
try
//defaults
result:=bnew;
xresult:=false;
v8:=nil;
//info
v8:=vnew;
if (ai.format<>'')        then v8.s['f']:=ai.format;
if (ai.subformat<>'')     then v8.s['s']:=ai.subformat;
if (ai.info<>'')          then v8.s['i']:=ai.info;
if (ai.map16<>'')         then v8.s['m']:=ai.map16;
if ai.transparent         then v8.b['t']:=ai.transparent;
if ai.syscolors           then v8.b['sc']:=ai.syscolors;
if ai.flip                then v8.b['fp']:=ai.flip;
if ai.mirror              then v8.b['mr']:=ai.mirror;
if (ai.delay<>0)          then v8.i['d']:=ai.delay;
if (ai.itemindex<>0)      then v8.i['i']:=ai.itemindex;
if (ai.count<>0)          then v8.i['c']:=ai.count;
if (ai.bpp<>0)            then v8.i['bp']:=ai.bpp;
if ai.binary              then v8.b['bin']:=ai.binary;
if (ai.hotspotX<>0)       then v8.i['hx']:=ai.hotspotX;
if (ai.hotspotY<>0)       then v8.i['hy']:=ai.hotspotY;
if ai.hotspotMANUAL       then v8.b['hm']:=ai.hotspotMANUAL;
if ai.owrite32bpp         then v8.b['w32']:=ai.owrite32bpp;
if ai.readB64             then v8.b['r64']:=ai.readB64;
if ai.readB128            then v8.b['r128']:=ai.readB128;
if ai.writeB64            then v8.b['w64']:=ai.writeB64;
if ai.writeB128           then v8.b['w128']:=ai.writeB128;
if (ai.iosplit<>0)        then v8.i['ios']:=ai.iosplit;
if (ai.cellwidth<>0)      then v8.i['cw']:=ai.cellwidth;
if (ai.cellheight<>0)     then v8.i['ch']:=ai.cellheight;
if ai.use32               then v8.b['u32']:=ai.use32;//22may2022
if dtransparent           then v8.b['dt']:=dtransparent;
if omovie                 then v8.b['mv']:=omovie;
if (oaddress<>'')         then v8.s['ad']:=oaddress;
if ocleanmask32bpp        then v8.b['c32']:=ocleanmask32bpp;
if rhavemovie             then v8.b['hmv']:=rhavemovie;
//.info
tmp:=v8.data;
result.addint4(0);
result.addint4(tmp.len);
result.add(tmp);
//.pixels
result.addint4(1);
result.addint4(12+idata.len);
result.addint4(bits);
result.addint4(width);
result.addint4(height);
result.add(idata);
//.finished
result.addint4(maxint);
//successful
xresult:=true;
skipend:
except;end;
try
result.oautofree:=true;
if (not xresult) and (result<>nil) then result.clear;
freeobj(@v8);
except;end;
end;
//## fromdata ##
function tbasicimage.fromdata(s:tstr8):boolean;//19feb2022
label
   redo,skipend;
var
   v8:tvars8;
   abits,xid,xpos,xlen:longint;
   xdata:tstr8;
   //## xpull ##
   function xpull:boolean;
   label
      skipend;
   var
      b,w,h,slen:longint;
   begin
   try
   //defaults
   result:=false;
   //clear
   xdata.clear;
   //id
   if ((xpos+3)>=xlen) then goto skipend;
   xid:=s.int4[xpos];
   inc(xpos,4);
   //eof
   if (xid=maxint) then
      begin
      result:=true;
      goto skipend;
      end;
   //slen
   if ((xpos+3)>=xlen) then goto skipend;
   slen:=s.int4[xpos];
   inc(xpos,4);
   //check
   if ((xpos+slen-1)>=xlen) then goto skipend;
   //data
   if not xdata.add3(s,xpos,slen) then goto skipend;
   inc(xpos,slen);
   //set
   case xid of
   0:v8.data:=xdata;
   1:begin
      b:=xdata.int4[0];//0..3
      w:=xdata.int4[4];//4..7
      h:=xdata.int4[8];//8..11
      if (b<0) or (w<=0) or (h<=0) then goto skipend;
      if not xdata.del3(0,12) then goto skipend;
      if not setraw(b,w,h,xdata) then goto skipend;
      end;
   else goto skipend;//error
   end;
   //successfsul
   result:=true;
   skipend:
   except;end;
   end;
begin
try
//defaults
result:=false;
v8:=nil;
xdata:=nil;
abits:=bits;
//check
if not block(s) then exit;
//init
xlen:=s.len;
xpos:=0;
v8:=vnew;
xdata:=bnew;
//get
redo:
if not xpull then goto skipend;
if (xid<>maxint) then goto redo;

//info
ai.format            :=v8.s['f'];
ai.subformat         :=v8.s['s'];
ai.info              :=v8.s['i'];
ai.map16             :=v8.s['m'];
ai.transparent       :=v8.b['t'];
ai.syscolors         :=v8.b['sc'];
ai.flip              :=v8.b['fp'];
ai.mirror            :=v8.b['mr'];
ai.delay             :=v8.i['d'];
ai.itemindex         :=v8.i['i'];
ai.count             :=v8.i['c'];
ai.bpp               :=v8.i['bp'];
ai.binary            :=v8.b['bin'];
ai.hotspotX          :=v8.i['hx'];
ai.hotspotY          :=v8.i['hy'];
ai.hotspotMANUAL     :=v8.b['hm'];
ai.owrite32bpp       :=v8.b['w32'];
ai.use32             :=v8.b['u32'];//22may2022
ai.readB64           :=v8.b['r64'];
ai.readB128          :=v8.b['r128'];
ai.writeB64          :=v8.b['w64'];
ai.writeB128         :=v8.b['w128'];
ai.iosplit           :=v8.i['ios'];
ai.cellwidth         :=v8.i['cw'];
ai.cellheight        :=v8.i['ch'];
dtransparent         :=v8.b['dt'];
omovie               :=v8.b['mv'];
oaddress             :=v8.s['ad'];
ocleanmask32bpp      :=v8.b['c32'];
rhavemovie           :=v8.b['hmv'];

//successful
result:=true;
skipend:
except;end;
try
freeobj(@v8);
bfree(xdata);
bunlockautofree(s);
//error
if not result then setparams(abits,1,1);
except;end;
end;
//## sizeto ##
function tbasicimage.sizeto(dw,dh:longint):boolean;
begin
try;result:=setparams(ibits,dw,dh);except;end;
end;
//## setparams ##
function tbasicimage.setparams(dbits,dw,dh:longint):boolean;
var
   dy,dlen:longint;
begin
try
//defaults
result:=false;
//range
if (dbits<>8) and (dbits<>16) and (dbits<>24) and (dbits<>32) then dbits:=24;
if (dw<1) then dw:=1;
if (dh<1) then dh:=1;
//check
if (dbits=ibits) and (dw=iwidth) and (dh=iheight) then
   begin
   result:=true;
   exit;
   end;
//get
dlen:=(dbits div 8)*dw*dh;
if idata.setlen(dlen) then
   begin
   //init
   ibits:=dbits;
   iwidth:=dw;
   iheight:=dh;
   app__fasttimer;//fasttimer - 07jul2021
   irows.setlen(dh*sizeof(pointer));
   iprows8 :=irows.prows8;
   iprows16:=irows.prows16;
   iprows24:=irows.prows24;
   iprows32:=irows.prows32;
   //get
   for dy:=0 to (dh-1) do
   begin
   //.fasttimer - ycheck
   inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

   case dbits of
   8 :iprows8[dy] :=pointer(cardinal(idata.core)+(dy*dw));  //not 64bit safe -> cardinal only 0..2.1Gb
   16:iprows16[dy]:=pointer(cardinal(idata.core)+(dy*dw*2));
   24:iprows24[dy]:=pointer(cardinal(idata.core)+(dy*dw*3));
   32:iprows32[dy]:=pointer(cardinal(idata.core)+(dy*dw*4));
   end;
   end;//dy
   //successful
   result:=true;
   end;
except;end;
end;
//## setraw ##
function tbasicimage.setraw(dbits,dw,dh:longint;ddata:tstr8):boolean;
var
   p,xlen:longint;
   v:byte;
begin
try
result:=false;
setparams(dbits,dw,dh);
if (ddata<>nil) and (idata<>nil) then
   begin
   xlen:=frcmax(idata.len,ddata.len);
   if (xlen>=1) then
      begin
      //was: for p:=0 to (xlen-1) do idata.pbytes[p]:=ddata.pbytes[p];
      //faster - 22apr2022
      for p:=0 to (xlen-1) do
      begin
      v:=ddata.pbytes[p];
      idata.pbytes[p]:=v;
      end;//p
      end;
   end;
result:=true;//19feb2022
except;end;
try;bautofree(ddata);except;end;
end;
//## getscanline ##
function tbasicimage.findscanline(slayer,sy:longint):pointer;
begin
//defaults
result:=nil;
//check
if (iwidth<1) or (iheight<1) then exit;
//range
if (sy<0) then sy:=0 else if (sy>=iheight) then sy:=iheight-1;
//get
result:=pointer(cardinal(idata)+(sy*iwidth*(ibits div 8)));//not 64bit safe
end;

//## tbmp ######################################################################
//## create ##
constructor tbmp.create;
begin
satinc(satBmp,1);
zzadd(self);
inherited create;
//options
misaiclear(ai);
dtransparent:=true;
omovie:=false;
oaddress:='';
ocleanmask32bpp:=false;
rhavemovie:=false;
//vars
ilockptr:=nil;
ibits:=0;
iwidth:=0;
iheight:=0;
ilockcount:=0;
iunlocking:=false;
isharp:=0;//0=off, 1=monochrome, 8=greyscale
{$ifdef D3}
isharphfont:=0;
{$endif}
icore  :=createbitmap;
irows  :=bnew;
irows8 :=nil;
irows15:=nil;
irows16:=nil;
irows24:=nil;
irows32:=nil;
//defaults
setparams(32,1,1);
end;
//## destroy ##
destructor tbmp.destroy;
begin
try
//release
unlock;
sharp:=0;
//vars
irows8 :=nil;
irows15:=nil;
irows16:=nil;
irows24:=nil;
irows32:=nil;
freeobj(@icore);
bfree(irows);
//self
inherited destroy;
satinc(satBmp,-1);
except;end;
end;
//## setbits ##
procedure tbmp.setbits(x:longint);
begin
try;setparams(x,iwidth,iheight);except;end;
end;
//## setwidth ##
procedure tbmp.setwidth(x:longint);
begin
try;setparams(ibits,x,iheight);except;end;
end;
//## setheight ##
procedure tbmp.setheight(x:longint);
begin
try;setparams(ibits,iwidth,x);except;end;
end;
//## cansetparams ##
function tbmp.cansetparams:boolean;
begin
try;result:=(not locked) and (isharp=0);except;end;
end;
//## setparams ##
function tbmp.setparams(dbits,dw,dh:longint):boolean;
begin
try
//defaults
result:=false;
//check
if not cansetparams then exit;
//range
if (dbits<>1) and (dbits<>8) and (dbits<>15) and (dbits<>16) and (dbits<>24) and (dbits<>32) then dbits:=32;
dw:=frcmin(dw,1);
dh:=frcmin(dh,1);
//get
if (dbits<>ibits) or (dw<>iwidth) or (dh<>iheight) then
   begin
   //bits
   {$ifdef D3}
   if (dbits<>ibits) then
      begin
      case dbits of
       1:icore.pixelformat:=pf1bit;//05feb2022
      15:icore.pixelformat:=pf15bit;
      16:icore.pixelformat:=pf16bit;
      24:icore.pixelformat:=pf24bit;
      32:icore.pixelformat:=pf32bit;
      else icore.pixelformat:=pf32bit;//fallback position -> default for Android
      end;//case
      end;
   {$endif}
   //width
   if (icore.width<>dw) then icore.width:=dw;
   //height
   if (icore.height<>dh) then icore.height:=dh;
   //sync
   xinfo;
   //successful
   result:=true;
   end
else result:=true;
except;end;
end;
//## xinfo ##
procedure tbmp.xinfo;
var
   int1:longint;
   e:string;
begin
try
int1:=misb(icore);
if (int1>=1) then ibits:=int1
else
   begin
   missetb(icore,ibits);//fixed - 07apr2021
   //Critical Note: 32bit image loses it's bits setting when "assigned/pasted" to our icore (bitmap)
   //               so must restore bit value and check mask for 32bit images is valid because
   //               24bit images pasted into a 32bit image have an empty mask (all zeros)
   //               when this is the case change all the zeros to 255's - 18jun2021
   if (ibits=32) and mask__empty(icore) then mask__setval(icore,255);//build a "solid" alpha mask - 18jun2021
   end;
iwidth:=misw(icore);
iheight:=mish(icore);
except;end;
end;
//## cancanvas ##
function tbmp.cancanvas:boolean;
begin
try;result:=true;except;end;
end;
//## getcanvas ##
function tbmp.getcanvas:tcanvas;
begin
try;result:=icore.canvas;except;end;
end;
//## canassign ##
function tbmp.canassign:boolean;
begin
try;result:=(not locked) and (isharp=0);except;end;
end;
//## assign ##
function tbmp.assign(x:tobject):boolean;
var
   sbits:longint;
begin
try
//defaults
result:=false;
//check
if (not canassign) or zznil(x,7402) then exit;//04may2021
//get
if (x is tbitmap) then
   begin
   icore.assign(x as tbitmap);
   xinfo;
   result:=true;//27apr2021
   end
else if (x=clipboard) then
   begin
   sbits:=misb(icore);
   icore.assign(clipboard);
   xinfo;
   result:=true;//27apr2021
   end;
{$ifdef jpeg}
if (x is tjpegimage) then
   begin
   icore.assign(x as tjpegimage);
   xinfo;
   result:=true;//27apr2021
   end;
{$endif}
except;end;
end;
//## canrows ##
function tbmp.canrows:boolean;
begin
try;result:=locked;except;end;
end;
//## locked ##
function tbmp.locked:boolean;
begin
try;result:=(ilockcount>=1);except;end;
end;
//## lock ##
function tbmp.lock:boolean;
label
   skipend;
var
{$ifdef D10}
   a:tbitmapdata;
{$endif}
   dy:longint;
begin
try
//defaults
result:=false;
//check
inc(ilockcount);
if (ilockcount<>1) then exit;
//init
irows.setlen(iheight*sizeof(tpointer));
irows8 :=irows.core;
irows15:=irows.core;
irows16:=irows.core;
irows24:=irows.core;
irows32:=irows.core;

//get rows ---------------------------------------------------------------------

{$ifdef D3}
ilockptr:=nil;//not used for Win32
case ibits of
1 :for dy:=0 to (iheight-1) do irows8[dy] :=icore.scanline[dy];//05feb2022
8 :for dy:=0 to (iheight-1) do irows8[dy] :=icore.scanline[dy];
15:for dy:=0 to (iheight-1) do irows15[dy]:=icore.scanline[dy];
16:for dy:=0 to (iheight-1) do irows16[dy]:=icore.scanline[dy];
24:for dy:=0 to (iheight-1) do irows24[dy]:=icore.scanline[dy];
32:for dy:=0 to (iheight-1) do irows32[dy]:=icore.scanline[dy];
end;
{$endif}

{$ifdef D10}
//lock
if not icore.map(tmapaccess.write,a) then
   begin
   ilocked:=false;//cancel lock
   goto skipend;
   end;
//info
ilockptr:=@a;//retain this object
case ibits of
1 :for dy:=0 to (iheight-1) do irows8[dy] :=a.getscanline(dy);//05feb2022
8 :for dy:=0 to (iheight-1) do irows8[dy] :=a.getscanline(dy);
15:for dy:=0 to (iheight-1) do irows15[dy]:=a.getscanline(dy);
16:for dy:=0 to (iheight-1) do irows16[dy]:=a.getscanline(dy);
24:for dy:=0 to (iheight-1) do irows24[dy]:=a.getscanline(dy);
32:for dy:=0 to (iheight-1) do irows32[dy]:=a.getscanline(dy);
end;
{$endif}

//successful
result:=true;
skipend:
except;end;
end;
//## unlock ##
function tbmp.unlock:boolean;
begin
try
//defaults
result:=false;
//check
if iunlocking or (ilockcount<=0) then exit else iunlocking:=true;

{$ifdef D10}
if (ilockptr<>nil) then
   begin
   icore.unmap(tbitmapdata(ilockptr^));
   ilockptr:=nil;
   end;
{$endif}

//successful
result:=true;
except;end;
try
xinfo;//25jna2021
iunlocking:=false;
ilockcount:=frcmin(ilockcount-1,0);
except;end;
end;
//## cansharp ##
function tbmp.cansharp:boolean;
begin
try;result:=(not locked);except;end;
end;
//## setsharp ##
procedure tbmp.setsharp(x:longint);
label
   dosharp,donormal,done;
{$ifdef D3}
var
   xlf:tlogfont;
   v,xf1,xf2:hfont;
{$endif}
{
  DEFAULT_QUALITY = 0;
  DRAFT_QUALITY = 1;
  PROOF_QUALITY = 2;
  NONANTIALIASED_QUALITY = 3;
  ANTIALIASED_QUALITY = 4;
{}
begin
try
//filter
case x of
minint..0:x:=0;//off
1..7     :x:=1;//monchrome
8..maxint:x:=8;//greyscale
end;//case
//check
if (not cansharp) or (x=isharp) then exit;
//get
isharp:=x;
if (x=0) then goto donormal else goto dosharp;
//sharp ------------------------------------------------------------------------
dosharp:
{$ifdef D3}
//Note: Any change in width and/or height will cause font to be reset
getobject(icore.canvas.font.handle,sizeof(xlf),@xlf);
xlf.lfQuality:=low__aorb(NONANTIALIASED_QUALITY,4,x=8);//was: DEFAULT_QUALITY;
xf1:=createfontindirect(xlf);
xf2:=selectobject(icore.canvas.handle,xf1);
isharphfont:=xf1;
{$endif}

{$ifdef D10}
//xxxxxxxxxxxxxxxxxxx//??????????????????//D10: No support yet
{$endif}

goto done;


//normal -----------------------------------------------------------------------
donormal:
{$ifdef D3}
//reinstate previous font -> keep Delphi happy - 04apr2020
if (isharphfont<>0) then
   begin
   v:=selectobject(icore.canvas.handle,isharphfont);
   deleteobject(v);
   isharphfont:=0;
   end;
{$endif}

{$ifdef D10}
//xxxxxxxxxxxxxxxxxxx//??????????????????//D10: No support yet
{$endif}

goto done;

//done -------------------------------------------------------------------------
done:
except;end;
end;

//## tbitmapenhanced ###########################################################
//## create ##
constructor tbitmapenhanced.create;//01NOV2011
begin
inherited create;
misaiclear(ai);//01NOV2011
end;
//## destroy ##
destructor tbitmapenhanced.destroy;//28NOV2010
begin
try
inherited destroy;
except;end;
end;

//## tstr8 #####################################################################
//## create ##
constructor tstr8.create(xlen:longint);
begin
zzadd(self);//01may2021
satinc(satStr8,1);
inherited create;
otestlock1:=false;
oautofree:=false;
ilockcount:=0;
idata:=nil;
idatalen:=0;
icount:=0;
ibytes :=idata;
ichars :=idata;
iints4 :=idata;
irows8 :=idata;
irows15:=idata;
irows16:=idata;
irows24:=idata;
irows32:=idata;
xresize(xlen,true);
end;
//## destroy ##
destructor tstr8.destroy;
begin
try
low__freemem(idata,idatalen,8021);
inherited destroy;
satinc(satStr8,-1);
except;end;
end;
//## copyfrom ##
function tstr8.copyfrom(s:tstr8):boolean;//09feb2022
begin
try
//defaults
result:=false;
//check
if (s=self) then
   begin
   result:=true;
   exit;
   end;
if (s=nil) or (not block(s)) then exit;
//clear
clear;
//get
oautofree:=s.oautofree;
otestlock1:=s.otestlock1;
add(s);
except;end;
try;bunlockautofree(s);except;end;
end;
//## maplist ##
function tstr8.maplist:tlistptr;//26apr2021, 07apr2021
begin
try
result.count:=len;
result.bytes:=idata;
//was: result.bytes:=@idata^;
//was: result.bytes:=idata;
//was: result.bytes:=@core^;
//was: result.bytes:=core;//<-- Not sure if this caused the intermittent CRASHING of Gossamer, duplicate fix at "low__maplist2"
except;end;
end;
//## lock ##
procedure tstr8.lock;
begin
try;inc(ilockcount);except;end;
end;
//## unlock ##
procedure tstr8.unlock;
begin
try;ilockcount:=frcmin(ilockcount-1,0);except;end;
end;
//## writeto1 ##
function tstr8.writeto1(a:pointer;asize,xfrom1,xlen:longint):boolean;
begin
try;result:=writeto(a,asize,xfrom1-1,xlen);except;end;
end;
//## writeto1b ##
function tstr8.writeto1b(a:pointer;asize:longint;var xfrom1:longint;xlen:longint):boolean;
begin
try
xlen:=frcrange(xlen,0,frcmin(asize,0));//fixed - 22may2022
result:=writeto(a,asize,xfrom1-1,xlen);
if result then inc(xfrom1,xlen)
except;end;
end;
//## writeto ##
function tstr8.writeto(a:pointer;asize,xfrom0,xlen:longint):boolean;//28jul2021
var
   sp,slen,maxp,p:longint;
   b:pdlBYTE;
   v:byte;
begin
try
//defaults
result:=false;
//check
if (a=nil) then exit;
//init
slen:=len;//our length
fillchar(a^,asize,0);
b:=a;
xlen:=frcmax(xlen,asize);
if (xlen<=0) then
   begin
   result:=true;
   exit;
   end;
//get
sp:=xfrom0;
for p:=0 to (xlen-1) do
begin
if (sp>=0) then
   begin
   //was: if (sp<slen) then b[p]:=pbytes[sp] else break;
   //faster - 22apr2022
   if (sp<slen) then
      begin
      v:=pbytes[sp];
      b[p]:=v;
      end
   else break;
   end;
inc(sp);
end;
//successful
result:=true;
except;end;
end;
//## setbdata ##
procedure tstr8.setbdata(x:tstr8);//27apr2021
begin
try;clear;add(x);except;end;
end;
//## setbappend ##
procedure tstr8.setbappend(x:tstr8);//27apr2021
begin
try;add(x);except;end;
end;
//## getbdata ##
function tstr8.getbdata:tstr8;//27apr2021, 28jan2021
begin
try
result:=bnew;
result.add(self);
result.oautofree:=true;
except;end;
end;
//## datpush ##
function tstr8.datpush(n:longint;x:tstr8):boolean;//27jun2022
begin
try
result:=false;
addint4(n);
if block(x) then result:=addint4(x.len) and add(x) else result:=addint4(0);
except;end;
try;bunlockautofree(x);except;end;
end;
//## datpull ##
function tstr8.datpull(var xpos,n:longint;x:tstr8):boolean;//27jun2022
label
   skipend;
var
   int1,xlen:longint;
begin
try
result:=false;
n:=-1;
//range
if (xpos<0) then xpos:=0;
//check
if block(x) then x.clear;
if ((xpos+7)>=icount) then goto skipend;
//get
n   :=int4[xpos]; inc(xpos,4);
xlen:=int4[xpos]; inc(xpos,4);
int1:=xpos;
inc(xpos,xlen);//inc over data EVEN if an error occurs - 27jun2022
//.read data
if (xlen>=1) and (x<>nil) then x.add3(self,int1,xlen);
//successful
result:=true;
skipend:
except;end;
try;bunlockautofree(x);except;end;
end;
//## empty ##
function tstr8.empty:boolean;
begin
try;result:=(icount<=0);except;end;
end;
//## notempty ##
function tstr8.notempty:boolean;
begin
try;result:=(icount>=1);except;end;
end;
//## uppercase ##
function tstr8.uppercase:boolean;
begin
try;result:=uppercase1(1,len);except;end;
end;
//## uppercase1 ##
function tstr8.uppercase1(xpos1,xlen:longint):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
xlen:=frcmax(xlen,len);
//get
if (xpos1>=1) and (xpos1<=xlen) and (xlen>=1) and (ibytes<>nil) then
   begin
   for p:=xpos1 to xlen do if (ibytes[p-1]>=97) and (ibytes[p-1]<=122) then
      begin
      ibytes[p-1]:=byte(ibytes[p-1]-32);
      result:=true;
      end;//p
   end;
except;end;
end;
//## lowercase ##
function tstr8.lowercase:boolean;
begin
try;result:=lowercase1(1,len);except;end;
end;
//## uppercase1 ##
function tstr8.lowercase1(xpos1,xlen:longint):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
xlen:=frcmax(xlen,len);
//get
if (xpos1>=1) and (xpos1<=xlen) and (xlen>=1) and (ibytes<>nil) then
   begin
   for p:=xpos1 to xlen do if (ibytes[p-1]>=65) and (ibytes[p-1]<=90) then
      begin
      ibytes[p-1]:=byte(ibytes[p-1]+32);
      result:=true;
      end;//p
   end;
except;end;
end;
//## swap ##
function tstr8.swap(s:tstr8):boolean;//27dec2021
var
   t:tstr8;
begin
try
//defaults
result:=false;
t:=nil;
//check
if not block(s) then exit;
//init
t:=bnew;
//self -> t
t.add(self);
//s -> self
clear;
add(s);
//t -> s
s.clear;
s.add(t);
//successful
result:=true;
except;end;
try;bunlockautofree(s);except;end;
end;
//## same ##
function tstr8.same(var x:tstr8):boolean;
begin
try;result:=same2(0,x);except;end;
end;
//## same2 ##
function tstr8.same2(xfrom:longint;var x:tstr8):boolean;
label
   skipend;
var
   i,p:longint;
begin
try
//defaults
result:=false;
//check
if (x=idata) then
   begin
   result:=true;
   exit;
   end;
//get
if block(x) then
   begin
   //init
   if (xfrom<0) then xfrom:=0;
   //get
   if (x.count>=1) and (x.pbytes<>nil) then
      begin
      //check
      if (ibytes=nil) then goto skipend;
      //get
      for p:=0 to (x.count-1) do
      begin
      i:=xfrom+p;
      if (i>=icount) or (ibytes[i]<>x.pbytes[p]) then goto skipend;
      end;//p
      end;
   //successful
   result:=true;
   end;
skipend:
except;end;
try;bunlockautofree(x);except;end;
end;
//## asame ##
function tstr8.asame(x:array of byte):boolean;
begin
try;result:=asame3(0,x,true);except;end;
end;
//## asame2 ##
function tstr8.asame2(xfrom:longint;x:array of byte):boolean;
begin
try;result:=asame3(xfrom,x,true);except;end;
end;
//## asame3 ##
function tstr8.asame3(xfrom:longint;x:array of byte;xcasesensitive:boolean):boolean;
begin
try;result:=asame4(xfrom,low(x),high(x),x,xcasesensitive);except;end;
end;
//## asame4 ##
function tstr8.asame4(xfrom,xmin,xmax:longint;var x:array of byte;xcasesensitive:boolean):boolean;
label
   skipend;
var
   i,p:longint;
   sv,v:byte;
begin
try
result:=false;
//check
if (sizeof(x)=0) or (ibytes=nil) then exit;
//range
if (xfrom<0) then xfrom:=0;
//init
xmin:=frcrange(xmin,low(x),high(x));
xmax:=frcrange(xmax,low(x),high(x));
if (xmin>xmax) then exit;
//get
for p:=xmin to xmax do
begin
i:=xfrom+(p-xmin);
if (i>=icount) or (i<0) then goto skipend//22aug2020
else if xcasesensitive and (x[p]<>ibytes[i]) then goto skipend
else
   begin
   sv:=x[p];
   v:=ibytes[i];
   if (sv>=65) and (sv<=90) then inc(sv,32);
   if (v>=65)  and (v<=90)  then inc(v,32);
   if (sv<>v) then goto skipend;
   end;
end;//p
//successful
result:=true;
skipend:
except;end;
end;
//## xresize ##
function tstr8.xresize(x:longint;xsetcount:boolean):boolean;
var
   xnew,xold:longint;
begin
try
//defaults
result:=false;
//init
xnew:=frcrange(x,0,maxint);
xold:=frcrange(idatalen,0,maxint);
//get
if (xnew<>xold) then
   begin
   //debug check
   if system_debug and otestlock1 and (system_debug_testlock1<>0) then showerror('Lock 1 violation [001]');//debug purposes only - 09may2021
   //get
   if not low__reallocmem(idata,xold,xnew,2) then xnew:=xold;//revert back to previous size if allocation fails - 27apr2021
   idatalen:=xnew;
   ibytes:=idata;
   ichars:=idata;
   iints4 :=idata;
   irows8 :=idata;
   irows15:=idata;
   irows16:=idata;
   irows24:=idata;
   irows32:=idata;
   end;
//sync
if xsetcount then icount:=xnew else icount:=frcrange(icount,0,xnew);
//successful
result:=true;//27apr2021
except;end;
end;
//## clear ##
function tstr8.clear:boolean;
begin
try;result:=setlen(0);except;end;
end;
//## setlen ##
function tstr8.setlen(x:longint):boolean;
begin
try;result:=xresize(x,true);except;end;
end;
//## minlen ##
function tstr8.minlen(x:longint):boolean;//atleast this length
var
   int1:longint;
begin
try
//defaults
result:=false;
//get
x:=frcrange(x,0,maxint);
if (x>idatalen) then
   begin
   case largest(idatalen,x) of
   0..100      :int1:=100;//100b
   101..1000   :int1:=1000;//1K
   1001..10000 :int1:=10000;//10K - 11jan2022
   10001..100000:int1:=100000;//100K
{
   0..100      :int1:=100;//100b
   101..1000   :int1:=1000;//1K
   1001..100000:int1:=100000;//100K
{}
   else         int1:=1000000;//1M
   end;//case
   result:=xresize(x+int1,false);//requested len + some more for extra speed - 29apr2020
   end
else result:=true;//27apr2021
except;end;
end;
//## fill ##
function tstr8.fill(xfrom,xto:longint;xval:byte):boolean;
var
   p:longint;
begin
try
result:=(ibytes<>nil);
if result and (xfrom<=xto) and (icount>=1) and frcrange2(xfrom,0,icount-1) and frcrange2(xto,xfrom,icount-1) then
   begin
   for p:=xfrom to xto do ibytes[p]:=xval;
   end;
except;end;
end;
//## del3 ##
function tstr8.del3(xfrom,xlen:longint):boolean;//27jan2021
begin
try;result:=del(xfrom,xfrom+xlen-1);except;end;
end;
//## del ##
function tstr8.del(xfrom,xto:longint):boolean;//27apr2021
var
   p,int1:longint;
   v:byte;
begin
try
//defaults
result:=true;//pass-thru
//check
if (icount<=0) or (xfrom>xto) or (xto<0) or (xfrom>=icount) then exit;
//get
if frcrange2(xfrom,0,icount-1) and frcrange2(xto,xfrom,icount-1) then
   begin
   //shift down
   int1:=xto+1;
   //was: if (int1<icount) and (ibytes<>nil) then for p:=int1 to (icount-1) do ibytes[xfrom+p-int1]:=ibytes[p];
   if (int1<icount) and (ibytes<>nil) then
      begin
      //assigning value using "v" SPEEDS things up - 22apr2022
      for p:=int1 to (icount-1) do
      begin
      v:=ibytes[p];
      ibytes[xfrom+p-int1]:=v;
      end;//p
      end;
   //resize
   result:=xresize(icount-(xto-xfrom+1),true);//27apr2021
   end;
except;end;
end;
//object support ---------------------------------------------------------------
//## add ##
function tstr8.add(var x:tstr8):boolean;//27apr2021
begin
try;result:=ins2(x,icount,0,maxint);except;end;
end;
//## addb ##
function tstr8.addb(x:tstr8):boolean;
begin
try;result:=add(x);except;end;
end;
//## add2 ##
function tstr8.add2(var x:tstr8;xfrom,xto:longint):boolean;//27apr2021
begin
try;result:=ins2(x,icount,xfrom,xto);except;end;
end;
//## add3 ##
function tstr8.add3(var x:tstr8;xfrom,xlen:longint):boolean;//27apr2021
begin
try;if (xlen>=1) then result:=ins2(x,icount,xfrom,xfrom+xlen-1) else result:=true;except;end;
end;
//## add31 ##
function tstr8.add31(var x:tstr8;xfrom1,xlen:longint):boolean;//28jul2021
begin
try;if (xlen>=1) then result:=ins2(x,icount,(xfrom1-1),(xfrom1-1)+xlen-1) else result:=true;except;end;
end;
//## ins ##
function tstr8.ins(var x:tstr8;xpos:longint):boolean;//27apr2021
begin
try;result:=ins2(x,xpos,0,maxint);except;end;
end;
//## ins2 ##
function tstr8.ins2(var x:tstr8;xpos,xfrom,xto:longint):boolean;//22apr2022, 27apr2021, 26apr2021
label
   skipend;
var
   dcount,p,int1,int2:longint;
   s,d:pdlbyte;
   v:byte;
begin
try
//defaults
result:=false;
//check
if zznil(x,2250) or (x=idata) then//30apr2021
   begin
   result:=true;
   exit;
   end;
//init
xpos:=frcrange(xpos,0,icount);//allow to write past end
//check
int1:=x.count;
if (int1=0) then//06jul2021
   begin
   result:=true;
   goto skipend;
   end;
if (int1<=0) or (xfrom>xto) or (xto<0) or (xfrom>=int1) then goto skipend;
//init
xfrom:=frcrange(xfrom,0,int1-1);
xto:=frcrange(xto,xfrom,int1-1);
dcount:=icount+(xto-xfrom+1);//always means to increase the size - 26apr2021
//check
if not minlen(dcount) then goto skipend;//27apr2021
//shift up
if (xpos<icount) and (ibytes<>nil) then//27apr2021
   begin
   int1:=xto-xfrom+1;
   //was: for p:=(dcount-1) downto (xpos+int1) do ibytes[p]:=ibytes[p-int1];
   //assigning value indirectly using "v" SPEEDS things up drastically - 22apr2022
   for p:=(dcount-1) downto (xpos+int1) do
   begin
   v:=ibytes[p-int1];
   ibytes[p]:=v;
   end;//p
   end;
//copy + size
if (ibytes<>nil) then//27apr2021
   begin
   //was: for p:=xfrom to xto do ibytes[xpos+p-xfrom]:=x.pbytes[p];
   //assigning value indirectly using "v" SPEEDS things up drastically - 22apr2022
   for p:=xfrom to xto do
   begin
   v:=x.pbytes[p];
   ibytes[xpos+p-xfrom]:=v;
   end;//p
   end;
icount:=dcount;
//successful
result:=true;
skipend:
except;end;
try;bautofree(x);except;end;
end;
//## owr ##
function tstr8.owr(var x:tstr8;xpos:longint):boolean;//overwrite -> enlarge if required - 27apr2021, 01oct2020
begin
try;result:=owr2(x,xpos,0,maxint);except;end;
end;
//## owr2 ##
function tstr8.owr2(var x:tstr8;xpos,xfrom,xto:longint):boolean;//22apr2022
label
   skipend;
var
   dcount,p,int1:longint;
   v:byte;
begin
try
//defaults
result:=false;
//check
if zznil(x,2251) or (x=idata) then
   begin
   result:=true;
   exit;
   end;
//init
xpos:=frcmin(xpos,0);
//check
int1:=x.count;
if (int1<=0) or (xfrom>xto) or (xto<0) or (xfrom>=int1) then
   begin
   result:=true;//27apr2021
   goto skipend;
   end;
//init
xfrom:=frcrange(xfrom,0,int1-1);
xto:=frcrange(xto,xfrom,int1-1);
dcount:=xpos+(xto-xfrom+1);
//check
if not minlen(dcount) then goto skipend;
//copy + size
if (ibytes<>nil) and (x.pbytes<>nil) then//27apr2021
   begin
   //was: for p:=xfrom to xto do ibytes[xpos+p-xfrom]:=x.pbytes[p];
   //local var "v" makes things FASTER - 22apr2022
   for p:=xfrom to xto do
   begin
   v:=x.pbytes[p];
   ibytes[xpos+p-xfrom]:=v;
   end;//p
   end;
icount:=largest(dcount,icount);
//successful
result:=true;
skipend:
except;end;
try;bautofree(x);except;end;
end;
//array support ----------------------------------------------------------------
//## aadd ##
function tstr8.aadd(x:array of byte):boolean;//27apr2021
begin
try;result:=ains2(x,icount,0,maxint);except;end;
end;
//## aadd1 ##
function tstr8.aadd1(x:array of byte;xpos1,xlen:longint):boolean;//1based - 27apr2021, 19aug2020
begin
try;result:=ains2(x,icount,xpos1-1,xpos1-1+xlen);except;end;
end;
//## aadd2 ##
function tstr8.aadd2(x:array of byte;xfrom,xto:longint):boolean;//27apr2021
begin
try;result:=ains2(x,icount,xfrom,xto);except;end;
end;
//## ains ##
function tstr8.ains(x:array of byte;xpos:longint):boolean;//27apr2021
begin
try;result:=ains2(x,xpos,0,maxint);except;end;
end;
//## ains2 ##
function tstr8.ains2(x:array of byte;xpos,xfrom,xto:longint):boolean;//26apr2021
var
   dcount,p,int1:longint;
   v:byte;
begin
try
//defaults
result:=false;
//check
if (xto<xfrom) then exit;
//range
xfrom:=frcrange(xfrom,low(x),high(x));
xto  :=frcrange(xto  ,low(x),high(x));
if (xto<xfrom) then exit;
//init
xpos:=frcrange(xpos,0,icount);//allow to write past end
dcount:=icount+(xto-xfrom+1);
minlen(dcount);
//shift up
if (xpos<icount) and (ibytes<>nil) then//27apr2021
   begin
   int1:=xto-xfrom+1;
   //was: for p:=(dcount-1) downto (xpos+int1) do ibytes[p]:=ibytes[p-int1];
   //faster - 22apr2022
   for p:=(dcount-1) downto (xpos+int1) do
   begin
   v:=ibytes[p-int1];
   ibytes[p]:=v;
   end;//p
   end;
//copy + size
if (ibytes<>nil) then//27apr2021
   begin
   //was: for p:=xfrom to xto do ibytes[xpos+p-xfrom]:=x[p];
   //faster - 22apr2022
   for p:=xfrom to xto do
   begin
   v:=x[p];
   ibytes[xpos+p-xfrom]:=v;
   end;//p
   end;
icount:=dcount;
//successful
result:=true;
except;end;
end;
//## pins2 ##
function tstr8.pins2(x:pdlbyte;xcount,xpos,xfrom,xto:longint):boolean;//07feb2022
var
   dcount,p,int1:longint;
   v:byte;
begin
try
//defaults
result:=false;
//check
if (x=nil) or (xcount<=0) then
   begin
   result:=true;
   exit;
   end;
if (xto<xfrom) then exit;
//range
xfrom:=frcrange(xfrom,0,xcount-1);
xto  :=frcrange(xto  ,0,xcount-1);
if (xto<xfrom) then exit;
//init
xpos:=frcrange(xpos,0,icount);//allow to write past end
dcount:=icount+(xto-xfrom+1);
minlen(dcount);
//shift up
if (xpos<icount) and (ibytes<>nil) then//27apr2021
   begin
   int1:=xto-xfrom+1;
   //was: for p:=(dcount-1) downto (xpos+int1) do ibytes[p]:=ibytes[p-int1];
   //faster - 22apr2022
   for p:=(dcount-1) downto (xpos+int1) do
   begin
   v:=ibytes[p-int1];
   ibytes[p]:=v;
   end;//p
   end;
//copy + size
if (ibytes<>nil) then//27apr2021
   begin
   //was: for p:=xfrom to xto do ibytes[xpos+p-xfrom]:=x[p];
   //faster - 22apr2022
   for p:=xfrom to xto do
   begin
   v:=x[p];
   ibytes[xpos+p-xfrom]:=v;
   end;//p
   end;
icount:=dcount;
//successful
result:=true;
except;end;
end;
//## insbyt1 ##
function tstr8.insbyt1(xval:byte;xpos:longint):boolean;
begin
try;result:=ains2([xval],xpos,0,0);except;end;
end;
//## insbol1 ##
function tstr8.insbol1(xval:boolean;xpos:longint):boolean;
begin
try;if xval then result:=ains2([1],xpos,0,0) else result:=ains2([0],xpos,0,0);except;end;
end;
//## insint4 ##
function tstr8.insint4(xval,xpos:longint):boolean;
var
   a:tint4;
begin
try;a.val:=xval;result:=ains2([a.bytes[0],a.bytes[1],a.bytes[2],a.bytes[3]],xpos,0,3);except;end;
end;
//string support ---------------------------------------------------------------
//## sadd ##
function tstr8.sadd(x:string):boolean;//27apr2021
begin
try;result:=sins2(x,icount,0,maxint);except;end;
end;
//## sadd2 ##
function tstr8.sadd2(x:string;xfrom,xto:longint):boolean;//27apr2021
begin
try;result:=sins2(x,icount,xfrom,xto);except;end;
end;
//## sadd3 ##
function tstr8.sadd3(x:string;xfrom,xlen:longint):boolean;//27apr2021
begin
try;if (xlen>=1) then result:=sins2(x,icount,xfrom,xfrom+xlen-1) else result:=true;except;end;
end;
//## sins ##
function tstr8.sins(x:string;xpos:longint):boolean;//27apr2021
begin
try;result:=sins2(x,xpos,0,maxint);except;end;
end;
//## sins2 ##
function tstr8.sins2(x:string;xpos,xfrom,xto:longint):boolean;
label
   skipend;
var//Always zero based for "xfrom" and "xto"
   xlen,dcount,p,int1:longint;
   v:byte;
begin
try
//defaults
result:=false;
//check
xlen:=length(x);
if (xlen<=0) then
   begin
   result:=true;
   exit;
   end;
//check #2
if (xto<xfrom) then exit;//27apr2021
//range
xfrom:=frcrange(xfrom,0,xlen-1);
xto  :=frcrange(xto  ,0,xlen-1);
if (xto<xfrom) then exit;
//init
xpos:=frcrange(xpos,0,icount);//allow to write past end
dcount:=icount+(xto-xfrom+1);
//check
if not minlen(dcount) then goto skipend;
//shift up
if (xpos<icount) and (ibytes<>nil) then//27apr2021
   begin
   int1:=xto-xfrom+1;
   //was: for p:=(dcount-1) downto (xpos+int1) do ibytes[p]:=ibytes[p-int1];
   //faster - 22apr2022
   for p:=(dcount-1) downto (xpos+int1) do
   begin
   v:=ibytes[p-int1];;
   ibytes[p]:=v;
   end;//p
   end;
//copy + size
if (ibytes<>nil) then//27apr2021
   begin
   //was: for p:=xfrom to xto do ibytes[xpos+p-xfrom]:=byte(x[p+stroffset]);//force 8bit conversion from unicode to 8bit binary - 02may2020
   //faster - 22apr2022
   for p:=xfrom to xto do
   begin
   v:=byte(x[p+stroffset]);//force 8bit conversion from unicode to 8bit binary - 02may2020
   ibytes[xpos+p-xfrom]:=v;
   end;//p
   end;
icount:=dcount;
//successful
result:=true;
skipend:
except;end;
end;
//push support -----------------------------------------------------------------
//## pushcmp8 ##
function tstr8.pushcmp8(var xpos:longint;xval:comp):boolean;
begin
try
result:=ains(tcmp8(xval).bytes,xpos);
if result then inc(xpos,8);
except;end;
end;
//## pushcur8 ##
function tstr8.pushcur8(var xpos:longint;xval:currency):boolean;
begin
try
result:=ains(tcur8(xval).bytes,xpos);
if result then inc(xpos,8);
except;end;
end;
//## pushint4 ##
function tstr8.pushint4(var xpos:longint;xval:longint):boolean;
begin
try
result:=ains(tint4(xval).bytes,xpos);
if result then inc(xpos,4);
except;end;
end;
//## pushint4R ##
function tstr8.pushint4R(var xpos:longint;xval:longint):boolean;
begin
try
xval:=low__intr(xval);//swap round
result:=ains(tint4(xval).bytes,xpos);
if result then inc(xpos,4);
except;end;
end;
//## pushint3 ##
function tstr8.pushint3(var xpos:longint;xval:longint):boolean;
var
   r,g,b:byte;
begin
try
low__int3toRGB(xval,r,g,b);
result:=ains([r,g,b],xpos);
if result then inc(xpos,3);
except;end;
end;
//## pushwrd2 ##
function tstr8.pushwrd2(var xpos:longint;xval:word):boolean;
begin
try
result:=ains(twrd2(xval).bytes,xpos);
if result then inc(xpos,2);
except;end;
end;
//## pushwrd2R ##
function tstr8.pushwrd2R(var xpos:longint;xval:word):boolean;
begin
try
xval:=low__wrdr(xval);
result:=ains(twrd2(xval).bytes,xpos);
if result then inc(xpos,2);
except;end;
end;
//## pushbyt1 ##
function tstr8.pushbyt1(var xpos:longint;xval:byte):boolean;
begin
try
result:=ains([xval],xpos);
if result then inc(xpos,1);
except;end;
end;
//## pushbol1 ##
function tstr8.pushbol1(var xpos:longint;xval:boolean):boolean;
begin
try
if xval then result:=ains([1],xpos) else result:=ains([0],xpos);
if result then inc(xpos,1);
except;end;
end;
//## pushchr1 ##
function tstr8.pushchr1(var xpos:longint;xval:char):boolean;
begin
try
result:=ains([byte(xval)],xpos);
if result then inc(xpos,1);
except;end;
end;
//## pushstr ##
function tstr8.pushstr(var xpos:longint;xval:string):boolean;
begin
try
result:=sins(xval,xpos);
if result then inc(xpos,length(xval));
except;end;
end;
//add support ------------------------------------------------------------------
//## addcmp8 ##
function tstr8.addcmp8(xval:comp):boolean;
begin
try;result:=aadd(tcmp8(xval).bytes);except;end;
end;
//## addcur8 ##
function tstr8.addcur8(xval:currency):boolean;
begin
try;result:=aadd(tcur8(xval).bytes);except;end;
end;
//## addRGBA4 ##
function tstr8.addRGBA4(r,g,b,a:byte):boolean;
begin
try;result:=aadd([r,g,b,a]);except;end;
end;
//## addRGB3 ##
function tstr8.addRGB3(r,g,b:byte):boolean;
begin
try;result:=aadd([r,g,b]);except;end;
end;
//## addint4 ##
function tstr8.addint4(xval:longint):boolean;
begin
try;result:=aadd(tint4(xval).bytes);except;end;
end;
//## addint4R ##
function tstr8.addint4R(xval:longint):boolean;
begin
try
xval:=low__intr(xval);//swap round
result:=aadd(tint4(xval).bytes);
except;end;
end;
//## addint3 ##
function tstr8.addint3(xval:longint):boolean;
var
   r,g,b:byte;
begin
try
low__int3toRGB(xval,r,g,b);
result:=aadd([r,g,b]);
except;end;
end;
//## addwrd2 ##
function tstr8.addwrd2(xval:word):boolean;
begin
try;result:=aadd(twrd2(xval).bytes);except;end;//16aug2020
end;
//## addwrd2R ##
function tstr8.addwrd2R(xval:word):boolean;
begin
try
xval:=low__wrdr(xval);//swap round
result:=aadd(twrd2(xval).bytes);//16aug2020
except;end;
end;
//## addsmi2 ##
function tstr8.addsmi2(xval:smallint):boolean;//01aug2021
var
   a:twrd2;
begin
try
a.si:=xval;
result:=aadd([a.bytes[0],a.bytes[1]]);
except;end;//16aug2020
end;
//## addbyt1 ##
function tstr8.addbyt1(xval:byte):boolean;
begin
try;result:=aadd([xval]);except;end;
end;
//## addbol1 ##
function tstr8.addbol1(xval:boolean):boolean;//21aug2020
begin
try;if xval then result:=aadd([1]) else result:=aadd([0]);except;end;
end;
//## addchr1 ##
function tstr8.addchr1(xval:char):boolean;
begin
try;result:=aadd([byte(xval)]);except;end;
end;
//## addstr ##
function tstr8.addstr(xval:string):boolean;
begin
try;result:=sadd(xval);except;end;
end;
//## addrec ##
function tstr8.addrec(a:pointer;asize:longint):boolean;//07feb2022
begin
try;result:=pins2(pdlbyte(a),asize,icount,0,asize-1);except;end;
end;
//get support ------------------------------------------------------------------
//## getcmp8 ##
function tstr8.getcmp8(xpos:longint):comp;
var
   a:tcmp8;
begin
try
if (xpos>=0) and ((xpos+7)<icount) and (ibytes<>nil) then
   begin
   a.bytes[0]:=ibytes[xpos+0];
   a.bytes[1]:=ibytes[xpos+1];
   a.bytes[2]:=ibytes[xpos+2];
   a.bytes[3]:=ibytes[xpos+3];
   a.bytes[4]:=ibytes[xpos+4];
   a.bytes[5]:=ibytes[xpos+5];
   a.bytes[6]:=ibytes[xpos+6];
   a.bytes[7]:=ibytes[xpos+7];
   result:=a.val;
   end
else result:=0;
except;end;
end;
//## getcur8 ##
function tstr8.getcur8(xpos:longint):currency;
var
   a:tcur8;
begin
try
if (xpos>=0) and ((xpos+7)<icount) and (ibytes<>nil) then
   begin
   a.bytes[0]:=ibytes[xpos+0];
   a.bytes[1]:=ibytes[xpos+1];
   a.bytes[2]:=ibytes[xpos+2];
   a.bytes[3]:=ibytes[xpos+3];
   a.bytes[4]:=ibytes[xpos+4];
   a.bytes[5]:=ibytes[xpos+5];
   a.bytes[6]:=ibytes[xpos+6];
   a.bytes[7]:=ibytes[xpos+7];
   result:=a.val;
   end
else result:=0;
except;end;
end;
//## getint4 ##
function tstr8.getint4(xpos:longint):longint;
var
   a:tint4;
begin
try
if (xpos>=0) and ((xpos+3)<icount) and (ibytes<>nil) then
   begin
   a.bytes[0]:=ibytes[xpos+0];
   a.bytes[1]:=ibytes[xpos+1];
   a.bytes[2]:=ibytes[xpos+2];
   a.bytes[3]:=ibytes[xpos+3];
   result:=a.val;
   end
else result:=0;
except;end;
end;
//## getint4i ##
function tstr8.getint4i(xindex:longint):longint;
begin
try;result:=getint4(xindex*4);except;end;
end;
//## getint4R ##
function tstr8.getint4R(xpos:longint):longint;//14feb2021
var
   a:tint4;
begin
try
if (xpos>=0) and ((xpos+3)<icount) and (ibytes<>nil) then
   begin
   a.bytes[0]:=ibytes[xpos+3];//swap round
   a.bytes[1]:=ibytes[xpos+2];
   a.bytes[2]:=ibytes[xpos+1];
   a.bytes[3]:=ibytes[xpos+0];
   result:=a.val;
   end
else result:=0;
except;end;
end;
//## getint3 ##
function tstr8.getint3(xpos:longint):longint;
begin
try;if (xpos>=0) and ((xpos+2)<icount) and (ibytes<>nil) then result:=ibytes[xpos+0]+(ibytes[xpos+1]*256)+(ibytes[xpos+2]*256*256) else result:=0;except;end;
end;
//## getsml2 ##
function tstr8.getsml2(xpos:longint):smallint;//28jul2021
var
   a:twrd2;
begin
try
if (xpos>=0) and ((xpos+1)<icount) and (ibytes<>nil) then
   begin
   a.bytes[0]:=ibytes[xpos+0];
   a.bytes[1]:=ibytes[xpos+1];
   result:=a.si;
   end
else result:=0;
except;end;
end;
//## getwrd2 ##
function tstr8.getwrd2(xpos:longint):word;
var
   a:twrd2;
begin
try
if (xpos>=0) and ((xpos+1)<icount) and (ibytes<>nil) then
   begin
   a.bytes[0]:=ibytes[xpos+0];
   a.bytes[1]:=ibytes[xpos+1];
   result:=a.val;
   end
else result:=0;
except;end;
end;
//## getwrd2R ##
function tstr8.getwrd2R(xpos:longint):word;//14feb2021
var
   a:twrd2;
begin
try
if (xpos>=0) and ((xpos+1)<icount) and (ibytes<>nil) then
   begin
   a.bytes[0]:=ibytes[xpos+1];//swap round
   a.bytes[1]:=ibytes[xpos+0];
   result:=a.val;
   end
else result:=0;
except;end;
end;
//## getbyt1 ##
function tstr8.getbyt1(xpos:longint):byte;
begin
try;if (xpos>=0) and (xpos<icount) and (ibytes<>nil) then result:=ibytes[xpos] else result:=0;except;end;
end;
//## getbol1 ##
function tstr8.getbol1(xpos:longint):boolean;
begin
try;if (xpos>=0) and (xpos<icount) and (ibytes<>nil) then result:=(ibytes[xpos]<>0) else result:=false;except;end;
end;
//## getchr1 ##
function tstr8.getchr1(xpos:longint):char;
begin
try;if (xpos>=0) and (xpos<icount) and (ibytes<>nil) then result:=char(ibytes[xpos]) else result:=#0;except;end;
end;
//## getstr ##
function tstr8.getstr(xpos,xlen:longint):string;//fixed - 16aug2020
var
   dlen,p:longint;
begin
try
if (xlen>=1) and (xpos>=0) and (xpos<icount) and (ibytes<>nil) then
   begin
   dlen:=frcmax(xlen,icount-xpos);
   if (dlen>=1) then
      begin
      setlength(result,dlen);
      for p:=xpos to (xpos+dlen-1) do result[p-xpos+stroffset]:=char(ibytes[p]);
      end
   else result:='';
   end
else result:='';
except;end;
end;
//## getstr1 ##
function tstr8.getstr1(xpos,xlen:longint):string;
begin
try;result:=getstr(xpos-1,xlen);except;end;
end;
//## getnullstr ##
function tstr8.getnullstr(xpos,xlen:longint):string;//20mar2022
var
   dcount,dlen,p:longint;
   v:byte;
begin
try
if (xlen>=1) and (xpos>=0) and (xpos<icount) and (ibytes<>nil) then
   begin
   dlen:=frcmax(xlen,icount-xpos);
   if (dlen>=1) then
      begin
      setlength(result,dlen);
      dcount:=0;
      for p:=xpos to (xpos+dlen-1) do
      begin
      if (ibytes[p]=0) then
         begin
         if (dcount<>dlen) then setlength(result,dcount);
         break;
         end;
      //was: result[p-xpos+stroffset]:=char(ibytes[p]);
      v:=ibytes[p];
      result[p-xpos+stroffset]:=char(v);
      inc(dcount);
      end;//p
      end
   else result:='';
   end
else result:='';
except;end;
end;
//## getnullstr1 ##
function tstr8.getnullstr1(xpos,xlen:longint):string;//20mar2022
begin
try;result:=getnullstr(xpos-1,xlen);except;end;
end;
//## gettext ##
function tstr8.gettext:string;
var
   p:longint;
   v:byte;
begin
try
if (icount>=1) and (ibytes<>nil) then//27apr2021
   begin
   setlength(result,icount);
   //was: for p:=0 to (icount-1) do result[p+stroffset]:=char(ibytes[p]);//27apr2021
   //faster - 22apr2022
   for p:=0 to (icount-1) do
   begin
   v:=ibytes[p];
   result[p+stroffset]:=char(v);//27apr2021
   end;//p
   end
else result:='';
except;end;
end;
//## settext ##
procedure tstr8.settext(x:string);
var
   xlen,p:longint;
   v:byte;
begin
try
xlen:=length(x);
setlen(xlen);
if (xlen>=1) and (ibytes<>nil) then//27apr2021
   begin
   //was: for p:=1 to xlen do ibytes[p-1]:=byte(x[p-1+stroffset]);//force 8bit conversion
   //faster - 22apr2022
   for p:=1 to xlen do
   begin
   v:=byte(x[p-1+stroffset]);
   ibytes[p-1]:=v;//force 8bit conversion
   end;//p
   end;
except;end;
end;
//## gettextarray ##
function tstr8.gettextarray:string;
label
   skipend;
var
   a,aline:tstr8;
   xmax,p:longint;
begin
try
//defaults
result:='';
a:=nil;
aline:=nil;
//check
if (icount<=0) or (ibytes=nil) then goto skipend;
//init
a:=bnew;
aline:=bnew;
xmax:=icount-1;
//get
for p:=0 to xmax do
begin
aline.sadd(inttostr(ibytes[p])+low__insstr(',',p<xmax));
if (aline.count>=1010) then
   begin
   aline.sadd(rcode);
   a.add(aline);
   zzstr(aline,2).clear;
   end;
end;//p
//.finalise
if (aline.count>=1) then
   begin
   a.add(aline);
   zzstr(aline,1).clear;
   end;
//set
result:=':array[0..'+inttostr(icount-1)+'] of byte=('+rcode+zzstr(a,3).text+');';//cleaned 02mar2022
skipend:
except;end;
try
bfree(a);
bfree(aline);
except;end;
end;
//set support ------------------------------------------------------------------
//## setcmp8 ##
procedure tstr8.setcmp8(xpos:longint;xval:comp);
var
   a:tcmp8;
begin
try
if (xpos<0) then xpos:=0;
if (not minlen(xpos+8)) or (ibytes=nil) then exit;
a.val:=xval;
ibytes[xpos+0]:=a.bytes[0];
ibytes[xpos+1]:=a.bytes[1];
ibytes[xpos+2]:=a.bytes[2];
ibytes[xpos+3]:=a.bytes[3];
ibytes[xpos+4]:=a.bytes[4];
ibytes[xpos+5]:=a.bytes[5];
ibytes[xpos+6]:=a.bytes[6];
ibytes[xpos+7]:=a.bytes[7];
icount:=frcmin(icount,xpos+8);//10may2020
except;end;
end;
//## setcur8 ##
procedure tstr8.setcur8(xpos:longint;xval:currency);
var
   a:tcur8;
begin
try
if (xpos<0) then xpos:=0;
if (not minlen(xpos+8)) or (ibytes=nil) then exit;
a.val:=xval;
ibytes[xpos+0]:=a.bytes[0];
ibytes[xpos+1]:=a.bytes[1];
ibytes[xpos+2]:=a.bytes[2];
ibytes[xpos+3]:=a.bytes[3];
ibytes[xpos+4]:=a.bytes[4];
ibytes[xpos+5]:=a.bytes[5];
ibytes[xpos+6]:=a.bytes[6];
ibytes[xpos+7]:=a.bytes[7];
icount:=frcmin(icount,xpos+8);//10may2020
except;end;
end;
//## setint4 ##
procedure tstr8.setint4(xpos:longint;xval:longint);
var
   a:tint4;
begin
try
if (xpos<0) then xpos:=0;
if (not minlen(xpos+4)) or (ibytes=nil) then exit;
a.val:=xval;
ibytes[xpos+0]:=a.bytes[0];
ibytes[xpos+1]:=a.bytes[1];
ibytes[xpos+2]:=a.bytes[2];
ibytes[xpos+3]:=a.bytes[3];
icount:=frcmin(icount,xpos+4);//10may2020
except;end;
end;
//## setint4i ##
procedure tstr8.setint4i(xindex:longint;xval:longint);
begin
try;setint4(xindex*4,xval);except;end;
end;
//## setint4R ##
procedure tstr8.setint4R(xpos:longint;xval:longint);
var
   a:tint4;
begin
try
if (xpos<0) then xpos:=0;
if (not minlen(xpos+4)) or (ibytes=nil) then exit;
a.val:=xval;
ibytes[xpos+0]:=a.bytes[3];//swap round
ibytes[xpos+1]:=a.bytes[2];
ibytes[xpos+2]:=a.bytes[1];
ibytes[xpos+3]:=a.bytes[0];
icount:=frcmin(icount,xpos+4);//10may2020
except;end;
end;
//## setint3 ##
procedure tstr8.setint3(xpos:longint;xval:longint);
var
   r,g,b:byte;
begin
try
if (xpos<0) then xpos:=0;
if (not minlen(xpos+3)) or (ibytes=nil) then exit;
low__int3toRGB(xval,r,g,b);
ibytes[xpos+0]:=r;
ibytes[xpos+1]:=g;
ibytes[xpos+2]:=b;
icount:=frcmin(icount,xpos+3);//10may2020
except;end;
end;
//## setsml2 ##
procedure tstr8.setsml2(xpos:longint;xval:smallint);
var
   a:twrd2;
begin
try
if (xpos<0) then xpos:=0;
if (not minlen(xpos+2)) or (ibytes=nil) then exit;
a.si:=xval;
ibytes[xpos+0]:=a.bytes[0];
ibytes[xpos+1]:=a.bytes[1];
icount:=frcmin(icount,xpos+2);//10may2020
except;end;
end;
//## setwrd2 ##
procedure tstr8.setwrd2(xpos:longint;xval:word);
var
   a:twrd2;
begin
try
if (xpos<0) then xpos:=0;
if (not minlen(xpos+2)) or (ibytes=nil) then exit;
a.val:=xval;
ibytes[xpos+0]:=a.bytes[0];
ibytes[xpos+1]:=a.bytes[1];
icount:=frcmin(icount,xpos+2);//10may2020
except;end;
end;
//## setwrd2R ##
procedure tstr8.setwrd2R(xpos:longint;xval:word);
var
   a:twrd2;
begin
try
if (xpos<0) then xpos:=0;
if (not minlen(xpos+2)) or (ibytes=nil) then exit;
a.val:=xval;
ibytes[xpos+0]:=a.bytes[1];//swap round
ibytes[xpos+1]:=a.bytes[0];
icount:=frcmin(icount,xpos+2);//10may2020
except;end;
end;
//## setbyt1 ##
procedure tstr8.setbyt1(xpos:longint;xval:byte);
begin
try
if (xpos<0) then xpos:=0;
if (not minlen(xpos+1)) or (ibytes=nil) then exit;
ibytes[xpos]:=xval;
icount:=frcmin(icount,xpos+1);//10may2020
except;end;
end;
//## setbol1 ##
procedure tstr8.setbol1(xpos:longint;xval:boolean);
begin
try
if (xpos<0) then xpos:=0;
if (not minlen(xpos+1)) or (ibytes=nil) then exit;
if xval then ibytes[xpos]:=1 else ibytes[xpos]:=0;
icount:=frcmin(icount,xpos+1);//10may2020
except;end;
end;
//## setchr1 ##
procedure tstr8.setchr1(xpos:longint;xval:char);
begin
try
if (xpos<0) then xpos:=0;
if (not minlen(xpos+1)) or (ibytes=nil) then exit;
ibytes[xpos]:=byte(xval);
icount:=frcmin(icount,xpos+1);//10may2020
except;end;
end;
//## setstr ##
procedure tstr8.setstr(xpos:longint;xlen:longint;xval:string);
var
   xminlen,p:longint;
   v:byte;
begin
try
if (xpos<0) then xpos:=0;
if (xlen<=0) or (xval='') then exit;
xlen:=frcmax(xlen,length(xval));
xminlen:=xpos+xlen;
if (not minlen(xminlen)) or (ibytes=nil) then exit;
//was: ERROR: for p:=xpos to (xpos+xlen-1) do ibytes[p]:=ord(xval[p+stroffset]);
//was: for p:=0 to (xlen-1) do ibytes[xpos+p]:=ord(xval[p+stroffset]);
for p:=0 to (xlen-1) do
begin
v:=ord(xval[p+stroffset]);
ibytes[xpos+p]:=v;
end;//p
icount:=frcmin(icount,xminlen);//10may2020
except;end;
end;
//## setstr1 ##
procedure tstr8.setstr1(xpos:longint;xlen:longint;xval:string);
begin
try;setstr(xpos-1,xlen,xval);except;end;
end;
//## setarray ##
function tstr8.setarray(xpos:longint;xval:array of byte):boolean;
var
   xminlen,xmin,xmax,p:longint;
   v:byte;
begin
try
//defaults
result:=false;
//get
if (xpos<0) then xpos:=0;
xmin:=low(xval);
xmax:=high(xval);
xminlen:=xpos+(xmax-xmin+1);
if (not minlen(xminlen)) or (ibytes=nil) then exit;
//was: for p:=xmin to xmax do ibytes[xpos+(p-xmin)]:=xval[p];
for p:=xmin to xmax do
begin
v:=xval[p];
ibytes[xpos+(p-xmin)]:=v;
end;//p
icount:=frcmin(icount,xminlen);//10may2020
//successful
result:=true;
except;end;
end;
//## scanline ##
function tstr8.scanline(xfrom:longint):pointer;
begin
try
//defaults
result:=nil;
if (icount<=0) then exit;
//get
if (xfrom<0) then xfrom:=0 else if (xfrom>=icount) then xfrom:=icount-1;
if (ibytes<>nil) then result:=tpointer(@ibytes[xfrom]);
except;end;
end;
//## getbytes ##
function tstr8.getbytes(x:longint):byte;//0-based
begin
try;if (x>=0) and (x<icount) and (ibytes<>nil) then result:=ibytes[x] else result:=0;except;end;
end;
//## setbytes ##
procedure tstr8.setbytes(x:longint;xval:byte);
begin
try;if (x>=0) and (x<icount) and (ibytes<>nil) then ibytes[x]:=xval;except;end;
end;
//## getbytes1 ##
function tstr8.getbytes1(x:longint):byte;//1-based
begin
try;if (x>=1) and (x<=icount) and (ibytes<>nil) then result:=ibytes[x-1] else result:=0;except;end;
end;
//## setbytes1 ##
procedure tstr8.setbytes1(x:longint;xval:byte);
begin
try;if (x>=1) and (x<=icount) and (ibytes<>nil) then ibytes[x-1]:=xval;except;end;
end;
//## getchars ##
function tstr8.getchars(x:longint):char;//D10 uses unicode here - 27apr2021
begin
try;if (x>=0) and (x<icount) and (ibytes<>nil) then result:=char(ibytes[x]) else result:=#0;except;end;
end;
//## setchars ##
procedure tstr8.setchars(x:longint;xval:char);//D10 uses unicode here
begin
try;if (x>=0) and (x<icount) and (ibytes<>nil) then ibytes[x]:=byte(xval);except;end;
end;

//replace support --------------------------------------------------------------
//## setreplace ##
procedure tstr8.setreplace(x:tstr8);
begin
try;clear;add(x);except;end;
end;
//## setreplacecmp8 ##
procedure tstr8.setreplacecmp8(x:comp);
begin
try;clear;setcmp8(0,x);except;end;
end;
//## setreplacecur8 ##
procedure tstr8.setreplacecur8(x:currency);
begin
try;clear;setcur8(0,x);except;end;
end;
//## setreplaceint4 ##
procedure tstr8.setreplaceint4(x:longint);
begin
try;clear;setint4(0,x);except;end;
end;
//## setreplacewrd2 ##
procedure tstr8.setreplacewrd2(x:word);
begin
try;clear;setwrd2(0,x);except;end;
end;
//## setreplacebyt1 ##
procedure tstr8.setreplacebyt1(x:byte);
begin
try;clear;setbyt1(0,x);except;end;
end;
//## setreplacebol1 ##
procedure tstr8.setreplacebol1(x:boolean);
begin
try;clear;setbol1(0,x);except;end;
end;
//## setreplacechr1 ##
procedure tstr8.setreplacechr1(x:char);
begin
try;clear;setchr1(0,x);except;end;
end;
//## setreplacestr ##
procedure tstr8.setreplacestr(x:string);
begin
try;clear;setstr(0,length(x),x);except;end;
end;

//## tmemstr8 ##################################################################
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//mmmmmmmmmmmmmmmmmmmm
//## create ##
constructor tmemstr8.create(_ptr:tstr8);
begin
//self
zzadd(self);//01may2021
inherited create;
//set
idata:=zzstr(_ptr,10);
iposition:=0;
end;
//## destroy ##
destructor tmemstr8.destroy;
begin
try;inherited destroy;except;end;
end;
//## read ##
function tmemstr8.read(var x;xlen:longint):longint;
begin
try
//set
if zznil(idata,2261) then result:=0
else
   begin
   result:=blen(idata)-iposition;
   if (result>xlen) then result:=xlen;
   if (idata.pbytes<>nil) then move(idata.pbytes[iposition],x,result);//27apr2021
   inc(iposition,result);
   end;//if
except;end;
end;
//## write ##
function tmemstr8.write(const x;xlen:longint):longint;
begin
try
//set
if zznil(idata,2262) then result:=0
else
  begin
  result:=xlen;
  idata.setlen(iposition+result);
  if (idata.pbytes<>nil) then move(x,idata.pbytes[iposition],result);//27apr2021
  inc(iposition,result);
  end;
except;end;
end;
//## seek ##
function tmemstr8.seek(offset:longint;origin:word):longint;
begin
try
//check
if zznil(idata,2263) then
   begin
   iposition:=0;
   result:=0;
   exit;
   end;//if
//set
case Origin of
soFromBeginning:iposition:=offset;
soFromCurrent:iposition:=iposition+offset;
soFromEnd:iposition:=blen(idata)-offset;
end;//end of case
//range
iposition:=frcrange(iposition,0,blen(idata));
//return result
result:=iposition;
except;end;
end;
//## readstring ##
function tmemstr8.readstring(count:longint):string;
var
  len:longint;
begin
try
//defaults
result:='';
//check
if zznil(idata,2264) then exit;
//process
len:=blen(idata)-iposition;
if (len>count) then len:=count;
result:=bgetstr1(idata,iposition+1,len);
inc(iposition,len);
except;end;
end;
//## writestring ##
procedure tmemstr8.writestring(const x:string);
begin
//was: try;write(pchar(x)^,length(x));except;end;
try;if zzok(idata,7073) then idata.replacestr:=x;except;end;
end;
//## setsize ##
procedure tmemstr8.setsize(newsize:longint);
begin
try
//check
if zznil(idata,2265) then exit;
//set
idata.setlen(newsize);
if (iposition>newsize) then iposition:=newsize;
except;end;
end;

//## tvars8 ####################################################################
//## create ##
constructor tvars8.create;
begin
zzadd(self);//01may2021
satinc(satVars8,1);
inherited create;
icore:=bnew;
end;
//## destroy ##
destructor tvars8.destroy;
begin
try
bfree(icore);
inherited destroy;
satinc(satVars8,-1);
except;end;
end;
//## len ##
function tvars8.len:longint;
begin
try;result:=zzstr(icore,20).len;except;end;
end;
//## clear ##
procedure tvars8.clear;
begin
try;zzstr(icore,21).clear;except;end;
end;
//## bdef ##
function tvars8.bdef(xname:string;xdefval:boolean):boolean;
begin
try
result:=xdefval;
if found(xname) then result:=b[xname];
except;end;
end;
//## idef ##
function tvars8.idef(xname:string;xdefval:longint):longint;
begin
try
result:=xdefval;
if found(xname) then result:=i[xname];
except;end;
end;
//## idef2 ##
function tvars8.idef2(xname:string;xdefval,xmin,xmax:longint):longint;
begin
try
result:=xdefval;
if found(xname) then result:=i[xname];
//range
result:=frcrange(result,xmin,xmax);
except;end;
end;
//## idef64 ##
function tvars8.idef64(xname:string;xdefval:comp):comp;
begin
try
result:=xdefval;
if found(xname) then result:=i64[xname];
except;end;
end;
//## idef642 ##
function tvars8.idef642(xname:string;xdefval,xmin,xmax:comp):comp;
begin
try
result:=xdefval;
if found(xname) then result:=i64[xname];
//range
result:=frcrange64(result,xmin,xmax);
except;end;
end;
//## sdef ##
function tvars8.sdef(xname,xdefval:string):string;
begin
try
result:=xdefval;
if found(xname) then result:=s[xname];
except;end;
end;
//## getb ##
function tvars8.getb(xname:string):boolean;
begin
try;result:=(i[xname]<>0);except;end;
end;
//## setb ##
procedure tvars8.setb(xname:string;xval:boolean);
begin
try;if xval then xsets(xname,'1') else xsets(xname,'0');except;end;
end;
//## geti ##
function tvars8.geti(xname:string):longint;
begin
try;result:=strint(value[xname]);except;end;
end;
//## seti ##
procedure tvars8.seti(xname:string;xval:longint);
begin
try;xsets(xname,inttostr(xval));except;end;
end;
//## geti64 ##
function tvars8.geti64(xname:string):comp;
begin
try;result:=strint64(value[xname]);except;end;
end;
//## seti64 ##
procedure tvars8.seti64(xname:string;xval:comp);
begin
try;xsets(xname,intstr64(xval));except;end;
end;
//## getdt64 ##
function tvars8.getdt64(xname:string):tdatetime;
var
   y,m,d,hh,mm,ss,ms:word;
   a:tstr8;
begin
try
//defaults
result:=0;
//init
a:=nil;
a:=bnew;
//get
a.text:=gets(xname);
if (a.len>=8) then
   begin
   ms:=frcrange(a.wrd2[7],0,999);//7..8
   ss:=frcrange(a.byt1[6],0,59);//6
   mm:=frcrange(a.byt1[5],0,59);//5
   hh:=frcrange(a.byt1[4],0,23);//4
   d:=frcrange(a.byt1[3],1,31);//3
   m:=frcrange(a.byt1[2],1,12);//2
   y:=a.wrd2[0];
   //set
   result:=low__safedate(low__encodedate2(y,m,d)+low__encodetime2(hh,mm,ss,ms));
   end;
except;end;
try;bfree(a);except;end;
end;
//## setdt64 ##
procedure tvars8.setdt64(xname:string;xval:tdatetime);//31jan2022
var
   y,m,d,hh,mm,ss,ms:word;
   a:tstr8;
begin
try
a:=nil;
a:=bnew;
low__decodedate2(xval,y,m,d);
low__decodetime2(xval,hh,mm,ss,ms);
a.wrd2[7]:=frcrange(ms,0,999);//7..8
a.byt1[6]:=frcrange(ss,0,59);//6
a.byt1[5]:=frcrange(mm,0,59);//5
a.byt1[4]:=frcrange(hh,0,23);//4
a.byt1[3]:=frcrange(d,1,31);//3
a.byt1[2]:=frcrange(m,1,12);//2
a.wrd2[0]:=y;//0..1
xsets(xname,a.text);
except;end;
try;bfree(a);except;end;
end;
//## getc ##
function tvars8.getc(xname:string):currency;
begin
try;result:=strtofloatex(value[xname]);except;end;
end;
//## setc ##
procedure tvars8.setc(xname:string;xval:currency);
begin
try;xsets(xname,floattostrex2(xval));except;end;
end;
//## gets ##
function tvars8.gets(xname:string):string;
var
   xpos,nlen,dlen,blen:longint;
begin
try
result:='';
if xfind(xname,xpos,nlen,dlen,blen) and zzok(icore,7075) then result:=zzstr(icore,22).str[xpos+16+nlen,dlen];
except;end;
end;
//## sets ##
procedure tvars8.sets(xname,xvalue:string);
begin
try;xsets(xname,xvalue);except;end;
end;
//## getd ##
function tvars8.getd(xname:string):tstr8;//27apr2021
var
   xpos,nlen,dlen,blen:longint;
begin
try
//was: result:=bnew2(124);
result:=bnew_autofree;//27apr2021
if xfind(xname,xpos,nlen,dlen,blen) then result.bdata:=bcopy1(zzstr(icore,23),(xpos+1)+16+nlen,dlen);
except;end;
end;
//## dget ##
function tvars8.dget(xname:string;xdata:tstr8):boolean;//2dec2021
var
   xpos,nlen,dlen,blen:longint;
begin
try
result:=false;
if not block(xdata) then exit;
if xfind(xname,xpos,nlen,dlen,blen) then
   begin
   xdata.clear;
   xdata.add3(icore,(xpos+0)+16+nlen,dlen);
   result:=true;
   end;
except;end;
try
if not result then xdata.clear;
bunlockautofree(xdata);
except;end;
end;
//## setd ##
procedure tvars8.setd(xname:string;xvalue:tstr8);
begin
try;xsetd(xname,xvalue);except;end;
end;
//## bok ##
function tvars8.bok(xname:string;xval:boolean):boolean;
begin
try;result:=(xval<>b[xname]);if result then b[xname]:=xval;except;end;
end;
//## iok ##
function tvars8.iok(xname:string;xval:longint):boolean;
begin
try;result:=(xval<>i[xname]);if result then i[xname]:=xval;except;end;
end;
//## i64ok ##
function tvars8.i64ok(xname:string;xval:comp):boolean;
begin
try;result:=(xval<>i64[xname]);if result then i64[xname]:=xval;except;end;
end;
//## cok ##
function tvars8.cok(xname:string;xval:currency):boolean;
begin
try;result:=(xval<>c[xname]);if result then c[xname]:=xval;except;end;
end;
//## sok ##
function tvars8.sok(xname,xval:string):boolean;
begin
try;result:=(xval<>s[xname]);if result then s[xname]:=xval;except;end;
end;
//## found ##
function tvars8.found(xname:string):boolean;
var
   xpos,nlen,dlen,blen:longint;
begin
try;result:=xfind(xname,xpos,nlen,dlen,blen);except;end;
end;
//## xfind ##
function tvars8.xfind(xname:string;var xpos,nlen,dlen,blen:longint):boolean;
label
   redo;
var
   xlen:longint;
   v:tint4;
   c,nref:tcur8;
   lb:pdlbyte;
begin
try
//defaults
result:=false;
xpos:=0;
nlen:=0;
dlen:=0;
blen:=0;
//check
if zznil(icore,2266) or (icore.pbytes=nil) then exit;//27apr2021
//init
xlen:=icore.len;
lb:=icore.pbytes;
nref.val:=low__ref256u(xname);
//find
redo:
if ((xpos+15)<xlen) then
   begin
   //nlen/4 - name length
   v.bytes[0]:=lb[xpos+0];
   v.bytes[1]:=lb[xpos+1];
   v.bytes[2]:=lb[xpos+2];
   v.bytes[3]:=lb[xpos+3];
   if (v.val<0) then v.val:=0;
   nlen:=v.val;
   //dlen/4 - data length
   v.bytes[0]:=lb[xpos+4];
   v.bytes[1]:=lb[xpos+5];
   v.bytes[2]:=lb[xpos+6];
   v.bytes[3]:=lb[xpos+7];
   if (v.val<0) then v.val:=0;
   dlen:=v.val;
   //nref/8
   c.bytes[0]:=lb[xpos+8];
   c.bytes[1]:=lb[xpos+9];
   c.bytes[2]:=lb[xpos+10];
   c.bytes[3]:=lb[xpos+11];
   c.bytes[4]:=lb[xpos+12];
   c.bytes[5]:=lb[xpos+13];
   c.bytes[6]:=lb[xpos+14];
   c.bytes[7]:=lb[xpos+15];
   //blen - block length "16 + <name> + <data>"
   blen:=16+nlen+dlen;
   //name
   case (c.ints[0]=nref.ints[0]) and (c.ints[1]=nref.ints[1]) and low__comparetext(xname,icore.str[xpos+16,nlen]) of
   true:result:=true;
   false:begin//inc to next block
      inc(xpos,blen);
      goto redo;
      end;
   end;//case
   end;
except;end;
end;
//## xnext ##
function tvars8.xnext(var xfrom,xpos,nlen,dlen,blen:longint):boolean;
var
   xlen:longint;
   v:tint4;
   lb:pdlbyte;
begin
try
//defaults
result:=false;
if (xfrom<0) then xfrom:=0;
xpos:=0;
nlen:=0;
dlen:=0;
blen:=0;
//check
if zznil(icore,2269) or (icore.pbytes=nil) then exit;//27apr2021
//init
xlen:=icore.len;
lb:=icore.pbytes;
//find
if ((xfrom+15)<xlen) then
   begin
   //nlen/4 - name length
   v.bytes[0]:=lb[xfrom+0];
   v.bytes[1]:=lb[xfrom+1];
   v.bytes[2]:=lb[xfrom+2];
   v.bytes[3]:=lb[xfrom+3];
   if (v.val<0) then v.val:=0;
   nlen:=v.val;
   //dlen/4 - data length
   v.bytes[0]:=lb[xfrom+4];
   v.bytes[1]:=lb[xfrom+5];
   v.bytes[2]:=lb[xfrom+6];
   v.bytes[3]:=lb[xfrom+7];
   if (v.val<0) then v.val:=0;
   dlen:=v.val;
   //blen - block length "16 + <name> + <data>"
   blen:=16+nlen+dlen;
   //name
   xpos:=xfrom;
   inc(xfrom,blen);
   //successful
   result:=true;
   end;
except;end;
end;
//## xnextname ##
function tvars8.xnextname(var xpos:longint;var xname:string):boolean;
label
   redo;
var
   nlen,dlen,blen,xlen:longint;
   v:tint4;
   c,nref:tcur8;
   lb:pdlbyte;
begin
try
//defaults
result:=false;
xname:='';
if (xpos<0) then xpos:=0;
nlen:=0;
dlen:=0;
blen:=0;
//check
if zznil(icore,2270) or (icore.pbytes=nil) then exit;//27apr2021
//init
xlen:=icore.len;
lb:=icore.pbytes;
nref.val:=low__ref256u(xname);
//get
if ((xpos+15)<xlen) then
   begin
   //nlen/4 - name length
   v.bytes[0]:=lb[xpos+0];
   v.bytes[1]:=lb[xpos+1];
   v.bytes[2]:=lb[xpos+2];
   v.bytes[3]:=lb[xpos+3];
   if (v.val<0) then v.val:=0;
   nlen:=v.val;
   //dlen/4 - data length
   v.bytes[0]:=lb[xpos+4];
   v.bytes[1]:=lb[xpos+5];
   v.bytes[2]:=lb[xpos+6];
   v.bytes[3]:=lb[xpos+7];
   if (v.val<0) then v.val:=0;
   dlen:=v.val;
   //nref/8
   c.bytes[0]:=lb[xpos+8];
   c.bytes[1]:=lb[xpos+9];
   c.bytes[2]:=lb[xpos+10];
   c.bytes[3]:=lb[xpos+11];
   c.bytes[4]:=lb[xpos+12];
   c.bytes[5]:=lb[xpos+13];
   c.bytes[6]:=lb[xpos+14];
   c.bytes[7]:=lb[xpos+15];
   //blen - block length "16 + <name> + <data>"
   blen:=16+nlen+dlen;
   //name
   xname:=icore.str[xpos+16,nlen];
   //inc
   inc(xpos,blen);
   //successful
   result:=true;
   end;
except;end;
end;
//## xdel ##
function tvars8.xdel(xname:string):boolean;//02jan2022
label
   skipend;
var
   p,xpos,xlen,nlen,dlen,blen:longint;
   v:tint4;
   nref:tcur8;
   lb:pdlbyte;
begin
try
//defaults
result:=false;
//check
if (xname='') or zznil(icore,2271) then exit;
//delete existing
zzstr(icore,27);
if xfind(xname,xpos,nlen,dlen,blen) then
   begin
   bdel1(icore,xpos+1,blen);
   result:=true;
   end;
except;end;
end;
//## xsets ##
procedure tvars8.xsets(xname,xvalue:string);
label
   skipend;
var
   p,xpos,xlen,nlen,dlen,blen:longint;
   v:tint4;
   nref:tcur8;
   lb:pdlbyte;
begin
try
//check
if (xname='') or zznil(icore,2271) then goto skipend;
//delete existing
zzstr(icore,27);
if xfind(xname,xpos,nlen,dlen,blen) then bdel1(icore,xpos+1,blen);
//init
nlen:=length(xname);
dlen:=length(xvalue);
xpos:=_blen(icore);
blen:=16+nlen+dlen;
xlen:=xpos+blen;
nref.val:=low__ref256u(xname);
//size
if (icore.len<>xlen) and (not icore.setlen(xlen)) then exit;//27apr2021
//check
if (zzstr(icore,28).pbytes=nil) then exit;//27apr2021
//init
lb:=icore.pbytes;
//nlen/4
v.val:=nlen;
lb[xpos+0]:=v.bytes[0];
lb[xpos+1]:=v.bytes[1];
lb[xpos+2]:=v.bytes[2];
lb[xpos+3]:=v.bytes[3];
//dlen/4
v.val:=dlen;
lb[xpos+4]:=v.bytes[0];
lb[xpos+5]:=v.bytes[1];
lb[xpos+6]:=v.bytes[2];
lb[xpos+7]:=v.bytes[3];
//nref/8
lb[xpos+8]:=nref.bytes[0];
lb[xpos+9]:=nref.bytes[1];
lb[xpos+10]:=nref.bytes[2];
lb[xpos+11]:=nref.bytes[3];
lb[xpos+12]:=nref.bytes[4];
lb[xpos+13]:=nref.bytes[5];
lb[xpos+14]:=nref.bytes[6];
lb[xpos+15]:=nref.bytes[7];
//name
for p:=1 to nlen do lb[xpos+15+p]:=byte(xname[p-1+stroffset]);//force 8bit conversion from unicode to 8bit binary - 02may2020
//data
if (dlen>=1) then
   begin
   for p:=1 to dlen do lb[xpos+15+nlen+p]:=byte(xvalue[p-1+stroffset]);//force 8bit conversion from unicode to 8bit binary - 02may2020
   end;
skipend:
except;end;
end;
//## xsetd ##
procedure tvars8.xsetd(xname:string;xvalue:tstr8);
label
   skipend;
var
   p,xpos,xlen,nlen,dlen,blen:longint;
   v:tint4;
   nref:tcur8;
   sb,lb:pdlbyte;
   v8:byte;
begin
try
block(xvalue);
//check
if (xname='') or zznil(icore,2272) or (icore=xvalue) then goto skipend;
//delete existing
if xfind(xname,xpos,nlen,dlen,blen) then bdel1(zzstr(icore,29),xpos+1,blen);
//init
nlen:=length(xname);
dlen:=_blen(xvalue);
xpos:=_blen(icore);
blen:=16+nlen+dlen;
xlen:=xpos+blen;
nref.val:=low__ref256u(xname);
//size
if (icore.len<>xlen) and (not icore.setlen(xlen)) then exit;
//check
if (icore.pbytes=nil) then exit;
//init
lb:=icore.pbytes;
//nlen/4
v.val:=nlen;
lb[xpos+0]:=v.bytes[0];
lb[xpos+1]:=v.bytes[1];
lb[xpos+2]:=v.bytes[2];
lb[xpos+3]:=v.bytes[3];
//dlen/4
v.val:=dlen;
lb[xpos+4]:=v.bytes[0];
lb[xpos+5]:=v.bytes[1];
lb[xpos+6]:=v.bytes[2];
lb[xpos+7]:=v.bytes[3];
//nref/8
lb[xpos+8]:=nref.bytes[0];
lb[xpos+9]:=nref.bytes[1];
lb[xpos+10]:=nref.bytes[2];
lb[xpos+11]:=nref.bytes[3];
lb[xpos+12]:=nref.bytes[4];
lb[xpos+13]:=nref.bytes[5];
lb[xpos+14]:=nref.bytes[6];
lb[xpos+15]:=nref.bytes[7];
//name
for p:=1 to nlen do lb[xpos+15+p]:=byte(xname[p-1+stroffset]);//force 8bit conversion from unicode to 8bit binary - 02may2020
//data
if (dlen>=1) then
   begin
   sb:=zzstr(xvalue,31).pbytes;
   //was: for p:=1 to dlen do lb[xpos+15+nlen+p]:=sb[p-1];
   //faster - 22apr2022
   for p:=1 to dlen do
   begin
   v8:=sb[p-1];
   lb[xpos+15+nlen+p]:=v8;
   end;//p
   end;
skipend:
except;end;
try;bunlockautofree(xvalue);except;end;
end;
//## gettext ##
function tvars8.gettext:string;
var
   a:tstr8;
begin
try
result:='';
a:=nil;
a:=data;
if (a<>nil) then result:=a.text;
except;end;
try;bautofree(a);except;end;
end;
//## settext ##
procedure tvars8.settext(x:string);
begin
try;data:=bcopystr1(x,1,maxint);except;end;
end;
//## getdata ##
function tvars8.getdata:tstr8;
label
   redo;
var
   xfrom,xpos,nlen,dlen,blen:longint;
begin
try
//defaults
result:=bnew_autofree;
//init
xfrom:=0;
//get
redo:
if (result<>nil) and zzok(icore,7076) and xnext(xfrom,xpos,nlen,dlen,blen) then
   begin
   zzstr(icore,33);
   result.sadd(icore.str[xpos+16,nlen]+': '+icore.str[xpos+16+nlen,dlen]+rcode);
   goto redo;
   end;
except;end;
end;
//## setdata ##
procedure tvars8.setdata(xdata:tstr8);
label
   redo;
var
   xline:tstr8;
   xlen,p,xpos:longint;
   lb:pdlbyte;
begin
try
//init
xline:=nil;
clear;
//check
if zznil(xdata,2077) or (icore=xdata) then exit;
//init
block(zzstr(xdata,34));
xline:=bnew;
xpos:=0;
//get
redo:
if low__nextline0(xdata,xline,xpos) then
   begin
   xlen:=xline.len;
   if (xlen>=1) and (xline.pbytes<>nil) then//27apr2021
      begin
      lb:=xline.pbytes;
      for p:=1 to xlen do if (lb[p-1]=58) then//":"
         begin
         xsets(xline.str[0,p-1],xline.str[p+1,xlen]);
         break;
         end;//p
      end;//xlen
   goto redo;
   end;
except;end;
try
bfree(xline);
bunlockautofree(xdata);
except;end;
end;
//## getbinary ##
function tvars8.getbinary(hdr:string):tstr8;
label
   skipend,redo;
const
   nMAXSIZE=high(word);
var
   xfrom,xpos,nlen,dlen,blen:longint;
begin
try
//defaults
result:=bnew_autofree;
//init
xfrom:=0;
//hdr
if (hdr<>'') and (not result.sadd(hdr)) then goto skipend;
//get
redo:
if xnext(xfrom,xpos,nlen,dlen,blen) then
   begin
   zzstr(icore,36);
   //nlen+vlen
   if (nlen>nMAXSIZE) then nlen:=nMAXSIZE;
   if not result.addwrd2(nlen) then goto skipend;
   if not result.addint4(dlen) then goto skipend;
   //name
   if not result.add3(icore,xpos+16,nlen) then goto skipend;
   //data
   if not result.add3(icore,xpos+16+nlen,dlen) then goto skipend;
   //loop
   goto redo;
   end;
skipend:
except;end;
end;
//## setbinary ##
procedure tvars8.setbinary(hdr:string;xval:tstr8);
label
   skipend,redo;
var
   xlen,xpos:longint;
   aname,aval:tstr8;
   //## apull ##
   function apull:boolean;
   var
      nlen,vlen:longint;
   begin
   //defaults
   result:=false;
   //check
   if (xpos>=xlen) then exit;
   //init
   nlen:=xval.wrd2[xpos+0];//0..1
   vlen:=xval.int4[xpos+2];//2..5
   if (nlen<=0) or (vlen<0) then exit;
   //get
   aname.clear;
   aname.add3(xval,xpos+6,nlen);
   aval.clear;
   if (vlen>=1) then aval.add3(xval,xpos+6+nlen,vlen);
   //inc
   inc(xpos,6+nlen+vlen);
   //successful
   result:=true;
   end;
begin
try
//defaults
clear;
aname:=nil;
aval:=nil;
//check
if zznil(xval,2278) or (icore=xval) then exit;
//init
block(xval);
aname:=bnew;
aval:=bnew;
xpos:=0;
zzstr(icore,38);
xlen:=zzstr(xval,37).len;
//hdr
if (hdr<>'') then
   begin
   aval.add3(xval,0,length(hdr));
   if not low__comparetext(hdr,aval.text) then goto skipend;
   inc(xpos,length(hdr));
   end;
//name+value sets
redo:
if apull then
   begin
   xsetd(aname.text,aval);
   goto redo;
   end;
skipend:
except;end;
try
bfree(aname);
bfree(aval);
bunlockautofree(xval);
except;end;
end;

//## tmask8 ####################################################################
//## newmask8 ##
function newmask8(w,h:longint):tmask8;
begin
result:=nil;
result:=tmask8.create(w,h);
end;
//## create ##
constructor tmask8.create(w,h:longint);
begin
satinc(satMask8,1);
zzadd(self);
inherited create;
iwidth:=0;
iheight:=0;
icount:=0;
iblocksize:=sizeof(tmaskrgb96);
irowsize:=0;
icore:=bnew;
irows:=bnew;
resize(w,h);
end;
//## destroy ##
destructor tmask8.destroy;
begin
try
bfree(icore);
bfree(irows);
inherited destroy;
satinc(satMask8,-1);
except;end;
end;
//## resize ##
function tmask8.resize(w,h:longint):boolean;
var
   p,dy,xcount,xrowsize:longint;
begin
try
//defaults
result:=false;
//init
w:=frcmin(w,1);
h:=frcmin(h,1);
xrowsize:=(w div iblocksize)*iblocksize;//round up to nearest block of 12b
if (xrowsize<>w) then inc(xrowsize,iblocksize);
xcount:=(h*xrowsize);
//get
if (xcount<>icore.len) and icore.setlen(xcount) then//27apr2021
   begin
   irowsize:=xrowsize;
   iwidth:=w;
   iheight:=h;
   ibytes:=icore.core;
   icount:=xcount;
   //rows
   p:=0;
   app__fasttimer;
   irows.setlen(h*sizeof(pointer));
   app__fasttimer;
   irows96:=irows.core;
   irows8:=irows.core;
   for dy:=0 to (h-1) do
   begin
   irows96[dy]:=icore.scanline(p);
   inc(p,irowsize);

   //fasttimer - ycheck
   inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;
   end;//dy
   //successful
   result:=true;
   end
else result:=true;
except;end;
end;
//## cls ##
function tmask8.cls(xval:byte):boolean;
var
   sr96:pmaskrow96;
   dc96:tmaskrgb96;
   p,dx,dy,dw96:longint;
begin
try
//check
if (iwidth<1) or (iheight<1) then exit;
//init
for p:=0 to high(dc96) do dc96[p]:=xval;
//get
dw96:=irowsize div sizeof(dc96);
p:=0;
for dy:=0 to (iheight-1) do
begin
sr96:=rows[dy];
for dx:=0 to (dw96-1) do sr96[dx]:=dc96;

//fasttimer - ycheck
inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;
end;//dy
except;end;
end;
//## fill ##
function tmask8.fill(xarea:trect;xval:byte;xround:boolean):boolean;//29apr2020
var//Speed: 3,300ms -> 1,280ms -> 1,141ms -> 1,080ms
   sr96:pmaskrow96;
   dc96:tmaskrgb96;
   amin,xcorner,dxstart,dx96,xleft96,xright96,p,i,dx1,dx2,dx,dy,dw,dh,dw96:longint;
   bol1:boolean;
//xxxxxxxxxxxxxxxxxxxxxxx this needs to be replaced with "low__cornersolid()" for a consistent system wide approach - 16may2020
   //## xcorneroffset_solid ##
   procedure xcorneroffset_solid;
   begin
   //.int1 -> set offset to draw slightly rounded corners - 09apr2020
   xcorner:=0;
   case amin of
   3..10:if (dy=xarea.top) or (dy=xarea.bottom)           then xcorner:=1;//1px curved corner
   11..maxint:begin//multi-pixel curved corner
      if      (dy=xarea.top)     or (dy=xarea.bottom)     then xcorner:=3
      else if (dy=(xarea.top+1)) or (dy=(xarea.bottom-1)) then xcorner:=2
      else if (dy=(xarea.top+2)) or (dy=(xarea.bottom-2)) then xcorner:=1
      else if (dy=(xarea.top+3)) or (dy=(xarea.bottom-3)) then xcorner:=1
      else if (dy=(xarea.top+4)) or (dy=(xarea.bottom-4)) then xcorner:=1;
      end;
   end;//case
   end;
begin
try
//defaults
result:=true;

//check
if (iwidth<1) or (iheight<1) or (xarea.right<xarea.left) or (xarea.bottom<xarea.top) or (xarea.right<0) or (xarea.left>=iwidth) or (xarea.bottom<0) or (xarea.top>=iheight) then exit;

//init
xcorner:=0;
amin:=smallest(xarea.bottom-xarea.top+1,xarea.right-xarea.left+1);
dw:=iwidth;
dh:=iheight;
dw96:=irowsize div sizeof(dc96);
//.left
xleft96:=xarea.left div iblocksize;
if ((xleft96*iblocksize)>xarea.left) then dec(xleft96);
xleft96:=frcrange(xleft96,0,frcmin(dw96-1,0));
//.right
xright96:=xarea.right div iblocksize;
if ((xright96*iblocksize)<xarea.right) then inc(xright96);
xright96:=frcrange(xright96,xleft96,frcmin(dw96-1,0));
dxstart:=xleft96*iblocksize;

//get
for dy:=0 to (dh-1) do
begin
sr96:=rows[dy];
if (dy>=xarea.top) and (dy<=xarea.bottom) then
   begin
   //fasttimer - ycheck
   inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

   //.xcorner -> set offset to draw slightly rounded corners - 09apr2020
   if xround then xcorneroffset_solid;
   dx1:=xarea.left+xcorner;
   dx2:=xarea.right-xcorner;

   //.dx
   dx:=dxstart;
   for dx96:=xleft96 to xright96 do
   begin
   bol1:=false;
   dc96:=sr96[dx96];

   //.0
   if (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[0]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.1
   if (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[1]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.2
   if (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[2]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.3
   if (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[3]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.4
   if (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[4]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.5
   if (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[5]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.6
   if (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[6]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.7
   if (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[7]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.8
   if (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[8]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.9
   if (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[9]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.10
   if (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[10]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.11
   if (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[11]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //set
   if bol1 then sr96[dx96]:=dc96;
   end;//dx96
   end;
end;//dy
except;end;
end;
//## fill2 ##
function tmask8.fill2(xarea:trect;xval:byte;xround:boolean):boolean;//29apr2020
var//Speed: 3,300ms -> 1,280ms -> 1,141ms -> 1,080ms -> 700ms -> 672ms (5x faster) -> 500ms
   //Usage: Use in top-down window order -> draw topmost window, then next, then next, and last the bottommost window - 17may2020
   sr96:pmaskrow96;
   dc96:tmaskrgb96;
   amin,xcorner,dxstart,dx96,xleft96,xright96,p,i,dx1,dx2,dx,dy,dw,dh,dw96:longint;
   bol1:boolean;
//xxxxxxxxxxxxxxxxxxxxxxx this needs to be replaced with "low__cornersolid()" for a consisten system wide approach - 16may2020
   //## xcorneroffset_solid ##
   procedure xcorneroffset_solid;
   begin
   //.int1 -> set offset to draw slightly rounded corners - 09apr2020
   xcorner:=0;
   case amin of
   3..10:if (dy=xarea.top) or (dy=xarea.bottom)           then xcorner:=1;//1px curved corner
   11..maxint:begin//multi-pixel curved corner
      if      (dy=xarea.top)     or (dy=xarea.bottom)     then xcorner:=3
      else if (dy=(xarea.top+1)) or (dy=(xarea.bottom-1)) then xcorner:=2
      else if (dy=(xarea.top+2)) or (dy=(xarea.bottom-2)) then xcorner:=1
      else if (dy=(xarea.top+3)) or (dy=(xarea.bottom-3)) then xcorner:=1
      else if (dy=(xarea.top+4)) or (dy=(xarea.bottom-4)) then xcorner:=1;
      end;
   end;//case
   end;
begin
try
//defaults
result:=true;

//check
if (iwidth<1) or (iheight<1) or (xarea.right<xarea.left) or (xarea.bottom<xarea.top) or (xarea.right<0) or (xarea.left>=iwidth) or (xarea.bottom<0) or (xarea.top>=iheight) then exit;

//init
xcorner:=0;
amin:=smallest(xarea.bottom-xarea.top+1,xarea.right-xarea.left+1);
dw:=iwidth;
dh:=iheight;
dw96:=irowsize div sizeof(dc96);
//.left
xleft96:=xarea.left div iblocksize;
if ((xleft96*iblocksize)>xarea.left) then dec(xleft96);
xleft96:=frcrange(xleft96,0,frcmin(dw96-1,0));
//.right
xright96:=xarea.right div iblocksize;
if ((xright96*iblocksize)<xarea.right) then inc(xright96);
xright96:=frcrange(xright96,xleft96,frcmin(dw96-1,0));
dxstart:=xleft96*iblocksize;

//get
for dy:=0 to (dh-1) do
begin
sr96:=rows[dy];
if (dy>=xarea.top) and (dy<=xarea.bottom) then
   begin
   //fasttimer - ycheck
   inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

   //.xcorner -> set offset to draw slightly rounded corners - 09apr2020
   if xround then xcorneroffset_solid;
   dx1:=xarea.left+xcorner;
   dx2:=xarea.right-xcorner;

   //.dx
   dx:=dxstart;
   for dx96:=xleft96 to xright96 do
   begin
   bol1:=false;
   dc96:=sr96[dx96];

   //.0
   if (dc96[0]=0) and (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[0]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.1
   if (dc96[1]=0) and (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[1]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.2
   if (dc96[2]=0) and (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[2]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.3
   if (dc96[3]=0) and (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[3]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.4
   if (dc96[4]=0) and (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[4]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.5
   if (dc96[5]=0) and (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[5]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.6
   if (dc96[6]=0) and (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[6]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.7
   if (dc96[7]=0) and (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[7]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.8
   if (dc96[8]=0) and (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[8]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.9
   if (dc96[9]=0) and (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[9]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.10
   if (dc96[10]=0) and (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[10]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //.11
   if (dc96[11]=0) and (dx>=dx1) and (dx<=dx2) then
      begin
      dc96[11]:=xval;
      bol1:=true;
      end;//dx
   inc(dx);
   //set
   if bol1 then sr96[dx96]:=dc96;
   end;//dx96
   end;
end;//dy
except;end;
end;
//## mrow ##
procedure tmask8.mrow(dy:longint);
begin//speed: 4,094ms -> 3,400ms -> 2,100ms -> 2,000ms
ilastdy:=dy*irowsize;
end;
//## mval ##
function tmask8.mval(dx:longint):byte;
begin//speed: 4,094ms -> 3,400ms -> 2,100ms -> 2,000ms -> 1350ms
result:=ibytes[ilastdy+dx];
end;
//## mval2 ##
function tmask8.mval2(dx,dy:longint):byte;
begin//speed: 4,094ms -> 3,400ms -> 2,100ms -> 2,000ms
result:=ibytes[(dy*irowsize)+dx];
end;

//## tany ######################################################################
//## create2 ##
constructor tany.create;
begin
//self
satinc(satAny,1);
inherited create;
//options
omustfree:=true;
ocopyvals:=true;
//vars
cap:='';
name:='';
filename:='';
refstr:='';
ref32:=0;
ref64:=0;
obj:=nil;
obj2:=nil;
img:=nil;
img2:=nil;
str:=nil;
str2:=nil;
tag:=0;
tag2:=0;
//.sysid32
sysid32:=system_sysid32_tany;
low__iroll(system_sysid32_tany,1);
end;
//## destroy ##
destructor tany.destroy;
begin
try
//vars
cap:='';
name:='';
filename:='';
refstr:='';
ref32:=0;
ref64:=0;
if omustfree then
   begin
   if (obj<>nil)  then freeobj(@obj);
   if (obj2<>nil) then freeobj(@obj2);
   if (img<>nil)  then freeobj(@img);
   if (img2<>nil) then freeobj(@img2);
   if (str<>nil)  then bfree(str);
   if (str2<>nil) then bfree(str2);
   end;
//self
inherited destroy;
satinc(satAny,-1);
except;end;
end;
//## todata ##
function tany.todata:tstr8;
label
   skipend;
var
   d:tstr8;//pointer only
   xresult:boolean;
   //## xadd ##
   function xadd(xid:longint;xval:tstr8):boolean;
   begin
   try;result:=block(xval) and d.addint4(xid) and d.addint4(xval.len) and d.add(xval);except;end;
   try;bunlockautofree(xval);except;end;
   end;
   //## xaddint ##
   function xaddint(xid,xval:longint):boolean;
   begin
   try;result:=d.addint4(xid) and d.addint4(4) and d.addint4(xval);except;end;
   end;
   //## xaddcmp ##
   function xaddcmp(xid:longint;xval:comp):boolean;
   begin
   try;result:=d.addint4(xid) and d.addint4(8) and d.addcmp8(xval);except;end;
   end;
   //## xaddstr ##
   function xaddstr(xid:longint;xval:string):boolean;
   begin
   try;result:=d.addint4(xid) and d.addint4(length(xval)) and d.sadd(xval);except;end;
   end;
begin
try
//defaults
result:=bnew;
d:=result;
xresult:=false;
//add
if (cap<>'')       and (not xaddstr(0,cap)) then goto skipend;
if (name<>'')      and (not xaddstr(1,name)) then goto skipend;
if (filename<>'')  and (not xaddstr(2,filename)) then goto skipend;
if (refstr<>'')    and (not xaddstr(3,refstr)) then goto skipend;
if (ref32<>0)      and (not xaddint(4,ref32)) then goto skipend;
if (ref64<>0)      and (not xaddcmp(5,ref64)) then goto skipend;
if (tag<>0)        and (not xaddint(6,tag)) then goto skipend;
if (tag2<>0)       and (not xaddcmp(7,tag2)) then goto skipend;
//obj
//obj2
if (img<>nil)      and (not xadd(8,img.todata)) then goto skipend;
if (img2<>nil)     and (not xadd(9,img2.todata)) then goto skipend;
if (blen(str)>=1)  and (not xadd(10,str)) then goto skipend;
if (blen(str2)>=1) and (not xadd(11,str2)) then goto skipend;
//finish
if not result.addint4(maxint) then goto skipend;
//successful
xresult:=true;
skipend:
except;end;
try
result.oautofree:=true;
if zzok2(result) and (not xresult) then result.clear;
except;end;
end;
//## fromdata ##
function tany.fromdata(s:tstr8):boolean;
label
   redo,skipend;
var
   xid,xpos,xlen:longint;
   xdata:tstr8;
   //## xpull ##
   function xpull:boolean;
   label
      skipend;
   var
      slen:longint;
   begin
   try
   //defaults
   result:=false;
   //clear
   xdata.clear;
   //id
   if ((xpos+3)>=xlen) then goto skipend;
   xid:=s.int4[xpos];
   inc(xpos,4);
   //eof
   if (xid=maxint) then
      begin
      result:=true;
      goto skipend;
      end;
   //slen
   if ((xpos+3)>=xlen) then goto skipend;
   slen:=s.int4[xpos];
   inc(xpos,4);
   //check
   if ((xpos+slen-1)>=xlen) then goto skipend;
   //data
   if not xdata.add3(s,xpos,slen) then goto skipend;
   inc(xpos,slen);
   //set
   case xid of
   0:cap:=xdata.text;
   1:name:=xdata.text;
   2:filename:=xdata.text;
   3:refstr:=xdata.text;
   4:ref32:=xdata.int4[0];
   5:ref64:=xdata.cmp8[0];
   8:begin
      if (img=nil) then img:=misimg32(1,1);
      if not img.fromdata(xdata) then goto skipend;
      end;
   9:begin
      if (img2=nil) then img2:=misimg32(1,1);
      if not img2.fromdata(xdata) then goto skipend;
      end;
   10:begin
      if (str=nil) then str:=bnew;
      if not str.add(xdata) then goto skipend;
      end;
   11:begin
      if (str2=nil) then str2:=bnew;
      if not str2.add(xdata) then goto skipend;
      end;
   else goto skipend;//error
   end;
   //reduce ram
   xdata.clear;
   //successfsul
   result:=true;
   skipend:
   except;end;
   end;
begin
try
//defaults
result:=false;
xdata:=nil;
//check
if not block(s) then goto skipend;
//init
xpos:=0;
xlen:=s.len;
xid:=-1;
xdata:=bnew;
//clear
cap:='';
name:='';
filename:='';
refstr:='';
ref32:=0;
ref64:=0;
if (img<>nil) then img.fromdata(nil);
if (img2<>nil) then img2.fromdata(nil);
if (str<>nil) then str.clear;
if (str2<>nil) then str2.clear;
//get
redo:
if not xpull then goto skipend;
if (xid<>maxint) then goto redo;
//successful
result:=true;
skipend:
except;end;
try
bfree(xdata);
bunlockautofree(s);
except;end;
end;
//## makeCopyvals ##
function tany.makeCopyvals:boolean;
begin
try
result:=true;
omustfree:=true;
ocopyvals:=true;
except;end;
end;
//## makeHoldvals ##
function tany.makeHoldvals:boolean;
begin
try
result:=true;
omustfree:=false;
ocopyvals:=false;
except;end;
end;
//## copyfrom ##
function tany.copyfrom(s:tany):boolean;
label
   skipend;
var
   bol1,bol2,bol3:boolean;
begin
try
//defaults
result:=false;
//options
omustfree:=s.omustfree;
ocopyvals:=s.ocopyvals;
//simple
cap:=s.cap;
name:=s.name;
filename:=s.filename;
refstr:=s.refstr;//14feb2022
ref32:=s.ref32;
ref64:=s.ref64;
tag:=s.tag;
tag2:=s.tag2;
//get
case ocopyvals of
true:begin//recommended method for any data HOSTING application - 09feb2022
   bol1:=low__true2(man__copyfrom(s.obj,@obj),man__copyfrom(s.obj2,@obj2));
   bol2:=low__true2(man__copyfrom(s.img,@img),man__copyfrom(s.img2,@img2));
   bol3:=low__true2(man__copyfrom(s.str,@str),man__copyfrom(s.str2,@str2));
   if not low__true3(bol1,bol2,bol3) then goto skipend;
   end;
false:begin//note: it is dangerous to COPY the handle of the object, as a single instance can destroy the ONE real instance of the objects and all the other copies of it's handles then point to NOTHING likely resulting in a fatal error down the road - 09feb2022
   obj:=s.obj;
   obj2:=s.obj2;
   img:=s.img;
   img2:=s.img2;
   str:=s.str;
   str2:=s.str2;
   end;
end;
//successful
result:=true;
skipend:
except;end;
end;
//## setcap ##
function tany.setcap(x:string):tany;
begin
try;result:=self;cap:=x;except;end;
end;
//## setname ##
function tany.setname(x:string):tany;
begin
try;result:=self;name:=x;except;end;
end;
//## setfilename ##
function tany.setfilename(x:string):tany;
begin
try;result:=self;filename:=x;except;end;
end;
//## setrefstr ##
function tany.setrefstr(x:string):tany;
begin
try;result:=self;refstr:=x;except;end;
end;
//## setref32 ##
function tany.setref32(x:longint):tany;
begin
try;result:=self;ref32:=x;except;end;
end;
//## setref64 ##
function tany.setref64(x:comp):tany;
begin
try;result:=self;ref64:=x;except;end;
end;
//## setobj ##
function tany.setobj(x:tobject):tany;
begin
try;result:=self;obj:=x;except;end;
end;
//## setobj2 ##
function tany.setobj2(x:tobject):tany;
begin
try;result:=self;obj2:=x;except;end;
end;
//## setimg ##
function tany.setimg(x:tbasicimage):tany;
begin
try;result:=self;img:=x;except;end;
end;
//## setimg2 ##
function tany.setimg2(x:tbasicimage):tany;
begin
try;result:=self;img2:=x;except;end;
end;
//## setstr ##
function tany.setstr(x:tstr8):tany;
begin
try;result:=self;str:=x;except;end;
end;
//## setstr2 ##
function tany.setstr2(x:tstr8):tany;
begin
try;result:=self;str2:=x;except;end;
end;
//## settag ##
function tany.settag(x:longint):tany;
begin
try;result:=self;tag:=x;except;end;
end;
//## settag2 ##
function tany.settag2(x:longint):tany;
begin
try;result:=self;tag2:=x;except;end;
end;

//## tdynamiclist ##############################################################
//## create ##
constructor tdynamiclist.create;
begin
//self
satinc(satDynlist,1);
inherited create;
//sd
//vars
sorted:=nil;
icore:=nil;
ilockedBPI:=false;
isize:=0;
icount:=0;
ibpi:=1;
ilimit:=maxint;
if (globaloverride_incSIZE>=1) then iincsize:=globaloverride_incSIZE else iincsize:=200;//22MAY2010
freesorted:=true;
//defaults
_createsupport;
_init;
_corehandle;
end;
//## destroy ##
destructor tdynamiclist.destroy;
begin
try
//clear
clear;
//controls
_destroysupport;
low__freemem(icore,isize*ibpi,9021);
sdm_track(-isize*ibpi);//04may2019
if freesorted and zzok(sorted,7077) then freeobj(@sorted);
//self
inherited destroy;
satinc(satDynlist,-1);
except;end;
end;
//## sdm_track ##
procedure tdynamiclist.sdm_track(xby:comp);
begin
try
//nil
except;end;
end;
//## _createsupport ##
procedure tdynamiclist._createsupport;
begin
//nil
end;
//## _destroysupport ##
procedure tdynamiclist._destroysupport;
begin
//nil
end;
//## nosort ##
procedure tdynamiclist.nosort;
begin
try;if zzok(sorted,7078) then freeobj(@sorted);except;end;
end;
//## nullsort ##
procedure tdynamiclist.nullsort;
var
   p:longint;
begin
try
//check
if zznil(sorted,2279) then
   begin
   freesorted:=true;
   sorted:=tdynamicinteger.create;
   end;//end of if
//process
//.sync "sorted" object
sorted.size:=size;
sorted.count:=count;
//.fill with default "non-sorted" map list
for p:=0 to (count-1) do sorted.items[p]:=p;
except;end;
end;
//## sort ##
procedure tdynamiclist.sort(_asc:boolean);
begin
try
//init
nullsort;
//get
if (count>=1) then _sort(_asc);
except;end;
end;
//## _sort ##
procedure tdynamiclist._sort(_asc:boolean);
begin
{nil}
end;
//## _init ##
procedure tdynamiclist._init;
begin
try;_setparams(0,0,1,false);except;end;
end;
//## _corehandle ##
procedure tdynamiclist._corehandle;
begin
{nil}
end;
//## _oncreateitem ##
procedure tdynamiclist._oncreateitem(sender:tobject;index:longint);
begin
try;if assigned(oncreateitem) then oncreateitem(self,index);except;end;
end;
//## _onfreeitem ##
procedure tdynamiclist._onfreeitem(sender:tobject;index:longint);
begin
try;if assigned(onfreeitem) then onfreeitem(self,index);except;end;
end;
//## setincsize ##
procedure tdynamiclist.setincsize(x:longint);
begin
try;iincsize:=frcmin(x,1);except;end;
end;
//## clear ##
procedure tdynamiclist.clear;
begin
try;size:=0;except;end;
end;
//## notify ##
function tdynamiclist.notify(s,f:longint;_event:tdynamiclistevent):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
//no range checking (isize may be undefined at this stage, assume s & f are within range)
if (s<0) or (f<0) or (s>f) then exit;
//process
for p:=s to f do if assigned(_event) then _event(self,p);
//successful
result:=true;
except;end;
end;
//## shift ##
procedure tdynamiclist.shift(s,by:longint);
var
   p:longint;
begin
try
if (by>=1) then for p:=(isize-1) downto (s+by) do swap(p,p-by)
else if (by<=-1) then for p:=s to (isize-1) do swap(p,p+by);
except;end;
end;
//## swap ##
function tdynamiclist.swap(x,y:longint):boolean;
var
   a:byte;
   b:pdlBYTE;
   p:longint;
begin
try
//defaults
result:=false;
//check
if (x<0) or (x>=isize) or (y<0) or (y>=isize) then exit;
if assigned(onswapitems) then onswapitems(self,x,y)
else
    begin
    //init
    b:=icore;
    x:=x*ibpi;
    y:=y*ibpi;
    //get (swap values byte-by-byte)
    for p:=0 to (ibpi-1) do
    begin
    //1
    a:=b[x+p];
    //2
    b[x+p]:=b[y+p];
    //3
    b[y+p]:=a;
    end;//p
    end;
//successful
result:=true;
except;end;
end;
//## setparams ##
function tdynamiclist.setparams(_count,_size,_bpi:longint):boolean;
begin
try;result:=_setparams(_count,_size,_bpi,true);except;end;
end;
//## _setparams ##
function tdynamiclist._setparams(_count,_size,_bpi:longint;_notify:boolean):boolean;
label
     skipend;
var
   a:pointer;
   p,_oldsize,_limit:longint;
begin
try
//defaults
result:=false;
//enforce range
if ilockedBPI then _bpi:=ibpi else _bpi:=frcmin(_bpi,1);
_limit:=(maxint div nozero(1000002,_bpi))-1;
_size:=frcrange(_size,0,_limit);
_oldsize:=frcrange(isize,0,_limit)*ibpi;
//process
//.size
if (_size<>isize) then
   begin
   a:=icore;
   //.enlarge
   if (_size>isize) then
      begin
      low__reallocmemCLEAR(icore,_oldsize,_size*_bpi,3);
      sdm_track((_size*_bpi)-_oldsize);//04may2019
      //.update core handle
      if (a<>icore) then _corehandle;
      if _notify then notify(isize,_size-1,_oncreateitem);
      end
   //.shrink
   else if (_size<isize) then
      begin
      if _notify then notify(_size,isize-1,_onfreeitem);
      low__reallocmemCLEAR(icore,_oldsize,_size*_bpi,4);
      sdm_track((_size*_bpi)-_oldsize);//04may2019
      //.update core handle
      if (a<>icore) then _corehandle;
      end;//end of if
   //.check
   end;
//.vars
ilimit:=_limit;
isize:=_size;
icount:=frcrange(_count,0,_size);
ibpi:=_bpi;
//successful
result:=true;
skipend:
except;end;
end;
//## atleast ##
function tdynamiclist.atleast(_size:longint):boolean;
begin
try;if (_size>=size) then result:=_setparams(count,((_size div nozero(1000003,incsize))+1)*incsize,bpi,true) else result:=true;except;end;
end;
//## addrange ##
function tdynamiclist.addrange(_count:longint):boolean;
var
   newsize,newcount:longint;
begin
try
//defaults
result:=false;
//check
if (_count<=0) then exit;
//prepare
newsize:=isize;
newcount:=icount+_count;
//check
if (newcount>ilimit) then exit;
if (newcount>newsize) then
   begin
   newsize:=newcount+iincsize;
   if (newsize>ilimit) then newsize:=ilimit;
   end;//end of if
//process
result:=setparams(newcount,newsize,bpi) and (newcount>=icount);
except;end;
end;
//## add ##
function tdynamiclist.add:boolean;
begin
try;result:=addrange(1);except;end;
end;
//## delrange
function tdynamiclist.delrange(s,_count:longint):boolean;
begin
try
//defaults
result:=false;
//check
if (s<0) or (s>=isize) then exit;
_count:=frcrange(_count,0,isize-s);
if (_count<=0) then exit;
//process
//.free
if not notify(s,s+_count-1,_onfreeitem) then exit;
//.shift down by "_count"
shift(s+_count,-_count);
//.shrink
if not _setparams(count-_count,isize-_count,bpi,false) then exit;
//successful
result:=true;
except;end;
end;
//## _del ##
function tdynamiclist._del(x:longint):boolean;//2nd copy - 20oct2018
begin
try;result:=delrange(x,1);except;end;
end;
//## del ##
function tdynamiclist.del(x:longint):boolean;
begin
try;result:=delrange(x,1);except;end;
end;
//## insrange ##
function tdynamiclist.insrange(s,_count:longint):boolean;
var
   _oldsize,p:longint;
begin
try
//defaults
result:=false;
//check
_count:=frcmin(_count,0);
if (_count<=0) or (s<0) or (s>=isize) then exit;
if ((isize+_count)>ilimit) then exit;
//process
//.enlarge
_oldsize:=isize*bpi;
inc(isize,_count);
inc(icount,_count);
low__reallocmemCLEAR(icore,_oldsize,isize*bpi,5);
//.shift up by "_count"
shift(s,_count);
//.new
if not notify(s,s+_count-1,_oncreateitem) then exit;
//successful
result:=true;
except;end;
end;
//## ins ##
function tdynamiclist.ins(x:longint):boolean;
begin
try;result:=insrange(x,1);except;end;
end;
//## setcount ##
procedure tdynamiclist.setcount(x:longint);
begin
try;setparams(x,size,bpi);except;end;
end;
//## setsize ##
procedure tdynamiclist.setsize(x:longint);
begin
try;setparams(count,x,bpi);except;end;
end;
//## setbpi ##
procedure tdynamiclist.setbpi(x:longint);//bytes per item
begin
try;setparams(count,size,x);except;end;
end;
//## findvalue ##
function tdynamiclist.findvalue(_start:longint;_value:pointer):longint;
var
   a,b:pdlBYTE;
   maxp2,ai,p2,p:longint;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) or (_value=nil) then exit;
//init
a:=core;
b:=_value;
maxp2:=ibpi-1;
//get
for p:=_start to (icount-1) do
    begin
    ai:=p*ibpi;
    p2:=0;
    repeat
    if (a[ai+p2]<>b[p2]) then break;
    inc(p2);
    until (p2>maxp2);
    if (p2>maxp2) then
       begin
       result:=p;
       exit;
       end;//p2
    end;//p
except;end;
end;
//## sindex ##
function tdynamiclist.sindex(x:longint):longint;
begin//sorted index
if zznil(sorted,2280) or (x>=sorted.count) then result:=x else result:=sorted.value[x];
end;

//## tdynamicinteger ###########################################################
//## create ##
constructor tdynamicinteger.create;//01may2019
begin
satinc(satDynint,1);
inherited create;
end;
//## destroy ##
destructor tdynamicinteger.destroy;//01may2019
begin
inherited destroy;
satinc(satDynint,-1);
end;
//## _init ##
procedure tdynamicinteger._init;
begin
try
_setparams(0,0,4,false);
ilockedBPI:=true;
itextsupported:=true;
except;end;
end;
//## copyfrom ##
function tdynamicinteger.copyfrom(s:tdynamicinteger):boolean;
var
   p,xcount:longint;
begin
try
//defaults
result:=false;
//check
if (s=self) then
   begin
   result:=true;
   exit;
   end;
if (s=nil) then exit;
//get
freesorted:=s.freesorted;
utag:=s.utag;
xcount:=s.count;
size:=s.size;
count:=xcount;
for p:=(xcount-1) downto 0 do value[p]:=s.value[p];
if (s.sorted=nil) then
   begin
   if (sorted<>nil) then nosort;
   end
else
   begin
   nullsort;
   for p:=(s.sorted.count-1) downto 0 do sorted.value[p]:=s.sorted.value[p];
   end;
except;end;
end;
//## _corehandle ##
procedure tdynamicinteger._corehandle;
begin
iitems:=core;
end;
//## getvalue ##
function tdynamicinteger.getvalue(_index:longint):longint;
begin
//.check
if (_index<0) or (_index>=count) then result:=0
else result:=items[_index];
end;
//## setvalue ##
procedure tdynamicinteger.setvalue(_index:longint;_value:longint);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]:=_value;
end;
//## getsvalue ##
function tdynamicinteger.getsvalue(_index:longint):longint;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamicinteger.setsvalue(_index:longint;_value:longint);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamicinteger.find(_start:longint;_value:longint):longint;
var
   p:longint;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//process
for p:=_start to (icount-1) do if (iitems[p]=_value) then
    begin
    result:=p;
    break;
    end;//p
except;end;
end;
//## _sort ##
procedure tdynamicinteger._sort(_asc:boolean);
begin
try;__sort(items,sorted.items,0,count-1,_asc);except;end;
end;
//## __sort ##
procedure tdynamicinteger.__sort(a:pdllongint;b:pdllongint;l,r:longint;_asc:boolean);
var
  p,tmp,i,j:longint;
begin
try
repeat
I := L;
J := R;
P := a^[b^[(L + R) shr 1]];
  repeat
  if _asc then
     begin
     while (a^[b^[I]]<P) do inc(I);
     while (a^[b^[J]]>P) do dec(J);
     end
  else
     begin
     while (a^[b^[I]]>P) do inc(I);
     while (a^[b^[J]]<P) do dec(J);
     end;//end of if
  if I <= J then
     begin
     tmp:=b^[i];
     b^[i]:=b^[j];
     b^[j]:=tmp;
     inc(I);
     dec(J);
     end;//end of if
  until I > J;
if L < J then __sort(a,b,L,J,_asc);
L := I;
until I >= R;
except;end;
end;

//## tdynamicbyte ##############################################################
//## create ##
constructor tdynamicbyte.create;//01may2019
begin
satinc(satDynbyte,1);
inherited create;
end;
//## destroy ##
destructor tdynamicbyte.destroy;//01may2019
begin
inherited destroy;
satinc(satDynbyte,-1);
end;
//## _init ##
procedure tdynamicbyte._init;
begin
try
_setparams(0,0,1,false);
ilockedBPI:=true;
itextsupported:=true;
except;end;
end;
//## _corehandle ##
procedure tdynamicbyte._corehandle;
begin
iitems:=core;
ibits:=core;
end;
//## getvalue ##
function tdynamicbyte.getvalue(_index:longint):byte;
begin
//.check
if (_index<0) or (_index>=count) then result:=0
else result:=items[_index];
end;
//## setvalue ##
procedure tdynamicbyte.setvalue(_index:longint;_value:byte);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]:=_value;
end;
//## getsvalue ##
function tdynamicbyte.getsvalue(_index:longint):byte;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamicbyte.setsvalue(_index:longint;_value:byte);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamicbyte.find(_start:longint;_value:byte):longint;
var
   p:longint;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//process
for p:=_start to (icount-1) do if (iitems[p]=_value) then
    begin
    result:=p;
    break;
    end;//p
except;end;
end;
//## _sort ##
procedure tdynamicbyte._sort(_asc:boolean);
begin
try;__sort(items,sorted.items,0,count-1,_asc);except;end;
end;
//## __sort ##
procedure tdynamicbyte.__sort(a:pdlbyte;b:pdllongint;l,r:longint;_asc:boolean);
var
  p:byte;
  tmp,i,j:longint;
begin
try
repeat
I := L;
J := R;
P := a^[b^[(L + R) shr 1]];
  repeat
  if _asc then
     begin
     while (a^[b^[I]]<P) do inc(I);
     while (a^[b^[J]]>P) do dec(J);
     end
  else
     begin
     while (a^[b^[I]]>P) do inc(I);
     while (a^[b^[J]]<P) do dec(J);
     end;//end of if
  if I <= J then
     begin
     tmp:=b^[i];
     b^[i]:=b^[j];
     b^[j]:=tmp;
     inc(I);
     dec(J);
     end;//end of if
  until I > J;
if L < J then __sort(a,b,L,J,_asc);
L := I;
until I >= R;
except;end;
end;

//## tdynamiccurrency ##########################################################
//## create ##
constructor tdynamiccurrency.create;//01may2019
begin
inherited create;
end;
//## destroy ##
destructor tdynamiccurrency.destroy;//01may2019
begin
inherited destroy;
end;
//## _init ##
procedure tdynamiccurrency._init;
begin
try
_setparams(0,0,8,false);
ilockedBPI:=true;
itextsupported:=true;
except;end;
end;
//## _corehandle ##
procedure tdynamiccurrency._corehandle;
begin
iitems:=core;
end;
//## getvalue ##
function tdynamiccurrency.getvalue(_index:longint):currency;
begin
//.check
if (_index<0) or (_index>=count) then result:=0
else result:=items[_index];
end;
//## setvalue ##
procedure tdynamiccurrency.setvalue(_index:longint;_value:currency);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]:=_value;
end;
//## getsvalue ##
function tdynamiccurrency.getsvalue(_index:longint):currency;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamiccurrency.setsvalue(_index:longint;_value:currency);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamiccurrency.find(_start:longint;_value:currency):longint;
var//* Uses "2xInteger for QUICK comparision".
   //* Direct "Currency" comparison is upto 3-4 times slower.
   a:pdlbilongint;
   b:pbilongint;
   p:longint;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//prepare
a:=core;
b:=@_value;
//process
for p:=_start to (icount-1) do if (a[p][0]=b[0]) and (a[p][1]=b[1]) then
    begin
    result:=p;
    break;
    end;//end of if
except;end;
end;
//## _sort ##
procedure tdynamiccurrency._sort(_asc:boolean);
begin
try;__sort(items,sorted.items,0,count-1,_asc);except;end;
end;
//## __sort ##
procedure tdynamiccurrency.__sort(a:pdlCURRENCY;b:pdllongint;l,r:longint;_asc:boolean);
var
  p:currency;
  tmp,i,j:longint;
begin
try
repeat
I := L;
J := R;
P := a^[b^[(L + R) shr 1]];
  repeat
  if _asc then
     begin
     while (a^[b^[I]]<P) do inc(I);
     while (a^[b^[J]]>P) do dec(J);
     end
  else
     begin
     while (a^[b^[I]]>P) do inc(I);
     while (a^[b^[J]]<P) do dec(J);
     end;//end of if
  if I <= J then
     begin
     tmp:=b^[i];
     b^[i]:=b^[j];
     b^[j]:=tmp;
     inc(I);
     dec(J);
     end;//end of if
  until I > J;
if L < J then __sort(a,b,L,J,_asc);
L := I;
until I >= R;
except;end;
end;

//## tdynamicstring ############################################################
//## create ##
constructor tdynamicstring.create;//01may2019
begin
satinc(satDynstr,1);
inherited create;
end;
//## destroy ##
destructor tdynamicstring.destroy;//01may2019
begin
inherited destroy;
satinc(satDynstr,-1);
end;
//## copyfrom ##
function tdynamicstring.copyfrom(s:tdynamicstring):boolean;
var
   p,xcount:longint;
begin
try
//defaults
result:=false;
//check
if (s=self) then
   begin
   result:=true;
   exit;
   end;
if (s=nil) then exit;
//get
freesorted:=s.freesorted;
utag:=s.utag;
xcount:=s.count;
size:=s.size;
count:=xcount;
for p:=(xcount-1) downto 0 do value[p]:=s.value[p];
if (s.sorted=nil) then
   begin
   if (sorted<>nil) then nosort;
   end
else
   begin
   nullsort;
   for p:=(s.sorted.count-1) downto 0 do sorted.value[p]:=s.sorted.value[p];
   end;
except;end;
end;
//## gettext ##
function tdynamicstring.gettext:string;
var
   a:tstr8;
   p,len:longint;
begin
try
//defaults
result:='';
a:=nil;
len:=0;
//get
a:=bnew;
for p:=0 to (count-1) do a.sadd(value[p]+rcode);
//set
result:=a.text;
except;end;
try;bfree(a);except;end;
end;
//## settext ##
procedure tdynamicstring.settext(x:string);
var
   xdata,xline:tstr8;
   p:longint;
begin
try
//defaults
xdata:=nil;
xline:=nil;
p:=0;
//clear
clear;
//init
xdata:=bnewstr(x);
xline:=bnew;
//get
while low__nextline0(xdata,xline,p) do value[count]:=xline.text;
except;end;
try
bfree(xdata);
bfree(xline);
except;end;
end;
//## getstext ##
function tdynamicstring.getstext:string;
var
   a:tstr8;
   p,len:longint;
begin
try
//defaults
result:='';
a:=nil;
len:=0;
//get
a:=bnew;
for p:=0 to (count-1) do a.sadd(svalue[p]+rcode);
//set
result:=a.text;
except;end;
try;bfree(a);except;end;
end;
//## _init ##
procedure tdynamicstring._init;
begin
try
_setparams(0,0,4,false);
ilockedBPI:=true;
except;end;
end;
//## _corehandle ##
procedure tdynamicstring._corehandle;
begin
iitems:=core;
end;
//## _oncreateitem ##
procedure tdynamicstring._oncreateitem(sender:tobject;index:longint);
begin
try
low__newpstring(iitems[index]);//29NOV2011
inherited;
except;end;
end;
//## _onfreeitem ##
procedure tdynamicstring._onfreeitem(sender:tobject;index:longint);
begin
try
inherited;
low__despstring(iitems[index]);//29NOV2011
except;end;
end;
//## getvalue ##
function tdynamicstring.getvalue(_index:longint):string;
begin
if (_index<0) or (_index>=count) then result:='' else result:=items[_index]^;
end;
//## setvalue ##
procedure tdynamicstring.setvalue(_index:longint;_value:string);
begin
//.check
if (_index<0) then exit
else if (_index>=isize) and (not atleast(_index)) then exit;
//.count
if (_index>=icount) then icount:=_index+1;
//.set
items[_index]^:=_value;
end;
//## getsvalue ##
function tdynamicstring.getsvalue(_index:longint):string;
begin
result:=value[sindex(_index)];
end;
//## setsvalue ##
procedure tdynamicstring.setsvalue(_index:longint;_value:string);
begin
value[sindex(_index)]:=_value;
end;
//## find ##
function tdynamicstring.find(_start:longint;_value:string;_casesensitive:boolean):longint;
var
   p:longint;
begin
try
//defaults
result:=-1;
//check
if (_start<0) or (_start>=count) then exit;
//process
if _casesensitive then
   begin
   for p:=_start to (icount-1) do if low__comparetextcase(iitems[p]^,_value) then//27apr2021
      begin
      result:=p;
      break;
      end;
   end
else
   begin
   for p:=_start to (icount-1) do if low__comparetext(iitems[p]^,_value) then
      begin
      result:=p;
      break;
      end;
   end;
except;end;
end;
//## _sort ##
procedure tdynamicstring._sort(_asc:boolean);
begin
try;__sort(items,sorted.items,0,count-1,_asc);except;end;
end;
//## __sort ##
procedure tdynamicstring.__sort(a:pdlstring;b:pdllongint;l,r:longint;_asc:boolean);
var
  p:pstring;
  tmp,i,j:longint;
begin
try
repeat
I := L;
J := R;
P := a^[b^[(L + R) shr 1]];
  repeat
  if _asc then
     begin
     while (low__comparetext2(a^[b^[I]]^,p^)<0) do inc(I);
     while (low__comparetext2(a^[b^[J]]^,p^)>0) do dec(J);
     end
  else
     begin
     while (low__comparetext2(a^[b^[I]]^,p^)>0) do inc(I);
     while (low__comparetext2(a^[b^[J]]^,p^)<0) do dec(J);
     end;//end of if
  if I <= J then
     begin
     tmp:=b^[i];
     b^[i]:=b^[j];
     b^[j]:=tmp;
     inc(I);
     dec(J);
     end;//end of if
  until I > J;
if L < J then __sort(a,b,L,J,_asc);
L := I;
until I >= R;
except;end;
end;

//## tframe ####################################################################
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//fffffffffffffffffffffffff
//## create ##
constructor tframe.create;
begin
satinc(satFrame,1);
zzadd(self);
inherited create;
//defaults
ifmax:=29;
ilastdataid:=0;
idataid:=0;
ildata:=nil;
il32:=nil;
clear;
end;
//## destroy ##
destructor tframe.destroy;
begin
try
//controls
bfree(ildata);
freeobj(@il32);
//set
inherited destroy;
satinc(satFrame,-1);
except;end;
end;
//-- framesets -----------------------------------------------------------------
//## setfmax ##
procedure tframe.setfmax(x:longint);
begin
try
//range
x:=frcrange(x,0,high(ifs));
//get
if low__setint(ifmax,x) then
   begin
   xsyncinfo;
   xincid;
   end;
except;end;
end;
//## fclear ##
procedure tframe.fclear;
var
   p:longint;
begin
try
for p:=0 to high(ifs) do
begin
ifs[p]         :=low__rgb(255,255,255);//white
ifd[p]         :=low__rgb(0,0,0);//black
ift[p]         :=0;
ifo[p]         :=255;
ifw[p]         :=0;//off
end;//p
xsyncinfo;
xincid;
except;end;
end;
//## fok ##
function tframe.fok(xindex:longint):boolean;
begin
try;result:=(xindex>=0) and (xindex<=high(ifs)) and (xindex<=ifmax);except;end;
end;
//## fdel ##
procedure tframe.fdel(xindex:longint);
begin
try
if not fok(xindex) then exit;
ifs[xindex]         :=low__rgb(255,255,255);//white
ifd[xindex]         :=low__rgb(0,0,0);//black
ift[xindex]         :=0;
ifo[xindex]         :=255;
ifw[xindex]         :=0;//off
xsyncinfo;
xincid;
except;end;
end;
//## fadd ##
function tframe.fadd(scol,dcol,xrich,xopacity,xsize:longint):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
//find last free item
for p:=0 to high(ifw) do if (ifw[p]<=0) then
   begin
   fset(p,scol,dcol,xrich,xopacity,xsize);
   result:=true;
   break;
   end;//p
except;end;
end;
//## fset ##
function tframe.fset(xindex,scol,dcol,xrich,xopacity,xsize:longint):boolean;
var
   xok:boolean;
begin
try
//defaults
result:=false;
xok:=false;
//check
if not fok(xindex) then exit;
//range
xrich:=frcrange(xrich,0,20);
xopacity:=frcrange(xopacity,0,255);
xsize:=frcrange(xsize,0,500);
//get
if low__setint(ifs[xindex],scol) then xok:=true;
if low__setint(ifd[xindex],dcol) then xok:=true;
if low__setint(ift[xindex],xrich) then xok:=true;
if low__setint(ifo[xindex],xopacity) then xok:=true;
if low__setint(ifw[xindex],xsize) then xok:=true;
//set
if xok then
   begin
   xsyncinfo;
   xincid;
   end;
//successful
result:=true;
except;end;
end;
//## fget ##
function tframe.fget(xindex:longint;var scol,dcol,xrich,xopacity,xsize:longint):boolean;
var
   xok:boolean;
begin
try
//defaults
result:=false;
scol:=low__rgb(255,255,255);
dcol:=low__rgb(0,0,0);
xrich:=0;
xopacity:=0;
xsize:=0;
//check
if not fok(xindex) then exit;
//get
scol:=ifs[xindex];
dcol:=ifd[xindex];
xrich:=frcrange(ift[xindex],0,20);
xopacity:=frcrange(ifo[xindex],0,255);
xsize:=frcrange(ifw[xindex],0,500);
//successful
result:=true;
except;end;
end;
//-- options -------------------------------------------------------------------
//## oset ##
procedure tframe.oset(xopacity,xshadepower,xshadeangle:longint;xsoftjoins:boolean);
var
   xok:boolean;
begin
try
//defaults
xok:=false;
//range
xopacity:=frcrange(xopacity,0,255);
xshadepower:=frcrange(xshadepower,0,255);
xshadeangle:=frcrange(xshadeangle,0,3);//0=45, 1=135, 2=225, 3=315
//get
if low__setint(iopacity,xopacity) then xok:=true;
if low__setint(ishadepower,xshadepower) then xok:=true;
if low__setint(ishadeangle,xshadeangle) then xok:=true;
if low__setbol(isoftjoins,xsoftjoins) then xok:=true;
//set
if xok then
   begin
   xsyncinfo;
   xincid;
   end;
except;end;
end;
//## oget ##
procedure tframe.oget(var xopacity,xshadepower,xshadeangle:longint;var xsoftjoins:boolean);
begin
try
xopacity:=frcrange(iopacity,0,255);
xshadepower:=frcrange(ishadepower,0,255);
xshadeangle:=frcrange(ishadeangle,0,3);//0=45, 1=135, 2=225, 3=315
xsoftjoins:=isoftjoins;
except;end;
end;
//-- logo ----------------------------------------------------------------------
//## lset ##
procedure tframe.lset(xusecolors:boolean;xscol,xdcol,xopacity,xrich,xrelx,xrely,xrelm:longint);
var
   xok:boolean;
begin
try
//defaults
xok:=false;
//range
xopacity:=frcrange(xopacity,0,255);
xrich:=frcrange(xrich,0,20);
xrelm:=frcrange(xrelm,0,1);//0=top-left, 1=bottom-left
//get
if low__setbol(ilusecolors,xusecolors) then xok:=true;
if low__setint(ils,xscol) then xok:=true;
if low__setint(ild,xdcol) then xok:=true;
if low__setint(ilo,xopacity) then xok:=true;
if low__setint(ilt,xrich) then xok:=true;
if low__setint(ilx,xrelx) then xok:=true;
if low__setint(ily,xrely) then xok:=true;
if low__setint(ilm,xrelm) then xok:=true;
//set
if xok then
   begin
   xsyncinfo;
   xincid;
   end;
except;end;
end;
//## lget ##
procedure tframe.lget(var xusecolors:boolean;var xscol,xdcol,xopacity,xrich,xrelx,xrely,xrelm:longint);
begin
try
xusecolors:=ilusecolors;
xscol:=ils;
xdcol:=ild;
xopacity:=frcrange(ilo,0,255);
xrich:=frcrange(ilt,0,20);
xrelx:=ilx;
xrely:=ily;
xrelm:=frcrange(ilm,0,1);
except;end;
end;
//## lsetdata ##
function tframe.lsetdata(xlogodata:tstr8;var e:string):boolean;
label
   skipend;
var
   xext:string;
   xok:boolean;
begin
try
//defaults
result:=false;
xok:=false;
//clear
if zznil(xlogodata,2281) or (xlogodata.len<=0) then
   begin
   if zzok(ildata,7079) then ildata.clear;//original datastream for il32
   if zzok(il32,7080) then
      begin
      xok:=true;
      il32.sizeto(1,1);
      end;
   result:=true;
   goto skipend;
   end;
//get
if block(xlogodata) then
   begin
   //init
   if zznil(ildata,2282) then ildata:=bnew;
   if zznil(il32,2283) then il32:=misimg32(1,1);
   xext:=anyformatb(xlogodata);
   xok:=true;
   //retain a copy of datastream
   ildata.clear;
   ildata.add(xlogodata);
   //get image
   if      (xext='BMP') then
      begin
      if not misfrombmp82432(il32,xlogodata,e) then goto skipend;
      end
   else if (xext='PNG') then
      begin
      if not misfromjpg82432(il32,clnone,xlogodata,e) then goto skipend;
      end
   else if (xext='JPG') then
      begin
      if not misfrompng82432(il32,clnone,xlogodata,e) then goto skipend;
      end
   else
      begin
      e:=gecUnknownformat;
      goto skipend;
      end;
   end;
//successful
result:=true;
skipend:
except;end;
try
if not result then
   begin
   if zzok(ildata,7081) then ildata.clear;
   if zzok(il32,7082)   then il32.sizeto(1,1);
   end;
if xok then
   begin
   xsyncinfo;
   xincid;
   end;
except;end;
try;bunlockautofree(xlogodata);except;end;
end;
//## lgetdata ##
function tframe.lgetdata(xlogodata:tstr8):boolean;
begin
try
//defaults
result:=false;
//get
if block(xlogodata) then
   begin
   xlogodata.clear;
   if zzok(ildata,7083) and (ildata.len>=1) then result:=xlogodata.add(ildata);
   end;
except;end;
try;bunlockautofree(xlogodata);except;end;
end;
//-- special -------------------------------------------------------------------
//## sset ##
procedure tframe.sset(xinstagram,xresample:longint);
var
   xok:boolean;
begin
try
//defaults
xok:=false;
//range
xinstagram:=frcrange(xinstagram,0,4);//0=off, 1=588, 2=600, 3=108, 4=1920
xresample:=frcrange(xresample,0,7);//0=off, 1=1x, 2=2x, 3=2X ... 6=4x, 7=4X
//get
if low__setint(isinstagram,xinstagram) then xok:=true;
if low__setint(isresample,xresample) then xok:=true;
//set
if xok then
   begin
   xsyncinfo;
   xincid;
   end;
except;end;
end;
//## sget ##
procedure tframe.sget(var xinstagram,xresample:longint);
begin
try
xinstagram:=frcrange(isinstagram,0,4);//0=off, 1=588, 2=600, 3=108, 4=1920
xresample:=frcrange(isresample,0,7);//0=off, 1=1x, 2=2x, 3=2X ... 6=4x, 7=4X
except;end;
end;
//-- io ------------------------------------------------------------------------
//## ioget ##
function tframe.ioget(xdata:tstr8;xformat:string;var e:string):boolean;
label
   skipend;
var
   a:tvars8;
   b:tstr8;
   p,xopacity,xshadepower,xshadeangle:longint;
   xusecolors,xsoftjoins:boolean;
   xscol,xdcol,xrich,xrelx,xrely,xrelm:longint;
   xinstagram,xresample:longint;
   xsize:longint;
   str1:string;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
a:=nil;
b:=nil;
//check
if not block(xdata) then goto skipend;
xdata.clear;

//init
a:=vnew2(959);

//get
//.simple frame "SFM"
if low__comparetext(xformat,'SFM') then
   begin
   //header
   a.s['fps_ver']:='v0';
   //framesets
   for p:=0 to ifmax do
   begin
   str1:='.'+inttostr(p);
   fget(p,xscol,xdcol,xrich,xopacity,xsize);
   a.i['color'+str1]:=xscol;
   a.i['color2'+str1]:=xdcol;
   a.i['size'+str1]:=xsize;
   a.i['opacity'+str1]:=xopacity;
   a.i['richness'+str1]:=xrich;
   end;//p
   end
//.enhanced frame "FPS" - default format
else
   begin
   //header
   a.s['fps_ver']:='v1';
   //options
   oget(xopacity,xshadepower,xshadeangle,xsoftjoins);
   a.i['opacity']:=xopacity;
   a.i['shade']:=xshadepower;
   a.i['shadeangle']:=xshadeangle;
   a.b['softenjoins']:=xsoftjoins;
   //logo options
   lget(xusecolors,xscol,xdcol,xopacity,xrich,xrelx,xrely,xrelm);
   a.i['logoopacity']:=xopacity;
   a.i['logocol1']:=xscol;
   a.i['logocol2']:=xdcol;
   a.i['richness']:=xrich;
   a.b['logocolors']:=xusecolors;
   a.i['logorelx']:=xrelx;
   a.i['logorely']:=xrely;
   a.i['logorelm']:=xrelm;
   //logo data
   if (b=nil) then b:=bnew;
   if lgetdata(b) and (b.len>=1) and low__tob64(b,b,0,e) then a.d['logodata']:=b else a.s['logodata']:='';
   //special options
   sget(xinstagram,xresample);
   a.i['instagram']:=xinstagram;
   a.i['resample']:=xresample;
   //framesets
   for p:=0 to ifmax do
   begin
   str1:='.'+inttostr(p);
   fget(p,xscol,xdcol,xrich,xopacity,xsize);
   a.i['color'+str1]:=xscol;
   a.i['color2'+str1]:=xdcol;
   a.i['size'+str1]:=xsize;
   a.i['opacity'+str1]:=xopacity;
   a.i['richness'+str1]:=xrich;
   end;//p
   end;

//set
xdata.addb(a.data);

//successful
result:=true;
skipend:
except;end;
try
if (not result) and zzok(xdata,7084) then xdata.clear;
freeobj(@a);
bfree(b);
bunlockautofree(xdata);
except;end;
end;
//## ioset ##
function tframe.ioset(xdata:tstr8;var e:string):boolean;
label
   skipend;
var
   a:tvars8;
   xlogdata:tstr8;
   p,xopacity,xshadepower,xshadeangle:longint;
   xusecolors,xsoftjoins:boolean;
   xscol,xdcol,xrich,xrelx,xrely,xrelm:longint;
   xinstagram,xresample:longint;
   xsize:longint;
   xformat,str1:string;
   //## xinit ##
   procedure xinit;
   begin
   clear;
   if (a=nil) then a:=vnew2(960);
   a.data:=xdata;
   end;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
a:=nil;
xlogdata:=nil;
//check
if not block(xdata) then goto skipend;

//init
xformat:=anyformatb(xdata);

//get
if low__comparetext(xformat,'SFM') then
   begin
   //init
   xinit;
   //framesets
   for p:=0 to ifmax do
   begin
   str1:='.'+inttostr(p);
   fget(p,xscol,xdcol,xrich,xopacity,xsize);//defaults
   if a.found('color'+str1)     then xscol:=a.i['color'+str1];
   if a.found('color2'+str1)    then xdcol:=a.i['color2'+str1];
   if a.found('size'+str1)      then xsize:=a.i['size'+str1];
   if a.found('opacity'+str1)   then xopacity:=a.i['opacity'+str1];
   if a.found('richness'+str1)  then xrich:=a.i['richness'+str1];
   fget(p,xscol,xdcol,xrich,xopacity,xsize);//set new values
   end;//p
   end
else if low__comparetext(xformat,'FPS') then
   begin
   //init
   xinit;
   //options
   oget(xopacity,xshadepower,xshadeangle,xsoftjoins);//get defaults
   if a.found('opacity')        then xopacity:=a.i['opacity'];
   if a.found('shade')          then xshadepower:=a.i['shade'];
   if a.found('shadeangle')     then xshadeangle:=a.i['shadeangle'];
   if a.found('softenjoins')    then xsoftjoins:=a.b['softenjoins'];
   oset(xopacity,xshadepower,xshadeangle,xsoftjoins);//set new values
   //logo options
   lget(xusecolors,xscol,xdcol,xopacity,xrich,xrelx,xrely,xrelm);//get defaults
   if a.found('logoopacity')    then xopacity:=a.i['logoopacity'];
   if a.found('logocol1')       then xscol:=a.i['logocol1'];
   if a.found('logocol2')       then xdcol:=a.i['logocol2'];
   if a.found('richness')       then xrich:=a.i['richness'];
   if a.found('logocolors')     then xusecolors:=a.b['logocolors'];
   if a.found('logorelx')       then xrelx:=a.i['logorelx'];
   if a.found('logorely')       then xrely:=a.i['logorely'];
   if a.found('logorelm')       then xrelm:=a.i['logorelm'];
   lset(xusecolors,xscol,xdcol,xopacity,xrich,xrelx,xrely,xrelm);//set new values
   //logo data
   xlogdata:=a.d['logodata'];//returns a new instance of "b"
   if zzok(xlogdata,7085) and low__fromb64(xlogdata,xlogdata,e) then
      begin
      block(xlogdata);
      try;lsetdata(xlogdata,str1);except;end;//set new values
      bunlock(xlogdata);
      end;
   //special options
   sget(xinstagram,xresample);//get defaults
   if a.found('instagram')      then xinstagram:=a.i['instagram'];
   if a.found('resample')       then xresample:=a.i['resample'];
   sset(xinstagram,xresample);//set new values
   //framesets
   for p:=0 to ifmax do
   begin
   str1:='.'+inttostr(p);
   fget(p,xscol,xdcol,xrich,xopacity,xsize);//defaults
   if a.found('color'+str1)     then xscol:=a.i['color'+str1];
   if a.found('color2'+str1)    then xdcol:=a.i['color2'+str1];
   if a.found('size'+str1)      then xsize:=a.i['size'+str1];
   if a.found('opacity'+str1)   then xopacity:=a.i['opacity'+str1];
   if a.found('richness'+str1)  then xrich:=a.i['richness'+str1];
   fset(p,xscol,xdcol,xrich,xopacity,xsize);//new values
   end;//p
   end
else
   begin
   e:=gecUnknownformat;
   goto skipend;
   end;

//successful
result:=true;
skipend:
except;end;
try
if not result then clear;
freeobj(@a);
bfree(xlogdata);
bunlockautofree(xdata);
except;end;
end;
//-- workers -------------------------------------------------------------------
//## clear ##
procedure tframe.clear;
var
   p:longint;
begin
try
//frame
iopacity       :=255;
ishadeangle    :=0;
ishadepower    :=0;
isoftjoins     :=false;
//framesets
for p:=0 to high(ifs) do
begin
ifs[p]         :=low__rgb(255,255,255);//white
ifd[p]         :=low__rgb(0,0,0);//black
ift[p]         :=0;
ifo[p]         :=255;
ifw[p]         :=0;//off
end;//p
//logo
ilo            :=0;//off
ilusecolors    :=false;
ils            :=low__rgb(255,255,255);//white
ild            :=low__rgb(0,0,0);//black
ilt            :=0;
ilx            :=0;
ily            :=0;
ilm            :=0;//top-left
if zzok(ildata,7086) then ildata.clear;
if zzok(il32,7087)   then il32.sizeto(1,1);
//special
isInstagram    :=0;
isResample     :=0;
//inc
low__iroll(idataid,1);
//sync
xsyncinfo;
except;end;
end;
//## xsyncinfo ##
procedure tframe.xsyncinfo;
var
   v,p:longint;
begin
try
v:=0;
for p:=0 to high(ifs) do if (ifs[p]>=1) then inc(v,ifw[p]);
isize:=v;
except;end;
end;
//## changed ##
function tframe.changed(xreset:boolean):boolean;
begin
try
result:=(idataid<>ilastdataid);
if result and xreset then ilastdataid:=idataid;
except;end;
end;
//## xincid ##
procedure tframe.xincid;
begin
try;low__iroll(idataid,1);except;end;
end;
//-- workers -------------------------------------------------------------------
//## xmakesimple ##
procedure tframe.xmakesimple(scol,dcol,xsize:longint);
begin
try
clear;
fadd(scol,dcol,0,255,xsize);
except;end;
end;
//## xmakesimple2 ##
procedure tframe.xmakesimple2(scol,dcol,xsize,scol2,dcol2,xsize2:longint);
begin
try
clear;
fadd(scol,dcol,0,255,xsize);
fadd(scol2,dcol2,0,255,xsize2);
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//ffffffffffffffffffffffffffffffffffff
//## draw82432 ##
function tframe.draw82432(da_cliparea:trect;senlarge,sfullsoften:boolean;s,b:tobject;var e:string):boolean;
label//Note: s=image to draw frame on, b=optional background image (does not size the frame)
   skipdone,skipend;
const
   xpad=10;
var
   srs8 :pcolorrows8;
   srs24:pcolorrows24;
   srs32:pcolorrows32;
   sp,p2,p,dx,dy:longint;
   dc8, sc8 :tcolor8;
   dc24,sc24:tcolor24;
   dc32,sc32:tcolor32;
   xcollist24:array[0..32000] of tcolor24;
   xcolrich:array[0..32000] of byte;
   xindexlist:array[0..32000] of longint;
   xdrawnstrongly:array[0..32000] of boolean;
   xdrawnopacity:array[0..32000] of longint;
   xopacitylist:array[0..high(ifw)] of longint;
   xlogoopacity,int1,int2,int3,xglobalshadeangle,xglobalopacity,xglobalshade,xrich,xrich2,xcol,xcol2,xsize,xopacity,xsideval,xshade,i,xcount:longint;
   xsiderich,bok,xsoftenjoins,xreverse:boolean;
   xmem:string;
   xlastinner,xinner:trect;
   bbits,bw,bh,sbits,sw,sh:longint;
   //## srich8 ##
   procedure srich8;
   var
      v,b1:longint;
   begin
   b1:=random(xrich);
   v:=sc8+b1-xrich2;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   sc8:=byte(v);
   end;
   //## srich24 ##
   procedure srich24;
   var
      v,b1:longint;
   begin
   b1:=random(xrich);
   //.r
   v:=sc24.r+b1-xrich2;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   sc24.r:=byte(v);
   //.g
   v:=sc24.g+b1-xrich2;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   sc24.g:=byte(v);
   //.b
   v:=sc24.b+b1-xrich2;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   sc24.b:=byte(v);
   end;
   //## srich32 ##
   procedure srich32;
   var
      v,b1:longint;
   begin
   b1:=random(xrich);
   //.r
   v:=sc32.r+b1-xrich2;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   sc32.r:=byte(v);
   //.g
   v:=sc32.g+b1-xrich2;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   sc32.g:=byte(v);
   //.b
   v:=sc32.b+b1-xrich2;
   if (v<0) then v:=0 else if (v>255) then v:=255;
   sc32.b:=byte(v);
   end;
   //## aopc8 ##
   procedure aopc8(p,dy,dx:longint);//set pixel via opacity
   var
      v:longint;
   begin
   //opacity
   if (xopacity>=1) then
      begin
      //get
      dc8:=srs8[dy][dx];
      sc24:=xcollist24[p];
      if xsiderich then srich24;
      //.r
      v:=((dc8*(255-xopacity)) + ((sc24.r+xsideval)*xopacity)) div 255;
      if (v<0) then v:=0 else if (v>255) then v:=255;
      sc8:=byte(v);
      //set
      srs8[dy][dx]:=sc8;
      end;
   //.xdrawnstrongly
   xdrawnstrongly[p]:=(xopacity>=30);
   xdrawnopacity[p]:=xopacity;
   end;
   //## aopc24 ##
   procedure aopc24(p,dy,dx:longint);//set pixel via opacity
   var
      v:longint;
   begin
   //opacity
   if (xopacity>=1) then
      begin
      //get
      dc24:=srs24[dy][dx];
      sc24:=xcollist24[p];
      if xsiderich then srich24;
      //.r
      v:=((dc24.r*(255-xopacity)) + ((sc24.r+xsideval)*xopacity)) div 255;
      if (v<0) then v:=0 else if (v>255) then v:=255;
      sc24.r:=byte(v);
      //.g
      v:=((dc24.g*(255-xopacity)) + ((sc24.g+xsideval)*xopacity)) div 255;
      if (v<0) then v:=0 else if (v>255) then v:=255;
      sc24.g:=byte(v);
      //.b
      v:=((dc24.b*(255-xopacity)) + ((sc24.b+xsideval)*xopacity)) div 255;
      if (v<0) then v:=0 else if (v>255) then v:=255;
      sc24.b:=byte(v);
      //set
      srs24[dy][dx]:=sc24;
      end;
   //.xdrawnstrongly
   xdrawnstrongly[p]:=(xopacity>=30);
   xdrawnopacity[p]:=xopacity;
   end;
   //## aopc32 ##
   procedure aopc32(p,dy,dx:longint);//set pixel via opacity
   var
      v:longint;
   begin
   //opacity
   if (xopacity>=1) then
      begin
      //get
      dc32:=srs32[dy][dx];
      sc24:=xcollist24[p];
      if xsiderich then srich24;
      //.r
      v:=((dc32.r*(255-xopacity)) + ((sc24.r+xsideval)*xopacity)) div 255;
      if (v<0) then v:=0 else if (v>255) then v:=255;
      sc32.r:=byte(v);
      //.g
      v:=((dc32.g*(255-xopacity)) + ((sc24.g+xsideval)*xopacity)) div 255;
      if (v<0) then v:=0 else if (v>255) then v:=255;
      sc32.g:=byte(v);
      //.b
      v:=((dc32.b*(255-xopacity)) + ((sc24.b+xsideval)*xopacity)) div 255;
      if (v<0) then v:=0 else if (v>255) then v:=255;
      sc32.b:=byte(v);
      //.a
      sc32.a:=dc32.a;
      //set
      srs32[dy][dx]:=sc32;
      end;
   //.xdrawnstrongly
   xdrawnstrongly[p]:=(xopacity>=30);
   xdrawnopacity[p]:=xopacity;
   end;
   //## pblur8 ##
   procedure pblur8(dy,dx,dopacity:longint);
   var
      ac,sc:tcolor8;
      v,dr,dc:longint;
      //## padd ##
      procedure padd(ddy,ddx:longint);
      var
         sc:tcolor8;
      begin
      if (ddx>=0) and (ddx<sw) and (ddy>=0) and (ddy<sh) and (sfullsoften or ( (ddx<xlastinner.left) or (ddy<xlastinner.top) or (ddx>xlastinner.right) or (ddy>xlastinner.bottom))) then
         begin
         sc:=srs8[ddy][ddx];
         inc(dc);
         inc(dr,sc);
         end;
      end;
   begin
   //check
   if (dx<0) or (dx>=sw) or (dy<0) or (dy>=sh) then exit;
   //init
   dc:=0;
   dr:=0;
   //get
   padd(dy-1,dx-2); padd(dy-1,dx-1); padd(dy-1,dx); padd(dy-1,dx+1); padd(dy-1,dx+2);
   padd(dy  ,dx-2); padd(dy  ,dx-1); padd(dy  ,dx); padd(dy  ,dx+1); padd(dy  ,dx+2);
   padd(dy+1,dx-2); padd(dy+1,dx-1); padd(dy+1,dx); padd(dy+1,dx+1); padd(dy+1,dx+2);
   //set
   if (dc>=2) then
      begin
      //.r
      dr:=dr div dc;
      if (dr>255) then dr:=255;
      sc:=byte(dr);
      //set
      if (dx>=0) and (dx<sw) and (dy>=0) and (dy<sh) then
         begin
         //.dopacity
         if (dopacity<255) then
            begin
            ac:=srs8[dy][dx];
            //.r
            v:=( (ac*(255-dopacity))+(sc*dopacity) ) div 255;
            if (v>255) then v:=255;
            sc:=byte(v);
            end;
         //set
         srs8[dy][dx]:=sc;
         end;
      end;
   end;
   //## pblur24 ##
   procedure pblur24(dy,dx,dopacity:longint);
   var
      ac,sc:tcolor24;
      v,dr,dg,db,dc:longint;
      //## padd ##
      procedure padd(ddy,ddx:longint);
      var
         sc:tcolor24;
      begin
      if (ddx>=0) and (ddx<sw) and (ddy>=0) and (ddy<sh) and (sfullsoften or ( (ddx<xlastinner.left) or (ddy<xlastinner.top) or (ddx>xlastinner.right) or (ddy>xlastinner.bottom))) then
         begin
         sc:=srs24[ddy][ddx];
         inc(dc);
         inc(dr,sc.r);
         inc(dg,sc.g);
         inc(db,sc.b);
         end;
      end;
   begin
   //check
   if (dx<0) or (dx>=sw) or (dy<0) or (dy>=sh) then exit;
   //init
   dc:=0;
   dr:=0;
   dg:=0;
   db:=0;
   //get
   padd(dy-1,dx-2); padd(dy-1,dx-1); padd(dy-1,dx); padd(dy-1,dx+1); padd(dy-1,dx+2);
   padd(dy  ,dx-2); padd(dy  ,dx-1); padd(dy  ,dx); padd(dy  ,dx+1); padd(dy  ,dx+2);
   padd(dy+1,dx-2); padd(dy+1,dx-1); padd(dy+1,dx); padd(dy+1,dx+1); padd(dy+1,dx+2);
   //set
   if (dc>=2) then
      begin
      //.r
      dr:=dr div dc;
      if (dr>255) then dr:=255;
      sc.r:=byte(dr);
      //.g
      dg:=dg div dc;
      if (dg>255) then dg:=255;
      sc.g:=byte(dg);
      //.b
      db:=db div dc;
      if (db>255) then db:=255;
      sc.b:=byte(db);
      //set
      if (dx>=0) and (dx<sw) and (dy>=0) and (dy<sh) then
         begin
         //.dopacity
         if (dopacity<255) then
            begin
            ac:=srs24[dy][dx];
            //.r
            v:=( (ac.r*(255-dopacity))+(sc.r*dopacity) ) div 255;
            if (v>255) then v:=255;
            sc.r:=byte(v);
            //.g
            v:=( (ac.g*(255-dopacity))+(sc.g*dopacity) ) div 255;
            if (v>255) then v:=255;
            sc.g:=byte(v);
            //.b
            v:=( (ac.b*(255-dopacity))+(sc.b*dopacity) ) div 255;
            if (v>255) then v:=255;
            sc.b:=byte(v);
            end;
         //set
         srs24[dy][dx]:=sc;
         end;
      end;
   end;
   //## pblur32 ##
   procedure pblur32(dy,dx,dopacity:longint);
   var
      ac,sc:tcolor32;
      v,dr,dg,db,dc,da:longint;
      //## padd ##
      procedure padd(ddy,ddx:longint);
      var
         sc:tcolor32;
      begin
      if (ddx>=0) and (ddx<sw) and (ddy>=0) and (ddy<sh) and (sfullsoften or ( (ddx<xlastinner.left) or (ddy<xlastinner.top) or (ddx>xlastinner.right) or (ddy>xlastinner.bottom))) then
         begin
         sc:=srs32[ddy][ddx];
         inc(dc);
         inc(dr,sc.r);
         inc(dg,sc.g);
         inc(db,sc.b);
         inc(da,sc.a);
         end;
      end;
   begin
   //check
   if (dx<0) or (dx>=sw) or (dy<0) or (dy>=sh) then exit;
   //init
   dc:=0;
   dr:=0;
   dg:=0;
   db:=0;
   da:=0;
   //get
   padd(dy-1,dx-2); padd(dy-1,dx-1); padd(dy-1,dx); padd(dy-1,dx+1); padd(dy-1,dx+2);
   padd(dy  ,dx-2); padd(dy  ,dx-1); padd(dy  ,dx); padd(dy  ,dx+1); padd(dy  ,dx+2);
   padd(dy+1,dx-2); padd(dy+1,dx-1); padd(dy+1,dx); padd(dy+1,dx+1); padd(dy+1,dx+2);
   //set
   if (dc>=2) then
      begin
      //.r
      dr:=dr div dc;
      if (dr>255) then dr:=255;
      sc.r:=byte(dr);
      //.g
      dg:=dg div dc;
      if (dg>255) then dg:=255;
      sc.g:=byte(dg);
      //.b
      db:=db div dc;
      if (db>255) then db:=255;
      sc.b:=byte(db);
      //.a
      da:=da div dc;
      if (da>255) then da:=255;
      sc.a:=byte(da);
      //set
      if (dx>=0) and (dx<sw) and (dy>=0) and (dy<sh) then
         begin
         //.dopacity
         if (dopacity<255) then
            begin
            ac:=srs32[dy][dx];
            //.r
            v:=( (ac.r*(255-dopacity))+(sc.r*dopacity) ) div 255;
            if (v>255) then v:=255;
            sc.r:=byte(v);
            //.g
            v:=( (ac.g*(255-dopacity))+(sc.g*dopacity) ) div 255;
            if (v>255) then v:=255;
            sc.g:=byte(v);
            //.b
            v:=( (ac.b*(255-dopacity))+(sc.b*dopacity) ) div 255;
            if (v>255) then v:=255;
            sc.b:=byte(v);
            //.a
            v:=( (ac.a*(255-dopacity))+(sc.a*dopacity) ) div 255;
            if (v>255) then v:=255;
            sc.a:=byte(v);
            end;
         //set
         srs32[dy][dx]:=sc;
         end;
      end;
   end;
   //## pblurframe8 ##
   procedure pblurframe8(da:trect;xfrom,xto,dopacity:longint);
   var
      p2,p:longint;
   begin
   for p2:=xfrom to xto do
   begin
   //.top
   for p:=(da.left+1+p2) to (da.right-1-p2) do pblur8(da.top+p2,p,dopacity);
   //.bottom
   for p:=(da.left+1+p2) to (da.right-1-p2) do pblur8(da.bottom-p2,p,dopacity);
   //.left
   for p:=(da.top+p2) to (da.bottom-p2) do pblur8(p,da.left+p2,dopacity);
   //.right
   for p:=(da.top+p2) to (da.bottom-p2) do pblur8(p,da.right-p2,dopacity);
   end;//p2
   end;
   //## pblurframe24 ##
   procedure pblurframe24(da:trect;xfrom,xto,dopacity:longint);
   var
      p2,p:longint;
   begin
   for p2:=xfrom to xto do
   begin
   //.top
   for p:=(da.left+1+p2) to (da.right-1-p2) do pblur24(da.top+p2,p,dopacity);
   //.bottom
   for p:=(da.left+1+p2) to (da.right-1-p2) do pblur24(da.bottom-p2,p,dopacity);
   //.left
   for p:=(da.top+p2) to (da.bottom-p2) do pblur24(p,da.left+p2,dopacity);
   //.right
   for p:=(da.top+p2) to (da.bottom-p2) do pblur24(p,da.right-p2,dopacity);
   end;//p2
   end;
   //## pblurframe32 ##
   procedure pblurframe32(da:trect;xfrom,xto,dopacity:longint);
   var
      p2,p:longint;
   begin
   for p2:=xfrom to xto do
   begin
   //.top
   for p:=(da.left+1+p2) to (da.right-1-p2) do pblur32(da.top+p2,p,dopacity);
   //.bottom
   for p:=(da.left+1+p2) to (da.right-1-p2) do pblur32(da.bottom-p2,p,dopacity);
   //.left
   for p:=(da.top+p2) to (da.bottom-p2) do pblur32(p,da.left+p2,dopacity);
   //.right
   for p:=(da.top+p2) to (da.bottom-p2) do pblur32(p,da.right-p2,dopacity);
   end;//p2
   end;
   //## pgapblur ##
   function pgapblur(xindex,xrange:longint):boolean;
   var
      p:longint;
   begin
   result:=false;
   for p:=(xindex-xrange) to (xindex+xrange) do if (p>=0) and ((p+1)<xcount) and (xdrawnstrongly[p]<>xdrawnstrongly[p+1]) then
      begin
      result:=true;
      break;
      end;//p
   end;
   //## popacityrich ##
   function popacityrich(xval:longint):longint;
   begin//allow some Richness to seep into pBlur's via varying the opacity rate - 06aug2020
   if (xrich>=1) then result:=xval+round((xrich/40)*xval*((50-random(100))/100)) else result:=xval;
   if (result<0) then result:=0 else if (result>255) then result:=255;
   end;
   //## adrawlogo32 ##
   procedure adrawlogo32;
   var
      lx,ly:longint;
   begin
   try
   //check
   if (xlogoopacity<=0) then exit;
   //init
   case ilm of
   1:begin//relative to bottom-left inner frame corner
      lx:=xcount+xinner.left  -ilx-(misw(il32) div 2);
      ly:=-xcount+xinner.bottom-ily-(mish(il32) div 2);
      end;
   else
      begin//relative to top-left inner frame corner
      lx:=xcount+xinner.left-ilx-(misw(il32) div 2);
      ly:=xcount+xinner.top -ily-(mish(il32) div 2);
      end;
   end;//case
   //get
   miscopyareaxx8(rect(0,0,maxint,maxint),lx,ly,misw(il32),mish(il32),misarea(il32),s,il32,nil,nil,nil,nil,nil,nil,0,0,false,xlogoopacity,1,mispixel24VAL(il32,0,0),0,0,0,nil,nil,nil,nil,nil,nil,nil,false);
   except;end;
   end;
   //## xsetside ##
   procedure xsetside(xside:longint;xrich:boolean);
   begin
   xsideval:=0;
   xsiderich:=xrich;
   case xglobalshadeangle of
   0:begin//top right = 45
      case xside of
      1,2:xsideval:=xshade;
      0,3:xsideval:=-xshade;
      end;
      end;
   1:begin//top left = 135
      case xside of
      0,1:xsideval:=xshade;
      2,3:xsideval:=-xshade;
      end;
      end;
   2:begin//bottom left = 225
      case xside of
      0,3:xsideval:=xshade;
      1,2:xsideval:=-xshade;
      end;
      end;
   3:begin//bottom right = 315
      case xside of
      2,3:xsideval:=xshade;
      0,1:xsideval:=-xshade;
      end;
      end;
   end;//case
   end;
begin
try
//defaults
result:=false;
xcount:=0;
xreverse:=true;//false;//xxxxxxxxxxxxxxxx

//check
if not misok82432(s,sbits,sw,sh) then goto skipend;
bok:=misok82432(b,bbits,bw,bh);

//init
xsoftenjoins:=isoftjoins;
xlogoopacity:=frcrange(ilo,0,255);
xglobalopacity:=frcrange(iopacity,0,255);
xglobalshade:=frcrange(ishadepower,0,255);
xglobalshadeangle:=frcrange(ishadeangle,0,3);
xsideval:=0;
xsiderich:=false;

//calculate framesets
for p:=0 to high(ifw) do if (ifw[p]>=1) then
   begin
   xsize:=frcmin(ifw[p],1);
   xopacitylist[p]:=frcrange(ifo[p],0,255);
   xrich:=frcrange(ift[p],0,20);
   xcol:=ifs[p];
   xcol2:=ifd[p];
   if xreverse then low__swapint(xcol,xcol2);
   for i:=0 to (xsize-1) do
   begin
   if (xcount<=high(xcollist24)) then
      begin
      xcollist24[xcount]:=low__intrgb(low__colsplice((i*100) div frcmin(xsize-1,1),xcol,xcol2));
      xcolrich[xcount]:=xrich;
      xindexlist[xcount]:=p;//track which index is what line
      inc(xcount);
      end
   else break;
   end;//i
   end;//p

//size
sw:=sw+low__insint(2*xcount,senlarge);
sh:=sh+low__insint(2*xcount,senlarge);
if (not missize(s,sw,sh)) or (sw<>misw(s)) or (sh<>mish(s)) then goto skipend;

//cls - render image over entire output image incase of ANY opacity<255 - 05aug2020
case zzok(b,7090) of
true:miscopyareaxx1(0,0,sw,sh,rect(0,0,bw-1,bh-1),s,b);
false:miscls(s,low__rgb(255,255,255));
end;

//b - background image - optional
xinner.left:=low__insint(xcount,senlarge);
xinner.right:=sw-1-xinner.left;
xinner.top:=low__insint(xcount,senlarge);
xinner.bottom:=sh-1-xinner.top;
xlastinner:=rect(xcount,xcount,sw-1-xcount,sh-1-xcount);
if zzok(b,7091) and (not miscopyareaxx1(xinner.left,xinner.top,xinner.right-xinner.left+1,xinner.bottom-xinner.top+1,rect(0,0,bw-1,bh-1),s,b)) then goto skipend;
if (xcount<=0) then goto skipdone;
if not misrows82432(s,srs8,srs24,srs32) then goto skipend;

//frame
for p:=0 to frcmax(xcount-1,smallest(sw,sh) div 2) do
begin
xdrawnstrongly[p]:=false;
xdrawnopacity[p]:=0;
sp:=xindexlist[p];
xopacity:=frcrange((xopacitylist[sp]*xglobalopacity) div 255,0,255);
xshade:=frcrange(xglobalshade,0,255);

if (xcolrich[p]>=1) then
   begin
   //.init
   xrich:=2*xcolrich[p];
   xrich2:=frcmin(xrich div 2,1);
   //.8
   if (sbits=8) then
      begin
      //.top
      xsetside(1,true);
      for dx:=(p+1) to (sw-2-p) do aopc8(p,p,dx);
      //.bottom
      xsetside(3,true);
      for dx:=(p+1) to (sw-2-p) do aopc8(p,sh-1-p,dx);
      //.left
      xsetside(0,true);
      for dy:=p to (sh-1-p) do aopc8(p,dy,p);
      //.right
      xsetside(2,true);
      for dy:=p to (sh-1-p) do aopc8(p,dy,sw-1-p);
      end
   //.24
   else if (sbits=24) then
      begin
      //.top
      xsetside(1,true);
      for dx:=(p+1) to (sw-2-p) do aopc24(p,p,dx);
      //.bottom
      xsetside(3,true);
      for dx:=(p+1) to (sw-2-p) do aopc24(p,sh-1-p,dx);
      //.left
      xsetside(0,true);
      for dy:=p to (sh-1-p) do aopc24(p,dy,p);
      //.right
      xsetside(2,true);
      for dy:=p to (sh-1-p) do aopc24(p,dy,sw-1-p);
      end
   //.32
   else if (sbits=32) then
      begin
      //.top
      xsetside(1,true);
      for dx:=(p+1) to (sw-2-p) do aopc32(p,p,dx);
      //.bottom
      xsetside(3,true);
      for dx:=(p+1) to (sw-2-p) do aopc32(p,sh-1-p,dx);
      //.left
      xsetside(0,true);
      for dy:=p to (sh-1-p) do aopc32(p,dy,p);
      //.right
      xsetside(2,true);
      for dy:=p to (sh-1-p) do aopc32(p,dy,sw-1-p);
      end;
   end
else
   begin
   //.8
   if (sbits=8) then
      begin
      //.top
      xsetside(1,false);
      for dx:=(p+1) to (sw-2-p) do aopc8(p,p,dx);
      //.bottom
      xsetside(3,false);
      for dx:=(p+1) to (sw-2-p) do aopc8(p,sh-1-p,dx);
      //.left
      xsetside(0,false);
      for dy:=p to (sh-1-p) do aopc8(p,dy,p);
      //.right
      xsetside(2,false);
      for dy:=p to (sh-1-p) do aopc8(p,dy,sw-1-p);
      end
   //.24
   else if (sbits=24) then
      begin
      //.top
      xsetside(1,false);
      for dx:=(p+1) to (sw-2-p) do aopc24(p,p,dx);
      //.bottom
      xsetside(3,false);
      for dx:=(p+1) to (sw-2-p) do aopc24(p,sh-1-p,dx);
      //.left
      xsetside(0,false);
      for dy:=p to (sh-1-p) do aopc24(p,dy,p);
      //.right
      xsetside(2,false);
      for dy:=p to (sh-1-p) do aopc24(p,dy,sw-1-p);
      end
   //.32
   else if (sbits=32) then
      begin
      //.top
      xsetside(1,false);
      for dx:=(p+1) to (sw-2-p) do aopc32(p,p,dx);
      //.bottom
      xsetside(3,false);
      for dx:=(p+1) to (sw-2-p) do aopc32(p,sh-1-p,dx);
      //.left
      xsetside(0,false);
      for dy:=p to (sh-1-p) do aopc32(p,dy,p);
      //.right
      xsetside(2,false);
      for dy:=p to (sh-1-p) do aopc32(p,dy,sw-1-p);
      end;
   end;
end;//p

//.blur the "gaps" between any frames (a gap is defined at opacity <=30) - 06aug2020
if xsoftenjoins then
   begin
   case sbits of
   8 :for p:=0 to frcmax(xcount-1,smallest(sw,sh) div 2) do if pgapblur(p,2) then pblurframe8(rect(p,p,sw-1-p,sh-1-p),0,0,255);
   24:for p:=0 to frcmax(xcount-1,smallest(sw,sh) div 2) do if pgapblur(p,2) then pblurframe24(rect(p,p,sw-1-p,sh-1-p),0,0,255);
   32:for p:=0 to frcmax(xcount-1,smallest(sw,sh) div 2) do if pgapblur(p,2) then pblurframe32(rect(p,p,sw-1-p,sh-1-p),0,0,255);
   end;
   end;

//.blur frame corner "joins"
if (xglobalshade>=1) and xsoftenjoins then
   begin
   for i:=0 to 1 do
   begin
   for p:=0 to frcmax(xcount-1,smallest(sw,sh) div 2) do if xdrawnstrongly[p] then
      begin
      xrich:=2*xcolrich[p];
      xrich2:=frcmin(xrich div 2,1);
      int1:=frcmax(xdrawnopacity[p]*2,255);
      int2:=frcmax(xdrawnopacity[p] div 5,35);
      //.8
      if (sbits=8) then
         begin
         case xglobalshadeangle of
         0,2:begin
            //top-left corner join
            pblur8(p,p,popacityrich(int1));
            for p2:=1 to int2 do
            begin
            int3:=round(int1*(int2-p2)/int2);
            pblur8(p,p+p2,popacityrich(int3));
            pblur8(p+p2,p,popacityrich(int3));
            end;
            //bottom-right corner join
            pblur8(sh-1-p,sw-1-p,popacityrich(int1));
            for p2:=1 to int2 do
            begin
            int3:=round(int1*(int2-p2)/int2);
            pblur8(sh-1-p,sw-1-p2-p,popacityrich(int3));
            pblur8(sh-1-p2-p,sw-1-p,popacityrich(int3));
            end;
            end;
         1,3:begin
            //top-right corner join
            pblur8(p,sw-1-p,popacityrich(int1));
            for p2:=1 to int2 do
            begin
            int3:=round(int1*(int2-p2)/int2);
            pblur8(p,sw-1-p2-p,popacityrich(int3));
            pblur8(p+p2,sw-1-p,popacityrich(int3));
            end;
            //bottom-left corner join
            pblur8(sh-1-p,p,popacityrich(int1));
            for p2:=1 to int2 do
            begin
            int3:=round(int1*(int2-p2)/int2);
            pblur8(sh-1-p,p+p2,popacityrich(int3));
            pblur8(sh-1-p2-p,p,popacityrich(int3));
            end;
            end;
         end;//case
         end//8
      //.24
      else if (sbits=24) then
         begin
         case xglobalshadeangle of
         0,2:begin
            //top-left corner join
            pblur24(p,p,popacityrich(int1));
            for p2:=1 to int2 do
            begin
            int3:=round(int1*(int2-p2)/int2);
            pblur24(p,p+p2,popacityrich(int3));
            pblur24(p+p2,p,popacityrich(int3));
            end;
            //bottom-right corner join
            pblur24(sh-1-p,sw-1-p,popacityrich(int1));
            for p2:=1 to int2 do
            begin
            int3:=round(int1*(int2-p2)/int2);
            pblur24(sh-1-p,sw-1-p2-p,popacityrich(int3));
            pblur24(sh-1-p2-p,sw-1-p,popacityrich(int3));
            end;
            end;
         1,3:begin
            //top-right corner join
            pblur24(p,sw-1-p,popacityrich(int1));
            for p2:=1 to int2 do
            begin
            int3:=round(int1*(int2-p2)/int2);
            pblur24(p,sw-1-p2-p,popacityrich(int3));
            pblur24(p+p2,sw-1-p,popacityrich(int3));
            end;
            //bottom-left corner join
            pblur24(sh-1-p,p,popacityrich(int1));
            for p2:=1 to int2 do
            begin
            int3:=round(int1*(int2-p2)/int2);
            pblur24(sh-1-p,p+p2,popacityrich(int3));
            pblur24(sh-1-p2-p,p,popacityrich(int3));
            end;
            end;
         end;//case
         end//24
      //.32
      else if (sbits=32) then
         begin
         case xglobalshadeangle of
         0,2:begin
            //top-left corner join
            pblur32(p,p,popacityrich(int1));
            for p2:=1 to int2 do
            begin
            int3:=round(int1*(int2-p2)/int2);
            pblur32(p,p+p2,popacityrich(int3));
            pblur32(p+p2,p,popacityrich(int3));
            end;
            //bottom-right corner join
            pblur32(sh-1-p,sw-1-p,popacityrich(int1));
            for p2:=1 to int2 do
            begin
            int3:=round(int1*(int2-p2)/int2);
            pblur32(sh-1-p,sw-1-p2-p,popacityrich(int3));
            pblur32(sh-1-p2-p,sw-1-p,popacityrich(int3));
            end;
            end;
         1,3:begin
            //top-right corner join
            pblur32(p,sw-1-p,popacityrich(int1));
            for p2:=1 to int2 do
            begin
            int3:=round(int1*(int2-p2)/int2);
            pblur32(p,sw-1-p2-p,popacityrich(int3));
            pblur32(p+p2,sw-1-p,popacityrich(int3));
            end;
            //bottom-left corner join
            pblur32(sh-1-p,p,popacityrich(int1));
            for p2:=1 to int2 do
            begin
            int3:=round(int1*(int2-p2)/int2);
            pblur32(sh-1-p,p+p2,popacityrich(int3));
            pblur32(sh-1-p2-p,p,popacityrich(int3));
            end;
            end;
         end;//case
         end;//32
      end;//p
   end;//i
   end;

//blur edges of "inner image"
if xsoftenjoins and sfullsoften then
   begin
   case sbits of
   8 :pblurframe8(xinner,-2,1,255);
   24:pblurframe24(xinner,-2,1,255);
   32:pblurframe32(xinner,-2,1,255);
   end;//case
   end;

//draw logo
if (misw(il32)>=2) and (mish(il32)>=2) and (xlogoopacity>=1) then adrawlogo32;

//successful
skipdone:
result:=true;
skipend:
except;end;
end;
//GUI Support ------------------------------------------------------------------
//## tbasicsystem ##############################################################
//xxxxxxxxxxxxxxxxxxxxxxxxxxx//ssssssssssssssssssssssssssssss
//## create ##
constructor tbasicsystem.create(xminver:longint;xhost:tobject;dwidth,dheight:longint);
var
   p:longint;
   junk:tnotifyevent;//xxxxxxxxxxxx
begin
//check
if (xminver>low__ver) then
   begin
   showerror('Internal system version too low');
   sihalt;
   end;
//self
satinc(satSystem,1);
zzadd(self);
imustcloseprompt:=false;//26aug2021
ilastmousemovecheckx:=minint;//07mar2022
ilastmousemovechecky:=minint;
icursorloadid:=-1;
iclosed:=false;
icloselocked:=0;
low__sysadd(self);
//.showoptions support
ipumptimer2:=ms64;
ishowoptions_inuse:=false;
ishowoptions_toolbar_colors:=nil;
ishowoptions_window:=nil;
ishowoptions_frames:=nil;
ishowoptions_list:=nil;
ishowoptions_cols:=nil;
ishowoptions_options:=nil;
ishowoptions_colors:=nil;
ishowoptions_framesize1:=nil;
ishowoptions_framesize2:=nil;
ishowoptions_sparkle1:=nil;
ishowoptions_sparkle2:=nil;
ishowoptions_timer100:=ms64;
ishowoptions_timer500:=ms64;
//.other
itimer_busy:=false;//05may2021
iwasdrop_showing:=false;
isplash:=nil;
imustgstate:=-1;//off
ilastdataid:=-1;
fontimer:=nil;
iontimerbusy:=false;
ishowoptions_crosssync:=false;//26feb2022
itiming:=false;
icreating:=true;
idestroying:=false;
ibuffer:=nil;
ibuffer2:=nil;
idragbuffer:=nil;
ihidecursorref:=0;//off - 28feb2022
isizing:=0;//22apr2022
imask:=nil;
inherited create;
omax_entirescreen:=false;
//host
if (xhost=nil) or (not (xhost is tcommonform)) then
   begin
   showerror('Invalid host');
   sihalt;
   end;
ihost:=(xhost as tcommonform);
ihost.caption:=low__programname;//Used when Win98 animates form's title bar during a Maximize or Normalize action - 04jun2021
ihost.cursor:=crArrow;


//init
ilastsystem_slowref64 :=ms64;//10may2021
iecomode64            :=ms64;
ishowonceref          :=ms64+30000;
ibufferresize64       :=ms64;
ibufferresize642      :=ms64;
itimer250             :=ms64;
itimer1000            :=ms64;
ihost.width           :=frcrange(round(dwidth*vizoom*(low__aorb(100,120,vitouch)/100)),10,misworkw);
ihost.height          :=frcrange(round(dheight*vizoom*(low__aorb(100,120,vitouch)/100)),10,misworkh);
//.sync width & height immedately -> so remaining procs are sure to have proper dimensions - 11may2021
iwidth                :=ihost.width;
iheight               :=ihost.height;
//.status support
istatuswin            :=nil;
istatustime           :=ms64;
istatuspert           :=0;
istatusrowcount       :=0;
istatustab            :=tbDefault;//05oct2022 -> unrestricted second column
for p:=0 to high(istatustext) do
begin
istatustext[p]:='';
istatustep[p]:=tepNone;
end;//p
istatustitle          :='Status';
istatusshow           :=false;
istatusstopped        :=false;
//.continue
ihost.borderstyle     :=bsnone;
low__centerform(ihost);
//gui state
igstate            :=gsNormal;
iwinemaximised     :=false;//supports PROPER maximise display in Wine - 05feb2022
inormalarea        :=rect(0,0,100,100);
//show modes
smnone             :=0;
smmodal            :=1;
smwait             :=2;
//xxxxxxxxxxishowmode:=smnone;
//index styles
xsnone             :=0;//nothing is selected
xsoutside          :=1;//coordinates outside of form
//was: xssize             :=2;//resize bar selected (resizing form)
xscontrol          :=3;//a control is selected
xsunknown          :=4;//unknown state
//pop support
ipophost           :=nil;
ipopshortcut       :=aknone;
//window support
iwinfocus          :=-1;
iwinfocuslayer     :=-1;
iwinhover          :=-1;
iwinhoverlayer     :=-1;
idragindex         :=-1;
idragstart         :=-1;
isizeindex         :=-1;
isizestart         :=-1;
idragging_fullwin  :=false;//15apr2021
//vars
ibuffer            :=misbmp(32,1,1);//switchable to 24bit via "vi32bit" - 09may2021
idragbuffer        :=misimg(misb(ibuffer),1,1);//use same bit depth as "ibuffer"
imask              :=tmask8.create(1,1);//high-speed window based mask for detecting window paint layers
imaskval           :=-1;//off
ikeyboardlaststate :=0;
imousebuttonlock   :=-1;//off
ilastsystem_mustid :=-1;
ilastsystem_mustidSLOW:=-1;//10may2021
imustclose         :=false;
iwheel             :=0;
ishiftok           :=false;
ictrlok            :=false;
ialtok             :=false;
ikey               :=aknone;
imousedbclicktime  :=ms64-30000;
imousedbclick      :=false;
imousedown         :=false;
imousedownref      :=0;//off
imousemoved        :=false;
imousewasdown      :=false;
imousedownxy       :=low__point(0,0);
imousemovexy       :=low__point(0,0);
iscreendownxy      :=low__point(0,0);
iscreenmovexy      :=low__point(0,0);
iscreendragging    :=false;
iscreendraggingv   :=false;
iscreendraggingh   :=false;
iscreendraggingfine:=false;
iscreendraggingfinev:=false;
iscreendraggingfineh:=false;
iscreendraggingout :=false;
iscreenmovingfine  :=false;
iscreenmovingfinexy:=low__point(0,0);
iscreenmovingfine64:=ms64;
imousebutton       :=abnone;//off
iinternalpaint     :=false;

//wound support - 30sep2022
iwoundratelimit:=5000;
iwoundratex:=0;
iwoundratey:=0;
iwounddirx:=1;
iwounddiry:=1;
iwoundlastx:=0;
iwoundlasty:=0;
iwoundref:=ms64;


//own support
ownlist.count      :=0;
ownid              :=0;

//window support
iwinlimit          :=high(winlist.list)+1;//255 -> max. number of windows is 255 (0..254), 255=reserved for graphic mask as "nil"
iwinmax            :=high(winlist.list);//254 -> window layer range is 0..254
winlist.count      :=0;
//window mask support
winmask_cnt:=0;
for p:=0 to high(winmask_id) do
begin
winmask_id[p] :=-1;
winmask_aid[p]:=-1;
winmask_vis[p]:=false;
winmask_rnd[p]:=false;
end;//p

//core
icorecount  :=0;
for p:=0 to high(icore) do icore[p]:=nil;
//action
iacount     :=0;
iabusy      :=false;
//paint
for p:=0 to high(recs) do recs[p]:=rect(0,0,0,0);
ibits       :=0;
ialignid    :=0;
ipaintid    :=0;

//vars
imasking    :=false;
ipaintbusy  :=false;
ipainting   :=0;
ipaintingpart:=false;
ipartpaintareaok:=false;
imustpaint  :=0;
imustalign  :=0;
ialigning   :=false;

//connect
ihost.vertscrollbar.visible:=false;
ihost.horzscrollbar.visible:=false;
ihost.onmousedown :=__onmousedown;
ihost.onmouseup   :=__onmouseup;
ihost.onmousemove :=__onmousemove;
ihost.onkeydown   :=__onkeydown;
ihost.onkeyup     :=__onkeyup;
ihost.onkeypress  :=__onkeypress;
ihost.onresize    :=__onresize;
ihost.onpaint     :=__onpaint;
ihost.onshow      :=__onshow;
ihost.keypreview  :=true;
if (ihost is tform1) then (ihost as tform1).onaccept:=__onaccept;//18jun2021
//was: if (ihost is tbaseform) then (ihost as tbaseform).onaccept:=__onaccept;//18jun2021
//was: if (ihost is tbaseform) then (ihost as tbaseform).onwheel:=__onwheel2;//26aug2020

//.timer
low__timerset(self,__ontimer,50);

//ready ------------------------------------------------------------------------
icreating   :=false;
imustalign  :=2;
imustpaint  :=2;

//drag and drop init -----------------------------------------------------------
dragacceptfiles(ihost.handle,true);
end;
//## destroy ##
destructor tbasicsystem.destroy;
var
   p:longint;
begin
try
//init
idestroying:=true;
//drag and drop stop -----------------------------------------------------------
if (ihost<>nil) then dragacceptfiles(ihost.handle,false);
//host - disconnect
low__timerdel(self,__ontimer);//disconnect our timer event from the system timer
fontimer          :=nil;
fontimer2         :=nil;
ihost.onmousedown :=nil;
ihost.onmouseup   :=nil;
ihost.onmousemove :=nil;
ihost.onkeydown   :=nil;
ihost.onkeyup     :=nil;
ihost.onkeypress  :=nil;
ihost.onshow      :=nil;
ihost.onresize    :=nil;
ihost.onpaint     :=nil;
if (ihost is tform1) then (ihost as tform1).onaccept:=nil;//18jun2021
//was: if (ihost is tbaseform) then (ihost as tbaseform).onaccept:=nil;//18jun2021
//was: if (ihost is tbaseform) then (ihost as tbaseform).onwheel:=nil;

//free specific controls
freeobj(@isplash);

//core - destroy any remaining windows/objects
for p:=0 to high(icore) do if zzok(icore[p],7092) then freeobj(@icore[p]);
freeobj(@ibuffer);
freeobj(@ibuffer2);
freeobj(@idragbuffer);
freeobj(@imask);
//self
low__sysdel(self);
inherited destroy;
satinc(satSystem,-1);
except;end;
end;
//## __onaccept ##
procedure tbasicsystem.__onaccept(sender:tobject;var msg:tmessage);//drag&drop files - 24APR2011, 07DEC2009
label//Important Note: Drag&Drop does not work when program is run from within Delphi on Win7 - 24APR2011
   skipend;
const
   flimit=255;
var
   a:tbasiccontrol;
   b:tpoint;
   p,count:longint;
   f:array [0..flimit] of char;
   ffolder,fstr:string;
begin
try
//init
fillchar(f,sizeof(f),#0);//23APR2011
//find out how many files we're accepting
count:=dragqueryfile(msg.WParam,$FFFFFFFF,f,flimit);
//get control
b:=low__mouse(ihost,'m');
if not xacceptfindbyxy(b.x,b.y,a) then goto skipend;

//query Windows one at a time for the file name
for p:=0 to (count-1) do
begin
//check
if idestroying or siclosing or sihalted then break;//03apr2021
//.start
dragqueryfile(msg.WParam,p,f,flimit);
//.filename
fstr:=fromnullstr(@f,sizeof(f));
//.foldername
case low__folderexists(fstr) of
true:begin//dropped item is a folder
   ffolder:=asfolder(fstr);
   fstr:=ffolder;//ensure supplied filename is converted to a folder - 24APR2011
   end;
false:ffolder:=asfolder(low__extractfilepath(fstr));//dropped item is a file
end;
//.set
if (a=nil) or (not a.accept_passthru(self,ffolder,fstr,p,count)) then break;
end;
skipend:
except;end;
//let Windows know that you're done
try;dragfinish(msg.WParam);except;end;
end;
//## closelock ##
procedure tbasicsystem.closelock;
begin
try;inc(icloselocked,1);except;end;
end;
//## closeunlock ##
procedure tbasicsystem.closeunlock;
begin
try;icloselocked:=frcmin(icloselocked-1,0);except;end;
end;
//## xfireevent ##
procedure tbasicsystem.xfireevent(sender:tobject;xevent:tnotifyevent);//lock close -> fireevent -> unlock close - 03apr2021
begin
try
if assigned(xevent) then
   begin
   closelock;
   try;xevent(sender);except;end;
   closeunlock;
   end;
except;end;
end;
//## getgstate ##
function tbasicsystem.getgstate:longint;
begin
try
result:=igstate;
if (imustgstate>=0) then result:=imustgstate
else if zzok(ihost,7093) then//this is incase we are out-of-sync with windows and our form's windowstate
   begin
   if xmaximised                           then result:=gsmax//05feb2022
   //was: else if (ihost.windowstate=wsMaximized) then result:=gsmax
   else if (ihost.windowstate=wsMinimized) then result:=gsmin;
   end;

//was: else if (application.mainform<>nil) and (ihost=application.mainform) then//this is incase we are out-of-sync with windows and out windowstate
//   begin
//   if      (application.mainform.windowstate=wsMaximized) then result:=gsmax
//   else if (application.mainform.windowstate=wsMinimized) then result:=gsmin;
//   end;
except;end;
end;
//## setgstate ##
procedure tbasicsystem.setgstate(x:longint);
begin
try;imustgstate:=frcrange(x,0,gsUpperlimit);except;end;
end;
//## mainappwindow ##
function tbasicsystem.mainappwindow:boolean;
begin
try;result:=zzok(ihost,7094) and (ihost=application.mainform);except;end;
end;
//## canposition ##
function tbasicsystem.canposition:boolean;
begin
try;result:=xnormal;except;end;
end;
//## canposition ##
procedure tbasicsystem.position(xstyle:string);
var
   a:trect;
   w,h,w2,h2:longint;
begin
try
//check
if not canposition then exit;
//init
xstyle:=low__lowercase(xstyle);
a:=misworkarea;
h:=a.bottom-a.top+1;
w:=a.right-a.left+1;
h2:=h div 2;
w2:=w div 2;
//get
if      (xstyle='position.t') then setbounds(a.left,a.top,w,h2)
else if (xstyle='position.b') then setbounds(a.left,a.bottom-h2,w,h2)
else if (xstyle='position.l') then setbounds(a.left,a.top,w2,h)
else if (xstyle='position.r') then setbounds(a.right-w2,a.top,w2,h)
else if (xstyle='position.lt') then
   begin
   syssettings.b['lockposition']:=not syssettings.b['lockposition'];
   viSyncandsave;
   end;
except;end;
end;
//## xmainwin ##
function tbasicsystem.xmainwin(var xwin:tbasicscroll):boolean;
var//Note: May not always return a result
   i,p:longint;
begin
try
//defaults
result:=false;
xwin:=nil;
//find
if (winlist.count>=1) then
   begin
   for p:=0 to (winlist.count-1) do
   begin
   i:=winlist.list[p];
   if (i>=0) and (i<icorecount) and zzok(icore[i],7095) and (icore[i] is tbasicscroll) and (icore[i].winstyle=wmfullwin) and icore[i].visible then
      begin
      xwin:=icore[i] as tbasicscroll;
      result:=true;
      break;
      end;
   end;//p
   end;
except;end;
end;
//## xsafearea ##
procedure tbasicsystem.xsafearea;
var
   a:trect;
   b:tbasicscroll;
   p,i,xsize,xsize0:longint;
   //## xcheck ##
   procedure xcheck;//updated 01feb2021
   const
      minspace=48;
   var
      xbs,dx,dy,dw,dh:longint;
      xheadok:boolean;
   begin
   //check
   if zznil(b,2290) or (b.winstyle=wmfullwin) then exit;
   //init
   dx:=b.left;
   dy:=b.top;
   dw:=b.clientwidth;
   dh:=b.clientheight;
   xheadok:=b.xhavehead and b.xhead.visible;
   xbs:=b.findbordersize;
   xsize0:=xbs+low__insint(minspace,not xheadok);
   xsize:=xbs+minspace;
   //get
   //.left
   if ((dx+dw-xsize)<a.left) then dx:=a.left-dw+xsize;
   //.right
   if ((dx+xsize)>a.right) then dx:=a.right-xsize;
   //.top
   case xheadok of
   true:if (dy<(a.top-xsize0)) then dy:=a.top-xsize0;//don't allow HEADER to vanish of top of screen
   false:if ((dy+dh-xsize0)<a.top) then dy:=a.top-dh+xsize0;//HEADER is not visible/present so allow MOST of form to vanish off top of screen - 01feb2021
   end;
   //.bottom
   if ((dy+xsize)>a.bottom) then dy:=a.bottom-xsize;
   //set
   if (dx<>b.left) or (dy<>b.top) or (dw<>b.clientwidth) or (dh<>b.clientheight) then
      begin
      if b.setbounds(dx,dy,dw,dh) then b.alignnow;
      end;
   end;
begin
try
//check
if mousedown then exit;

//-- Main Screen ---------------------------------------------------------------
//Note: Main screen as a window on MS Windows
if visafearea and zzok(ihost,7092) then
   begin
   //init
   a:=misworkarea;
   //.xsize
   if xmainwin(b) then
      begin
      xsize0:=b.findbordersize;
      xsize:=xsize0;
      if b.xhavehead and b.xhead.visible then inc(xsize,b.xhead.clientheight);
      end
   else
      begin
      xsize0:=0;
      xsize:=0;
      end;
   //get
   //.left
   if ((ihost.left+ihost.width-xsize)<a.left) then ihost.left:=a.left-ihost.width+xsize;
   //.right
   if ((ihost.left+xsize)>a.right) then ihost.left:=a.right-xsize;
   //.top
   if ((ihost.top+xsize0)<a.top) then ihost.top:=a.top-xsize0;
   //.bottom
   if ((ihost.top+xsize)>a.bottom) then ihost.top:=a.bottom-xsize;
   end;

//-- All our windows -----------------------------------------------------------
//Note: Skip over "wmfullwin" they are handled automatically and
//      elsewhere by the system - 28aug2020
//was: if visafearea and (winlist.count>=1) then
//Important Note: All Gossamer based windows are on screen at all times as of 27mar2021
if (winlist.count>=1) then
   begin
   a:=rect(0,0,width-1,height-1);
   for p:=0 to (winlist.count-1) do
   begin
   i:=winlist.list[p];
   if (i>=0) and (i<icorecount) and zzok(icore[i],7096) and (icore[i] is tbasicscroll) and (icore[i].winstyle>wmfullwin) and (icore[i].winstyle<=wmMax) and icore[i].visible then
      begin
      b:=icore[i] as tbasicscroll;
      xcheck;
      end;
   end;//p
   end;

except;end;
end;
//## xcenter ##
procedure tbasicsystem.xcenter(x:tbasiccontrol);
var
   dx,dy,dw,dh,cw,ch:longint;
begin
try
if zzok(x,7405) and (x is tbasicscroll) then
   begin
   //get
   cw:=width;
   ch:=height;
   dw:=frcmax((x as tbasicscroll).clientwidth,cw);
   dh:=frcmax((x as tbasicscroll).clientheight,ch);
   dx:=(cw-dw) div 2;
   dy:=(ch-dh) div 2;
   //set
   (x as tbasicscroll).setbounds(dx,dy,dw,dh);
   end;
except;end;
end;
//## xshowsplash ##
procedure tbasicsystem.xshowsplash;
begin
try
if zzok(isplash,7098) then exit;
isplash:=tbasicsplash.create(self);
isplash.xsplash;
except;end;
end;
//## xshowabout ##
procedure tbasicsystem.xshowabout;
begin
try
if zzok(isplash,7099) then exit;
isplash:=tbasicsplash.create(self);
isplash.xabout;
except;end;
end;
//## xshowoptions ##
procedure tbasicsystem.xshowoptions;
const
   vsp=5;
var
   dw,dh,int1,xpreviousfocus:longint;
   xcolor,a,ca:tbasicscroll;
   b,b2:tstr8;
   xcolorscheme:tbasicmenu;
   str1:string;
   bs:longint;
   xhost:tbasiccontrol;
   //## dint3 ##
   function dint3(xlabel,xname,xhelp:string;xmin,xmax,xdef:longint;xvalname:string):tbasicint;
   begin
   if zznil(xhost,2291) then exit;
   result:=xhost.nint3(xlabel,xhelp,xmin,xmax,xdef,0,'',xvalname);
   result.tagstr:=xname;
   result.onvalue:=xshowoptions_sync;
   result.oautoreload:=true;
   end;
   //## dint3b ##
   function dint3b(var xout:tbasicint;xlabel,xname,xhelp:string;xmin,xmax,xdef:longint;xvalname:string):tbasicint;
   begin
   result:=dint3(xlabel,xname,xhelp,xmin,xmax,xdef,xvalname);
   xout:=result;
   end;
   //## dset ##
   function dset(xlabel,xname,xhelp:string;xdef:longint):tbasicset;
   begin
   if zznil(xhost,2292) then exit;
   result:=xhost.nset(xlabel,xhelp,xdef,0);
   result.tagstr:=xname;
   result.onvalue:=xshowoptions_sync;
   result.oautoreload:=true;
   end;
   //## dsel3 ##
   function dsel3(xlabel,xname,xhelp:string;xdef:longint;xvalname:string):tbasicsel;
   begin
   if zznil(xhost,2293) then exit;
   result:=xhost.nsel3(xlabel,xhelp,xdef,xvalname);
   result.tagstr:=xname;
   result.onvalue:=xshowoptions_sync;
   result.oautoreload:=true;
   end;
begin
try
//defaults
a:=nil;
b:=nil;
b2:=nil;
xpreviousfocus:=winfocus;
xhost:=nil;
//check
if ishowoptions_inuse then exit else ishowoptions_inuse:=true;
//init
ishowoptions_timer100:=ms64;
ishowoptions_timer500:=ms64;
//get
dw:=largest(460,system_onshowoptionsNEWWIDTH);
dh:=largest(460,system_onshowoptionsNEWHEIGHT);;//was: 440 - 13mar2022
low__winzoom(dw,dh);//17mar2021
bs:=vibordersize;
a:=ndlg2(rect(0,0,dw+(2*bs),dh+(2*bs)),true,true);
a.ontimer2:=xshowoptions_timer;
a.xhead.caption:=ntranslate(protect_text(16770856,'Options'));
a.xtoolbar2.cadd(ntranslate(protect_text(16770871,'OK')),tepYes20,1,scdlg,rthtranslate('Close window'),low__aorb(60*5,system_onshowoptionsCLOSEDELAY,system_onshowoptionsCLOSEDELAY>=1));//12nov2022
a.xtoolbar2.add(ntranslate(protect_text(16771396,'Restore Defaults...')),tepRefresh20,2,'defaults',rthtranslate('Restore default settings'));

//.host system > open - 06nov2022
if assigned(system_onshowoptions1) then system_onshowoptions1(a);

//-- Color ---------------------------------------------------------------------
xcolor:=a.xpage2('color','Color','','Color Schemes',tepColor20,true);
xcolor.xcols.style:=bcVertical;
ishowoptions_toolbar_colors:=xcolor.xtoolbar.maketitle3('Color Schemes',false,false);
with ishowoptions_toolbar_colors do//23mar2022
begin
add(ntranslate(protect_text(16770831,'Menu')),tepMenu20,3,'options.menu',rthtranslate('Show Color Schemes menu'));
add('Copy',tepCopy20,3,'options.copycols',rthtranslate('Copy color scheme to Clipboard'));
add('Paste and Use',tepPaste20,3,'options.pastecols',rthtranslate('Paste color scheme from Clipboard and use'));
add('Darken',tepLess20,3,'options.darken',rthtranslate('Darken color scheme colors'));//18sep2022
add('Brighten',tepMore20,3,'options.brighten',rthtranslate('Brighten color scheme colors'));//18sep2022
onclick:=xshowoptions_sync;
end;

//.color schemes list
with xcolor.xcols.cols2[0,50,false] do
begin
xhost:=client;
//.colorname.top
xcolorscheme:=nlist3('','Select color scheme',nil,8,'colorname');//read/write via system var.name of "colorname" - 09oct2020
xcolorscheme.tagstr:='colorname';
ishowoptions_list:=xcolorscheme;
ishowoptions_list.onshowmenu:=xshowoptions_showmenu;//11oct2020
ishowoptions_list.ocanshowmenu:=true;//26mar2021
ishowoptions_list.onumberfrom:=1;
//was: xshowoptions_reload;
end;//end-color

//.colorname.bottom
with xcolor.xcols.cols2[1,50,true] do
begin
ishowoptions_colors:=ncolors;
ishowoptions_colors.makesystem;
end;
xcolor.xcols.vis[1]:=false;
ishowoptions_cols:=xcolor.xcols;


//-- Frame ---------------------------------------------------------------------
with a.xpage2('frame',protect_text(16771278,'Frame'),'','Frame Styles',tepFrame20,true) do
begin
xhost:=client;
xtoolbar.maketitle3(protect_text(16771149,'Frame Styles'),false,false);
ishowoptions_frames:=nlist3('','Select frame',nil,0,'framename');//read/write via system var.name of "colorname" - 09oct2020
ishowoptions_frames.tagstr:='framename';
ishowoptions_frames.onumberfrom:=0;

with xhigh2 do
begin
xhost:=client;
ntitle(false,'Frame Options','Frame options');
dint3b(ishowoptions_framesize1,'Size','bordersize',protect_text(16771582,'Adjust Frame Size'),0,72,32,'bordersize').ospbackname:='yellow';
dint3b(ishowoptions_sparkle1,'Sparkle','sparkle',protect_text(16771132,'Adjust Sparkle'),0,20,0,'sparkle').ospbackname:='blue';
end;

end;


//-- Font -------------------------------------------------------------------
with a.xpage2('font',protect_text(16770908,'Font'),'','Font',tepFont20,false) do
begin
xhost:=client;
ntitle(false,'Font','Font');

with dsel3(protect_text(16770837,'Zoom'),'zoom','',0,'zoom') do
begin
xadd(protect_text(16771197,'Automatic'),'0','Selected: Automatically match program size to monitor resolution | 100% for 1920x1080 "2K" monitor, 200% for 3840x2160 "4K" monitor and 400% for 7680x4320 "8K" monitor');
xadd('100%','1','Selected: Do not zoom program - use original size - 100%');
xadd('200%','2','Selected: Zoom program to 2x normal size - 200%');
xadd('300%','3','Selected: Zoom program to 3x normal size - 300%');
xadd('400%','4','Selected: Zoom program to 4x normal size - 400%');
reload;
ospbackname:='red';
end;

with dsel3(protect_text(16771320,'Font Size'),'fontsize','',0,'fontsize') do
begin
itemsperline:=5;
xadd('6','6','6pt');
xadd('8','8','8pt');
xadd('9','9','9pt');
xadd('10','10','10pt');
xadd('11','11','11pt');
xadd('12','12','12pt');
xadd('14','14','14pt');
xadd('16','16','16pt');
xadd('22','22','22pt');
xadd('24','24','24pt');
reload;
ospbackname:='orange';
end;

with dsel3(protect_text(16771300,'Font Name'),'fontname','',0,'fontnameraw') do
begin
itemsperline:=3;
str1:=protect_text(16771090,'Select font name');
xadd('Arial','Arial',str1);
xadd('MS Sans Serif','MS Sans Serif',str1);
xadd('Times New Roman','Times New Roman',str1);
xadd('Courier New','Courier New',str1);
xadd('System','System',str1);
xadd('Segoe UI','Segoe UI',str1);
xadd('Tahoma','Tahoma',str1);
xadd('Verdana','Verdana',str1);
xadd('@MS Gothic','@MS Gothic',str1);
xadd('DejaVu Sans','DejaVu Sans',str1);
xadd('DejaVu Serif','DejaVu Serif',str1);
xadd('Custom','*','Select once to use custom font.  Select again to choose font from list of available fonts');
reload;
ospbackname:='green';
onclick:=xshowoptions_click;
end;

with dsel3(protect_text(16771177,'Font Feathering'),'fontfeather','',0,'fontfeather') do
begin
xadd('Off','0','No font feathering');
xadd('Low','1','Subtle font feathering');
xadd('Medium','2','Additional font feathering');
xadd('High','3','Significant font feathering');
xadd('Ultra','4','Extreme font feathering');
reload;
ospbackname:='yellow';
end;

with dsel3('Font Specific Antialiasing','fontfeatherf','',0,'fontfeatherf') do
begin
xadd('Off','0','Off');
xadd('Dark','1','High-contrast antialiasing');
xadd('Moderate','2','Moderate-contrast antialiasing');
xadd('Light','3','Standard antialiasing');
reload;
ospbackname:='purple';
end;

with dsel3(protect_text(16771093,'Font Name 2 (Text Entry)'),'fontname2','',0,'fontnameraw2') do
begin
osepv:=5;
itemsperline:=3;
str1:='Select font name';
xadd('Arial','Arial',str1);
xadd('MS Sans Serif','MS Sans Serif',str1);
xadd('Times New Roman','Times New Roman',str1);
xadd('Courier New','Courier New',str1);
xadd('System','System',str1);
xadd('Segoe UI','Segoe UI',str1);
xadd('Tahoma','Tahoma',str1);
xadd('Verdana','Verdana',str1);
xadd('@MS Gothic','@MS Gothic',str1);
xadd('DejaVu Sans','DejaVu Sans',str1);
xadd('DejaVu Serif','DejaVu Serif',str1);
xadd('Custom','*',str1);
reload;
ospbackname:='blue';
visible:=programinit_fontname2;//07feb2022
onclick:=xshowoptions_click;
end;

with dsel3(protect_text(16771113,'Font Size 2 (Text Entry)'),'fontsize2','',0,'fontsize2') do//26feb2022
begin
itemsperline:=5;
xadd('6','6','6pt');
xadd('8','8','8pt');
xadd('9','9','9pt');
xadd('10','10','10pt');
xadd('11','11','11pt');
xadd('12','12','12pt');
xadd('14','14','14pt');
xadd('16','16','16pt');
xadd('22','22','22pt');
xadd('24','24','24pt');
reload;
ospbackname:='yellow';
visible:=programinit_fontname2;//07feb2022
end;

end;//end-font


//-- Settings -------------------------------------------------------------------
with a.xpage2('settings',protect_text(16771212,'Settings'),'','General Settings',tepSettings20,false) do
begin
xhost:=client;
ntitle(false,'Settings','General Settings');

with dset(protect_text(16771231,'Program Links'),'','',0) do
begin
visible:=not system_storeapp;
xset3(0,protect_text(16771221,'Start button link'),'startlink','Selected: Place a link to this program on your Start button | Not Selected: Remove link from Start button',false,'startlink');
xset3(1,protect_text(16771189,'Desktop link'),'desktoplink','Selected: Place a link to this program on your Desktop | Not Selected: Remove link from Desktop',false,'desktoplink');
ospbackname:='red';
end;

ishowoptions_options:=dset(protect_text(16770856,'Options'),'','',0);
with ishowoptions_options do//generate check codes for these as well//xxxxxxxxxxxxxxxxxxxxxxxx//??????????????????????//12feb2022
begin
itemsperline:=3;
xset3(0,'Curved Corners','round',protect_text(16771762,'Selected: Curved corners | Not Selected: Square corners'),false,'round');
xset3(1,'Soft Close','softclose',protect_text(16772186,'Selected: Close dialog window(s) when clicked outside of'),false,'softclose');
xset3(2,'Safe Area','safearea',protect_text(16771966,'Selected: Main window visible on screen at all times'),false,'safearea');//Main window option as of 27mar2021

xset3(3,'Show Splash','splash',protect_text(16771705,'Selected: Show artistic splash screen on program start'),false,'splash');
xset3(4,'Realtime Help','realtimehelp',protect_text(16771720,'Selected: Show realtime help'),false,'help');
xset3(5,'On Top','ontop',protect_text(16771532,'Selected: Program appears on top of others'),false,'ontop');

xset3(6,'Touch','touch',protect_text(16771825,'Selected: Enlarge controls for a touch screen'),false,'touch');
xset3(7,'Double Clicks','doubleclicks',protect_text(16772365,'Selected: Use single and double clicks | Not Selected: Use single clicks only'),false,'doubleclicks');
xset3(8,'Frame Maximised','framemax','Selected: Display frame when maximised | Not Selected: Hide frame when maximised',false,'framemax');

xset3(9,'Economy','ecomode',protect_text(16772958,'Selected: Reduce GUI repaints when idle - 2 fps when idle for 30+ seconds and 1 fps when idle for 10+ minutes'),false,'ecomode');
xset3(10,'32bit Graphics','32bit',protect_text(16772990,'Selected: 32bit graphics | Not Selected: 24bit graphics - faster and lighter on older machines'),false,'32bit');//12feb2022
xset3(11,'Minimal Scrollbars','minimalscroll',protect_text(16772298,'Selected: Minimal scrollbars | Not Selected: Standard scrollbars'),false,'minimalscroll');

xset3(12,'Large Title','headlarge','Selected: Large window title | Not Selected: Small window title',false,'headlarge');//01mar2022
xset3(13,'Center Title','headcenter','Selected: Center window title | Not Selected: Left align window title',false,'headcenter');//11oct2022
xset3(14,'Assisted Scroll','autoscroll','Selected: Scroll further with less effort using assisted scroll | Not Selected: Unassisted manual scroll',false,'autoscroll');//28sep2022

//was: too dangerous to implement: xset3(13,'Lock Position','lockposition',protect_text(16772934,'Selected: Lock main window in place - disallow resize, disallow move | Not Selected: Allow main window to resize and move'),false,'lockposition');

//example: Something like this protect_text('Selected: Reduce GUI repaints when idle - 2 fps when idle for 30+ seconds and 1 fps when idle for 10+ minutes',xcheckcode)
ospbackname:='green';
end;

with dset('Effects','','',0) do
begin
xset3(0,'Special Colors','specialcolors',protect_text(16772553,'Selected: Show special indication colors on selected controls | Not Selected: Use system colors'),false,'specialcolors');
xset3(1,'Enhanced','enhanced',protect_text(16772764,'Selected: Show visiual effects on controls | Not Selected: Show minimal visiual effects'),false,'enhanced');
xset3(2,'Curved Shading','shaderound',protect_text(16772229,'Selected: Curved shading | Not Selected: Flattened shading'),false,'shaderound');
xset3(3,'Colorise Images','coloriseimages',protect_text(16772483,'Selected: Show images in current color scheme colors | Not Selected: Show images normally'),false,'coloriseimages');//10mar2021
xset3(4,'Glow','shadeglow',protect_text(16771897,'Selected: Glow shading | Not Selected: Normal shading'),false,'shadeglow');

itemsperline:=3;
ospbackname:='blue';
end;

//was: dint3('Sparkle','sparkle',protect_text(16771132,'Adjust Sparkle'),0,20,0,'sparkle').ospbackname:='blue';
//was: dint3('Frame Size','bordersize',protect_text(16771582,'Adjust Frame Size'),0,72,32,'bordersize').ospbackname:='yellow';
dint3b(ishowoptions_sparkle2,'Sparkle','sparkle',protect_text(16771132,'Adjust Sparkle'),0,20,0,'sparkle').ospbackname:='blue';
dint3b(ishowoptions_framesize2,'Frame Size','bordersize',protect_text(16771582,'Adjust Frame Size'),0,72,32,'bordersize').ospbackname:='yellow';
dint3('Scrollbar Size','scrollsize',protect_text(16771546,'Adjust Scrollbar Size'),5,72,20,'scrollsize').ospbackname:='orange';


with dsel3(protect_text(16770910,'Cursor'),'cursorname','',0,'cursorname') do
begin
itemsperline:=4;
xadd('Default','default','Default');
xadd('Orange','orange','Orange');
xadd('Pink','pink','Pink');
xadd('Yellow','yellow','Yellow');
xadd('Purple','purple','Purple');
xadd('Navy','navy','Navy');
xadd('Green','green','Green');
xadd('Grey','grey','Grey');
xadd('Black','black','Black');
xadd('White','white','White');
xadd('Custom','custom','Custom Cursor.  Select once to use custom cursor.  Select again to choose cursor from disk.');
reload;
ovalueclick:=true;
ospbackname:='purple';//'green';
end;

end;//end-settings


//-- Misc -------------------------
//.wine options -> not supported for Store Apps - 30mar2022
if not system_storeapp then
   begin
   with a.xpage2('misc',protect_text(16771572,'Miscellaneous'),'','Miscellaneous Settings',tepOptions20,false) do
   begin
   xhost:=client;
   ntitle(false,'Miscellaneous','Miscellaneous Settings');
   with dsel3('Wine ('+low__aorbstr('not detected','detected',system_winepresent)+')','winemode','Support for running on Wine (https://www.winehq.org)',0,'winemode') do
   begin
   tep:=tepWine20;
   xadd('Automatic','0','Automatic Wine support');
   xadd('Enable','1','Enable Wine support');
   xadd('Disable','2','Disable Wine support');
   reload;
   ospbackname:='red';
   end;
   end;//end-misc
   end;

   
//reload
xshowoptions_reload;

//events
ishowoptions_frames.onclick:=xshowoptions_sync;
xcolorscheme.onclick:=xshowoptions_sync;
a.xtoolbar.onclick:=xshowoptions_sync;
a.xtoolbar2.onclick:=xshowoptions_sync;
//set
a.page:=low__udv(system_options_str1,low__udv(system_onshowoptionsINITPAGENAME,xcolor.opagename));//fixed - 29may2021
xcolor.ofirstpos:=system_options_pos1;
ishowoptions_window:=a;
xcenter(a);
xshowwait(a,xpreviousfocus);
system_options_str1:=a.page;
system_options_pos1:=xcolor.pos;

//.host system > close - 06nov2022
if assigned(system_onshowoptions2) then system_onshowoptions2(a);

//sync
viSyncandsave;
except;end;
try
ishowoptions_toolbar_colors:=nil;
ishowoptions_window:=nil;
ishowoptions_frames:=nil;
ishowoptions_list:=nil;
ishowoptions_cols:=nil;
ishowoptions_colors:=nil;
ishowoptions_options:=nil;
ishowoptions_framesize1:=nil;
ishowoptions_framesize2:=nil;
ishowoptions_sparkle1:=nil;
ishowoptions_sparkle2:=nil;
ishowoptions_crosssync:=false;
freeobj(@a);
freeobj(@b);
except;end;
try;ishowoptions_inuse:=false;except;end;
end;
//## xshowoptions_reload ##
procedure tbasicsystem.xshowoptions_reload;
var
   a,b:tstr8;
   c:tdynamicstring;
   xname,xlabel,xhelp:string;
   xsize:comp;
   bcount,xcurrentTEP,xstyle,xtep,p:longint;
   xincludeQuerymark,xonce:boolean;
   //## baddtitle ##
   procedure baddtitle(xcap:string);
   begin
   low__menutitle(b,tepNone,xcap,'');
   inc(bcount);
   end;
   //## badd2 ##
   procedure badd2(xcap,xname:string);
   begin
   low__menuitem(b,xcurrentTEP,xcap,xhelp,xname,100,true);
   inc(bcount);
   end;
   //## badd ##
   procedure badd(xcap,xname:string);
   begin
   badd2(xcap,low__insstr('?',xincludeQuerymark)+xname);
   end;
   //## xadd ##
   procedure xadd(xcap:string);
   begin
   badd2(xcap,low__insstr('?',xincludeQuerymark)+xcap);
   end;
   //## xadd3 ##
   procedure xadd3(xcap:string);
   begin
   c.value[c.count]:=xcap;
   end;
   //## xaddall3 ##
   procedure xaddall3(xsort:boolean);
   var
      p:longint;
   begin
   if xsort then c.sort(true);
   if (c.count>=1) then
      begin
      for p:=0 to (c.count-1) do xadd(c.svalue[p]);
      end;
   end;
begin
try
//defaults
a:=nil;
b:=nil;
c:=nil;
//init
a:=bnew;
b:=bnew;
c:=tdynamicstring.create;
bcount:=0;

//-- color ---------------------------------------------------------------------
//init
a.clear;
b.clear;
c.clear;
xincludeQuerymark:=true;
xhelp:='Select color scheme';
xcurrentTEP:=tepColor20;
xonce:=true;
low__menuinit(b);
//internal
baddtitle('Built-In');
if (ishowoptions_list<>nil) then ishowoptions_list.onumberfrom:=bcount;
xadd('Default');

//Mum's Wonderful color schemes...... 09may2021
xadd3('Army');
xadd3('Army 2');
xadd3('Burnt Yellow');//11oct2022
xadd3('Burnt Yellow 2');
xadd3('Burnt Yellow 3');
xadd3('Burnt Red');//11oct2022
xadd3('Burnt Red 2');
xadd3('Burnt Red 3');
xadd3('Burnt Purple');//11oct2022
xadd3('Burnt Purple 2');
xadd3('Burnt Purple 3');
xadd3('Burnt Orange');//11oct2022
xadd3('Burnt Orange 2');
xadd3('Burnt Orange 3');
xadd3('Eerie');//11oct2022
xadd3('Eerie 2');
xadd3('Eerie 3');
xadd3('Soft Green');
xadd3('Soft Green 2');
xadd3('Soft Green 3');
xadd3('Soft Green 4');
xadd3('Aqua Marine');
xadd3('Aqua Marine 2');
xadd3('Aqua Marine 3');
xadd3('Marine');
xadd3('Marine 2');
xadd3('Marine 3');
xadd3('Marine 4');
xadd3('Lilac');
xadd3('Lilac 2');
xadd3('Lilac 3');
xadd3('Gold');
xadd3('Gold 2');
xadd3('Gold 3');
xadd3('Gold 4');
xadd3('Silver Gold');
xadd3('Silver Gold 2');
xadd3('Grey');
xadd3('Grey 2');
xadd3('Grey 3');
xadd3('Grey 4');
xadd3('Grey 5');
xadd3('Grey 6');
xadd3('Soft Blue');
xadd3('Soft Blue 2');
xadd3('Soft Blue 3');
xadd3('Soft Blue 4');
xadd3('Soft Blue 5');//14nov2022
xadd3('Emerald');
xadd3('Emerald 2');
xadd3('Emerald 3');
xadd3('Washed Crimson');
xadd3('Washed Crimson 2');
xadd3('Washed Crimson 3');
xadd3('Dusty Pink');
xadd3('Dusty Pink 2');
xadd3('Dusty Pink 3');
xadd3('Golden Sands');
xadd3('Golden Sands 2');
xadd3('Golden Sands 3');
xadd3('Fern');
xadd3('Fern 2');
xadd3('Tangerine');
xadd3('Tangerine 2');
xadd3('Tangerine 3');
xadd3('Barely Beige');
xadd3('Barely Beige 2');
xadd3('Moon Blue');
xadd3('Moon Blue 2');
xadd3('Moon Blue 3');
xadd3('Moon Blue 4');
xadd3('Moon Blue 5');
xadd3('Howdy Brown');
xadd3('Howdy Brown 2');
xadd3('Howdy Brown 3');
xadd3('Chirpy Charcoal');
xadd3('Chirpy Charcoal 2');
xadd3('Dark Red Tint');//02may2022
xadd3('Dark Green Tint');//02may2022
xadd3('Dark Blue Tint');//02may2022
xadd3('Dark Yellow Tint');//02may2022
xadd3('Dark Aqua Tint');//02may2022
xadd3('Dreamy Cream');
xadd3('Dreamy Cream 2');
xadd3('Dreamy Cream 3');
xadd3('Gentle Ginger');
xadd3('Gentle Ginger 2');
xadd3('Gentle Ginger 3');
xadd3('Grumpy Green');
xadd3('Grumpy Green 2');
xadd3('Grumpy Green 3');
xadd3('Grumpy Green 4');
xadd3('Glowing Grey');
xadd3('Glowing Grey 2');
xadd3('Glowing Grey 3');
xadd3('Glowing Grey 4');
xadd3('Jovial Mauve');
xadd3('Jovial Mauve 2');
xadd3('Jovial Mauve 3');
xadd3('Luscious Lilac');
xadd3('Luscious Lilac 2');
xadd3('Luscious Lilac 3');
xadd3('Luscious Lilac 4');
xadd3('Slinky Pink');
xadd3('Slinky Pink 2');
xadd3('Slinky Pink 3');
xadd3('Rosebud Pink');
xadd3('Rosebud Pink 2');
xadd3('Silky Sand');
xadd3('Silky Sand 2');
xadd3('Silky Sand 3');
xadd3('Silky Sand 4');
xadd3('Really Red');
xadd3('Really Red 2');
xadd3('Really Red 3');
xadd3('Robust Red');
xadd3('Robust Red 2');
xadd3('Robust Red 3');
xadd3('Red');
xadd3('Red 2');
xadd3('Red 3');
xadd3('Red 4');
xadd3('Red 5');
xadd3('Red 6');
xadd3('Peach');
xadd3('Peach 2');
xadd3('Peach 3');
xadd3('Radiant Yellow');
xadd3('Radiant Yellow 2');
xadd3('Tangy Tangerine');
xadd3('Tangy Tangerine 2');
xadd3('Tangy Tangerine 3');
xadd3('Wild White');
xadd3('Wild Thing');
xadd3('Wild Thing 2');
xadd3('Wild Thing 3');
xadd3('Wild Thing 4');
xadd3('Black');
xadd3('Black 2');
xadd3('White');
xadd3('White 2');
xadd3('Blue');
xadd3('Blue 2');
xadd3('Blue 3');
xadd3('Blue 4');
xadd3('Blue 5');
xadd3('Blue 6');
xadd3('Royal Blue');
xadd3('Royal Blue 2');
xadd3('Royal Blue 3');
xadd3('Royal Blue 4');
xadd3('Royal Blue 5');
xadd3('Pink');
xadd3('Pink 2');
xadd3('Satin Pink');//15mar2022
xadd3('Satin Pink 2');//15mar2022
xadd3('Satin Pink 3');//15mar2022
xadd3('Satin Pink 4');//15mar2022
xadd3('Wild Mix');
xadd3('Wild Mix 2');
xadd3('Wild Mix 3');
xadd3('Wild Mix 4');
//.purple - 07jun2022
xadd3('Purple');
xadd3('Purple 2');
xadd3('Purple 3');
xadd3('Purple 4');
xadd3('Purple 5');
xadd3('Purple 6');
xadd3('Purple 7');
xadd3('Purple 8');
xadd3('Purple 9');
//.brown - 12jun2022
xadd3('Brown');
xadd3('Brown 2');
xadd3('Brown 3');
xadd3('Brown 4');
xadd3('Brown 5');
xadd3('Brown 6');//21jun2022
xadd3('Brown 7');//21jun2022
xadd3('Brown 8');//21jun2022
xadd3('Brown 9');//21jun2022

//.finialise
xaddall3(true);
badd('Pasted from Clipboard','paste_and_use');//27mar2022

//custom
baddtitle('Custom');
if (ishowoptions_list<>nil) then ishowoptions_list.onumberfrom2:=bcount;
for p:=0 to (cnCustomLimit-1) do badd('Custom '+inttostr(1+p),'custom'+inttostr(p));
//files
baddtitle('Saved');
if (ishowoptions_list<>nil) then ishowoptions_list.onumberfrom3:=bcount;

low__navlist(a,nlName,low__platfolder('schemes'),'*.'+cnFileEXT,'',false,false,true);
for p:=0 to maxint do
begin
case low__navget(a,p,xstyle,xtep,xsize,xname,xlabel) of
true:begin
   if xonce then xonce:=false;
   xname:=remlastext(xname);
   if (xname<>'') then badd2(xname,xname);//exclude ".bcs" as this is "<nil>" when extension is stripped which is same as default color scheme - 13apr2021
   end;
false:break;
end;
end;//p
if xonce then badd2('(none)','none');//"?none"

//finalise
low__menuend(b);
//set
if zzok(ishowoptions_list,7100) then
   begin
   ishowoptions_list.data:=b;
   if (ishowoptions_list.oloadfromname<>'') then ishowoptions_list.reload;
   end;


//-- frame ---------------------------------------------------------------------
if (ishowoptions_frames<>nil) and (ishowoptions_frames.data.len<=0) then
   begin
   //init
   a.clear;
   b.clear;
   c.clear;
   xincludeQuerymark:=false;
   xcurrentTEP:=tepFrame20;
   xhelp:='Select frame';
   xonce:=true;
   low__menuinit(b);
   //internal
   xadd('Default');
   if (system_framecount>=1) then
      begin
      for p:=0 to (system_framecount-1) do xadd3(system_framename[p]);
      end;
   xaddall3(true);

   //finalise
   low__menuend(b);
   //set
   ishowoptions_frames.data:=b;
   end;
if (ishowoptions_frames<>nil) and (ishowoptions_frames.oloadfromname<>'') then ishowoptions_frames.reload;

except;end;
try
freeobj(@a);
freeobj(@b);
freeobj(@c);
except;end;
end;
//## xshowoptions_timer ##
procedure tbasicsystem.xshowoptions_timer(sender:tobject);
begin
try
//timer100
if (ms64>=ishowoptions_timer100) then
   begin
   //get
   if zzok(ishowoptions_cols,7101) then ishowoptions_cols.vis[1]:=low__comparetext(strcopy1(vicolorname,1,7),'?custom') or (not low__comparetext(strcopy1(vicolorname,1,1),'?'));

   //reset
   ishowoptions_timer100:=ms64+100;
   end;
//timer500
if (ms64>=ishowoptions_timer500) then
   begin
   //paste and use - 27mar2022
   if zzok(ishowoptions_toolbar_colors,9999) then
      begin
      ishowoptions_toolbar_colors.benabled2['options.pastecols']:=low__canpastetxt;
      ishowoptions_toolbar_colors.bvisible2['options.brighten']:=low__comparetext(vicolorname,'?paste_and_use');
      ishowoptions_toolbar_colors.bvisible2['options.darken']:=low__comparetext(vicolorname,'?paste_and_use');
      end;
   //reset
   ishowoptions_timer500:=ms64+500;
   end;
except;end;
end;
//## xshowoptions_showmenu ##
procedure tbasicsystem.xshowoptions_showmenu(sender:tobject);
begin
try;xshowoptions_sync2(sender,'options.menu',false);except;end;
end;
//## xshowoptions_click ##
procedure tbasicsystem.xshowoptions_click(sender:tobject);
begin
try;xshowoptions_sync2(sender,'',true);except;end;
end;
//## xshowoptions_sync ##
procedure tbasicsystem.xshowoptions_sync(sender:tobject);
begin
try;xshowoptions_sync2(sender,'',false);except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//ssssssssssssssss
//## xshowoptions_sync2 ##
procedure tbasicsystem.xshowoptions_sync2(sender:tobject;xname:string;xclicked:boolean);
label
   skipend;
var
   str1,str2,e,n,v:string;
   p,int1,int2:longint;
   bol1:boolean;
   aset:tbasicset;//pointer only
   a:tbasiccontrol;
   //## xoptions_menu ##
   procedure xoptions_menu(xcode2:string);
   var
      b,m:tstr8;
      xcode,xtepcolor:longint;
      bol1,bol2:boolean;
   begin
   try
   //defaults
   m:=nil;
   b:=nil;
   //init
   if (xcode2='') then
      begin
      m:=bnew;
      bol1:=low__comparetext(strcopy1(vicolorname,1,7),'?custom') or (not low__comparetext(strcopy1(vicolorname,1,1),'?'));
      bol2:=low__canpastetxt;
      low__menuinit(m);
      low__menutitle(m,tepNone,'Color Schemes - Options','Color options');
      low__menuitem2(m,tepCopy20,'Copy',rthtranslate('Copy color scheme to clipboard as plain text'),'copy',100,aknone,true);
      low__menuitem2(m,tepPaste20,'Paste and Use',rthtranslate('Paste color scheme from Clipboard and use'),'pasteuse',100,aknone,bol2);//27mar2022
      //was: low__menuitem2(m,tepPaste20,'Paste and Use - Brighten Colors',rthtranslate('Paste color scheme from Clipboard and brighten colors and use'),'pasteuse2',100,aknone,bol2);//18sep2022
      low__menuitem2(m,tepPaste20,'Paste Replace...',rthtranslate('Paste color scheme from Clipboard and overwrite current'),'paste',100,aknone,bol1 and bol2);//14mar2021
      low__menuitem2(m,tepPaste20,'Paste New...',rthtranslate('Paste color scheme from Clipboard and save to file'),'pastenew',100,aknone,bol2);//14mar2021
      low__menusep(m);
      low__menuitem2(m,tepRefresh20,'Refresh','Refresh Color Schemes list','refresh',100,aknone,true);
      low__menuitem2(m,tepSave20,'Save As...','Save Color Scheme to file','save',100,aknone,true);
      low__menuitem2(m,tepFolder20,'Show Folder','Show Color Schemes folder','folder',100,aknone,true);
      low__menuend(m);
      end;
   //get
   if (xcode2<>'') or popmenu(pmNormal,iaNormal,m,xcode,xcode2,xtepcolor) then
      begin
      if      (xcode2='refresh') then xshowoptions_reload
      else if (xcode2='copy') and zzok(ishowoptions_colors,7103)  then ishowoptions_colors.tosys('?copy.hex',false)
      else if (xcode2='pasteuse') and zzok(ishowoptions_colors,7104) then ishowoptions_colors.tosys('?pasteuse.hex',true)
      else if (xcode2='pasteuse2') and zzok(ishowoptions_colors,7104) then ishowoptions_colors.tosys('?pasteuse2.hex',true)
      else if (xcode2='brighten') and zzok(ishowoptions_colors,7104) then ishowoptions_colors.tosys('?brighten.hex',true)
      else if (xcode2='darken') and zzok(ishowoptions_colors,7104) then ishowoptions_colors.tosys('?darken.hex',true)
      else if (xcode2='paste') and zzok(ishowoptions_colors,7104) then ishowoptions_colors.tosys('?paste.hex',true)
      else if (xcode2='pastenew') and zzok(ishowoptions_colors,7104) then ishowoptions_colors.tosys('?pastenew.hex',true)
      else if (xcode2='folder') then runlow(low__platfolder('schemes'),'')
      else if (xcode2='save') then
         begin
         if (sysfile_colorscheme='') then sysfile_colorscheme:=low__platfolder('schemes')+'Untitled.'+cnFileEXT;
         if popsave(sysfile_colorscheme,pebcs,low__platfolder('schemes')) then
            begin
            b:=bnew;
            b.text:=low__getcolors(@vinormal,@vititle,@vimorecolors);//25may2021
            case low__tofile(sysfile_colorscheme,b,e) of
            false:poperror(e);
            true:xshowoptions_reload;
            end;//case
            end;
         end;
      end;
   except;end;
   try
   bfree(m);
   bfree(b);
   except;end;
   end;
begin
try
//defaults
n:='';
v:='';
str1:='';
//init
xname:=low__lowercase(xname);
//get
if      (xname='options.menu') then xoptions_menu('')
else if zznil(sender,7407) then goto skipend//04may2021
else if (sender is tbasicmenu) then
   begin
   n:=(sender as tbasicmenu).tagstr;
   v:=(sender as tbasicmenu).ocode2;
   if zzok(syssettings,7105) then
      begin
      if (n='colorname') or (n='fontname') or (n='fontname2') or (n='framename') then//24feb2022
         begin
         syssettings.value[n]:=v;
         vimustsync:=true;
         end;
      end;
   end
else if (sender is tbasictick) then
   begin
   n:=(sender as tbasictick).tagstr;
   bol1:=(sender as tbasictick).value;
   if zzok(syssettings,7106) then
      begin
      syssettings.b[n]:=bol1;
      vimustsync:=true;
      end;
   end
else if (sender is tbasicint) then
   begin
   n:=(sender as tbasicint).tagstr;
   int1:=(sender as tbasicint).val;
   if zzok(syssettings,7107) then
      begin
      syssettings.i[n]:=int1;
      vimustsync:=true;
      end;
   end
else if (sender is tbasicset) then
   begin
   //init
   n:=(sender as tbasicset).tagstr;
   aset:=(sender as tbasicset);
   //get
   if zzok(syssettings,7108) then
      begin
      for p:=0 to maxint do
      begin
      case (aset.caps[p]<>'') of
      true:if (aset.nams[p]<>'') then syssettings.b[aset.nams[p]]:=aset.vals[p];
      false:break;
      end;//case
      end;//p
      vimustsync:=true;
      end;
   end
else if (sender is tbasicsel) then
   begin
   n:=(sender as tbasicsel).tagstr;
   int1:=(sender as tbasicsel).val;
   if zzok(syssettings,7109) then
      begin
      if (n='fontsize') or (n='fontsize2')then//26feb2022
         begin
         int2:=int1;
         case int2 of
         0:int1:=6;
         1:int1:=8;
         2:int1:=9;
         3:int1:=10;
         4:int1:=11;
         5:int1:=12;
         6:int1:=14;
         7:int1:=16;
         8:int1:=22;
         9:int1:=24;
         else int1:=8;
         end;//case
         end
      else if (n='fontname') or (n='fontname2') then
         begin
         str1:=(sender as tbasicsel).nams[int1];
         if xclicked and (str1='*') then
            begin
            if (sender as tbasicsel).wasselected then
               begin
               str2:=syssettings.s[n+'.c'];
               if popfont(str2) then syssettings.s[n+'.c']:=str2 else goto skipend;
               end
            else goto skipend;
            end;
         end
      else if (n='cursorname') then
         begin
         str1:=(sender as tbasicsel).nams[int1];//29aug2021
         if low__comparetext(str1,'custom') and low__comparetext(str1,syscursor_name) and (sender as tbasicsel).focused and (sender as tbasicsel).gui.mouseupstroke then str1:='custom.prompt'
         else if low__comparetext(str1,syscursor_name) then goto skipend;
         end
      else if (n='zoom') then
         begin
         //as is
         end;
      //set
      if (str1<>'') then
         begin
         if (n='cursorname') then low__setcursor((sender as tbasicsel).gui,str1,nil)//29aug2021
         else syssettings.s[n]:=str1;
         end
      else syssettings.i[n]:=int1;
      vimustsync:=true;
      end;
   end
else if (sender is tbasictoolbar) then
   begin
   int1:=(sender as tbasictoolbar).ocode;
   str1:=low__lowercase((sender as tbasictoolbar).ocode2);
   if (str1='defaults') then xdefaults
   else if (str1='options.menu') then xoptions_menu('')
   else if (str1='options.copycols') then xoptions_menu('copy')
   else if (str1='options.pastecols') then xoptions_menu('pasteuse')//27mar2022
   else if (str1='options.pastecols2') then xoptions_menu('pasteuse2')//18sep2022
   else if (str1='options.brighten') then xoptions_menu('brighten')//18sep2022
   else if (str1='options.darken') then xoptions_menu('darken');//18sep2022
   end;

//cross value sync - 26feb2022
ishowoptions_crosssync:=true;
//was: if (sender=ishowoptions_options) or (sender=ishowoptions_frameoptions) then ishowoptions_crosssync:=true;
skipend:
except;end;
end;
//## xshowoptions_crosssync ##
procedure tbasicsystem.xshowoptions_crosssync;
begin
try
//special cross-control update -> when one control has another's value and thus both might need to reload to relfect that cross-control change - 26feb2022
if (ishowoptions_framesize1<>nil) and (ishowoptions_framesize2<>nil) then
   begin
   ishowoptions_framesize1.reload;
   ishowoptions_framesize2.reload;
   ishowoptions_framesize1.ovalunit:=low__insstr('  (Best viewed at '+low__64(viFrameminsize)+'+)',(viFrameminsize>=1) and (viFrameminsize>viBordersize));
   ishowoptions_framesize2.ovalunit:=ishowoptions_framesize1.ovalunit;
   end;
if (ishowoptions_sparkle1<>nil) and (ishowoptions_sparkle2<>nil) then
   begin
   ishowoptions_sparkle1.reload;
   ishowoptions_sparkle2.reload;
   end;

{was:
if (ishowoptions_options<>nil) and (ishowoptions_frameoptions<>nil) then
   begin
   ishowoptions_frameoptions.reload;
   ishowoptions_options.reload;
   end;
{}//xxxxx
except;end;
end;
//## xshowhelp ##
procedure tbasicsystem.xshowhelp;
begin
try;low__plat('showhelp','',false);except;end;
end;
//## xdefaults ##
procedure tbasicsystem.xdefaults;
begin
try
//prompt
if not popquery2('Restore default settings?','','Restore Defaults',false) then exit;
//get
low__setcursor(nil,'default',nil);
siLoadsyssettingsfrom(nil);
except;end;
end;
//## xdefaultzoom ##
procedure tbasicsystem.xdefaultzoom;
begin
try
//prompt
//was: if not popquery2('Restore default zoom?','','Restore Zoom',false) then exit;
//get
syssettings.i['zoom']:=0;
//sync
viSync;
//save
siSavesyssettings;//only need to save system settings here - 05oct2020
except;end;
end;
//## setfullscreen ##
procedure tbasicsystem.setfullscreen(x:boolean);
begin
try
if stable and (x<>fullscreen) then
   begin
   case x of
   true:gstate:=gsMax;
   false:gstate:=gsNormal;
   end;//case
   end;
except;end;
end;
//## xmaximised ##
function tbasicsystem.xmaximised:boolean;
begin
try
//defaults
result:=false;
//check
if not stable then exit;
//get
if viwine then result:=iwinemaximised
else           result:=(ihost.windowstate=wsMaximized);
except;end;
end;
//## xnormal ##
function tbasicsystem.xnormal:boolean;
begin
try
//defaults
result:=false;
//check
if not stable then exit;
//get
if viwine then result:=not iwinemaximised
else           result:=(ihost.windowstate=wsNormal);
except;end;
end;
//## xsetNM ##
procedure tbasicsystem.xsetNM(xmax:boolean);//set normal/maximised
   //## xwinearea ##
   procedure xwinearea;
   begin
   inormalarea.left:=ihost.left;
   inormalarea.top:=ihost.top;
   inormalarea.right:=ihost.left+ihost.width-1;
   inormalarea.bottom:=ihost.top+ihost.height-1;
   end;
begin
try
//check
if not stable then exit;
//get
//.maximise
if xmax then
   begin
   if viwine then
      begin
      if not iwinemaximised then
         begin
         ihost.windowstate:=wsNormal;
         xwinearea;
         iwinemaximised:=true;
         end
      end
   else if (ihost.windowstate<>wsMaximized) then
      begin
      xwinearea;
      iwinemaximised:=true;
      ihost.windowstate:=wsMaximized;
      end;
   end
//.normal
else
   begin
   if viwine then
      begin
      if iwinemaximised then
         begin
         ihost.windowstate:=wsNormal;
         iwinemaximised:=false;
         ihost.setbounds(inormalarea.left,inormalarea.top,inormalarea.right-inormalarea.left+1,inormalarea.bottom-inormalarea.top+1);
         end
      end
   else if (ihost.windowstate<>wsNormal) then
      begin
      iwinemaximised:=false;
      ihost.windowstate:=wsNormal;
      end;
   end;
except;end;
end;
//## getfullscreen ##
function tbasicsystem.getfullscreen:boolean;
begin
try;result:=xmaximised;except;end;
end;
//## xsyncfullscreen ##
procedure tbasicsystem.xsyncfullscreen;
var
   a:trect;
begin
try
//check
if (not stable) or (not xmaximised) then exit;
//get
if omax_entirescreen then a:=misscreenarea else a:=misworkarea;
//.fixed 05feb2022
if (ihost.left<>a.left) or (ihost.top<>a.top) or (ihost.width<>(a.right-a.left+1)) or (ihost.height<>(a.bottom-a.top+1)) then ihost.setbounds(a.left,a.top,a.right-a.left+1,a.bottom-a.top+1);
except;end;
end;
//## curpos ##
function tbasicsystem.curpos:tpoint;//our internal cursor position (within the system area only) - 21may2020
var
   a,b:tpoint;
begin
try
b:=clienttoscreen(low__point(0,0));
low__getcursorpos(a);
result.x:=a.x-b.x;
result.y:=a.y-b.y;
except;end;
end;
//## downcurpos ##
function tbasicsystem.downcurpos:tpoint;//our internal cursor position (within the system area only) - 21may2020
var
   a,b:tpoint;
begin
try
b:=clienttoscreen(low__point(0,0));
low__getcursordownpos(a);
result.x:=a.x-b.x;
result.y:=a.y-b.y;
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxx//ssssssssssssssssssss
//## showing ##
function tbasicsystem.showing:boolean;//works under Win7 - 01FEB2011
begin
try
//defaults
result:=false;
//get
{$ifdef D3}
if zzok(ihost,7110) then result:=iswindowvisible(ihost.handle);
{$endif}
{$ifdef D10}
result:=true;//xxxxxxxxxxxxxxxxxx//???????????????????
{$endif}
except;end;
end;
//## getmaskval ##
function tbasicsystem.getmaskval:longint;
begin
try;if imasking then result:=imaskval else result:=-1;except;end;
end;
//## mustmask ##
function tbasicsystem.mustmask:boolean;
var
   i,p:longint;
begin
try
//defaults
result:=false;
//check
if (winlist.count<=1) then exit;//only required if 2 or more windows
//get
//.dimensions
if (not result) and ((imask.width<>ibuffer.width) or (imask.height<>ibuffer.height)) then result:=true;
//.count
if (not result) and (winmask_cnt<>winlist.count) then result:=true;
//.visual values
if (not result) then
   begin
   for p:=0 to (winlist.count-1) do
   begin
   i:=winlist.list[p];
   if (i>=0) and (i<icorecount) and zzok(icore[i],7111) and ((winmask_id[p]<>icore[i].id) or (winmask_aid[p]<>icore[i].aid) or (winmask_vis[p]<>icore[i].visible) or (winmask_rnd[p]<>icore[i].rounded)) then
      begin
      result:=true;
      break;
      end;
   end;//p
   end;
except;end;
end;
//## dragstart ##
procedure tbasicsystem.dragstart(xcoreindex:longint);
begin
try
if (idragindex=-1) and xvisible(xcoreindex) and (icore[xcoreindex].winstyle>wmfullwin) then
   begin
//dbstatus(1,'Drag-started: '+ms64str);//xxxxxxxxxxxxxxxxxxxx
   sizestop;
   satinc(satDragstart,1);
   idragindex:=xcoreindex;
   idragstart:=xcoreindex;
   paintallnow;
   end;
except;end;
end;
//## dragstart_fullwin ##
procedure tbasicsystem.dragstart_fullwin;//this relates to external OS only and NOT to our internal system - 15apr2021
begin
try
idragging_fullwin:=true;
except;end;
end;
//## dragstop ##
procedure tbasicsystem.dragstop;
var
   xmustpaint:boolean;
begin
try
//init
xmustpaint:=false;
//get
if (idragindex>=0) then
   begin
   idragindex:=-1;
   idragstart:=-1;
   xmustpaint:=true;
   end;
if idragging_fullwin then
   begin
   idragging_fullwin:=false;
   xmustpaint:=true;
   end;
//set
if xmustpaint then paintallnow;
except;end;
end;
//## sizestart ##
procedure tbasicsystem.sizestart(xcoreindex:longint);
begin//Note: sizing=0=off, 1=resizing MAIN window, 2=resizing all other window types - 22apr2022
try
if (isizeindex=-1) and xvisible(xcoreindex) then
   begin
   if (isizing<1) then isizing:=1;//22apr2022
   if (icore[xcoreindex].winstyle>wmfullwin) then
      begin
      dragstop;
      satinc(satSizestart,1);
      isizeindex:=xcoreindex;
      isizestart:=xcoreindex;
      isizing:=2;
      paintallnow;
      end;
   end;
except;end;
end;
//## sizestop ##
procedure tbasicsystem.sizestop;
begin
try
if (isizeindex>=0) then
   begin
   isizeindex:=-1;
   isizestart:=-1;
   paintallnow;
   end;
isizing:=0;
except;end;
end;
//## resizing ##
function tbasicsystem.resizing:boolean;
begin
try;result:=(isizing>=1);except;end;
end;
//## xdlg ##
function tbasicsystem.xdlg(var x:tbasiccontrol):boolean;
var
   p,i:longint;
begin
try
//defaults
result:=false;
x:=nil;
//find
if (winlist.count>=1) then
   begin
   for p:=(winlist.count-1) downto 0 do
   begin
   i:=winlist.list[p];
   if xinuse(i) and (icore[i].winstyle=wmdialog) and icore[i].visible then
      begin
      x:=icore[i];
      result:=true;
      break;
      end;
   end;//p
   end;
except;end;
end;
//## xwinfindlayer ##
function tbasicsystem.xwinfindlayer(xcoreindex:longint;var xlayer:longint):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
xlayer:=-1;//not found
//find
if (xcoreindex>=0) and (xcoreindex<icorecount) and (winlist.count>=1) then
   begin
   for p:=0 to (winlist.count-1) do if (xcoreindex=winlist.list[p]) then
      begin
      xlayer:=p;
      result:=true;
      break;
      end;//p
   end;
except;end;
end;
//## xwinfindbyxy ##
function tbasicsystem.xwinfindbyxy(sx,sy:longint;var xcoreindex,xwinlayer:longint):boolean;
var
   p,i:longint;
begin
try
//defaults
result:=false;
xcoreindex:=0;
xwinlayer:=0;
//check
if (winlist.count<=0) then exit;
//find
for p:=(winlist.count-1) downto 0 do
begin
i:=winlist.list[p];
if xinuse(i) and (icore[i].winstyle>wmcontrol) and icore[i].visible then
   begin
   if (sx>=icore[i].paintarea.left) and (sx<=icore[i].paintarea.right) and (sy>=icore[i].paintarea.top) and (sy<=icore[i].paintarea.bottom) then
      begin
      xcoreindex:=i;
      xwinlayer:=p;
      result:=true;
      break;
      end;
   //.dialog -> go no further than topmost dialog
   if (icore[i].winstyle=wmdialog) then break;
   end;
end;//p
except;end;
end;
//## xfindwinname ##
function tbasicsystem.xfindwinname(xwinname:string;var x:tbasicscroll):boolean;
var
   p,i:longint;
begin
try
//defaults
result:=false;
x:=nil;
//find
if (winlist.count>=1) then
   begin
   for p:=(winlist.count-1) downto 0 do
   begin
   i:=winlist.list[p];
   if xinuse(i) and zzok(icore[i],7408) and (icore[i] is tbasicscroll) and low__comparetext(xwinname,icore[i].owinname) then
      begin
      x:=icore[i] as tbasicscroll;
      result:=true;
      break;
      end;
   end;//p
   end;
except;end;
end;
//## xacceptfindbyxy ##
function tbasicsystem.xacceptfindbyxy(sx,sy:longint;var xout:tbasiccontrol):boolean;//updated - 20mar2022
var
   p2,p,i:longint;
begin
try
//defaults
result:=false;
xout:=nil;
//check
if (winlist.count<=0) then exit;
//find window
for p:=(winlist.count-1) downto 0 do
begin
i:=winlist.list[p];
if xinuse(i) and (icore[i].winstyle>wmcontrol) then
   begin
   //.a window to be searched
   if (sx>=icore[i].paintarea.left) and (sx<=icore[i].paintarea.right) and (sy>=icore[i].paintarea.top) and (sy<=icore[i].paintarea.bottom) then
      begin
      //.search EVERY control in the SYSTEM and look at those on the CURRENT window being searched - slower, BUT simple and accurate - 20mar2022
      for p2:=(icorecount-1) downto 0 do
      begin
      if xinuse(p2) and (p2<>i) and (icore[p2]<>nil) and (icore[p2].winstyle=wmcontrol) and (sx>=icore[p2].paintarea.left) and (sx<=icore[p2].paintarea.right) and (sy>=icore[p2].paintarea.top) and (sy<=icore[p2].paintarea.bottom) and (icore[i]=icore[p2].rootparent) and icore[p2].canaccept then
         begin
         xout:=icore[p2];
         result:=true;
         break;
         end;
      end;//p2
      //.now check the window itself LAST - 20mar2022
      if (not result) and icore[i].canaccept then
         begin
         xout:=icore[i];
         result:=true;
         end;
      end;
   //check
   if result then break;
   //.dialog -> go no further than topmost dialog
   if (icore[i].winstyle=wmdialog) then break;
   end;
end;//p
except;end;
end;
//## xwintop ##
procedure tbasicsystem.xwintop(x:tbasiccontrol);
begin
try;xwinadd(x,'t');except;end;
end;
//## xwinbot ##
procedure tbasicsystem.xwinbot(x:tbasiccontrol);
begin
try;xwinadd(x,'b');except;end;
end;
//## xwinnil ##
procedure tbasicsystem.xwinnil(x:tbasiccontrol);
begin
try;xwinadd(x,'n');except;end;
end;
//## xwinadd ##
procedure tbasicsystem.xwinadd(x:tbasiccontrol;xstyle:char);
var
   dv:twinlist;
   b:tbasiccontrol;
   i,p,xcount:longint;
   bol1,xbot,xtop,xonce:boolean;
   //## xadd ##
   procedure xadd(xwinstyle:longint);
   var
      xlist:twinlist;
      p:longint;
   begin
   //init
   xlist.count:=0;
   //get
   //.bot
   if (not xonce) and xbot and zzok(x,7112) and (x.winstyle=xwinstyle) and (xlist.count<iwinlimit) then
      begin
      inc(xlist.count);
      xlist.list[xlist.count-1]:=x.coreindex;
      xonce:=true;
      end;
   //.del - 14may2020 @ 12.11am!!!
   if (winlist.count>=1) then
      begin
      for p:=0 to (winlist.count-1) do
      begin
      i:=winlist.list[p];
      if xinuse(i) and (icore[i].winstyle=xwinstyle) and (xlist.count<iwinlimit) then
         begin
         if zzok(x,7113) and (i=x.coreindex) and (xbot or xtop or xonce) then
            begin
            //window already handled or set to be handled
            end
         else
            begin
            inc(xlist.count);
            xlist.list[xlist.count-1]:=i;
            if zzok(x,7114) and (i=x.coreindex) then xonce:=true;
            end;
         end;//i
      end;//p
      end;
   //.top -> force top or add at top of this stack if not already existent in stack - 14may2020
   if ((not xonce) or xtop) and zzok(x,7115) and (x.winstyle=xwinstyle) and (xlist.count<iwinlimit) then
      begin
      inc(xlist.count);
      xlist.list[xlist.count-1]:=x.coreindex;
      xonce:=true;
      end;
   //set
   if (xlist.count>=1) then
      begin
      for p:=0 to (xlist.count-1) do
      begin
      if (dv.count<iwinlimit) then
         begin
         inc(dv.count);
         dv.list[dv.count-1]:=xlist.list[p];
         end
      else break;
      end;//p
      end;
   end;
begin
try
//init
xbot:=(xstyle='b');
xtop:=(xstyle='t');
xonce:=false;
dv.count:=0;

//get
xadd(wmFullwin);
xadd(wmWindow);
xadd(wmOntop);
xadd(wmDialog);

//set
bol1:=false;
if (winlist.count<>dv.count) then bol1:=true
else if (winlist.count>=1) then
   begin
   for p:=0 to (winlist.count-1) do if (winlist.list[p]<>dv.list[p]) then
      begin
      bol1:=true;
      break;
      end;//p
   end;
winlist:=dv;
//.list has changed -> update
if bol1 then
   begin
   alignallnow;
   paintallnow;
   end;
except;end;
end;
//## stable ##
function tbasicsystem.stable:boolean;
begin
try;result:=(not icreating) and (not idestroying) and zzok(ihost,7116) and zzok(ibuffer,7117) and zzok(idragbuffer,7118);except;end;
end;
//## __onmousedown ##
procedure tbasicsystem.__onmousedown(sender:tobject;button:tmousebutton;shift:tshiftstate;x,y:longint);
var
   int1:byte;
begin
try
//check
low__resetclicktime;//03apr2021
if not stable then exit;
xwaitfocus;//03apr2021
//init
if      (button=mbLeft)   then int1:=1
else if (button=mbMiddle) then int1:=2
else if (button=mbRight)  then int1:=3
else                           int1:=1;//assume left button
//check
if (imousebuttonlock=-1) then imousebuttonlock:=int1 else exit;
//get
low__mouse2(sender,'d',x,y);
aadd('d',int1,x,y);
except;end;
end;
//## __onmouseup ##
procedure tbasicsystem.__onmouseup(sender:tobject;button:tmousebutton;shift:tshiftstate;x,y:longint);
var
   int1:byte;
begin
try
//check
low__resetclicktime;//03apr2021
if not stable then exit;
xwaitfocus;//03apr2021
//init
if      (button=mbLeft)   then int1:=1
else if (button=mbMiddle) then int1:=2
else if (button=mbRight)  then int1:=3
else                           int1:=1;//assume left button
//check
if (imousebuttonlock=-1) or (int1<>imousebuttonlock) then exit;
//get
low__mouse2(sender,'u',x,y);
aadd('u',int1,x,y);
except;end;
try;imousebuttonlock:=-1;except;end;//off
end;
//## __onmousemove ##
procedure tbasicsystem.__onmousemove(sender:tobject;shift:tshiftstate;x,y:longint);
begin
try
//check
if not stable then exit;
//note: sometimes (rarely) Windows will send continous "mousemove" messages with the same "x,y" values - this is a fix to prevent us accepting those dummy messages - 07mar2022
if (x=ilastmousemovecheckx) and (y=ilastmousemovechecky) then exit;
//wound
xwoundcalc(x,y);
//get
ilastmousemovecheckx:=x;
ilastmousemovechecky:=y;
low__resetmovetime;//03apr2021
low__mouse2(sender,'m',x,y);
aadd('m',0,x,y);
except;end;
end;
//## xwoundcalc ##
procedure tbasicsystem.xwoundcalc(x,y:longint);
const
   xlagfactor=3;
var
   diry:longint;
   //## xmakerate ##
   function xmakerate(xref:comp;xlen:longint):longint;//pixels per second -> 0..1,000
   var
      v,l:longint;
   begin
   try
   //defaults
   result:=0;
   //get
   v:=frcrange(low__sub32(ms64,xref),1,3000);
   l:=frcrange(low__posn(xlen),0,1000);
   //set
   result:=frcrange(round(l*(1000/v)),0,1000);
   except;end;
   end;
begin
try
//y
iwoundratey:=frcrange(((iwoundratey*xlagfactor)+xmakerate(iwoundref,y-iwoundlasty)) div (xlagfactor+1),0,iwoundratelimit);
iwounddiry:=low__aorb(-1,1,y>=iwoundlasty);
//x
iwoundratex:=frcrange(((iwoundratex*xlagfactor)+xmakerate(iwoundref,x-iwoundlastx)) div (xlagfactor+1),0,iwoundratelimit);
iwounddirx:=low__aorb(-1,1,x>=iwoundlastx);
//reset
iwoundref:=ms64;
iwoundlastx:=x;
iwoundlasty:=y;
except;end;
end;
//## woundratextime ##
function tbasicsystem.woundratextime(xmaxtime:longint;xincludedir:boolean):longint;
begin
try;result:=round(xmaxtime*woundratexpert1)*low__aorb(1,-1,xincludedir and (iwounddirx<0));except;end;
end;
//## woundrateytime ##
function tbasicsystem.woundrateytime(xmaxtime:longint;xincludedir:boolean):longint;
begin
try;result:=round(xmaxtime*woundrateypert1)*low__aorb(1,-1,xincludedir and (iwounddiry<0));except;end;
end;
//## woundratexpert1 ##
function tbasicsystem.woundratexpert1:extended;
begin
try;result:=(iwoundratex/iwoundratelimit);except;end;
end;
//## woundrateypert1 ##
function tbasicsystem.woundrateypert1:extended;
begin
try;result:=(iwoundratey/iwoundratelimit);except;end;
end;
//## woundratexpert100 ##
function tbasicsystem.woundratexpert100:longint;
begin
try;result:=frcrange(round(woundratexpert1*100),0,100);except;end;
end;
//## woundrateypert100 ##
function tbasicsystem.woundrateypert100:longint;
begin
try;result:=frcrange(round(woundrateypert1*100),0,100);except;end;
end;
//## __onkeydown ##
procedure tbasicsystem.__onkeydown(sender:tobject;var key:word;shift:tshiftstate);
var
   int1:longint;
begin
try
low__resetkeytime;//03apr2021
low__mousefine_turnon(ssshift in shift);
if low__keyboard2('d',key,(ssshift in shift),(ssctrl in shift),(ssalt in shift),int1,ikeyboardlaststate) then aadd('k',0,int1,0);
except;end;
end;
//## __onkeyup ##
procedure tbasicsystem.__onkeyup(sender:tobject;var key:word;shift:tshiftstate);
var
   int1:longint;
begin
try
low__resetkeytime;//03apr2021
low__mousefine_turnon(ssshift in shift);
if low__keyboard2('u',key,(ssshift in shift),(ssctrl in shift),(ssalt in shift),int1,ikeyboardlaststate) then aadd('k',0,int1,0);
except;end;
end;
//## __onkeypress ##
procedure tbasicsystem.__onkeypress(sender:tobject;var key:char);
var
   int1:longint;
begin
try
low__resetkeytime;//03apr2021
if low__keyboard2('k',ord(key),false,false,false,int1,ikeyboardlaststate) then aadd('k',0,int1,0);
except;end;
end;
//## __onshow ##
procedure tbasicsystem.__onshow(sender:tobject);
begin
try

except;end;
end;
//## __onresize ##
procedure tbasicsystem.__onresize(sender:tobject);
begin
try
//check
if not stable then exit;
//get
xsyncfullscreen;
sizenow;
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxx//ssssssssssssssssssssss
//## ppincludearea ##
procedure tbasicsystem.ppincludearea(xpaintarea:trect);//part-paint include area
begin
try
//check
if (not ipaintingpart) or (xpaintarea.right<xpaintarea.left) or (xpaintarea.bottom<xpaintarea.top) or (xpaintarea.right<0) or (xpaintarea.bottom<0) or (xpaintarea.left>=iwidth) or (xpaintarea.top>=iheight) then exit;
//range
xpaintarea.left:=frcrange(xpaintarea.left,0,iwidth-1);
xpaintarea.top:=frcrange(xpaintarea.top,0,iheight-1);
xpaintarea.right:=frcrange(xpaintarea.right,xpaintarea.left,iwidth-1);
xpaintarea.bottom:=frcrange(xpaintarea.bottom,xpaintarea.top,iheight-1);
//get
if not ipartpaintareaok then
   begin
   ipartpaintarea:=xpaintarea;
   ipartpaintareaok:=true;
   end
else
   begin
   if (xpaintarea.left<ipartpaintarea.left)     then ipartpaintarea.left:=xpaintarea.left;
   if (xpaintarea.top<ipartpaintarea.top)       then ipartpaintarea.top:=xpaintarea.top;
   if (xpaintarea.right>ipartpaintarea.right)   then ipartpaintarea.right:=xpaintarea.right;
   if (xpaintarea.bottom>ipartpaintarea.bottom) then ipartpaintarea.bottom:=xpaintarea.bottom;
   end;
except;end;
end;
//## xareaongui ##
function tbasicsystem.xareaongui(x:trect):boolean;
begin
try;if (x.right<0) or (x.left>=iwidth) or (x.bottom<0) or (x.top>=iheight) or (x.right<x.left) or (x.bottom<x.top) then result:=false else result:=true;except;end;
end;
//## xareaseen ##
function tbasicsystem.xareaseen(sa:trect;xbeneathwindowlayer:longint):boolean;
const
   //Note: x/ypad for spacing out the required squares area below a rounded area - 22may2020
   xpad=3;
   ypad=5;
var
   i,p:longint;
   a:trect;
begin
try
//defaults
result:=false;
//check
if not xareaongui(sa) then exit;
//range
xbeneathwindowlayer:=frcrange(xbeneathwindowlayer,0,iwinlimit);
//quick check
if (winlist.count<=0) or (xbeneathwindowlayer>=winlist.count) then
   begin
   result:=true;
   exit;
   end;
//slow check
result:=true;
for p:=xbeneathwindowlayer to (winlist.count-1) do
begin
i:=winlist.list[p];
if xvisible(i) then
   begin
   a:=icore[i].paintarea;
   if xareaongui(a) then
      begin
      //.compare with rounded area using "xpad/ypad" compenstation
      if icore[i].rounded then
         begin
         if (a.left<=(sa.left-xpad)) and (a.right>=(sa.right+xpad)) and (a.top<=(sa.top-ypad)) and (a.bottom>=(sa.bottom+ypad)) then
            begin
            result:=false;
            break;
            end;
         end
      //.compare with square area directly
      else
         begin
         if (a.left<=sa.left) and (a.right>=sa.right) and (a.top<=sa.top) and (a.bottom>=sa.bottom) then
            begin
            result:=false;
            break;
            end;
         end;
      end;
   end;
end;//p
except;end;
end;

//## __onpaint ##
procedure tbasicsystem.__onpaint(sender:tobject);//28jul2020
label
   partpaint,fullpaint,done,skipend;
const
   xpartpaintlimit=10;
var//Note: -1=no paint, 0=full paint, 1..N=paint rects
   //.holds part-paint rects to be paint on screen
   pa:array[0..99] of trect;
   pacount:longint;
   //.other
   xdragpaintarea,ppa,sa,da:trect;
   sr8:pcolorrow8;
   srs8,drs8:pcolorrows8;
   sr24,dr24:pcolorrow24;
   sr32,dr32:pcolorrow32;
   sc24:tcolor24;
   sc32:tcolor32;
   int1,int2,xbits,xcount,xfn,tw,cw,ch,dx,dy,p,i:longint;
   xline:tstr8;
   xdrop_showing,bol1,xdragpaintareaok,xshowing,xdragfast,xmustmask,xlocked,xmustfull:boolean;
   xref,xref2:comp;//xxxxxxxxxxxxxxxxxx
   str1:string;
   //.drag and window support
   xdragindex,xdragstart,xdraglayer,xtoplayer,xwincount:longint;
   //## dfull0 ##
   procedure dfull0;
   begin
   if xareaseen(low__rect(0,0,cw-1,ch-1),0) then miscls(ibuffer,vinormal.background);
   app__fasttimer;//fasttimer - 07jul2021
   end;
   //## dfull1 ##
   procedure dfull1(xto:longint;xinclusive:boolean);
   var
      p,i:longint;
   begin
   //check
   if (xto<0) or (winlist.count<=0) then exit;
   //get
   for p:=0 to (winlist.count-1) do
   begin
   i:=winlist.list[p];
   if imasking then imaskval:=p+1;
   if (i=xto) then
      begin
      if xinclusive then
         begin
         icore[i].xpaint;
         app__fasttimer;//fasttimer - 07jul2021
         end;
      break;
      end
   else
      begin
      icore[i].xpaint;
      app__fasttimer;//fasttimer - 07jul2021
      end;
   end;//p
   end;
   //## dfull2 ##
   procedure dfull2(xfrom:longint;xinclusive:boolean);
   label
      skipone;
   var
      p,i:longint;
      xok:boolean;
   begin
   //check
   if (winlist.count<=0) or (xfrom>=icorecount) then exit;
   if (xfrom<0) then xfrom:=0;
   //get
   xok:=false;
   for p:=0 to (winlist.count-1) do
   begin
   i:=winlist.list[p];
   if imasking then imaskval:=p+1;
   if (not xok) and (i=xfrom) then
      begin
      xok:=true;
      if not xinclusive then goto skipone;
      end;
   if xok then
      begin
      icore[i].xpaint;
      app__fasttimer;//fasttimer - 07jul2021
      end;
   skipone:
   end;//p
   end;
   //## ppadd ##
   function ppadd(xpaintarea:trect):boolean;//part-paint include area
   begin
   try
   //defaults
   result:=true;
   //check
   if (pacount>high(pa)) then//at capacity
      begin
      result:=false;
      exit;
      end;
   //check
   if (xpaintarea.right<xpaintarea.left) or (xpaintarea.bottom<xpaintarea.top) or (xpaintarea.right<0) or (xpaintarea.bottom<0) or (xpaintarea.left>=iwidth) or (xpaintarea.top>=iheight) then exit;
   //range
   xpaintarea.left:=frcrange(xpaintarea.left,0,iwidth-1);
   xpaintarea.top:=frcrange(xpaintarea.top,0,iheight-1);
   xpaintarea.right:=frcrange(xpaintarea.right,xpaintarea.left,iwidth-1);
   xpaintarea.bottom:=frcrange(xpaintarea.bottom,xpaintarea.top,iheight-1);
   //add
   pa[pacount]:=xpaintarea;
   inc(pacount);
   except;end;
   end;
   //## xabort ##
   function xabort:boolean;
   begin
   result:=visyncing or (imustgstate>=0);
   if result then paintallnow;
   end;
   //## xredraw_drag ##
   procedure xredraw_drag;
   begin
   if xdragpaintareaok then miscopyarea(ihost.canvas,ibuffer.canvas,xdragpaintarea);
   app__fasttimer;//fasttimer - 07jul2021
   //.drop - 26jul2021
   drop_draw(ibuffer,ihost.canvas);
   end;
   //## xredraw_full ##
   procedure xredraw_full;
   begin
//was: ihost.canvas.draw(0,0,ibuffer.core);
   misdrawcanvas(ihost.canvas,0,0,ibuffer.core,ibuffer.core.canvas);
   app__fasttimer;//fasttimer - 07jul2021
   //.drop - 26jul2021
   drop_drawcancel;//as this is a full repaint no need to perform any "undraw" actions
   drop_draw(ibuffer,ihost.canvas);
   end;
   //## xredraw_part ##
   procedure xredraw_part;
   var
      p:longint;
      xundraw,xdraw:trect;
   begin
   //.redraw sections of screen
   if (pacount>=1) then
      begin
      //.double buffer: buffer -> buffer2 -> drop_draw -> host.canvas
      if xdrop_showing or iwasdrop_showing then
         begin
         //init
         if zznil(ibuffer2,102) then ibuffer2:=misbmp(32,1,1);
         ibuffer2.setparams(ibuffer.bits,ibuffer.width,ibuffer.height);

         //get
         //.buffer -> buffer2
         for p:=0 to (pacount-1) do
         begin
         if xabort then break;
         miscopyarea(ibuffer2.canvas,ibuffer.canvas,pa[p]);
         app__fasttimer;//fasttimer - 07jul2021
         end;//p
         //.drop -> buffer2
         drop_draw2(ibuffer,ibuffer2.canvas,xundraw,xdraw);
         //.buffer2 -> host.canvas
         for p:=0 to (pacount-1) do
         begin
         if xabort then break;
         miscopyarea(ihost.canvas,ibuffer2.canvas,pa[p]);
         app__fasttimer;//fasttimer - 07jul2021
         end;//p
         //.drop
         if validarea(xundraw) then miscopyarea(ihost.canvas,ibuffer2.canvas,xundraw);
         if validarea(xdraw) then miscopyarea(ihost.canvas,ibuffer2.canvas,xdraw);
         end
      else
      //.single buffer: buffer -> host.canvas
         begin
         for p:=0 to (pacount-1) do
         begin
         if xabort then break;
         miscopyarea(ihost.canvas,ibuffer.canvas,pa[p]);
         app__fasttimer;//fasttimer - 07jul2021
         end;//p
         end;
      end
   else
      begin
      //.drop - 26jul2021
      drop_draw(ibuffer,ihost.canvas);
      end;
   end;
begin
try
//defaults
xline:=nil;
xlocked:=false;
xdrop_showing:=drop_showing;

//.default paint mode -> detects difference between our paint requests (internal) and Windows paint requests (external), e.g. repaint Window under Win98 due to a window above us being dragged across etc - 22may2020
xmustfull:=not iinternalpaint;
iinternalpaint:=false;

//check
if not stable then iinternalpaint:=false;
xshowing:=showing;
if not xshowing then exit;
//.check busy
if ipaintbusy then//only allow paint OUTSIDE of timer event to force synced painting and sizing at all times - 20mar2020
   begin
   paintallnow;//full repaint
   exit;
   end
else ipaintbusy:=true;
//.eco mode - 09may2021
if not low__canecopaint(iecomode64) then
   begin
   iinternalpaint:=not xmustfull;
   ipaintbusy:=false;
   exit;
   end;


//init -------------------------------------------------------------------------
xref:=ms64;//xxxxxxxxxxxxxxxxxxxx
xref2:=ms64;//xxxxxxxxxxxxxxxxx
xcount:=-1;
pacount:=0;
//.drag and window support
xdragindex:=idragindex;
xdragstart:=idragstart;
//.check #2
if xabort then goto skipend;

//.reuse the "drag system" for the "size system" - 25feb2021
if (xdragindex<0) and (isizeindex>=0) then
   begin
   xdragindex:=isizeindex;
   xdragstart:=isizestart;
   end;
xdraglayer:=-1;
xtoplayer:=-1;
xwincount:=0;
xdragfast:=vidragfast;
xdragpaintareaok:=false;

//.reset random sparkler - 27feb2022
system_sparklepos:=0;

//.modes
xmustmask:=false;

//xxxxxxxxxxxxxxxmustfull:=true;xmustmask:=true;//xxxxxxxxxxxxxxxxxxx

//.dimensions
cw:=frcmin(ihost.clientwidth,1);
ch:=frcmin(ihost.clientheight,1);
xbits:=ibuffer.bits;

//.window layers
if (winlist.count>=1) then
   begin
   for p:=0 to (winlist.count-1) do
   begin
   i:=winlist.list[p];
   if xvisible(i) then
      begin
      inc(xwincount);
      if (i=xdragindex) then xdraglayer:=p;
      xtoplayer:=p;
      end;
   end;//p
   end;
//.reset
imaskval:=-1;

//align ------------------------------------------------------------------------
//.size + bits - 09may2021
int1:=low__aorb(24,32,vi32bit);
//.buffer
if (cw>ibuffer.width) or (ch>ibuffer.height) or (xbits<>int1) then
   begin
   //Important Note: Previously we just set the ibuffer to a larger size for faster resize speeds, but the subsystem "mustmask()" read this
   //                value thinking it was the intended size of ibuffer, when in fact it was just an oversized version for speed, this caused
   //                a continuous paint cycle until 5,000ms was up and the buffer was finally sized correctly - now further down below mask.resize()
   //                now uses "ibuffer.width,ibuffer.height" instead of old "cw,ch" - 28feb2022
   ibuffer.setparams(int1,frcmin(cw+100,ibuffer.width),frcmin(ch+100,ibuffer.height));
   xbits:=ibuffer.bits;
   app__fasttimer;//fasttimer - 07jul2021
   ibufferresize64:=ms64+5000;
   end
else if (ms64>=ibufferresize64) and ((ibuffer.width<>cw) or (ibuffer.height<>ch)) then
   begin
   ibuffer.setparams(int1,cw,ch);
   xbits:=ibuffer.bits;
   app__fasttimer;//fasttimer - 07jul2021
   ibufferresize64:=ms64+5000;
   end;
//.buffer2 -> secondary buffer for "drop" support with "flicker free" display -> need 2nd buffer to avoid flicker - 26jul2021
if xdrop_showing or iwasdrop_showing then ibufferresize642:=ms64+30000
else if zzok(ibuffer2,104) and (ms64>=ibufferresize642) then
   begin
   ibuffer2.setparams(ibuffer2.bits,1,1);
   app__fasttimer;//fasttimer - 07jul2021
   ibufferresize642:=ms64+5000;
   end;

//.all align events
if (imustalign>=1) or (cw<>iwidth) or (ch<>iheight) then
   begin
   imustalign:=0;//reset
   iwidth:=cw;
   iheight:=ch;
   low__iroll(ialignid,1);
   for p:=0 to (icorecount-1) do if xrootok(icore[p]) then
      begin
      icore[p].xalign;
      app__fasttimer;//fasttimer - 07jul2021
      end;
   end;


//detect paint mode ------------------------------------------------------------
//.mask check -> detect any changes in Window mask and switch to full paint mode if there are any
xmustmask:=mustmask;//assumes "ibuffer" is already correctly sized - 19may2020
if xmustmask then xmustfull:=true;

//.paint check -> has full paint mode been requested, if so, switch to full paint mode
if (imustpaint>=2) then xmustfull:=true;
imustpaint:=0;//reset now

//.show form catch #2
bol1:=xshowing;
if (ilastshowing<>bol1) then
   begin
   ilastshowing:=bol1;
   if ilastshowing then xmustfull:=true;
   end;

//paint start ------------------------------------------------------------------
//init
xlocked:=ibuffer.lock;
if (not xlocked) or (cw<1) or (ch<1) or ((xbits<>24) and (xbits<>32)) then goto skipend;
ibits:=xbits;
low__iroll(ipaintid,1);

//decide
if xmustfull then goto fullpaint else goto partpaint;

//part paint -------------------------------------------------------------------
partpaint:
//check
if (winlist.count<=0) then goto done;
//check load -> if too many controls need to paint then switch to full screen paint - 20may2020
int1:=0;
for p:=0 to (winlist.count-1) do
begin
i:=winlist.list[p];
if (i>=0) and xvisible(i) then
   begin
   inc(int1,icore[i].xmustpaintcount);
   if (int1>xpartpaintlimit) then goto fullpaint;
   end;//i
end;//p

//get
satinc(satPartpaint,1);
//dbstatus(30,'* Part-paint: '+inttostr(sysstats_active[satPartpaint])+' and '+inttostr(int1)+' controls<<'+ms64str);//xxxxxxxxxxx

try
ipaintingpart:=true;//trigger control based partpaint mode - 20may2020
for p:=0 to (winlist.count-1) do
begin
i:=winlist.list[p];
if (i>=0) and (i<icorecount) and zzok(icore[i],7119) then
   begin
   //init
   ipartpaintarea:=rect(0,0,0,0);
   ipartpaintareaok:=false;
   //get
   if imasking then imaskval:=p+1 else imaskval:=-1;
   if icore[i].visible then
      begin
      icore[i].xpaint;//self and all children
      app__fasttimer;//fasttimer - 07jul2021
      end;
   icore[i].xmustpaint:=false;
   //set
   if ipartpaintareaok and (not ppadd(ipartpaintarea)) then break;
   end;//i
end;//p
except;end;

goto done;


//full paint -------------------------------------------------------------------
fullpaint:
//.disable any "part-paint" modes
xmustfull:=true;
ipaintingpart:=false;

//.update mask
if (xwincount<=1) then imasking:=false
else if ((xdragindex<0) or (xdragstart>=0)) and xmustmask then
   begin
//was:   if imask.resize(cw,ch) then//this was actually out-of-sync with ibuffer when window is resized or sized 1st time -> causing mask in some cases to be smaller than ibuffer causing graphic routines to DISABLE mask support!!!! - 28feb2022
   if imask.resize(ibuffer.width,ibuffer.height) then
      begin
      app__fasttimer;//fasttimer - 07jul2021
      xref:=ms64;//xxxxxxxxxxxxxx
      satinc(satMaskcapture,1);
      imasking:=true;
      imask.cls(0);
      //draw window outlines -> top-down for max. speed
      for p:=(winlist.count-1) downto 0 do
      begin
      i:=winlist.list[p];
      //Special Note: Windows of type "wmFullwin" use a square mask at all times no matter their "rounded" status - 28aug2020
      if xvisible(i) and (i<>xdragstart) then
         begin
         imask.fill2(icore[i].clientarea,p+1,(icore[i].rounded and (icore[i].winstyle<>wmFullwin)));//0=none, 1..255=window layer
         app__fasttimer;//fasttimer - 07jul2021
         end;
      end;//p
      //update mask refs
      winmask_cnt:=winlist.count;
      for p:=0 to (winlist.count-1) do
      begin
      i:=winlist.list[p];
      if (i<>xdragstart) and (i>=0) and (i<icorecount) and zzok(icore[i],7120) then
         begin
         winmask_id[p] :=icore[i].id;
         winmask_aid[p]:=icore[i].aid;
         winmask_vis[p]:=icore[i].visible;
         winmask_rnd[p]:=icore[i].rounded;
         end;
      end;//p
      //dbstatus(26,'* Mask-capture: '+inttostr(sysstats_active[satMaskcapture])+' in '+inttostr(round(ms64-xref))+'ms <<'+ms64str);//xxxxxxxxxxx
      end;
   end;

//.capture screen into "dragbuffer" - 17may2020
if imasking and (xdragindex>=0) and (xdragstart>=0) then
   begin
   //init
   xref:=ms64;//xxxxxxxxxx
   satinc(satDragcapture,1);
   idragstart:=-1;//turn off
   isizestart:=-1;//turn off
   idragbuffer.sizeto(cw,ch);
   app__fasttimer;//fasttimer - 07jul2021
   //redraw screen without the "drag form" painted
   if not xdragfast then
      begin
      dfull0;
      dfull1(xdragindex,false);
      dfull2(xdragindex,false);
      end;
   //capture -> faster: was 63-150ms -> now 47-120ms
   srs8:=ibuffer.prows8;
   drs8:=idragbuffer.prows8;
   miscopypixels(drs8,srs8,xbits,cw,ch);
   app__fasttimer;//fasttimer - 07jul2021
   //dbstatus(27,'* Drag-capture: '+inttostr(sysstats_active[satDragcapture])+' in '+inttostr(round(ms64-xref))+'ms <<'+ms64str);//xxxxxxxxxxx
   end;

//.fullpaint -> in "drag buffer" mode
if imasking and (xdragindex>=0) and (idragbuffer.width>=cw) and (idragbuffer.height>=ch) then
   begin
   //init -> note: 1-based, e.g. background=layer0, window0=layer1, window3=layer4, window254=layer255 (last window/layer) - 17may2020
   xref:=ms64;//xxxxxxxxxxxxx
   satinc(satDragpaint,1);
   if (xdraglayer=-1) then int1:=iwinlimit else int1:=xdraglayer+1;
   //.sa
   if (xdragstart>=0) then sa:=low__rect(0,0,cw-1,ch-1)
   else
      begin
      sa:=idragrect;
      sa.left:=frcrange(sa.left,0,cw-1);
      sa.right:=frcrange(sa.right,sa.left,cw-1);
      sa.top:=frcrange(sa.top,0,ch-1);
      sa.bottom:=frcrange(sa.bottom,sa.top,ch-1);
      end;

   //dbstatus(24,'Dragrect: '+inttostr(sa.right-sa.left+1)+'w x '+inttostr(sa.bottom-sa.top+1)+'h ___'+low__rectstr(sa)+'<<'+ms64str);//xxxxxxxxxx
   //.da
   da:=low__rect(0,0,cw-1,ch-1);
   //draw: bottom.window...(drag.window-1)
   for dy:=sa.top to sa.bottom do
   begin
   //.fasttimer - ycheck
   inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

   //.bottom...(drag.window-1)
   if (xbits=24) then
      begin
      sr24:=idragbuffer.prows24[dy];
      dr24:=ibuffer.prows24[dy];
      case imasking of
      true:begin
         sr8:=imask.prows8[dy];//2x faster than "mrow()"
         for dx:=sa.left to sa.right do if (sr8[dx]<int1) then
            begin
            sc24:=sr24[dx];
            dr24[dx]:=sc24;
            end;//dx
         end;//begin
      false:begin
         for dx:=sa.left to sa.right do
         begin
         sc24:=sr24[dx];
         dr24[dx]:=sc24;
         end;//dx
         end;
      end;//case
      end
   else if (xbits=32) then
      begin
      sr32:=idragbuffer.prows32[dy];
      dr32:=ibuffer.prows32[dy];
      case imasking of
      true:begin
         sr8:=imask.prows8[dy];//2x faster than "mrow()"
         for dx:=sa.left to sa.right do if (sr8[dx]<int1) then
            begin
            sc32:=sr32[dx];
            dr32[dx]:=sc32;
            end;//dx
         end;//begin
      false:begin
         for dx:=sa.left to sa.right do
         begin
         sc32:=sr32[dx];
         dr32[dx]:=sc32;
         end;//dx
         end;
      end;//case
      end;//32
   end;//dy

   //.drag.window
   if (xdragindex>=0) and xvisible(xdragindex) then
      begin
      imaskval:=-1;//20may2020
      icore[xdragindex].xpaint;
      da:=icore[xdragindex].paintarea;
      app__fasttimer;//fasttimer - 07jul2021
      end;

   //.note: sa needs to adapt to larger area of both "original sa" and
   //       output "da" to correctly paint area on screen for dragging movement
   //       etc -> now allows for a single window ontop of base window, which
   //       previously failled to repaint ALL the edge areas in a timely
   //       manner -> now does - 28jul2020
   sa.left:=frcrange(smallest(sa.left,da.left),0,cw-1);
   sa.right:=frcrange(largest(sa.right,da.right),da.left,cw-1);
   sa.top:=frcrange(smallest(sa.top,da.top),0,ch-1);
   sa.bottom:=frcrange(largest(sa.bottom,da.bottom),da.top,ch-1);

   //.(drag.window+1)..254 -> this part only works if "imask" is active "imasking=true" - 17may2020
   //was: if (int1<iwinlimit) and (int1<xtoplayer) and imasking then
   if (int1<iwinlimit) and (int1<=xtoplayer) and imasking then//fixed 25feb2021
      begin
      //dbstatus(23,'Dragging...'+ms64str);//xxxxxxxxxxxxxxxxxxxxxxxx
      //get
      for dy:=sa.top to sa.bottom do
      begin
      //.fasttimer - ycheck
      inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

      if (xbits=24) then
         begin
         sr24:=idragbuffer.prows24[dy];
         dr24:=ibuffer.prows24[dy];
         sr8 :=imask.prows8[dy];//2x faster than "mrow()"
         for dx:=sa.left to sa.right do
         begin
         if (sr8[dx]>int1) then
            begin
            sc24:=sr24[dx];
            dr24[dx]:=sc24;
            end;
         end;//dx
         end
      else if (xbits=32) then
         begin
         sr32:=idragbuffer.prows32[dy];
         dr32:=ibuffer.prows32[dy];
         sr8 :=imask.prows8[dy];//2x faster than "mrow()"
         for dx:=sa.left to sa.right do
         begin
         if (sr8[dx]>int1) then
            begin
            sc32:=sr32[dx];
            dr32[dx]:=sc32;
            end;
         end;//dx
         end;
      end;//dy
      end;
   //.idragrect
   idragrect:=da;
   xdragpaintarea:=sa;
   xdragpaintareaok:=true;
   //dbstatus(28,'* Drag-paint: '+inttostr(sysstats_active[satDragpaint])+' in '+inttostr(round(ms64-xref))+'ms (dragfast='+bnc(xdragfast)+')<<'+ms64str);//xxxxxxxxxxx
   end
//.fullpaint -> in normal "paint entire screen" mode
else
   begin
   xref:=ms64;//xxxxxxxxxxxx
   satinc(satFullpaint,1);
   dfull0;
   app__fasttimer;//fasttimer - 07jul2021
   dfull2(0,true);
   app__fasttimer;//fasttimer - 07jul2021
   //dbstatus(29,'* Full-paint: '+inttostr(sysstats_active[satFullpaint])+' in '+inttostr(round(ms64-xref))+'ms <<'+ms64str);//xxxxxxxxxxx
   end;

goto done;


//done -------------------------------------------------------------------------
done:

//debug status
if system_debug then
   begin
   //system based debug information panels - 06may2021
   low__roll64(system_debugPaintcount,1);
   dbstatus(40,'GUI: ' +low__aorbstr('Normal mode','Fast',system_debugFAST));//fast=GUI and timers are stressing the overal system mechanics
   dbstatus(41,'Timer.ticks: '+low__64(systimerTICK)+'/ fast.ticks: '+low__64(sysfasttimerTICK));//number of simultaneous timer events being fired -> too many cause a stack overflow
   dbstatus(42,'Objs: '+low__64(systrack_objcount));//number of objects in use
   dbstatus(43,'Ptrs: '+low__64(systrack_ptrcount));
   dbstatus(44,'Ptrs.bytes: '+low__64(systrack_ptrbytes));
   dbstatus(45,'Total: '+low__64(sysstats_total));//number of total tracked items in use
   int1:=low__div32(system_debugPaintcount, frcmin64(low__div64(low__sub64(ms64,system_debugPainttime),1000),1) );
   dbstatus(46,'Paint Count: '+low__64(system_debugPaintcount)+' @ '+low__64(int1)+' fps');//number of total tracked items in use
   dbstatus(47,'Align Count: '+low__64(ialignid));
   //optional user based debug information panels - 06may2021
   for p:=0 to high(debug_info) do if (debug_info[p]<>'') then
      begin
      xfn:=0;
      int1:=low__fontmaxh(0);//font height of system default font -> this font is NEVER zoomed - 14mar2021
      if zznil(xline,2295) then xline:=bnew;
      xline.replacestr:=inttostr(p)+'. '+debug_info[p]+#32#32#32;
      dy:=p*int1;//not zoomed
      tw:=low__fonttextwidth(xfn,xline);
      da:=low__rect(0,dy,tw-1,dy+int1);
      low__draw(true,xbits,cw,ch,rows,imask,-1,'s',da,da,da,low__rgb(250,250,250),clnone,clnone,0,0,0,0,nil,nil,corNone,false);
      low__draw2(true,tbnone,xbits,cw,ch,rows,imask,-1,'t',da,da,da,0,clnone,clnone,0,dy,0,0,0,0,sysfont_data[xfn],xline,corNone,false,false,false,false,false);
      if ipaintingpart or xdragpaintareaok then ppadd(da);
      end;
   end;//p

//unlock
if xlocked then
   begin
   xlocked:=false;
   ibuffer.unlock;
   app__fasttimer;//fasttimer - 07jul2021
   end;

//draw -------------------------------------------------------------------------

if xabort then goto skipend;

case xmustfull of
true:begin//full-paint
   //.redraw the "dragged" area -> a sub-section of full screen
   if xdragpaintareaok then
      begin
      xredraw_drag;
      xredraw_part;//for dbstatus -> uses areas to map paint
      end
   //.redraw entire screen
   else xredraw_full;
   end;
false:begin//part-paint
   xredraw_part;
   end;
end;//case

//debug leak hunters -----------------------------------------------------------
//Note: these items display directly onto the MS Windows tform without using
//      any of Gossamer's systems -> required in order to properly hunt down
//      and isolate any system leaks - 28jan2021
if system_debug and sysleak_show and zzok(ihost,7121) and (ihost is tform) then
   begin
   int1:=(ihost as tform).canvas.textheight('#asdf897');
   for p:=0 to high(sysleak_start) do if leakinfo(p,str1) then (ihost as tform).canvas.textout(0,p*int1,str1);
   end;
//dbstatus(35,'Paint-time: '+dbtime+' / '+dbtimeave+' / '+dbtimeavefast+' <<'+ms64str);//xxxxxxxxxxxxx


skipend:
except;end;
try
//.clean up
if xlocked then ibuffer.unlock;
bfree(xline);

//shrink optional buffers ------------------------------------------------------
//.drag
if (xdragindex=-1) then
   begin
   idragbuffer.sizeto(1,1);
   app__fasttimer;//fasttimer - 07jul2021
   end;
//.mask
if not imasking then
   begin
   imask.resize(1,1);
   app__fasttimer;//fasttimer - 07jul2021
   end;
//.reset
imaskval:=-1;
except;end;
try
iwasdrop_showing:=xdrop_showing;
ipaintingpart:=false;
ipaintbusy:=false;
except;end;
end;
{}//xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
{
//## __onpaint ##
procedure tbasicsystem.__onpaint(sender:tobject);//28jul2020
label
   partpaint,fullpaint,done,skipend;
const
   xpartpaintlimit=10;
var//Note: -1=no paint, 0=full paint, 1..N=paint rects
   //.holds part-paint rects to be paint on screen
   pa:array[0..99] of trect;
   pacount:longint;
   //.other
   xdragpaintarea,ppa,sa,da:trect;
   sr8:pcolorrow8;
   srs8,drs8:pcolorrows8;
   sr24,dr24:pcolorrow24;
   sr32,dr32:pcolorrow32;
   sc24:tcolor24;
   sc32:tcolor32;
   int1,int2,xbits,xcount,xfn,tw,cw,ch,dx,dy,p,i:longint;
   xline:tstr8;
   xdrop_showing,bol1,xdragpaintareaok,xshowing,xdragfast,xmustmask,xlocked,xmustfull:boolean;
   xref,xref2:comp;//xxxxxxxxxxxxxxxxxx
   str1:string;
   //.drag and window support
   xdragindex,xdragstart,xdraglayer,xtoplayer,xwincount:longint;
   //## dfull0 ##
   procedure dfull0;
   begin
   if xareaseen(low__rect(0,0,cw-1,ch-1),0) then miscls(ibuffer,vinormal.background);
   app__fasttimer;//fasttimer - 07jul2021
   end;
   //## dfull1 ##
   procedure dfull1(xto:longint;xinclusive:boolean);
   var
      p,i:longint;
   begin
   //check
   if (xto<0) or (winlist.count<=0) then exit;
   //get
   for p:=0 to (winlist.count-1) do
   begin
   i:=winlist.list[p];
   if imasking then imaskval:=p+1;
   if (i=xto) then
      begin
      if xinclusive then
         begin
         icore[i].xpaint;
         app__fasttimer;//fasttimer - 07jul2021
         end;
      break;
      end
   else
      begin
      icore[i].xpaint;
      app__fasttimer;//fasttimer - 07jul2021
      end;
   end;//p
   end;
   //## dfull2 ##
   procedure dfull2(xfrom:longint;xinclusive:boolean);
   label
      skipone;
   var
      p,i:longint;
      xok:boolean;
   begin
   //check
   if (winlist.count<=0) or (xfrom>=icorecount) then exit;
   if (xfrom<0) then xfrom:=0;
   //get
   xok:=false;
   for p:=0 to (winlist.count-1) do
   begin
   i:=winlist.list[p];
   if imasking then imaskval:=p+1;
   if (not xok) and (i=xfrom) then
      begin
      xok:=true;
      if not xinclusive then goto skipone;
      end;
   if xok then
      begin
      icore[i].xpaint;
      app__fasttimer;//fasttimer - 07jul2021
      end;
   skipone:
   end;//p
   end;
   //## ppadd ##
   function ppadd(xpaintarea:trect):boolean;//part-paint include area
   begin
   try
   //defaults
   result:=true;
   //check
   if (pacount>high(pa)) then//at capacity
      begin
      result:=false;
      exit;
      end;
   //check
   if (xpaintarea.right<xpaintarea.left) or (xpaintarea.bottom<xpaintarea.top) or (xpaintarea.right<0) or (xpaintarea.bottom<0) or (xpaintarea.left>=iwidth) or (xpaintarea.top>=iheight) then exit;
   //range
   xpaintarea.left:=frcrange(xpaintarea.left,0,iwidth-1);
   xpaintarea.top:=frcrange(xpaintarea.top,0,iheight-1);
   xpaintarea.right:=frcrange(xpaintarea.right,xpaintarea.left,iwidth-1);
   xpaintarea.bottom:=frcrange(xpaintarea.bottom,xpaintarea.top,iheight-1);
   //add
   pa[pacount]:=xpaintarea;
   inc(pacount);
   except;end;
   end;
   //## xabort ##
   function xabort:boolean;
   begin
   result:=visyncing or (imustgstate>=0);
   if result then paintallnow;
   end;
   //## xredraw_drag ##
   procedure xredraw_drag;
   begin
   if xdragpaintareaok then miscopyarea(ihost.canvas,ibuffer.canvas,xdragpaintarea);
   app__fasttimer;//fasttimer - 07jul2021
   //.drop - 26jul2021
   drop_draw(ibuffer,ihost.canvas);
   end;
   //## xredraw_full ##
   procedure xredraw_full;
   begin
//was: ihost.canvas.draw(0,0,ibuffer.core);
   misdrawcanvas(ihost.canvas,0,0,ibuffer.core,ibuffer.core.canvas);
   app__fasttimer;//fasttimer - 07jul2021
   //.drop - 26jul2021
   drop_drawcancel;//as this is a full repaint no need to perform any "undraw" actions 
   drop_draw(ibuffer,ihost.canvas);
   end;
   //## xredraw_part ##
   procedure xredraw_part;
   var
      p:longint;
      xundraw,xdraw:trect;
   begin
   //.redraw sections of screen
   if (pacount>=1) then
      begin
      //.double buffer: buffer -> buffer2 -> drop_draw -> host.canvas
      if xdrop_showing or iwasdrop_showing then
         begin
         //init
         if zznil(ibuffer2,102) then ibuffer2:=misbmp(32,1,1);
         ibuffer2.setparams(ibuffer.bits,ibuffer.width,ibuffer.height);

         //get
         //.buffer -> buffer2
         for p:=0 to (pacount-1) do
         begin
         if xabort then break;
         miscopyarea(ibuffer2.canvas,ibuffer.canvas,pa[p]);
         app__fasttimer;//fasttimer - 07jul2021
         end;//p
         //.drop -> buffer2
         drop_draw2(ibuffer,ibuffer2.canvas,xundraw,xdraw);
         //.buffer2 -> host.canvas
         for p:=0 to (pacount-1) do
         begin
         if xabort then break;
         miscopyarea(ihost.canvas,ibuffer2.canvas,pa[p]);
         app__fasttimer;//fasttimer - 07jul2021
         end;//p
         //.drop
         if validarea(xundraw) then miscopyarea(ihost.canvas,ibuffer2.canvas,xundraw);
         if validarea(xdraw) then miscopyarea(ihost.canvas,ibuffer2.canvas,xdraw);
         end
      else
      //.single buffer: buffer -> host.canvas
         begin
         for p:=0 to (pacount-1) do
         begin
         if xabort then break;
         miscopyarea(ihost.canvas,ibuffer.canvas,pa[p]);
         app__fasttimer;//fasttimer - 07jul2021
         end;//p
         end;
      end
   else
      begin
      //.drop - 26jul2021
      drop_draw(ibuffer,ihost.canvas);
      end;
   end;
begin
try
//defaults
xline:=nil;
xlocked:=false;
xdrop_showing:=drop_showing;

//.default paint mode -> detects difference between our paint requests (internal) and Windows paint requests (external), e.g. repaint Window under Win98 due to a window above us being dragged across etc - 22may2020
xmustfull:=not iinternalpaint;
iinternalpaint:=false;

//check
if not stable then iinternalpaint:=false;
xshowing:=showing;
if not xshowing then exit;
//.check busy
if ipaintbusy then//only allow paint OUTSIDE of timer event to force synced painting and sizing at all times - 20mar2020
   begin
   paintallnow;//full repaint
   exit;
   end
else ipaintbusy:=true;
//.eco mode - 09may2021
if not low__canecopaint(iecomode64) then
   begin
   iinternalpaint:=not xmustfull;
   ipaintbusy:=false;
   exit;
   end;


//init -------------------------------------------------------------------------
xref:=ms64;//xxxxxxxxxxxxxxxxxxxx
xref2:=ms64;//xxxxxxxxxxxxxxxxx
xcount:=-1;
pacount:=0;
//.drag and window support
xdragindex:=idragindex;
xdragstart:=idragstart;
//.check #2
if xabort then goto skipend;

//.reuse the "drag system" for the "size system" - 25feb2021
if (xdragindex<0) and (isizeindex>=0) then
   begin
   xdragindex:=isizeindex;
   xdragstart:=isizestart;
   end;
xdraglayer:=-1;
xtoplayer:=-1;
xwincount:=0;
xdragfast:=vidragfast;
xdragpaintareaok:=false;
//.modes
xmustmask:=false;

//.dimensions
cw:=frcmin(ihost.clientwidth,1);
ch:=frcmin(ihost.clientheight,1);
xbits:=ibuffer.bits;

//.window layers
if (winlist.count>=1) then
   begin
   for p:=0 to (winlist.count-1) do
   begin
   i:=winlist.list[p];
   if xvisible(i) then
      begin
      inc(xwincount);
      if (i=xdragindex) then xdraglayer:=p;
      xtoplayer:=p;
      end;
   end;//p
   end;
//.reset
imaskval:=-1;

//align ------------------------------------------------------------------------
//.size + bits - 09may2021
int1:=low__aorb(24,32,vi32bit);
//.buffer
if (cw>ibuffer.width) or (ch>ibuffer.height) or (xbits<>int1) then
   begin
   ibuffer.setparams(int1,frcmin(cw+100,ibuffer.width),frcmin(ch+100,ibuffer.height));
   xbits:=ibuffer.bits;
   app__fasttimer;//fasttimer - 07jul2021
   ibufferresize64:=ms64+5000;
   end
else if (ms64>=ibufferresize64) and ((ibuffer.width<>cw) or (ibuffer.height<>ch)) then
   begin
   ibuffer.setparams(int1,cw,ch);
   xbits:=ibuffer.bits;
   app__fasttimer;//fasttimer - 07jul2021
   ibufferresize64:=ms64+5000;
   end;
//.buffer2 -> secondary buffer for "drop" support with "flicker free" display -> need 2nd buffer to avoid flicker - 26jul2021
if xdrop_showing or iwasdrop_showing then ibufferresize642:=ms64+30000
else if zzok(ibuffer2,104) and (ms64>=ibufferresize642) then
   begin
   ibuffer2.setparams(ibuffer2.bits,1,1);
   app__fasttimer;//fasttimer - 07jul2021
   ibufferresize642:=ms64+5000;
   end;

//.all align events
if (imustalign>=1) or (cw<>iwidth) or (ch<>iheight) then
   begin
   imustalign:=0;//reset
   iwidth:=cw;
   iheight:=ch;
   low__iroll(ialignid,1);
   for p:=0 to (icorecount-1) do if xrootok(icore[p]) then
      begin
      icore[p].xalign;
      app__fasttimer;//fasttimer - 07jul2021
      end;
   end;


//detect paint mode ------------------------------------------------------------
//.mask check -> detect any changes in Window mask and switch to full paint mode if there are any
xmustmask:=mustmask;//assumes "ibuffer" is already correctly sized - 19may2020
if xmustmask then xmustfull:=true;

//.paint check -> has full paint mode been requested, if so, switch to full paint mode
if (imustpaint>=2) then xmustfull:=true;
imustpaint:=0;//reset now

//.show form catch #2
bol1:=xshowing;
if (ilastshowing<>bol1) then
   begin
   ilastshowing:=bol1;
   if ilastshowing then xmustfull:=true;
   end;

//paint start ------------------------------------------------------------------
//init
xlocked:=ibuffer.lock;
if (not xlocked) or (cw<1) or (ch<1) or ((xbits<>24) and (xbits<>32)) then goto skipend;
ibits:=xbits;
low__iroll(ipaintid,1);

//decide
if xmustfull then goto fullpaint else goto partpaint;


//part paint -------------------------------------------------------------------
partpaint:
//check
if (winlist.count<=0) then goto done;
//check load -> if too many controls need to paint then switch to full screen paint - 20may2020
int1:=0;
for p:=0 to (winlist.count-1) do
begin
i:=winlist.list[p];
if (i>=0) and xvisible(i) then
   begin
   inc(int1,icore[i].xmustpaintcount);
   if (int1>xpartpaintlimit) then goto fullpaint;
   end;//i
end;//p

//get
satinc(satPartpaint,1);
//dbstatus(30,'* Part-paint: '+inttostr(sysstats_active[satPartpaint])+' and '+inttostr(int1)+' controls<<'+ms64str);//xxxxxxxxxxx

try
ipaintingpart:=true;//trigger control based partpaint mode - 20may2020
for p:=0 to (winlist.count-1) do
begin
i:=winlist.list[p];
if (i>=0) and (i<icorecount) and zzok(icore[i],7119) then
   begin
   //init
   ipartpaintarea:=rect(0,0,0,0);
   ipartpaintareaok:=false;
   //get
   if imasking then imaskval:=p+1 else imaskval:=-1;
   if icore[i].visible then
      begin
      icore[i].xpaint;//self and all children
      app__fasttimer;//fasttimer - 07jul2021
      end;
   icore[i].xmustpaint:=false;
   //set
   if ipartpaintareaok and (not ppadd(ipartpaintarea)) then break;
   end;//i
end;//p
except;end;

goto done;


//full paint -------------------------------------------------------------------
fullpaint:
//.disable any "part-paint" modes
xmustfull:=true;
ipaintingpart:=false;

//.update mask
if (xwincount<=1) then imasking:=false
else if ((xdragindex<0) or (xdragstart>=0)) and xmustmask then
   begin
   if imask.resize(cw,ch) then
      begin
      app__fasttimer;//fasttimer - 07jul2021
      xref:=ms64;//xxxxxxxxxxxxxx
      satinc(satMaskcapture,1);
      imasking:=true;
      imask.cls(0);
      //draw window outlines -> top-down for max. speed
      for p:=(winlist.count-1) downto 0 do
      begin
      i:=winlist.list[p];
      //Special Note: Windows of type "wmFullwin" use a square mask at all times no matter their "rounded" status - 28aug2020
      if xvisible(i) and (i<>xdragstart) then
         begin
         imask.fill2(icore[i].clientarea,p+1,(icore[i].rounded and (icore[i].winstyle<>wmFullwin)));//0=none, 1..255=window layer
         app__fasttimer;//fasttimer - 07jul2021
         end;
      end;//p
      //update mask refs
      winmask_cnt:=winlist.count;
      for p:=0 to (winlist.count-1) do
      begin
      i:=winlist.list[p];
      if (i<>xdragstart) and (i>=0) and (i<icorecount) and zzok(icore[i],7120) then
         begin
         winmask_id[p] :=icore[i].id;
         winmask_aid[p]:=icore[i].aid;
         winmask_vis[p]:=icore[i].visible;
         winmask_rnd[p]:=icore[i].rounded;
         end;
      end;//p
      //dbstatus(26,'* Mask-capture: '+inttostr(sysstats_active[satMaskcapture])+' in '+inttostr(round(ms64-xref))+'ms <<'+ms64str);//xxxxxxxxxxx
      end;
   end;

//.capture screen into "dragbuffer" - 17may2020
if imasking and (xdragindex>=0) and (xdragstart>=0) then
   begin
   //init
   xref:=ms64;//xxxxxxxxxx
   satinc(satDragcapture,1);
   idragstart:=-1;//turn off
   isizestart:=-1;//turn off
   idragbuffer.sizeto(cw,ch);
   app__fasttimer;//fasttimer - 07jul2021
   //redraw screen without the "drag form" painted
   if not xdragfast then
      begin
      dfull0;
      dfull1(xdragindex,false);
      dfull2(xdragindex,false);
      end;
   //capture -> faster: was 63-150ms -> now 47-120ms
   srs8:=ibuffer.prows8;
   drs8:=idragbuffer.prows8;
   miscopypixels(drs8,srs8,xbits,cw,ch);
   app__fasttimer;//fasttimer - 07jul2021
   //dbstatus(27,'* Drag-capture: '+inttostr(sysstats_active[satDragcapture])+' in '+inttostr(round(ms64-xref))+'ms <<'+ms64str);//xxxxxxxxxxx
   end;

//.fullpaint -> in "drag buffer" mode
if imasking and (xdragindex>=0) and (idragbuffer.width>=cw) and (idragbuffer.height>=ch) then
   begin
   //init -> note: 1-based, e.g. background=layer0, window0=layer1, window3=layer4, window254=layer255 (last window/layer) - 17may2020
   xref:=ms64;//xxxxxxxxxxxxx
   satinc(satDragpaint,1);
   if (xdraglayer=-1) then int1:=iwinlimit else int1:=xdraglayer+1;
   //.sa
   if (xdragstart>=0) then sa:=low__rect(0,0,cw-1,ch-1)
   else
      begin
      sa:=idragrect;
      sa.left:=frcrange(sa.left,0,cw-1);
      sa.right:=frcrange(sa.right,sa.left,cw-1);
      sa.top:=frcrange(sa.top,0,ch-1);
      sa.bottom:=frcrange(sa.bottom,sa.top,ch-1);
      end;

   //dbstatus(24,'Dragrect: '+inttostr(sa.right-sa.left+1)+'w x '+inttostr(sa.bottom-sa.top+1)+'h ___'+low__rectstr(sa)+'<<'+ms64str);//xxxxxxxxxx
   //.da
   da:=low__rect(0,0,cw-1,ch-1);
   //draw: bottom.window...(drag.window-1)
   for dy:=sa.top to sa.bottom do
   begin
   //.fasttimer - ycheck
   inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

   //.bottom...(drag.window-1)
   if (xbits=24) then
      begin
      sr24:=idragbuffer.prows24[dy];
      dr24:=ibuffer.prows24[dy];
      case imasking of
      true:begin
         sr8:=imask.prows8[dy];//2x faster than "mrow()"
         for dx:=sa.left to sa.right do if (sr8[dx]<int1) then
            begin
            sc24:=sr24[dx];
            dr24[dx]:=sc24;
            end;//dx
         end;//begin
      false:begin
         for dx:=sa.left to sa.right do
         begin
         sc24:=sr24[dx];
         dr24[dx]:=sc24;
         end;//dx
         end;
      end;//case
      end
   else if (xbits=32) then
      begin
      sr32:=idragbuffer.prows32[dy];
      dr32:=ibuffer.prows32[dy];
      case imasking of
      true:begin
         sr8:=imask.prows8[dy];//2x faster than "mrow()"
         for dx:=sa.left to sa.right do if (sr8[dx]<int1) then
            begin
            sc32:=sr32[dx];
            dr32[dx]:=sc32;
            end;//dx
         end;//begin
      false:begin
         for dx:=sa.left to sa.right do
         begin
         sc32:=sr32[dx];
         dr32[dx]:=sc32;
         end;//dx
         end;
      end;//case
      end;//32
   end;//dy

   //.drag.window
   if (xdragindex>=0) and xvisible(xdragindex) then
      begin
      imaskval:=-1;//20may2020
      icore[xdragindex].xpaint;
      da:=icore[xdragindex].paintarea;
      app__fasttimer;//fasttimer - 07jul2021
      end;

   //.note: sa needs to adapt to larger area of both "original sa" and
   //       output "da" to correctly paint area on screen for dragging movement
   //       etc -> now allows for a single window ontop of base window, which
   //       previously failled to repaint ALL the edge areas in a timely
   //       manner -> now does - 28jul2020
   sa.left:=frcrange(smallest(sa.left,da.left),0,cw-1);
   sa.right:=frcrange(largest(sa.right,da.right),da.left,cw-1);
   sa.top:=frcrange(smallest(sa.top,da.top),0,ch-1);
   sa.bottom:=frcrange(largest(sa.bottom,da.bottom),da.top,ch-1);

   //.(drag.window+1)..254 -> this part only works if "imask" is active "imasking=true" - 17may2020
   //was: if (int1<iwinlimit) and (int1<xtoplayer) and imasking then
   if (int1<iwinlimit) and (int1<=xtoplayer) and imasking then//fixed 25feb2021
      begin
      //dbstatus(23,'Dragging...'+ms64str);//xxxxxxxxxxxxxxxxxxxxxxxx
      //get
      for dy:=sa.top to sa.bottom do
      begin
      //.fasttimer - ycheck
      inc(sysfasttimer_ycount); if (sysfasttimer_ycount>=sysfasttimer_ytrigger) then fasttimer_ycheck;

      if (xbits=24) then
         begin
         sr24:=idragbuffer.prows24[dy];
         dr24:=ibuffer.prows24[dy];
         sr8 :=imask.prows8[dy];//2x faster than "mrow()"
         for dx:=sa.left to sa.right do
         begin
         if (sr8[dx]>int1) then
            begin
            sc24:=sr24[dx];
            dr24[dx]:=sc24;
            end;
         end;//dx
         end
      else if (xbits=32) then
         begin
         sr32:=idragbuffer.prows32[dy];
         dr32:=ibuffer.prows32[dy];
         sr8 :=imask.prows8[dy];//2x faster than "mrow()"
         for dx:=sa.left to sa.right do
         begin
         if (sr8[dx]>int1) then
            begin
            sc32:=sr32[dx];
            dr32[dx]:=sc32;
            end;
         end;//dx
         end;
      end;//dy
      end;
   //.idragrect
   idragrect:=da;
   xdragpaintarea:=sa;
   xdragpaintareaok:=true;
   //dbstatus(28,'* Drag-paint: '+inttostr(sysstats_active[satDragpaint])+' in '+inttostr(round(ms64-xref))+'ms (dragfast='+bnc(xdragfast)+')<<'+ms64str);//xxxxxxxxxxx
   end
//.fullpaint -> in normal "paint entire screen" mode
else
   begin
   xref:=ms64;//xxxxxxxxxxxx
   satinc(satFullpaint,1);
   dfull0;
   app__fasttimer;//fasttimer - 07jul2021
   dfull2(0,true);
   app__fasttimer;//fasttimer - 07jul2021
   //dbstatus(29,'* Full-paint: '+inttostr(sysstats_active[satFullpaint])+' in '+inttostr(round(ms64-xref))+'ms <<'+ms64str);//xxxxxxxxxxx
   end;

goto done;


//done -------------------------------------------------------------------------
done:

//debug status
if system_debug then
   begin
   //system based debug information panels - 06may2021
   low__roll64(system_debugPaintcount,1);
   dbstatus(40,'GUI: ' +low__aorbstr('Normal mode','Fast',system_debugFAST));//fast=GUI and timers are stressing the overal system mechanics
   dbstatus(41,'Timer.ticks: '+low__64(systimerTICK)+'/ fast.ticks: '+low__64(sysfasttimerTICK));//number of simultaneous timer events being fired -> too many cause a stack overflow
   dbstatus(42,'Objs: '+low__64(systrack_objcount));//number of objects in use
   dbstatus(43,'Ptrs: '+low__64(systrack_ptrcount));
   dbstatus(44,'Ptrs.bytes: '+low__64(systrack_ptrbytes));
   dbstatus(45,'Total: '+low__64(sysstats_total));//number of total tracked items in use
   int1:=low__div32(system_debugPaintcount, frcmin64(low__div64(low__sub64(ms64,system_debugPainttime),1000),1) );
   dbstatus(46,'Paint Count: '+low__64(system_debugPaintcount)+' @ '+low__64(int1)+' fps');//number of total tracked items in use
   dbstatus(47,'Align Count: '+low__64(ialignid));
   //optional user based debug information panels - 06may2021
   for p:=0 to high(debug_info) do if (debug_info[p]<>'') then
      begin
      xfn:=0;
      int1:=low__fontmaxh(0);//font height of system default font -> this font is NEVER zoomed - 14mar2021
      if zznil(xline,2295) then xline:=bnew;
      xline.replacestr:=inttostr(p)+'. '+debug_info[p]+#32#32#32;
      dy:=p*int1;//not zoomed
      tw:=low__fonttextwidth(xfn,xline);
      da:=low__rect(0,dy,tw-1,dy+int1);
      low__draw(true,xbits,cw,ch,rows,imask,-1,'s',da,da,da,low__rgb(250,250,250),clnone,clnone,0,0,0,0,nil,nil,corNone,false);
      low__draw2(true,tbnone,xbits,cw,ch,rows,imask,-1,'t',da,da,da,0,clnone,clnone,0,dy,0,0,0,0,sysfont_data[xfn],xline,corNone,false,false,false,false,false);
      if ipaintingpart or xdragpaintareaok then ppadd(da);
      end;
   end;//p

//unlock
if xlocked then
   begin
   xlocked:=false;
   ibuffer.unlock;
   app__fasttimer;//fasttimer - 07jul2021
   end;

//draw -------------------------------------------------------------------------

if xabort then goto skipend;

case xmustfull of
true:begin//full-paint
   //.redraw the "dragged" area -> a sub-section of full screen
   if xdragpaintareaok then
      begin
      xredraw_drag;
      xredraw_part;//for dbstatus -> uses areas to map paint
      end
   //.redraw entire screen
   else xredraw_full;
   end;
false:begin//part-paint
   xredraw_part;
   end;
end;//case

//debug leak hunters -----------------------------------------------------------
//Note: these items display directly onto the MS Windows tform without using
//      any of Gossamer's systems -> required in order to properly hunt down
//      and isolate any system leaks - 28jan2021
if system_debug and sysleak_show and zzok(ihost,7121) and (ihost is tform) then
   begin
   int1:=(ihost as tform).canvas.textheight('#asdf897');
   for p:=0 to high(sysleak_start) do if leakinfo(p,str1) then (ihost as tform).canvas.textout(0,p*int1,str1);
   end;
//dbstatus(35,'Paint-time: '+dbtime+' / '+dbtimeave+' / '+dbtimeavefast+' <<'+ms64str);//xxxxxxxxxxxxx


skipend:
except;end;
try
//.clean up
if xlocked then ibuffer.unlock;
bfree(xline);

//shrink optional buffers ------------------------------------------------------
//.drag
if (xdragindex=-1) then
   begin
   idragbuffer.sizeto(1,1);
   app__fasttimer;//fasttimer - 07jul2021
   end;
//.mask
if not imasking then
   begin
   imask.resize(1,1);
   app__fasttimer;//fasttimer - 07jul2021
   end;
//.reset
imaskval:=-1;
except;end;
try
iwasdrop_showing:=xdrop_showing;
ipaintingpart:=false;
ipaintbusy:=false;
except;end;
end;
{}
//## __ontimer ##
procedure tbasicsystem.__ontimer(sender:tobject);
begin
try
if not itiming then
   begin
   itiming:=true;
   try;xtimer;except;end;
   itiming:=false;
   end;
except;end;
end;
//## __ontimer2 ##
procedure tbasicsystem.__ontimer2(sender:tobject);
begin
try
//check
//xxxxxxxxxxxxxif not itiming then exit;
//get
//xxxxxxxxxxif not itiming2 then
   begin
//xxxxxxxxxx   itiming2:=true;
   try;xtimer;except;end;
//xxxxxxxxxxxxx   itiming2:=false;
   end;
except;end;
end;
//## pumptimer2 ##
procedure tbasicsystem.pumptimer2;//forceably drive the timer - 15jul2021
begin
try
app__timer;//19feb2021
__ontimer2(self);
if (ms64>=ipumptimer2) then
   begin
   app__processallmessages;
   ipumptimer2:=ms64+100;
   end;
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxx//ssssssssssssssssssssssssssss
//## xtimer ##
procedure tbasicsystem.xtimer;
var
   p,cw,ch,int1:longint;
   xms64:comp;
   bol1:boolean;
begin
try
//closed
if iclosed then exit;

//dbstatus(20,ms64str);//xxxxxxxxxxxxxxxxxxxxxxxxxxxx
leakhunt(1,'sys.xtimer');//xxxxxxxxxxxxxxxxxxxxxxxxx
//dbstatus(12,'system.focusindex: '+inttostr(ifocusindex));//xxxxxxxxxxxxxxxx
//dbstatus(13,'system.hoverindex: '+inttostr(ihoverindex));//xxxxxxxxxxxxxxxx
//dbstatus(14,'resize.modes: '+inttostr(ifocussizemodex)+'__'+inttostr(ifocussizemodey)+'<<'+ms64str);//xxxxxxxxxxxx

//check
if not stable then exit;

//closing
if siclosing and (icloselocked<=0) then
   begin
   iclosed:=true;
   exit;
   end;

//init
xms64:=ms64;
cw:=frcmin(ihost.clientwidth,1);
ch:=frcmin(ihost.clientheight,1);

//turbo
{//xxxxxxxxxxxxxxxxxxx//????????????????
xxxxxxxxxxxxxxxxxxxxx
if sysfasttiminginuse then
   begin
   turbonow;//07jul2021
   end;//xxxxxxxxxxxxxx//??????????????????????
{}//xxxxxxxxxxxxx

//sysflash
if (ms64>=sysflash_timer) then
   begin
   sysflash_timer:=ms64+700;
   sysflash:=not sysflash;
   end;

//mustGstate
if (imustGstate>=0) then
   begin
   //init
   bol1:=false;
   int1:=frcrange(imustgstate,0,gsUpperlimit);
   //get
   //.gstate
   if (int1<>igstate) then
      begin
      igstate:=int1;
      bol1:=true;
      end;
   //.reset here -> after igstate has it's new value - 14mar2021
   imustgstate:=-1;
   //.windowstate
//was:   if (int1=gsMax) and (ihost.windowstate<>wsMaximized) then
   if (int1=gsMax) and (not xmaximised) then
      begin
      xsetNM(true);
      bol1:=true;
      end
   else if (int1=gsNormal) and (not xnormal) then
      begin
      xsetNM(false);
      bol1:=true;
      end;
   //sync
   if bol1 then vimustsync:=true;
   end;

//.mustsync - mainform only - 14mar2021, 16aug2020
if vimustsync and (not visyncing) then
   begin
   vimustsync:=false;
   if (application.mainform<>nil) then visync;
   alignallnow;
   paintallnow;
   end;

//itimer250
if (xms64>=itimer250) then
   begin
   //wound rates
   xwoundcalc(iwoundlastx,iwoundlasty);//30sep2022

   //downidle reset - 03apr2021
   if mousedown then low__resetdowntime;

   //settings check
   if visyssettingsloaded and viprgsettingsloaded then
      begin
      //show splash
      if (ishowonceref<>0) and (ms64<ishowonceref) and showing then
         begin
         ishowonceref:=0;//off
         //show splash on startup
         if visplash and (application.mainform=ihost) then xshowsplash else viSplashdone:=true;
         end;
      //splash
      if zzok(isplash,7122) and isplash.xmustclose then
         begin
         freeobj(@isplash);
         viSplashdone:=true;//15mar2022
         end;
      end;

   //xsyncfullscreen - 28jul2020
   xsyncfullscreen;

   //ilastsystem_mustid
   if (ilastsystem_mustid<>system_mustid) then
      begin
      ilastsystem_mustid:=system_mustid;
      if (imustpaint<system_mustpaint) then imustpaint:=system_mustpaint;
      if (imustalign<system_mustalign) then imustalign:=system_mustalign;
      end;

   //ilastsystem_mustidSLOW - used by debug system to optionally paint the screen SLOWLY with debug information rather than racing full speed ahead - 10may2021
   if (xms64>=ilastsystem_slowref64) then
      begin
      ilastsystem_slowref64:=xms64+1000;
      if (ilastsystem_mustidSLOW<>system_mustidSLOW) then
         begin
         ilastsystem_mustidSLOW:=system_mustidSLOW;
         if (imustpaint<system_mustpaint) then imustpaint:=system_mustpaint;
         if (imustalign<system_mustalign) then imustalign:=system_mustalign;
         end;
      end;

   //.show form catch #1
   bol1:=showing;
   if (ilastshowing<>bol1) then
      begin
      ilastshowing:=bol1;
      if ilastshowing then paintallnow;
      end;

   //.cursor update
   if (icursorloadid<>syscursor_loadid) then
      begin
      icursorloadid:=syscursor_loadid;
      //.force cursor to display changes - 29aug2021
      ihost.cursor:=crDefault;
      ihost.cursor:=crArrow;
      end;

   //.mousemoving - turnoff - 27feb2022
   if iscreenmovingfine and (ms64>=iscreenmovingfine64) then iscreenmovingfine:=false;

   //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//ssssssssssssssssssss
   //dbstatus(20,inttostr(winlist.count)+'>>'+inttostr(winhoverlayer)+'__'+inttostr(winhover)+'____'+inttostr(winfocuslayer)+'__'+inttostr(winfocus)+'<<'+ms64str);//xxxxxxxxxxxxxxxx
   //dbstatus(22,'Drag-start: '+inttostr(sysstats_active[satDragstart])+'__drag-capture: '+inttostr(sysstats_active[satDragcapture])+'__drag-paint: '+inttostr(sysstats_active[satDragpaint])+'<<'+ms64str);//xxxxxxxxxxxxxxxxx


   //hidecursor - 28feb2022
   if (ihidecursorref>0) then
      begin
      if (ihidecursorref>ms64) then//on - hide cursor
         begin
         if (ihost.cursor<>crNone) then ihost.cursor:=crNone;
         end
      else//off - restore cursor
         begin
         ihidecursorref:=0;
         if (ihost.cursor=crNone) then ihost.cursor:=crArrow;
         end;
      end;

   //reset
   itimer250:=xms64+250;
   end;

//size
if (cw<>iwidth) or (ch<>iheight) or (vidataid<>ilastdataid) then
   begin
   ilastdataid:=vidataid;//16aug2020
   imustalign:=2;
   imustpaint:=2;
   end;

//actionlist
//was: if (iacount>=1) and xhavewaitfocusLOOSE then anext;
if (iacount>=1) then anext;//this allows non-focused windows to still react to hover events etc - 19apr2021

//children timer's
if (icorecount>=1) then
   begin
   for p:=0 to (icorecount-1) do if zzok(icore[p],5000+p) then icore[p].xtimer;
   end;


//interval ---------------------------------------------------------------------
low__timerdelay(self,__ontimer,xtimerinterval);

//xmustpaint
if (xmustpaint>=1) then
   begin
   iinternalpaint:=true;//mark internal, else assumed to be external, e.g. Windows instigated - 22may2020
   ihost.repaint;
   end;

//.timer1000
if (ms64>=itimer1000) then
   begin
   //debug support
   if system_debug then
      begin
      leakhunt(-2,'sys.xtimer2');//yyyy
      leakhunt(2,'sys.xtimer2');//yyyy
      end;
   //system stats - assumes there is only one "system" object running and that we're it - 16may2020
   for p:=0 to high(sysstats_active) do
   begin
   if (sysstats_ratec[p]=0) then sysstats_ratec[p]:=sysstats_create[p]  else sysstats_ratec[p]:=(sysstats_ratec[p]+sysstats_create[p]) div 2;
   if (sysstats_rated[p]=0) then sysstats_rated[p]:=sysstats_destroy[p] else sysstats_rated[p]:=(sysstats_rated[p]+sysstats_destroy[p]) div 2;
   sysstats_create[p]:=0;
   sysstats_destroy[p]:=0;
   end;//p
   //safearea - 28aug2020
   xsafearea;
   //reset
   itimer1000:=ms64+1000;
   end;

//external timer link - 28jul2020
if (not iontimerbusy) and (not icreating) and assigned(fontimer) and (not iontimerbusy) then
   begin
   try
   iontimerbusy:=true;
   fontimer(self);
   except;end;
   iontimerbusy:=false;
   end;

//xoptions_mustcrosssync - 26feb2022
if ishowoptions_crosssync and (not visyncing) and (not vimustsync) then
   begin
   ishowoptions_crosssync:=false;
   xshowoptions_crosssync;
   end;

leakhunt(-1,'sys.xtimer');
except;end;
end;
//## hidecursor ##
procedure tbasicsystem.hidecursor;//28feb2022
begin
try;ihidecursorref:=ms64+2000;except;end;
end;
//## showcursor ##
procedure tbasicsystem.showcursor;//28feb2022
begin
try;ihidecursorref:=1;except;end;
end;
//## xtimerinterval ##
function tbasicsystem.xtimerinterval:longint;
begin
try
result:=50;
if (systimer_turbo64>=ms64) then result:=1;
except;end;
end;
//new handlers -----------------------------------------------------------------
//## nfullwin ##
function tbasicsystem.nfullwin:tbasicscroll;
begin
try
result:=tbasicscroll.create(self);
result.winstyle:=wmfullwin;
result.oroundstyle:=corRound;
result.oborderstyle:=bsSystem100;
result.owinresizeable:=true;//25feb2021
case syscode of
osW32,osW64:result.xhead.style:=wuAll;
else result.xhead.style:=wuClose;
end;
result.xhelp;//every normal window has help by default
result.xsetclientarea(rect(0,0,0,0));
result.help:=programslogan;//10mar2021
focuscontrol:=result;
except;end;
end;
//## nwindow ##
function tbasicsystem.nwindow(da:trect):tbasicscroll;
begin
try
result:=tbasicscroll.create(self);
result.winstyle:=wmwindow;
result.oroundstyle:=corRound;
result.oborderstyle:=bsSystem100;
result.owinresizeable:=true;//25feb2021
result.xhelp;//every normal window has help by default
result.xsetclientarea(da);
result.help:=programslogan;//10mar2021
focuscontrol:=result;
except;end;
end;
//## nontop ##
function tbasicsystem.nontop(da:trect):tbasicscroll;
begin
try
result:=tbasicscroll.create(self);
result.winstyle:=wmontop;
result.oroundstyle:=corRound;
result.oborderstyle:=bsSystem100;
result.owinresizeable:=true;//25feb2021
result.xhelp;//every normal window has help by default
result.xsetclientarea(da);
result.help:=programslogan;//10mar2021
focuscontrol:=result;
except;end;
end;
//## nsetcolor ##
function tbasicsystem.nsetcolor(da:trect;xshowhead:boolean):tbasicsetcolor;//27feb2021
begin
try
result:=tbasicsetcolor.create(self);
result.makedlg3(da,tepColor32,'Color',xshowhead,true,500,0);
except;end;
end;
//## ndlg ##
function tbasicsystem.ndlg(da:trect;xshowhead:boolean):tbasicscroll;
begin
try;result:=ndlg2(da,xshowhead,true);except;end;
end;
//## ndlg2 ##
function tbasicsystem.ndlg2(da:trect;xshowhead,xstatic:boolean):tbasicscroll;
begin
try;result:=ndlg3(da,tepnone,'',xshowhead,xstatic);except;end;
end;
//## ndlg3 ##
function tbasicsystem.ndlg3(da:trect;xtep:longint;xtitle:string;xshowhead,xstatic:boolean):tbasicscroll;
begin
try
result:=tbasicscroll.create(self);
result.winstyle:=wmdialog;
result.oroundstyle:=corRound;
result.oborderstyle:=bsSystem100;
result.owinresizeable:=true;//25feb2021
result.mkescape:=true;
result.mkreturn:=true;
result.ocode:=0;//cancelled
result.ocode2:='';
result.otepcolor:=clnone;//none
result.static:=xstatic;//17aug2020
if xshowhead then
   begin
   if (xtep<>tepnone) then result.xhead.tep:=xtep;
   if (xtitle<>'')    then result.xhead.caption:=xtitle;
   result.xhead.style:=wuClose;
   end;
result.xhelp;//every normal window has help by default
result.xsetclientarea(da);
result.help:=programslogan;//10mar2021
focuscontrol:=result;
except;end;
end;
//## xcommonevent ##
function tbasicsystem.xcommonevent(a:tbasiccontrol;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean;
begin
try
result:=true;//handled
//check
if zznil(a,2299) then exit;
//get
if (xcode2='status.cancel') then istatusstopped:=true;
except;end;
end;
//## xcommongetitem ##
function tbasicsystem.xcommongetitem(sender:tobject;xindex:longint;var xtab,xtep,xtepcolor:longint;var xcaption,xcaplabel,xhelp,xcode2:string;var xcode,xshortcut,xindent:longint;var xflash,xenabled,xtitle,xsep:boolean):boolean;
begin
try
//defaults
result:=false;
xtab:=0;;
xtep:=tepNone;
xcaption:='';
xcaplabel:='';
xhelp:='';
xcode2:='';
xcode:=0;
xshortcut:=aknone;
xindent:=0;
xenabled:=false;
xtitle:=false;
xsep:=false;
xflash:=false;
//get
if (istatuswin<>nil) and istatuswin.xhavemenu and (sender=istatuswin.xmenu) then
   begin
   xenabled:=true;
   if (xindex>=0) and (xindex<=high(istatustext)) then
      begin
      xcaption:=istatustext[xindex];
      xtep:=istatustep[xindex];
      xtab:=istatustab;
      end;
   result:=true;
   end;
except;end;
end;
//## xstatus_sysstatus_alloff ##
procedure tbasicsystem.xstatus_sysstatus_alloff;
begin
try
//low level support - 04oct2022
sysstatus_fromfile:=-1;
sysstatus_tofile:=-1;
sysstatus_encrypt:=-1;
sysstatus_blaizfolder:=-1;
sysstatus_blaizfolder_setpert:=false;
except;end;
end;
//## xstatusstart ##
procedure tbasicsystem.xstatusstart(xrowcount:longint);
begin//note: -1=reuse current tab setting - 15may2022
try;xstatusstart3(xrowcount,-1,true);except;end;
end;
//## xstatusstart2 ##
procedure tbasicsystem.xstatusstart2(xrowcount,xtab:longint);
begin
try;xstatusstart3(xrowcount,xtab,true);except;end;
end;
//## xstatusstart3 ##
procedure tbasicsystem.xstatusstart3(xrowcount,xtab:longint;xresetcancel:boolean);//20may2022
var
   p:longint;
begin
try
if (xtab>=0) and (xtab<=tbMax) then istatustab:=xtab;
if xresetcancel then
   begin
   istatusstopped:=false;
   xstatus_sysstatus_alloff;//low level support - 04oct2022
   end;
istatusrowcount:=frcrange(xrowcount,0,high(istatustext)+1);
istatustime:=ms64;
except;end;
end;
//## xstatustab ##
procedure tbasicsystem.xstatustab(xtab:longint);
begin
try;istatustab:=xtab;except;end;
end;
//## getstatusstopped ##
function tbasicsystem.getstatusstopped:boolean;
begin
try
result:=istatusstopped;
if (not result) and ((istatuswin<>nil) and (not istatuswin.visible)) then
   begin
   istatusstopped:=true;
   result:=istatusstopped;
   end;
except;end;
end;
//## getstatustext ##
function tbasicsystem.getstatustext(xindex:longint):string;
begin
try;if (xindex>=0) and (xindex<=high(istatustext)) then result:=istatustext[xindex] else result:='';except;end;
end;
//## setstatustext ##
procedure tbasicsystem.setstatustext(xindex:longint;x:string);
begin
try;if (xindex>=0) and (xindex<=high(istatustext)) then istatustext[xindex]:=x;except;end;
end;
//## getstatustep ##
function tbasicsystem.getstatustep(xindex:longint):longint;
begin
try;if (xindex>=0) and (xindex<=high(istatustext)) then result:=istatustep[xindex] else result:=tepNone;except;end;
end;
//## setstatustep ##
procedure tbasicsystem.setstatustep(xindex:longint;x:longint);
begin
try;if (xindex>=0) and (xindex<=high(istatustext)) then istatustep[xindex]:=x;except;end;
end;
//## xstatusstop ##
procedure tbasicsystem.xstatusstop;
begin
try;__xstatus(istatuspert,istatustitle,false,false);except;end;
end;
//## xstatus ##
procedure tbasicsystem.xstatus(xpert:double;xtitle:string);
begin
try;__xstatus(xpert,xtitle,true,false);except;end;
end;
//## setstatuspert ##
procedure tbasicsystem.setstatuspert(xpert:double);
begin
try;__xstatus(xpert,xstatustitle,true,false);except;end;
end;
//## xstatuspaintnow ##
procedure tbasicsystem.xstatuspaintnow;
begin
try
if (istatuswin<>nil) then
   begin
   istatuswin.xhead.caption:=istatustitle;
   istatuswin.xtoolbar2.bpert2['status.cancel']:=istatuspert;
   istatuswin.xmenu.paintimmediate;
   end;
except;end;
end;
//## __xstatus ##
procedure tbasicsystem.__xstatus(xpert:double;xtitle:string;xshow,xupdatenow:boolean);
begin
try
//range
if (xpert<0) then xpert:=0 else if (xpert>100) then xpert:=100;
//get
istatuspert:=xpert;
if (xtitle<>'*') then istatustitle:=low__udv(xtitle,'Status');//"*"=reuse current title - 15may2022

//adjust - 16may2022
if xshow and (istatuswin<>nil) then
   begin
   if (istatuswin.xmenu.countx<>istatusrowcount) then
      begin
      xupdatenow:=true;
      istatuswin.xmenu.makelistx(istatusrowcount);
      istatuswin.makeautohigh;
      end;
   end;

//set
case xshow of
true:begin
   xstatusstart3(istatusrowcount,-1,false);
   if (istatuswin=nil) then
      begin
      //lock
      inc(ishowaitcount);//20jun2021
      closelock;
      xwaitfocus;//set us as the current waitfocus -> causes all other "tbasicsystem's" to cancel any of their active wait tasks - 03par2021
      //finalise mouse
      amouseupfinalise;
      //create
      istatuswin:=nstatus(istatustitle);
      istatuswin.xmenu.orowcount:=istatusrowcount;
      istatuswin.xmenu.ofast:=true;
      istatuswin.xmenu.orows:=true;
      istatuswin.xmenu.oautoheight:=false;//true;
      istatuswin.xmenu.makelistx(istatusrowcount);
      istatuswin.xmenu.oautoclose:=false;
      istatuswin.xtoolbar2.hcsadd('Cancel',tepStop20,100,'status.cancel','Cancel task',-100);
      istatuswin.xtoolbar2.onclick2:=xcommonevent;
      istatuswin.makeautohigh;
      focuscontrol:=istatuswin.xtoolbar2;
      //.events
      istatuswin.xmenu.ongetitem:=xcommongetitem;
      //update
      xupdatenow:=true;
      end;
   //.update by time
   if (ms64>=istatustime) then
      begin
      xupdatenow:=true;
      istatustime:=ms64+200;
      end;
   //.update
   if xupdatenow then
      begin
      istatuswin.xmenu.paintnow;
      istatuswin.xhead.caption:=istatustitle;
      istatuswin.xtoolbar2.bpert2['status.cancel']:=istatuspert;
      end;
   end;
false:begin
   if (istatuswin<>nil) then
      begin
      istatuswin.visible:=false;
      winfocus:=istatuswin.tag;
      freeobj(@istatuswin);
      closeunlock;//close unlock
      ishowaitcount:=frcmin(ishowaitcount-1,0);//20jun2021
      end;
   //low level support - 04oct2022
   xstatus_sysstatus_alloff;
   end;
end;//case
//update system
pumptimer2;

except;end;
end;
//## nstatus ##
function tbasicsystem.nstatus(xtitle:string):tbasicscroll;
const
   xcancelcap='';
var
   dw,dh:longint;
   da:trect;
begin
try
//defaults
result:=nil;
//get
result:=tbasicscroll.create(self);
result.tag:=winfocus;//remember previous focus
result.winstyle:=wmdialog;
result.oroundstyle:=corRound;
result.oborderstyle:=bsSystem50;
result.owinresizeable:=false;//25feb2021
result.mkescape:=true;
result.mkreturn:=false;//02aug2021
result.ocode:=0;//cancelled
result.ocode2:='';
result.otepcolor:=clnone;//none
result.static:=true;
result.help:=programslogan;//10mar2021
if (xtitle<>'') then
   begin
   result.xhead.caption:=xtitle;
   result.xhead.osmall:=true;
   result.xhead.style:=wuNone;
   result.xhead.tep:=tepNone;
   end;
result.xhelp;//every normal window has help by default
result.oautoheight:=true;

//.da
//if (xsize<=0) then xsize:=100;
dw:=400;
dh:=320;
low__winzoom(dw,dh);//17mar2021
da.left:=(width-dw) div 2;
da.top:=(height-dh) div 2;
da.right:=da.left+dw-1;
da.bottom:=da.top+dh-1;
result.xsetclientarea(da);

//xxxxxxxxxxxa.nlabel('Status','Stats');
//b:=a.nedit('',xhelp);
//b.value:=x;
//with result.xtoolbar2 do
//begin
//cadd(low__udv(xokcap,ntranslate('OK')),tepYes20,1,scdlg,rthtranslate('OK'),0);
//cadd(low__udv(xcancelcap,ntranslate('Cancel')),tepClose20,0,scdlg,rthtranslate('Cancel'),120);
//end;
//set
//result.makeautohigh;
//result.focuscontrol:=b;
//result:=xshowwait(a,xpreviousfocus);
{}//xxxxxxxxxxxxxxxx

//xxxxxxx
//result.xsetclientarea(da);
//result.help:=programslogan;//10mar2021
//xxxxxxfocuscontrol:=result;
except;end;
end;
//## nscroll ##
function tbasicsystem.nscroll(da:trect):tbasicscroll;
begin
try
result:=tbasicscroll.create(self);
result.xsetclientarea(da);
except;end;
end;
//pop handlers -----------------------------------------------------------------
//## xsafepopXYWHex ##
procedure tbasicsystem.xsafepopXYWHex(var dx,dy,dw,dh:longint;dy2:longint);//15NOV2010
label//Note: works within the user's workarea
   redo;
var
   once:boolean;
   a:trect;
begin
try
//get
dw:=frcrange(dw,16,iwidth);
dh:=frcrange(dh,16,iheight);
once:=true;
//set
if (dx<=0) then dx:=0 else if ((dx+dw)>width) then dx:=iwidth-dw;
//..y
redo:
if (dy<=0) then dy:=0;
if ((dy+dh)>iheight) then
   begin
   //.sy2 - optional fallback position
   if once and (dy2<>maxint) then
      begin
      once:=false;
      dy:=dy2;
      goto redo;
      end;
   //set
   dy:=iheight-dh;
   end;
except;end;
end;
//## xhavewaitfocusLOOSE ##
function tbasicsystem.xhavewaitfocusLOOSE:boolean;//06apr2021
begin//Yes, "syswait_focus=nil" is valid -> esentially we assume we have focus control if "syswait_focus" is not set to a valid control other than ourselves hence the nil=ok=no other control has taken waitfocus - 06apr2021
try;result:=(syswait_focus=nil) or (syswait_focus=self);except;end;
end;
//## hostshowing ##
function tbasicsystem.hostshowing:boolean;
begin
try;result:=(ihost<>nil) and ihost.showing;except;end;
end;
//## xwaitfocus ##
procedure tbasicsystem.xwaitfocus;
begin
try;syswait_focus:=self;except;end;
end;
//## xshowwait ##
function tbasicsystem.xshowwait(a:tbasicscroll;xpreviousfocus:longint):boolean;
begin
try;result:=xshowwait2(a,xpreviousfocus,0);except;end;
end;
//## xshowwait2 ##
function tbasicsystem.xshowwait2(a:tbasicscroll;xpreviousfocus,xtimeout:longint):boolean;
begin
try;result:=xshowwait3(a,xpreviousfocus,xtimeout,true);except;end;
end;
//## xshowwait3 ##
function tbasicsystem.xshowwait3(a:tbasicscroll;xpreviousfocus,xtimeout:longint;xlimitsize:boolean):boolean;
var//Note: xlimitsize=true=window can't be larger than actual screen so limit it's size to the screen or less - 08mar2021
   xref,xautoclose:comp;
begin
try
//defaults
result:=false;
//check
if zznil(a,2297) or (not hostshowing) then exit;//28jul2021
//lock
inc(ishowaitcount);//20jun2021
closelock;
xwaitfocus;//set us as the current waitfocus -> causes all other "tbasicsystem's" to cancel any of their active wait tasks - 03par2021
//finalise mouse
amouseupfinalise;
//init
if (xtimeout>=1) then xautoclose:=ms64+xtimeout else xautoclose:=0;
if xlimitsize then a.xlimitsize;
//get
xref:=ms64;
while true do
begin
app__timer;//fasttimer - 07jul2021
sleep(1);
if (ms64>=xref) then
   begin
   //shutdown
   if idestroying or siclosing or sihalted or (not xhavewaitfocusLOOSE) then break;//03apr2021
   //window has been closed
   if (not a.visible) or (not a.stable) or (not stable) then break;
   if (visoftclose or a.osoftclose) and (iwinfocus<>a.coreindex) then break;//soft close
   //.autoclose
   if (xautoclose>=1) and (ms64>=xautoclose) then break;
   //keep system alive
   app__timer;//19feb2021
   __ontimer2(self);
   xref:=ms64+frcmin(xtimerinterval-20,1);//allow for 20ms during the "sleep(1)" call -> each call to a "sleep()" consumes approx. 15-20ms of time
   //fixed -> OK now - 05may2021
   app__processmessages;
   end;
end;
//return result
result:=(a.ocode>=1);
except;end;
try
a.visible:=false;
winfocus:=xpreviousfocus;
closeunlock;//close unlock
ishowaitcount:=frcmin(ishowaitcount-1,0);//20jun2021
except;end;
end;
//## xpopwait ##
function tbasicsystem.xpopwait(a:tbasicscroll;xpreviousfocus,dw,dh:longint;xcenter:boolean):boolean;//21may2020
begin
try;result:=xpopwait2(a,nil,xpreviousfocus,dw,dh,xcenter);except;end;
end;
//## xpopwait2 ##
function tbasicsystem.xpopwait2(a:tbasicscroll;xcontrol:tbasiccontrol;xpreviousfocus,dw,dh:longint;xcenter:boolean):boolean;//21may2020
var//Note: xcontrol is optional, if set, then "a" pops below or aboe "xcontrol" like a dropdown list - 04oct2020
   dx,dy,dy2:longint;
   b:tpoint;
begin//Align "d" on screen ready to pop based on "s" position or "sx,sy"
try
//defaults
result:=false;
//check
if zznil(a,2298) or (not hostshowing) then exit;//28jul2021
//init
a.mkescape:=true;
a.mkreturn:=false;//must click a menu item instead
//range
dw:=frcmin(dw,(2*a.findbordersize)+a.ominwidth);
dh:=frcmin(dh,(2*a.findbordersize)+a.ominheight);
//init
b:=downcurpos;//stops mouse up drift -> slight delay between mouse up and menu display can result in menu being placed in the wrong place -> this function locks the position in at the point of the mouse being clicked down - 29mar2020
dx:=b.x;
dy:=b.y;
dy2:=b.y-dh;
if xcenter then
   begin
   dx:=(iwidth-dw) div 2;
   dy:=(iheight-dh) div 2;
   dy2:=dy;
   end
else if zzok(xcontrol,7130) and xcontrol.visibletohost then
   begin
   dx:=xcontrol.clientarea.left;
   dy:=xcontrol.clientarea.bottom;
   dw:=frcmin(dw,xcontrol.clientarea.right-xcontrol.clientarea.left);
   end;
//get
xsafepopXYWHex(dx,dy,dw,dh,dy2);
if a.setbounds(dx,dy,dw,dh) then a.alignnow;
//set
result:=xshowwait(a,xpreviousfocus);
except;end;
end;
//## xclose ##
procedure tbasicsystem.xclose(a:tbasiccontrol);
var
   b:tbasiccontrol;
begin
try;if zzok(a,7131) and a.xwindow(b) then b.visible:=false;except;end;
end;
//## xcloseok ##
procedure tbasicsystem.xcloseok(a:tbasiccontrol);
var
   b:tbasiccontrol;
begin
try
if zzok(a,7132) and a.xwindow(b) then
   begin
   b.ocode:=1;//OK
   b.visible:=false;
   end;
except;end;
end;
//## popint ##
function tbasicsystem.popint(var xval:longint;xmin,xmax,xdef:longint;xtep32:longint;xtitle,xcap,xhelp,xcancelcap,xokcap:string;xsize:longint):boolean;
var
   a:tbasicscroll;
   b:tbasicint;
   da:trect;
   xpreviousfocus,dw,dh:longint;
   xref:comp;
begin
try
//defaults
result:=false;
xpreviousfocus:=winfocus;
a:=nil;
//init
if (xsize<=0) then xsize:=100;
dw:=round(350*(xsize/100));
dh:=320;
low__winzoom(dw,dh);//17mar2021
da.left:=(width-dw) div 2;
da.top:=(height-dh) div 2;
da.right:=da.left+dw-1;
da.bottom:=da.top+dh-1;
//get
a:=ndlg(da,false);
a.oborderstyle:=bsSystem50;
a.static:=true;
a.oautoheight:=true;
a.xhead.caption:=low__udv(xtitle,'Query');
//.tep
if (xtep32=tepNone) then xtep32:=tepQuery32;
a.xhead.tep:=xtep32;
a.xhelp;
b:=a.nint(xcap,xhelp,xmin,xmax,xdef,xval);
with a.xtoolbar2 do
begin
cadd(low__udv(xokcap,ntranslate('OK')),tepYes20,1,scdlg,rthtranslate('OK'),0);
cadd(low__udv(xcancelcap,ntranslate('Cancel')),tepClose20,0,scdlg,rthtranslate('Cancel'),120);
end;
//set
a.makeautohigh;
focuscontrol:=b;
result:=xshowwait(a,xpreviousfocus);
if result then xval:=b.val;
except;end;
try;freeobj(@a);except;end;
end;
//## popedit ##
function tbasicsystem.popedit(var x:string;xcap,xhelp:string):boolean;
begin
try;result:=popedit2(x,tepNone,'',xcap,xhelp,'','',0);except;end;
end;
//## popedit2 ##
function tbasicsystem.popedit2(var x:string;xtep32:longint;xtitle,xcap,xhelp,xcancelcap,xokcap:string;xsize:longint):boolean;
var
   a:tbasicscroll;
   b:tbasicedit;
   da:trect;
   xpreviousfocus,dw,dh:longint;
   xref:comp;
begin
try
//defaults
result:=false;
xpreviousfocus:=winfocus;
a:=nil;
//init
if (xsize<=0) then xsize:=100;
dw:=round(550*(xsize/100));
dh:=320;
low__winzoom(dw,dh);//17mar2021
da.left:=(width-dw) div 2;
da.top:=(height-dh) div 2;
da.right:=da.left+dw-1;
da.bottom:=da.top+dh-1;
//get
a:=ndlg(da,false);
a.oborderstyle:=bsSystem50;
a.static:=true;
a.oautoheight:=true;
a.xhead.caption:=low__udv(xtitle,'Query');
//.tep
if (xtep32=tepNone) then xtep32:=tepQuery32;
a.xhead.tep:=xtep32;
a.xhelp;
a.nlabel(xcap,xhelp);
b:=a.nedit('',xhelp);
b.value:=x;
with a.xtoolbar2 do
begin
cadd(low__udv(xokcap,ntranslate('OK')),tepYes20,1,scdlg,rthtranslate('OK'),0);
cadd(low__udv(xcancelcap,ntranslate('Cancel')),tepClose20,0,scdlg,rthtranslate('Cancel'),120);
end;
//set
a.makeautohigh;
focuscontrol:=b;
result:=xshowwait(a,xpreviousfocus);
if result then x:=b.value;
except;end;
try;freeobj(@a);except;end;
end;
//## popmanyedit2 ##
function tbasicsystem.popmanyedit2(xcount:longint;var x:array of string;xtep32:longint;xtitle:string;xcap:array of string;xhelp:array of string;xcancelcap,xokcap:string;xsize:longint):boolean;
var
   a:tbasicscroll;
   b:array[0..99] of tbasicedit;
   da:trect;
   p,xpreviousfocus,dw,dh:longint;
   xref:comp;
begin
try
//defaults
result:=false;
xpreviousfocus:=winfocus;
a:=nil;
//check
if (low(x)<>0) or (xcount<=0) then exit;
//init
xcount:=frcmax(xcount,high(x)+1);
if (xsize<=0) then xsize:=100;
dw:=round(550*(xsize/100));
dh:=320;
low__winzoom(dw,dh);//17mar2021
da.left:=(width-dw) div 2;
da.top:=(height-dh) div 2;
da.right:=da.left+dw-1;
da.bottom:=da.top+dh-1;
//get
a:=ndlg(da,false);
a.oborderstyle:=bsSystem50;
a.static:=true;
a.oautoheight:=true;
a.xhead.caption:=low__udv(xtitle,'Query');
//.tep
if (xtep32=tepNone) then xtep32:=tepQuery32;
a.xhead.tep:=xtep32;
a.xhelp;
for p:=0 to (xcount-1) do
begin
a.nlabel(xcap[p],xhelp[p]);
b[p]:=a.nedit('',xhelp[p]);
b[p].value:=x[p];
end;//p

with a.xtoolbar2 do
begin
cadd(low__udv(xokcap,ntranslate('OK')),tepYes20,1,scdlg,rthtranslate('OK'),0);
cadd(low__udv(xcancelcap,ntranslate('Cancel')),tepClose20,0,scdlg,rthtranslate('Cancel'),120);
end;
//set
a.makeautohigh;
focuscontrol:=b[0];
result:=xshowwait(a,xpreviousfocus);
if result then
   begin
   for p:=0 to (xcount-1) do x[p]:=b[p].value;
   end;
except;end;
try;freeobj(@a);except;end;
end;
//## poptxt ##
function tbasicsystem.poptxt(var x:string;xwrap:longint;xcap,xhelp:string):boolean;
begin
try;result:=poptxt3(x,xwrap,false,false,xcap,xhelp,'','');except;end;
end;
//## poptxt2 ##
function tbasicsystem.poptxt2(var x:string;xwrap:longint;xreadonly:boolean;xcap,xhelp:string):boolean;
begin
try;result:=poptxt3(x,xwrap,false,xreadonly,xcap,xhelp,'','');except;end;
end;
//## poptxt3 ##
function tbasicsystem.poptxt3(var x:string;xwrap:longint;xrows,xreadonly:boolean;xcap,xhelp,xcancelcap,xokcap:string):boolean;
var
   a:tstr8;
begin
try
result:=false;
a:=nil;
a:=bnew;
a.text:=x;
if poptxt8(a,xwrap,xrows,xreadonly,xcap,xhelp,xcancelcap,xokcap) then
   begin
   x:=a.text;
   result:=true;
   end;
except;end;
try;bfree(a);except;end;
end;
//## poptxt8 ##
function tbasicsystem.poptxt8(xtext:tstr8;xwrap:longint;xrows,xreadonly:boolean;xcap,xhelp,xcancelcap,xokcap:string):boolean;
var
   a:tbasicscroll;
   b:tbasicbwp;
   da:trect;
   xpreviousfocus,dw,dh:longint;
   xref:comp;
begin
try
//defaults
result:=false;
xpreviousfocus:=winfocus;
a:=nil;
block(xtext);
//init
dw:=550;
dh:=450;
low__winzoom(dw,dh);//17mar2021
da.left:=(width-dw) div 2;
da.top:=(height-dh) div 2;
da.right:=da.left+dw-1;
da.bottom:=da.top+dh-1;
//get
a:=ndlg(da,false);
a.mkreturn:=false;//we need the return key for the text box - 11mar2021
a.oborderstyle:=bsSystem50;
a.static:=true;
a.xhead.caption:=low__udv(xcap,'Text');
a.xhead.tep:=tepIcon32;
a.xhelp;
a.xtoolbar.add('Edit',tepEdit20,0,'edit','Show edit menu');
b:=a.nbwp3(xhelp,xtext,xwrap,xrows,true,true);//retain data for later down - 17mar2021
b.maketxt1;//21jun2022
b.oreadonly:=xreadonly;
with a.xtoolbar2 do
begin
cadd(low__udv(xokcap,ntranslate('OK')),tepYes20,1,scdlg,rthtranslate('OK'),0);
cadd(low__udv(xcancelcap,ntranslate('Cancel')),tepClose20,0,scdlg,rthtranslate('Cancel'),300);//5m
end;
//init
b.revertinit(xtext,true);
b.undoon;//18jun2022
//events
a.xtoolbar.setbc14(a,b,nil,nil);
a.xtoolbar.onclick2:=poptxt__event2;
//set
focuscontrol:=b;
result:=xshowwait(a,xpreviousfocus);
if result and zzok(xtext,7134) then
   begin
   xtext.clear;
   b.iogettxt(xtext);
   end;
except;end;
try
freeobj(@a);
bunlockautofree(xtext);
except;end;
end;
//## poptxt__event2 ##
function tbasicsystem.poptxt__event2(a:tbasiccontrol;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean;
begin
try
result:=true;//handled
//check
if zznil(a,2299) then exit;
//get
if (xcode2='edit') and sbwpok(a.bc2) then sbwp(a.bc2).showmenu;
except;end;
end;
//## popquery ##
function tbasicsystem.popquery(x:string):boolean;
begin
try;result:=popquery2(x,'','',false);except;end;
end;
//## popquery2 ##
function tbasicsystem.popquery2(x,xcancelcap,xokcap:string;xlarge:boolean):boolean;
begin
try;result:=popqueryex(x,xcancelcap,xokcap,low__aorb(350,550,xlarge),low__aorb(200,320,xlarge),60,0);except;end;
end;
//## popqueryex ##
function tbasicsystem.popqueryex(x,xcancelcap,xokcap:string;dw,dh,ccancel,cok:longint):boolean;
var
   a:tbasicscroll;
   da:trect;
   xpreviousfocus:longint;
   xref:comp;
begin
try
//defaults
result:=false;
xpreviousfocus:=winfocus;
a:=nil;
//init
low__winzoom2(dw,dh,50,50);//17mar2021
da.left:=(width-dw) div 2;
da.top:=(height-dh) div 2;
da.right:=da.left+dw-1;
da.bottom:=da.top+dh-1;
//get
a:=ndlg(da,false);
a.oborderstyle:=bsSystem50;
a.static:=true;
a.xhead.caption:='Query';
a.xhead.tep:=tepQuery32;
a.xhelp;
a.nbwp('Query message',bcopystrall(x)).makeviewonly;
with a.xtoolbar2 do
begin
cadd(low__udv(xokcap,ntranslate('OK')),tepYes20,1,scdlg,rthtranslate('OK'),cok);
cadd(low__udv(xcancelcap,ntranslate('Cancel')),tepClose20,0,scdlg,rthtranslate('Cancel'),ccancel);
end;
//set
result:=xshowwait(a,xpreviousfocus);
except;end;
try;freeobj(@a);except;end;
end;
//## popinfo ##
function tbasicsystem.popinfo(xtitle,x:string):boolean;
begin
try;result:=popinfo2(xtitle,x,'',false);except;end;
end;
//## popinfo2 ##
function tbasicsystem.popinfo2(xtitle,x,xclosecap:string;xlarge:boolean):boolean;
begin
try;result:=popinfoex(xtitle,x,xclosecap,low__aorb(350,550,xlarge),low__aorb(200,320,xlarge),60);except;end;
end;
//## popinfoex ##
function tbasicsystem.popinfoex(xtitle,x,xclosecap:string;dw,dh,cclose:longint):boolean;
begin
try;result:=poperrorORinfo(xtitle,x,xclosecap,dw,dh,cclose,true);except;end;
end;
//## poperror ##
function tbasicsystem.poperror(x:string):boolean;
begin
try;result:=poperror2(x,'',false);except;end;
end;
//## poperror2 ##
function tbasicsystem.poperror2(x,xclosecap:string;xlarge:boolean):boolean;
begin
try;result:=poperrorex(x,xclosecap,low__aorb(350,550,xlarge),low__aorb(200,320,xlarge),60);except;end;
end;
//## poperrorex ##
function tbasicsystem.poperrorex(x,xclosecap:string;dw,dh,cclose:longint):boolean;
begin
try;result:=poperrorORinfo('',x,xclosecap,dw,dh,cclose,false);except;end;
end;
//## poperrorORinfo ##
function tbasicsystem.poperrorORinfo(xtitle,x,xclosecap:string;dw,dh,cclose:longint;xinfo:boolean):boolean;//03jun2021
var
   a:tbasicscroll;
   da:trect;
   xpreviousfocus:longint;
   xref:comp;
begin
try
//defaults
result:=false;
xpreviousfocus:=winfocus;
a:=nil;
//init
low__winzoom2(dw,dh,50,50);//17mar2021
da.left:=(width-dw) div 2;
da.top:=(height-dh) div 2;
da.right:=da.left+dw-1;
da.bottom:=da.top+dh-1;
//get
a:=ndlg(da,false);
a.oborderstyle:=bsSystem50;
a.static:=true;
if xinfo then
   begin
   a.xhead.caption:=low__udv(xtitle,'Information');//03jun2021
   a.xhead.tep:=tepInfo32;
   a.xhelp;
   a.nbwp('Information',bcopystrall(x)).makeviewonly;
   end
else
   begin
   a.xhead.caption:=low__udv(xtitle,'Error');//11oct2020
   a.xhead.tep:=tepError32;
   a.xhelp;
   a.nbwp('Error message',bcopystrall(x)).makeviewonly;
   end;
with a.xtoolbar2 do
begin
cadd(low__udv(xclosecap,ntranslate('Close')),tepYes20,1,scdlg,rthtranslate('Close'),cclose);
end;
//set
result:=xshowwait(a,xpreviousfocus);
except;end;
try;freeobj(@a);except;end;
end;
//## popmenu ##
function tbasicsystem.popmenu(xpopstyle,ximagealign:longint;xmenudata:tstr8;var xcode:longint;var xcode2:string;var xtepcolor:longint):boolean;
var
   xoutpos,xouthover,xoutselstart,xoutselcount:longint;
begin
try;result:=popmenu3(xpopstyle,ximagealign,xmenudata,nil,0,0,-1,0,0,xoutpos,xouthover,xoutselstart,xoutselcount,xcode,xcode2,xtepcolor);except;end;
end;
//## popmenu2 ##
function tbasicsystem.popmenu2(xpopstyle,ximagealign:longint;xmenudata:tstr8;xmenuname:string;xstyle:longint;var xcode:longint;var xcode2:string;var xtepcolor:longint):boolean;
begin
try;result:=popmenu2b(xpopstyle,ximagealign,xmenudata,nil,xmenuname,xstyle,xcode,xcode2,xtepcolor);except;end;
end;
//## popmenu2b ##
function tbasicsystem.popmenu2b(xpopstyle,ximagealign:longint;xmenudata:tstr8;xcontrol:tbasiccontrol;xmenuname:string;xstyle:longint;var xcode:longint;var xcode2:string;var xtepcolor:longint):boolean;
label
   skipend;
var//Special Note: menu position is remembered for next time when use clicks a menu item - 31mar2020
   int1,int2,int3,int4,i,p:longint;
   xref:currency;
   xok:boolean;
begin
try
//defaults
result:=false;
xcode:=0;
xcode2:='';
xtepcolor:=clnone;
//check
if not block(xmenudata) then exit;
//do not remember
if (xmenuname='') then
   begin
   result:=popmenu3(xpopstyle,ximagealign,xmenudata,nil,xstyle,0,-1,0,0,int1,int2,int3,int4,xcode,xcode2,xtepcolor);
   goto skipend;
   end;
//remember
xok:=false;
i:=0;
xmenuname:=low__lowercase(xmenuname);
//.find existing
if not xok then
   begin
   for p:=0 to high(sysmenu_name) do if (xmenuname=sysmenu_name[p]) then
      begin
      sysmenu_ref64[p]:=ms64;
      i:=p;
      xok:=true;
      break;
      end;//p
   end;
//.find new
if not xok then
   begin
   //get
   xok:=true;
   xref:=maxcur;
   for p:=0 to high(sysmenu_name) do if (sysmenu_ref64[p]<xref) then
      begin
      xref:=sysmenu_ref64[p];
      i:=p;
      end;//p
   //set
   sysmenu_name[i]:=xmenuname;
   sysmenu_pos[i]:=0;
   sysmenu_hover[i]:=-1;
   sysmenu_selstart[i]:=0;
   sysmenu_selcount[i]:=0;//none
   sysmenu_ref64[i]:=ms64;
   end;
//pop
result:=popmenu3(xpopstyle,ximagealign,xmenudata,nil,xstyle,sysmenu_pos[i],sysmenu_hover[i],sysmenu_selstart[i],sysmenu_selcount[i],int1,int2,int3,int4,xcode,xcode2,xtepcolor);
if result then
   begin
   sysmenu_pos[i]:=int1;
   sysmenu_hover[i]:=int2;
   sysmenu_selstart[i]:=int3;
   sysmenu_selcount[i]:=int4;
   end;
skipend:
except;end;
try;bunlockautofree(xmenudata);except;end;
end;
//## popmenu3 ##
function tbasicsystem.popmenu3(xpopstyle,ximagealign:longint;xmenudata:tstr8;xcontrol:tbasiccontrol;xstyle,xpos,xhover,xselstart,xselcount:longint;var xoutpos,xouthover,xoutselstart,xoutselcount,xcode:longint;var xcode2:string;var xtepcolor:longint):boolean;
begin
try;result:=popmenu4(xpopstyle,ximagealign,xmenudata,xcontrol,true,xstyle,0,xpos,xhover,xselstart,xselcount,xoutpos,xouthover,xoutselstart,xoutselcount,xcode,xcode2,xtepcolor);except;end;
end;
//## popmenu4 ##
function tbasicsystem.popmenu4(xpopstyle,ximagealign:longint;xmenudata:tstr8;xcontrol:tbasiccontrol;xshowhelp:boolean;xstyle,xdropcount,xpos,xhover,xselstart,xselcount:longint;var xoutpos,xouthover,xoutselstart,xoutselcount,xcode:longint;var xcode2:string;var xtepcolor:longint):boolean;
begin
try;result:=popmenu5(xpopstyle,ximagealign,xmenudata,xcontrol,xshowhelp,xstyle,xdropcount,xpos,xhover,xselstart,xselcount,xoutpos,xouthover,xoutselstart,xoutselcount,xcode,xcode2,xtepcolor,'');except;end;
end;
//## popmenu5 ##
function tbasicsystem.popmenu5(xpopstyle,ximagealign:longint;xmenudata:tstr8;xcontrol:tbasiccontrol;xshowhelp:boolean;xstyle,xdropcount,xpos,xhover,xselstart,xselcount:longint;var xoutpos,xouthover,xoutselstart,xoutselcount,xcode:longint;var xcode2:string;var xtepcolor:longint;xfindbycode2:string):boolean;//07jul2021
label
   skipend;
var
   a:tbasicscroll;
   xpreviousfocus,int1,int2,xindex:longint;
   xminwidth:boolean;
begin
try
//defaults
result:=false;
xpreviousfocus:=winfocus;
xoutpos:=0;
xouthover:=-1;
xoutselstart:=0;
xoutselcount:=0;
xcode:=0;//none
xcode2:='';
xtepcolor:=clnone;
xshowhelp:=xshowhelp and vihelp;//syncs with "tbasichelp's" own internal setting checker - 14mar2021
a:=nil;
block(xmenudata);
//check
if (low__menucount(xmenudata)<=0) then goto skipend;
//special options
xminwidth:=true;
if (xpopstyle=pmNarrow) then
   begin
   xminwidth:=false;
   end;
//init
a:=ndlg(rect(0,0,1,1),false);
a.owinresizeable:=false;//08mar2021
a.osafearea:=false;//29aug2020
a.osoftclose:=true;//force "softclose" mode for menus always - 03apr2021
if (xstyle=lslist) and zzok(xcontrol,7135) then
   begin
   a.oborderstyle:=bsSystem20;
   end
else a.oborderstyle:=bsSystem50;//50% - 29aug2020
a.ominwidth:=low__insint(120,xminwidth)+(2*a.findbordersize);
a.xhelp.showhelp:=xshowhelp;//19mar2021
a.xmenu.orowcount:=frcmin(xdropcount,0);
a.xmenu.bordersize:=0;
a.xmenu.ostyle:=frcrange(xstyle,0,2);//lsmenu(0)..lsmany(2)
a.xmenu.oimagealign:=ximagealign;
if      (a.xmenu.ostyle=lsmenu) then a.xmenu.makemenu
else if (a.xmenu.ostyle=lslist) then a.xmenu.makepoplist
else if (a.xmenu.ostyle=lsmany) then a.xmenu.makepopmany;
a.xmenu.data:=xmenudata;//allowed -> takes a copy
//.optional -> highlight item in list by searching for "xcode2" via "xfindbycode2" - 07jul2021
if (xfindbycode2<>'') and a.xmenu.xfindbycode2(xfindbycode2,xindex) then
   begin
   a.xmenu.itemindex:=xindex;
   end
else
   begin
   a.xmenu.pos:=frcmin(xpos,0);//07jul2021
   a.xmenu.xsetsel(xselstart,xselcount);
   end;
a.xmenu.hoverindex:=xhover;
a.xmenu.oautofocus:=true;
//int1 + int2
int1:=2*a.findbordersize;
if a.xhavehead then inc(int1,a.xhead.getalignheight(0));//here just incase it's ever used - 01mar2021
if a.xhavehelp and xshowhelp then int2:=a.xhelp.getalignheight(0) else int2:=0;

//.focus the control -> provides wheel ++ support to control - 21may2020
focuscontrol:=a.xmenu;
//get
if xpopwait2(a,xcontrol,xpreviousfocus,int1+a.xmenu.getalignwidth(0),int1+a.xmenu.getalignheight(0)+int2,false) then
   begin
   xoutpos:=a.xmenu.pos;
   xouthover:=a.xmenu.hoverindex;
   xoutselstart:=a.xmenu.selstart;
   xoutselcount:=a.xmenu.selcount;
   xcode:=a.xmenu.ocode;
   xcode2:=a.xmenu.ocode2;
   xtepcolor:=a.xmenu.otepcolor;//02mar2021
   result:=(xcode<>0);
   end;
//popshortcut -> user executed a shortcut (doesn't matter if it exists or not) -> menu has been closed and the shortcut, now feed stored shortcut back to host form for execution - 02apr2020
{
if low__shortcutok(a.popshortcut) and (xhost<>nil) and (xhost is tbasicform) then
   begin
   (xhost as tbasicform).xaction('k',0,a.popshortcut,0);
   end;
{}///xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//???????????????????

//.update system
//app__processmessages;
{}//xxxxxxxxxxxxxxxx
skipend:
except;end;
try;freeobj(@a);except;end;
try;bunlockautofree(xmenudata);except;end;
end;

//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//fffffffffffffffffffffffffff
//## popfont ##
function tbasicsystem.popfont(var xfontname:string):boolean;//26mar2022
var
   a:tbasicscroll;
   b:tbasicmenu;
   da:trect;
   int1,xpos,xcount,xpreviousfocus,dw,dh:longint;
   xref:comp;
   xlist,xline,xpoplist:tstr8;
begin
try
//defaults
result:=false;
xpreviousfocus:=winfocus;
a:=nil;
xlist:=nil;
xline:=nil;
xpoplist:=nil;
//init
dw:=400;
dh:=320;
low__winzoom(dw,dh);//17mar2021
da.left:=(width-dw) div 2;
da.top:=(height-dh) div 2;
da.right:=da.left+dw-1;
da.bottom:=da.top+dh-1;
//init
xlist:=bnew;
xline:=bnew;
xpoplist:=bnew;
low__menuinit(xpoplist);
low__fontlist(xlist);
//get
xpos:=0;
xcount:=0;
while true do
begin
if not low__nextline0(xlist,xline,xpos) then break;
low__menuadd(xpoplist,tepFNew20,clnone,xline.text,'Select font',xline.text,xcount,aknone,0,false,true,false,false);
inc(xcount);
end;
low__menuend(xpoplist);
//set
a:=ndlg(da,false);
a.oborderstyle:=bsSystem50;
//a.static:=true;
a.oautoheight:=true;
a.xhead.caption:='Font';
//.tep
a.xhead.tep:=tepIcon32;
a.xhelp;
//a.nlabel(xcap,xhelp);
b:=a.nlist('Font','Select a font',xpoplist,16);
b.xfindbycode2(xfontname,int1);
b.itemindex:=int1;
b.onumberfrom:=0;
with a.xtoolbar2 do
begin
cadd(ntranslate('OK'),tepYes20,1,scdlg,rthtranslate('OK'),0);
cadd(ntranslate('Cancel'),tepClose20,0,scdlg,rthtranslate('Cancel'),120);
end;
//show
a.makeautohigh;
focuscontrol:=b;
result:=xshowwait(a,xpreviousfocus);
if result then xfontname:=b.xgetval2(b.itemindex);
except;end;
try
freeobj(@a);
freeobj(@xline);
freeobj(@xlist);
freeobj(@xpoplist);
except;end;
end;
//## popdroplist ##
function tbasicsystem.popdroplist(xmenudata:tstr8;xcontrol:tbasiccontrol;var xpos,xcode:longint;var xcode2:string;xfindbycode2:string):boolean;
begin
try;result:=popdroplist2(xmenudata,xcontrol,0,xpos,xcode,xcode2,xfindbycode2);except;end;
end;
//## popdroplist2 ##
function tbasicsystem.popdroplist2(xmenudata:tstr8;xcontrol:tbasiccontrol;xdropcount:longint;var xpos,xcode:longint;var xcode2:string;xfindbycode2:string):boolean;
var
   xoutpos,xouthover,xoutselstart,xoutselcount,xtepcolor:longint;
begin
try
xdropcount:=frcmin(xdropcount,0);
result:=popmenu5(pmNormal,iaNormal,xmenudata,xcontrol,false,lslist,xdropcount,xpos,xpos,xpos,1,xoutpos,xouthover,xoutselstart,xoutselcount,xcode,xcode2,xtepcolor,xfindbycode2);
if result then xpos:=frcmin(xoutselstart,0);
except;end;
end;
//## popopenimg ##
function tbasicsystem.popopenimg(var xfilename:string;var xfilterindex:longint;xcommonfolder:string):boolean;//12apr2021
var
   xfilterlist:string;
begin
try
result:=false;
//filterlist
xfilterlist:=
peallimgs+
pepng+
{$ifdef gif}pegif+{$endif}
{$ifdef jpeg}pejpg+pejif+pejpeg+{$endif}
pebmp+
petea+
peany;
//get
result:=xpopnav3(xfilename,xfilterindex,xfilterlist,low__udv(xcommonfolder,low__platimages),'open','',protect_text(16771212,'Open Image'),true);
except;end;
end;
//## popsaveimg ##
function tbasicsystem.popsaveimg(var xfilename:string;xcommonfolder:string):boolean;//12apr2021
begin
try;result:=popsaveimg2(xfilename,xcommonfolder,'');except;end;
end;
//## popsaveimg2 ##
function tbasicsystem.popsaveimg2(var xfilename:string;xcommonfolder,xtitle2:string):boolean;//18jun2021, 12apr2021
var
   xfilterindex:longint;
   xfilterlist:string;
begin
try
result:=false;
//filterlist
xfilterindex:=0;
xfilterlist:=
pepng+
{$ifdef gif}pegif+{$endif}
{$ifdef jpeg}pejpg+pejif+pejpeg+{$endif}
pebmp+
petea;
//get
result:=xpopnav3(xfilename,xfilterindex,xfilterlist,low__udv(xcommonfolder,low__platimages),'save','',protect_text(16771124,'Save Image')+xtitle2,true);
except;end;
end;
//## popopencur ##
function tbasicsystem.popopencur(var xfilename:string;var xfilterindex:longint;xcommonfolder:string;xmore:boolean):boolean;//29aug2021
var
   xfilterlist:string;
   xcanpreview,xico,xgif:boolean;
begin
try
result:=false;
xcanpreview:=false;
//filterlist
xfilterlist:=
peallcurs+
pecur+
peani;
xico:=false;
xgif:=false;

//.more support
{$ifdef ico}xico:=true;{$endif}
{$ifdef gif}xgif:=true;{$endif}
if xmore and (xico or xgif) then
   begin
   xcanpreview:=true;
   xfilterlist:=
   peallcurs2+
   pecur+
   peani+
   low__insstr(peico,xico)+
   pepng+
   low__insstr(pegif,xgif)+
   '';
   end;

//get
result:=xpopnav3(xfilename,xfilterindex,xfilterlist,low__udv(xcommonfolder,low__platfolder('cursors')),'open','',protect_text(16770916,'Open Cursor'),xcanpreview);
except;end;
end;
//## popopen ##
function tbasicsystem.popopen(var xfilename:string;var xfilterindex:longint;xfilterlist,xcommonfolder:string):boolean;
begin
try;result:=popopen2(xfilename,xfilterindex,xfilterlist,xcommonfolder,'');except;end;
end;
//## popopen2 ##
function tbasicsystem.popopen2(var xfilename:string;var xfilterindex:longint;xfilterlist,xcommonfolder,xtitle2:string):boolean;
begin
try;result:=xpopnav2(xfilename,xfilterindex,xfilterlist,xcommonfolder,'open','','Open'+low__insstr(#32,xtitle2<>'')+xtitle2);except;end;
end;
//## popsave ##
function tbasicsystem.popsave(var xfilename:string;xfilterlist,xcommonfolder:string):boolean;
begin
try;result:=popsave2(xfilename,xfilterlist,xcommonfolder,'');except;end;
end;
//## popsave2 ##
function tbasicsystem.popsave2(var xfilename:string;xfilterlist,xcommonfolder,xtitle2:string):boolean;
var
   xfilterindex:longint;
begin
try
xfilterindex:=0;
result:=xpopnav2(xfilename,xfilterindex,xfilterlist,xcommonfolder,'save','','Save'+low__insstr(#32,xtitle2<>'')+xtitle2);
except;end;
end;
//## popfolder ##
function tbasicsystem.popfolder(var xfilename:string;xcommonfolder:string):boolean;
begin
try;result:=xpopnav(xfilename,xcommonfolder,'folder');except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxx//aaaaaaaaaaaaaaaaaaaaaaa
//## popnewfolder ##
function tbasicsystem.popnewfolder(xfolder:string;var xoutfolder:string):boolean;//14apr2021
label
   redo;
var
   str1,xname:string;
begin
try
//defaults
result:=false;
xoutfolder:='';
//range
xfolder:=asfolderNIL(xfolder);
if (xfolder='') then exit;
//init
xname:='';
redo:
if popedit2(xname,tepNewfolder32,'New Folder','Folder Name','Type a name for the folder','','Create Folder',70) and (xname<>'') then
   begin
   xname:=safename(xname);
   str1:=asfolder(xfolder+xname);
   case low__makefolder(str1) of
   true:begin
      xoutfolder:=str1;
      result:=true;
      end;
   false:begin
      poperror('Failed to create folder "'+xname+'"');
      goto redo;
      end;
   end;//case
   end;
except;end;
end;
//## popfolderimg ##
function tbasicsystem.popfolderimg(xfolder:string):boolean;
var
   a:tbasicscroll;
   b:tbasictea;
   c:tstr8;
   da:trect;
   xpreviousfocus,dw,dh:longint;
   xref:comp;
begin
try
//defaults
result:=false;
xpreviousfocus:=winfocus;
a:=nil;
c:=nil;
//range
xfolder:=asfoldernil(xfolder);
//init
dw:=350;
dh:=320;
low__winzoom(dw,dh);//17mar2021
da.left:=(width-dw) div 2;
da.top:=(height-dh) div 2;
da.right:=da.left+dw-1;
da.bottom:=da.top+dh-1;
//get
a:=ndlg(da,false);
a.oborderstyle:=bsSystem50;
a.static:=true;
a.oautoheight:=true;
a.xhead.caption:='Change Folder Image';
a.xhead.tep:=tepFolderimage32;
a.xhelp;
c:=bnew;
b:=a.ntea(20,20,'Image','Change folder image');
b.odefaultmsg:='( Default Image In Use )';
b.osyscolors:=true;
low__getfolderimg(xfolder,c);
b.setdata(c);

with a.xtoolbar do
begin
cadd(ntranslate('Open'),tepOpen20,0,'tea.open',rthtranslate('Open image from file'),0);
cadd(ntranslate('Save As'),tepSave20,0,'tea.save',rthtranslate('Save image to file'),0);
cadd(ntranslate('Copy'),tepCopy20,0,'tea.copy',rthtranslate('Copy image to clipboard'),0);
cadd(ntranslate('Paste'),tepPaste20,0,'tea.pastebasic',rthtranslate('Paste image from clipboard'),0);
cadd(ntranslate('Menu'),tepMenu20,0,'tea.menu',rthtranslate('Show menu'),0);
end;

with a.xtoolbar2 do
begin
cadd(ntranslate('OK'),tepYes20,1,scdlg,rthtranslate('OK'),0);
cadd(ntranslate('Cancel'),tepClose20,0,scdlg,rthtranslate('Cancel'),300);
cadd(ntranslate('Default Image...'),tepRefresh20,0,'tea.default',rthtranslate('Restore default image'),0);
end;
//events
a.xtoolbar.onclick2:=b.xcmd;
a.xtoolbar2.onclick2:=b.xcmd;
//.handles the button states for selected buttons on these toolbars
b.manage(a.xtoolbar,a.xtoolbar2);
//set
a.makeautohigh;
focuscontrol:=b;
result:=xshowwait(a,xpreviousfocus);
//.unmanage
b.unmanage;
//.result
if result then
   begin
   b.getdata(c);
   low__setfolderimg(xfolder,c);
   end;
except;end;
try
freeobj(@a);
bfree(c);
except;end;
end;
//## popfav ##
function tbasicsystem.popfav(var xfilename:string):boolean;
begin
try;result:=xpopnav(xfilename,'','fav');except;end;
end;
//## popnav ##
function tbasicsystem.popnav(var xfilename:string;xcommonfolder:string):boolean;
begin
try;result:=xpopnav(xfilename,xcommonfolder,'nav');except;end;
end;
//## xpopnav ##
function tbasicsystem.xpopnav(var xvalue:string;xcommonfolder,xstyle:string):boolean;
var
   xfilters:string;
   xfilterindex:longint;
begin
try;xfilterindex:=0;xfilters:='';result:=xpopnav2(xvalue,xfilterindex,xfilters,xcommonfolder,xstyle,'','');except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//pppppppppppppppppppppppppp
//## xpopnav2 ##
function tbasicsystem.xpopnav2(var xvalue:string;var xfilterindex:longint;xfilterlist,xcommonfolder,xstyle,xhisname,xtitle:string):boolean;
begin
try;result:=xpopnav3(xvalue,xfilterindex,xfilterlist,xcommonfolder,xstyle,xhisname,xtitle,false);except;end;
end;
//## xpopnav3 ##
function tbasicsystem.xpopnav3(var xvalue:string;var xfilterindex:longint;xfilterlist,xcommonfolder,xstyle,xhisname,xtitle:string;xcanpreview:boolean):boolean;
label
   redo;
var
   a:tbasicscroll;
   b:tbasicnav;
   da:trect;
   int1,xpreviousfocus,dw,dh:longint;
   xref:comp;
   xcap:string;
begin
try
//defaults
result:=false;
xpreviousfocus:=winfocus;
a:=nil;
//init
if (xstyle='nav') then
   begin
   dw:=600;
   dh:=550;
   end
else if (xstyle='fav') then
   begin
   dw:=500;
   dh:=450;
   end
else
   begin
   dw:=800;
   dh:=550;
   end;
low__winzoom(dw,dh);//17mar2021
da.left:=(width-dw) div 2;
da.top:=(height-dh) div 2;
da.right:=da.left+dw-1;
da.bottom:=da.top+dh-1;
//get
a:=ndlg(da,false);
a.oborderstyle:=bsSystem100;
a.static:=true;
b:=a.nnav;
b.oautoheight:=true;
a.xhelp;
//decide
redo:
if      (xstyle='open') then
   begin
   xhisname:=low__udv(xhisname,'opensave');
   xcap:=low__udv(xtitle,'Open');
   b.syspreview:=true;//22may2022
   b.canpreview:=xcanpreview;
   b.makeopen;
   b.xfromsys('opensave');
   b.ocommonfolder:=xcommonfolder;
   b.filterlist:=xfilterlist;
   b.filterindex:=xfilterindex;//set BEFORE value - 09mar2021
   b.value:=xvalue;
   b.favfolder:=xvalue;//folder to be added if user clicks "add" -> "add to favs list"
   end
else if (xstyle='save') then
   begin
   xhisname:=low__udv(xhisname,'opensave');
   xcap:=low__udv(xtitle,'Save As');
   b.syspreview:=true;//22may2022
   b.canpreview:=xcanpreview;
   b.makesave;
   b.xfromsys('opensave');
   b.ocommonfolder:=xcommonfolder;
   b.filterlist:=xfilterlist;
   b.filterfromfilename:=xvalue;//18jun2021
//was: b.filterindex:=xfilterindex;//set BEFORE value - 09mar2021
   b.value:=xvalue;
   b.favfolder:=xvalue;//folder to be added if user clicks "add" -> "add to favs list"
   end
else if (xstyle='folder') then
   begin
   xhisname:=low__udv(xhisname,'folder');
   xcap:=low__udv(xtitle,'Select Folder');
   b.makefolder;
   b.sortstyle:=nlName;
   b.ocommonfolder:=xcommonfolder;
   b.value:=xvalue;
   b.favfolder:=xvalue;//folder to be added if user clicks "add" -> "add to favs list"
   end
else if (xstyle='nav') then
   begin
   xhisname:=low__udv(xhisname,'nav');
   xcap:=low__udv(xtitle,'Navigate');
   b.makenav;
   b.xfromsys('nav');
   b.ocommonfolder:=xcommonfolder;
   b.value:=xvalue;
   b.favfolder:=xvalue;//folder to be added if user clicks "add" -> "add to favs list"
   end
else if (xstyle='fav') then
   begin
   xhisname:='';//not used
   xcap:=low__udv(xtitle,'Favourites');
   b.makefav;
   b.sortstyle:=nlName;
   b.ocommonfolder:='';
   b.xautoclose(true);
   b.favfolder:=xvalue;//folder to be added if user clicks "add" -> "add to favs list"
   end
else
   begin
   xstyle:='open';
   goto redo;
   end;
//set
b.hisname:=xhisname;
a.xhead.caption:=xcap;
result:=xshowwait(a,xpreviousfocus);
if result then xvalue:=b.value;
xfilterindex:=b.filterindex;//always return this even on a "cancel" - 10mar2021
//.sortstyle
if (xstyle='open') or (xstyle='save') then
   begin
   b.xtosys('opensave');
   viSync;
   siSavesyssettings;
   end
else if (xstyle='nav') then
   begin
   b.xtosys('nav');
   viSync;
   siSavesyssettings;
   end;
except;end;
try;freeobj(@a);except;end;
end;
//## popcolorstatic ##
function tbasicsystem.popcolorstatic(var xvalue:longint):boolean;
var
   m:tstr8;
   xcode,xtepcolor,int1:longint;
   xhelp,xcode2:string;
   //## xadd ##
   procedure xadd(xcap:string;xr,xg,xb:longint);
   begin
   if (xcap='') then xcap:=low__digpad11(xr,3)+'r, '+low__digpad11(xg,3)+'g, '+low__digpad11(xb,3)+'b';
   low__menuitemx2(m,tepColorPal20,low__rgb(xr,xg,xb),xcap,xhelp,'color',100,aknone,true);
   end;
   //## xadd2 ##
   procedure xadd2(xcap:string;xshiftby,xr,xg,xb:longint);
   begin
   if (xshiftby<>0) then
      begin
      xr:=frcrange(xr+xshiftby,0,255);
      xg:=frcrange(xg+xshiftby,0,255);
      xb:=frcrange(xb+xshiftby,0,255);
      end;
   if (xcap='') then xcap:=low__digpad11(xr,3)+'r, '+low__digpad11(xg,3)+'g, '+low__digpad11(xb,3)+'b';
   low__menuitemx2(m,tepColorPal20,low__rgb(xr,xg,xb),xcap,xhelp,'color',100,aknone,true);
   end;
begin
try
//defaults
result:=false;
m:=nil;
xhelp:='Click to use color';
//init
m:=bnew;
low__menuinit(m);
low__menutitle(m,tepNone,'Static Colors','List of static colors');
xadd('White',255,255,255);
xadd('Silver',192,192,192);
xadd('Gray',128,128,128);
xadd('Black',0,0,0);
//.red
xadd2('Pastel Red',100,255,0,0);
xadd('Red',255,0,0);
xadd2('Red 2',-50,255,0,0);
xadd2('Maroon',-127,255,0,0);
xadd2('Maroon 2',-150,255,0,0);
xadd2('Maroon 3',-200,255,0,0);
//.lime
xadd2('Pastel Lime',100,0,255,0);
xadd('Lime',0,255,0);
xadd2('Lime 2',-50,0,255,0);
xadd2('Green',-127,0,255,0);
xadd2('Green 2',-150,0,255,0);
xadd2('Green 3',-200,0,255,0);
//.blue
xadd2('Pastel Blue',100,0,0,255);
xadd('Blue',0,0,255);
xadd2('Blue',-50,0,0,255);
xadd2('Navy',-127,0,0,255);
xadd2('Navy 2',-150,0,0,255);
xadd2('Navy 3',-200,0,0,255);
//.fuchisa
xadd2('Pastel Fuchisa',100,255,0,255);
xadd('Fuchisa',255,0,255);
xadd2('Fuchisa 2',-50,255,0,255);
xadd2('Purple',-127,255,0,255);
xadd2('Purple 2',-150,255,0,255);
xadd2('Purple 3',-200,255,0,255);
//.yellow
xadd2('Pastel Yellow',100,255,255,0);
xadd('Yellow',255,255,0);
xadd2('Yellow 2',-50,255,255,0);
xadd2('Olive',-127,255,255,0);
xadd2('Olive 2',-150,255,255,0);
xadd2('Olive 3',-200,255,255,0);
//.aqua
xadd2('Pastel Aqua',100,0,255,255);
xadd('Aqua',0,255,255);
xadd2('Aqua 2',-50,0,255,255);
xadd2('Teal',-127,0,255,255);
xadd2('Teal 2',-150,0,255,255);
xadd2('Teal 3',-200,0,255,255);
//.orange
xadd2('Pastel Orange',100,255,128,0);
xadd2('Orange',20,255,128,0);
xadd2('Orange 2',0,255,128,0);
xadd2('Orange 3',-50,255,128,0);
//.pink
xadd2('Pink',20,255,198,255);
xadd2('Pink 2',0,255,198,255);
xadd2('Pink 3',-50,255,198,255);
xadd2('Pink 4',-127,255,198,255);
//.pale blue
xadd2('Sea Blue',60,0,128,255);
xadd2('Sea Blue 2',20,0,128,255);
xadd2('Sea Blue 3',0,0,128,255);
xadd2('Sea Blue 4',-50,0,128,255);
//.natural green
xadd2('Natural Green',60,128,255,0);
xadd2('Natural Green 2',20,128,255,0);
xadd2('Natural Green 3',0,128,255,0);
xadd2('Natural Green 4',-50,128,255,0);
//.lush green
xadd2('Alternative Green',60,128,255,128);
xadd2('Alternative Green 2',20,128,255,128);
xadd2('Alternative Green 3',0,128,255,128);
xadd2('Alternative Green 4',-50,128,255,128);
//.brown
xadd2('Pastel Brown',100,128,64,0);
xadd2('Brown',20,128,64,0);
xadd2('Brown 2',0,128,64,0);
xadd2('Brown 3',-50,128,64,0);
//.alternative pink
xadd2('Alternative Pink',20,255,0,128);
xadd2('Alternative Pink 2',0,255,0,128);
xadd2('Alternative Pink 3',-50,255,0,128);
//.alternative purple
xadd2('Alternative Purple',50,128,0,255);
xadd2('Alternative Purple 2',0,128,0,255);
xadd2('Alternative Purple 3',-50,128,0,255);

low__menuend(m);
//get
if popmenu2(pmNormal,iaNormal,m,'popcolorstatic',0,xcode,xcode2,xtepcolor) then
   begin
   xvalue:=xtepcolor;
   result:=true;
   end;
except;end;
try;freeobj(@m);except;end;
end;
//## popcolorhistory ##
function tbasicsystem.popcolorhistory(var xvalue:longint):boolean;
begin
try;result:=xcolorhistory(xvalue,false,false);except;end;
end;
//## popcolorhistory__add ##
function tbasicsystem.popcolorhistory__add(xvalue:longint):boolean;//19mar2021
begin
try;result:=xcolorhistory(xvalue,true,false);except;end;
end;
//## popcolorhistory__edit ##
function tbasicsystem.popcolorhistory__edit:boolean;//19mar2021
var
   int1:longint;
begin
try;int1:=clnone;result:=xcolorhistory(int1,false,true);except;end;
end;
//## xcolorhistory ##
function tbasicsystem.xcolorhistory(var xvalue:longint;xaddonly,xeditonly:boolean):boolean;//19mar2021
label//xaddonly: true=add "xvalue" to top of color history, false=display color history in a popup list
   skipend;
var
   xhis:array[0..99] of longint;
   xdata,m:tstr8;
   xcount,lp,vc,v,vint,vr,vg,vb,p,xcode,xtepcolor,int1:longint;
   str1,e,vstr,xhelp,xcode2:string;
   c24:tcolor24;
   //## hadd ##
   procedure hadd(xr,xg,xb:longint);
   var
      dcol,p:longint;
   begin
   try
   //check
   if (xcount>high(xhis)) then exit;
   //init
   dcol:=low__rgb(xr,xg,xb);
   //find existing
   if (xcount>=1) then
      begin
      for p:=0 to (xcount-1) do if (xhis[p]=dcol) then
         begin
         exit;
         end;
      end;
   //add new
   xhis[xcount]:=dcol;
   inc(xcount);
   except;end;
   end;
   //## xadd ##
   procedure xadd(xr,xg,xb:longint);
   var
      xcap:string;
   begin
   xcap:=low__digpad11(xr,3)+'r, '+low__digpad11(xg,3)+'g, '+low__digpad11(xb,3)+'b';
   low__menuitemx2(m,tepColorPal20,low__rgb(xr,xg,xb),xcap,xhelp,'color',100,aknone,true);
   end;
begin
try
//defaults
result:=false;
m:=nil;
xdata:=nil;
xcount:=0;

//1st
if xaddonly and (xvalue>=0) then
   begin
   c24:=low__intrgb(xvalue);
   hadd(c24.r,c24.g,c24.b);
   end;

//load
xdata:=bnew;
low__fromfile(low__platfolder('settings')+'colhis.txt',xdata,e);
//.edit
if xeditonly then
   begin
   str1:=xdata.text;
   if not poptxt(str1,wwsNone,'Edit Color History','Type one red,green,blue number per line') then goto skipend;
   xdata.text:=str1;
   end;
//.add to histor list
if (xdata.len>=1) then
   begin
   vr:=0;
   vg:=0;
   vb:=0;
   vc:=0;
   lp:=0;
   xdata.aadd([ss10]);//always ends in a return code
   for p:=0 to (xdata.len-1) do
   begin
   v:=xdata.pbytes[p];
   if (v=ssComma) or (v=ss10) or (v=ss13) then
      begin
      //get
      vstr:=xdata.str[lp,p-lp];//0-based
      vint:=frcrange(strint(vstr),0,255);
      case vc of
      0:vr:=vint;
      1:vg:=vint;
      2:vb:=vint;
      end;
      //set
      if ((v=ss10) or (v=ss13)) then
         begin
         //set
         if (vc>=1) then//at least one comma to confirm it is a color we are reading - 19mar2021
            begin
            hadd(vr,vg,vb);
            end;
         //reset
         vr:=0;
         vg:=0;
         vb:=0;
         vc:=-1;
         end;
      //inc
      inc(vc);
      lp:=p+1;
      end;
   //check
   if (xcount>high(xhis)) then break;
   end;//p
   end;
//.store
if xaddonly or xeditonly then
   begin
   xdata.clear;
   if (xcount>=1) then
      begin
      for p:=0 to (xcount-1) do
      begin
      c24:=low__intrgb(xhis[p]);
      xdata.sadd(low__digpad11(c24.r,3)+','+low__digpad11(c24.g,3)+','+low__digpad11(c24.b,3)+rcode);
      end;//p
      end;
   if not low__tofile(low__platfolder('settings')+'colhis.txt',xdata,e) then goto skipend;
   result:=true;
   goto skipend;
   end;

//prompt user
m:=bnew;
xhelp:='Click to use color';
low__menuinit(m);
low__menutitle(m,tepNone,'Color History','History of colors');
if (xcount>=1) then
   begin
   for p:=0 to (xcount-1) do
   begin
   c24:=low__intrgb(xhis[p]);
   xadd(c24.r,c24.g,c24.b);
   end;//p
   end;
if (xcount>=1) then low__menusep(m);
low__menuitem(m,tepEdit20,'Edit History...','Edit color history','edit',100,true);
low__menuend(m);
//get
if popmenu2(pmNormal,iaRight,m,'popcolorhistory',0,xcode,xcode2,xtepcolor) then
   begin
   if (xcode2='edit') then result:=popcolorhistory__edit
   else
      begin
      xvalue:=xtepcolor;
      result:=true;
      end;
   end;

skipend:
except;end;
try;bfree(m);bfree(xdata);except;end;
end;
//## popcolor ##
function tbasicsystem.popcolor(var xvalue:longint):boolean;
var
   a:tbasicsetcolor;
   da:trect;
   int1,xpreviousfocus,dw,dh:longint;
begin
try
//defaults
result:=false;
xpreviousfocus:=winfocus;
a:=nil;
//init
//dw:=700;
//dh:=550;

dw:=550;
dh:=500;

low__winzoom(dw,dh);//17mar2021
da.left:=(width-dw) div 2;
da.top:=(height-dh) div 2;
da.right:=da.left+dw-1;
da.bottom:=da.top+dh-1;
//get
a:=nsetcolor(da,true);
//pop
(a as tbasicsetcolor).setparams(xvalue,xvalue,sysdlg_popcolor_page);
result:=xshowwait(a,xpreviousfocus);
if result then
   begin
   (a as tbasicsetcolor).getparams(sysdlg_popcolor_color,int1,sysdlg_popcolor_page);
   xvalue:=sysdlg_popcolor_color;
   if (xvalue>=0) then popcolorhistory__add(xvalue);
   end;
except;end;
try;freeobj(@a);except;end;
end;
//## setbounds ##
procedure tbasicsystem.setbounds(x,y,w,h:longint);
var
   xwin:tbasicscroll;
   bs,xminw,xminh:longint;
begin
try
//check
if (host=nil) then exit;
//init
xminw:=minwinsize;
xminh:=minwinsize;
if xmainwin(xwin) then
   begin
   bs:=xwin.findbordersize;
   xminw:=frcmin(frcmin(xminw,2*bs),xwin.ominwidth);
   xminh:=frcmin(frcmin(xminh,2*bs),xwin.ominheight);
   end;
//w
if (w<xminw) then w:=xminw;
if (w>misscreenw) then w:=misscreenw;
//h
if (h<xminh) then h:=xminh;
if (h>misscreenh) then h:=misscreenh;
//set
if zzok(host,7137) then host.setbounds(x,y,w,h);
except;end;
end;
//## left ##
function tbasicsystem.left:longint;
begin
try
result:=0;
if zzok(host,7138) then result:=host.left;
except;end;
end;
//## top ##
function tbasicsystem.top:longint;
begin
try
result:=0;
if zzok(host,7139) then result:=host.top;
except;end;
end;
//## clienttoscreen ##
function tbasicsystem.clienttoscreen(x:tpoint):tpoint;
begin
try
{$ifdef D3}
//was: if zzok(host,7140) then result:=host.clienttoscreen(x) else result:=x;
if zzok(host,7140) then result:=low__clienttoscreen(host,x) else result:=x;
{$endif}
{$ifdef D10}
result:=x;
{$endif}
except;end;
end;
//## clientareatoscreen ##
function tbasicsystem.clientareatoscreen(x:trect):trect;
var
   v:tpoint;
begin
try
{$ifdef D3}
result:=x;
if zzok(host,7141) then
   begin
   //x
//was:   v:=host.clienttoscreen(point(x.left,x.top));
   v:=low__clienttoscreen(host,low__point(x.left,x.top));
   //y
//was:   v:=host.clienttoscreen(point(x.right,x.bottom));
   v:=low__clienttoscreen(host,low__point(x.right,x.bottom));
   end;
{$endif}
{$ifdef D10}
result:=x;
{$endif}
except;end;
end;
//## mustclose ##
procedure tbasicsystem.mustclose;
begin
try;imustclose:=true;except;end;
end;
//## paintallnow ##
procedure tbasicsystem.paintallnow;
begin
try;imustpaint:=2;except;end;
end;
//## paintnow ##
procedure tbasicsystem.paintnow;
begin
try;if (imustpaint<1) then imustpaint:=1;except;end;
end;
//## alignallnow ##
procedure tbasicsystem.alignallnow;
begin
try;imustalign:=2;except;end;
end;
//## alignnow ##
procedure tbasicsystem.alignnow;
begin
try;if (imustalign<1) then imustalign:=1;except;end;
end;
//## sizenow ##
procedure tbasicsystem.sizenow;
begin
try
imustalign:=2;//full
imustpaint:=2;//full
except;end;
end;
//## fullalignpaint ##
procedure tbasicsystem.fullalignpaint;
begin
try
imustalign:=2;//full
imustpaint:=2;//full
except;end;
end;
//## aadd ##
function tbasicsystem.aadd(xs:char;xm:byte;xx,xy:longint):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
//full
if (iacount>high(iam)) then exit;
//add
p:=iacount;
ias[p]:=xs;
iam[p]:=xm;
iax[p]:=xx;
iay[p]:=xy;
inc(iacount);
//successful
result:=true;
except;end;
end;
//## apull ##
function tbasicsystem.apull(var xs:char;var xm:byte;var xx,xy:longint):boolean;
var
   c,p:longint;
begin
try
//defaults
result:=false;
//empty
c:=iacount;
if (c<=0) then exit;
//get
xs:=ias[0];
xm:=iam[0];
xx:=iax[0];
xy:=iay[0];
//del
if (c>=2) then
   begin
   for p:=0 to (c-2) do
   begin
   ias[p]:=ias[p+1];
   iam[p]:=iam[p+1];
   iax[p]:=iax[p+1];
   iay[p]:=iay[p+1];
   end;//p
   end;
//set
iacount:=frcmin(c-1,0);
result:=true;
except;end;
end;
//## anext ##
procedure tbasicsystem.anext;//next action
label//Try to avoid using this proc whilst "__onpaint()" is engaged - 17may2020
   skipend,redo;
var
   str1:string;
   xstyle:char;
   mb:byte;
   xkey,sx,sy,int1,int2,int3,int4,int5:longint;
   xtimerfast:currency;
   s:tpoint;
   xshift,xctrl,xalt:boolean;
   //## xwintrack ##
   procedure xwintrack(xdown:boolean);
   var
      int1,int2:longint;
   begin
   //get
   if not xwinfindbyxy(sx,sy,int1,int2) then
      begin
      int1:=-1;
      int2:=-1;
      end;
   //set
   iwinhover:=int1;
   iwinhoverlayer:=int2;
   if xdown then
      begin
      iwinfocus:=int1;
      iwinfocuslayer:=int2;
      if xinuse(iwinfocus) and ((icore[iwinfocus].winstyle=wmwindow) or (icore[iwinfocus].winstyle=wmontop)) and icore[iwinfocus].oautotop then xwintop(icore[iwinfocus]);
      end;
   end;
   //## xkeyboard ##
   procedure xkeyboard;
   var
      a:tint4;
      b1:byte;
   begin
   a.val:=sx;
   b1:=a.bytes[3];
   a.bytes[3]:=0;
   xkey:=a.val;
   if (b1>=4) then
      begin
      xalt:=true;
      dec(b1,4);
      end;
   if (b1>=2) then
      begin
      xctrl:=true;
      dec(b1,2);
      end;
   if (b1>=1) then xshift:=true;
   end;
begin
try
//check
if (iacount<=0) then exit;
//if (iacount<=0) or iabusy then exit else iabusy:=true;//???????????????????????
//init
xshift :=false;
xctrl  :=false;
xalt   :=false;
xtimerfast:=ms64+50;

redo:
//xxxxxxxxxif painting or (not apull(xstyle,mb,sx,sy)) then goto skipend;
if not apull(xstyle,mb,sx,sy) then goto skipend;
//-- wheel support -------------------------------------------------------------
if (xstyle='w') then
   begin
   iwheel:=sx;
   try;if (iwheel<>0) then _onnotify(self,'w');except;end;
   iwheel:=0;//off
   end
//-- keyboard support ----------------------------------------------------------
else if (xstyle='k') then
   begin
   //init
   xkeyboard;
   //.akshift/akshiftup
   if low__setbol(ishiftok,xshift) then
      begin
      ikey:=low__aorb(akshiftup,akshift,ishiftok);
      try;_onnotify(self,'k');except;end;
      end;
   ictrlok  :=xctrl;
   ialtok   :=xalt;
   ikey     :=xkey;
   //event
   try;_onnotify(self,'k');except;end;
   //off
   ikey     :=aknone;
   end

//-- mouse support -------------------------------------------------------------
//.mouse down
else if (xstyle='d') then
   begin
   //init
   xwintrack(true);
   imousedown:=true;
   imousedownref:=ms64;//09mar2022
   imousewasdown:=false;
//was:   imousedbclick:=((ms64-imousedbclicktime)<=500);
   imousedbclick:=((ms64-imousedbclicktime)<=350);//require a slightly faster double click - more stable - 22apr2021
   imousedbclicktime:=ms64;
   imousedownxy:=low__point(sx,sy);
   imousemovexy:=low__point(sx,sy);
   case mb of
   1:imousebutton:=ableft;
   2:imousebutton:=abcenter;
   3:imousebutton:=abright;
   else imousebutton:=abnone;
   end;//case
   low__getcursorpos(s);
   iscreendownxy:=s;
   iscreenmovexy:=s;
   iscreendragging:=false;
   iscreendraggingv:=false;
   iscreendraggingh:=false;
   iscreendraggingfine:=false;
   iscreendraggingfinev:=false;
   iscreendraggingfineh:=false;
   iscreendraggingout:=false;//25feb2021
   //mouse focusindex
   xfindany(sx,sy,int1,int2,int3,int4);
   ifocussizemodex:=int3;
   ifocussizemodey:=int4;
   focusindex:=int1;
   hoverindex:=int2;
   if xinuse(int1) and zzok(core[int1],7142) then idownrect:=core[int1].clientarea else idownrect:=nilrect;
   if zzok(ihost,7143) then ihostdownrect:=rect(ihost.left,ihost.top,ihost.left+ihost.width-1,ihost.top+ihost.height-1) else ihostdownrect:=nilrect;
   //get
   try;_onnotify(self,'m');except;end;
   imousewasdown:=true;
   end
//.mouse up
else if (xstyle='u') then
   begin
   xwintrack(false);
   imousemovexy:=low__point(sx,sy);
   low__getcursorpos(s);
   iscreenmovexy:=s;
   imousedown:=false;
   imousedownref:=0;
   try;_onnotify(self,'m');except;end;
   imousedown:=false;
   imousedownref:=0;
   imousewasdown:=false;
   imousebutton:=abnone;//off
   iscreendragging:=false;
   iscreendraggingv:=false;
   iscreendraggingh:=false;
   iscreendraggingfine:=false;
   iscreendraggingfinev:=false;
   iscreendraggingfineh:=false;
   iscreendraggingout:=false;//25feb2021
   end
//.mouse move
else if (xstyle='m') then
   begin
   xwintrack(false);
   imousemoved:=true;
   try
   imousemovexy:=low__point(sx,sy);
   low__getcursorpos(s);
   iscreenmovexy:=s;
   if imousedown and (not iscreendragging) then
      begin
      //h
      if not low__nrw(iscreenmovexy.x,iscreendownxy.x,vidragtrigger) then
         begin
         iscreendragging:=true;
         iscreendraggingh:=true;
         end;
      //v
      if not low__nrw(iscreenmovexy.y,iscreendownxy.y,vidragtrigger) then
         begin
         iscreendragging:=true;
         iscreendraggingv:=true;
         end;
      end;
   //.fine
   if imousedown and (not iscreendraggingfine) then
      begin
      //h
      if not low__nrw(iscreenmovexy.x,iscreendownxy.x,vidragtriggerfine) then
         begin
         iscreendraggingfine:=true;
         iscreendraggingfineh:=true;
         end;
      //v
      if not low__nrw(iscreenmovexy.y,iscreendownxy.y,vidragtriggerfine) then
         begin
         iscreendraggingfine:=true;
         iscreendraggingfinev:=true;
         end;
      end;

   //.fine - mousemoving - 27feb2022
   if (not low__nrw(iscreenmovingfinexy.x,iscreenmovexy.x,1+vidragtriggerfine)) or (not low__nrw(iscreenmovingfinexy.y,iscreenmovexy.y,1+vidragtriggerfine)) then
      begin
      iscreenmovingfinexy.x:=iscreenmovexy.x;
      iscreenmovingfinexy.y:=iscreenmovexy.y;
      iscreenmovingfine:=true;
      iscreenmovingfine64:=ms64+1000;
      end;

   //.other
   if not imousedown then
      begin
      int5:=ihoverindex;
      xfindany(sx,sy,int1,int2,int3,int4);
      hoverindex:=int2;
      //.tell previous "hoverindex" control that it nolonger has hover index (e.g. cursor is xsoutside)
      if (int5<>ihoverindex) and (indexstyle(int5)=xscontrol) and zzok(icore[int5],7146) then icore[int5]._onnotify(self);
      end;
   try;_onnotify(self,'m');except;end;
   except;end;
   imousemoved:=false;
   end
//.unknown style
else showerror('Unknown action style "'+xstyle+'"');
//.next
if (iacount>=1) and (ms64<=xtimerfast) then goto redo;
skipend:
except;end;
//xxxxxxxxxxxxxxxxxx
//try;iabusy:=false;except;end;
end;
//## mousedraggingout2 ##
function tbasicsystem.mousedraggingout2(x:trect;xkeepchecking,xfine:boolean):boolean;
begin
try;result:=mousedraggingout3(0,0,x,xkeepchecking,xfine);except;end;
end;
//## mousedraggingout3 ##
function tbasicsystem.mousedraggingout3(xoffx,xoffy:longint;x:trect;xkeepchecking,xfine:boolean):boolean;
begin//Note: xoffx and xoffy allows for realtime adjustment of a "strictly local area of 0..N" inside of a control to be extended to a screen based (within system.host clientarea) without sender having to convert the area thenselves - 25feb2021
try
result:=false;
if xkeepchecking and imousedown and low__aorbbol(iscreendragging,iscreendraggingfine,xfine) and ((imousemovexy.x<(xoffx+x.left)) or (imousemovexy.x>(xoffx+x.right)) or (imousemovexy.y<(xoffy+x.top)) or (imousemovexy.y>(xoffy+x.bottom))) then
   begin
   result:=true;
   iscreendraggingout:=true;
   end;
if not xkeepchecking then result:=iscreendraggingout;
except;end;
end;
//## mousedraggingout ##
function tbasicsystem.mousedraggingout(x:tbasiccontrol;xkeepchecking,xfine:boolean):boolean;
begin
try
result:=false;
if xkeepchecking and imousedown and low__aorbbol(iscreendragging,iscreendraggingfine,xfine) and zzok(x,7147) and x.enabled and x.visible then result:=mousedraggingout2(x.clientarea,xkeepchecking,xfine);
if not xkeepchecking then result:=iscreendraggingout;
except;end;
end;
//## amouseupfinalise ##
procedure tbasicsystem.amouseupfinalise;//14may2020
begin
try
imousedown:=false;
imousedownref:=0;//off
imousewasdown:=false;
imousebutton:=abnone;//off
iscreendragging:=false;
iscreendraggingv:=false;
iscreendraggingh:=false;
iscreendraggingfine:=false;
iscreendraggingfinev:=false;
iscreendraggingfineh:=false;
except;end;
end;
//## mousedowntime ##
function tbasicsystem.mousedowntime:comp;//09mar2022
begin
try;result:=0;if imousedown and (imousedownref<>0) then result:=frcmin64(low__sub64(ms64,imousedownref),0);except;end;
end;
//## mousedownstroke ##
function tbasicsystem.mousedownstroke:boolean;
begin
try;result:=imousedown and (not imousewasdown);except;end;
end;
//## mouseupstroke ##
function tbasicsystem.mouseupstroke:boolean;
begin
try;result:=(not imousedown) and imousewasdown;except;end;
end;
//## mousenone ##
function tbasicsystem.mousenone:boolean;
begin
try;result:=(imousebutton=abnone);except;end;
end;
//## mouseleft ##
function tbasicsystem.mouseleft:boolean;
begin
try;result:=(imousebutton=ableft);except;end;
end;
//## mousecenter ##
function tbasicsystem.mousecenter:boolean;
begin
try;result:=(imousebutton=abcenter);except;end;
end;
//## mouseright ##
function tbasicsystem.mouseright:boolean;
begin
try;result:=(imousebutton=abright);except;end;
end;
//## indexstyle ##
function tbasicsystem.indexstyle(xindex:longint):longint;
begin
try
if      (xindex=minint)                             then result:=xsnone
else if (xindex=-2)                                 then result:=xsoutside
//was: else if (xindex=-1)                                 then result:=xssize
else if (xindex>=0) and (xindex<icorecount)         then result:=xscontrol
else                                                     result:=xsunknown;
except;end;
end;
//## styleindex ##
function tbasicsystem.styleindex(xstyle:longint):longint;
begin
try
if      (xstyle=xsnone)                             then result:=minint
else if (xstyle=xsoutside)                          then result:=-2
//was: else if (xstyle=xssize)                             then result:=-1
else if (xstyle=xscontrol)                          then result:=0
else if (xstyle=xsunknown)                          then result:=minint+1
else                                                     result:=minint+1;
except;end;
end;
//## xfindany ##
procedure tbasicsystem.xfindany(sx,sy:longint;var xfocusindex,xhoverindex,xsizemode,ysizemode:longint);
label
   skipend;
var
   a:tbasiccontrol;
   b:trect;
   bs,int1,i,p,cw,ch:longint;
   //## afind ##
   function afind(x:tbasiccontrol;xfindfocus:boolean):boolean;
   var
      a:tbasiccontrol;
      b:trect;
      p:longint;
   begin
   //defaults
   result:=false;
   //check
   if zznil(x,2300) or (not x.visible) then exit;
   //init
   xhoverindex:=x.coreindex;
   if xfindfocus and x.enabled then xfocusindex:=x.coreindex;
   //.this is the topmost child -> no more to look through
   if (x.ownlist.count<=0) then
      begin
      result:=true;
      exit;
      end;
   //find
   if (x.ownlist.count>=1) then
      begin
      for p:=0 to (x.ownlist.count-1) do if xownget(x.ownlist,p,a) and a.visible and (sx>=a.clientarea.left) and (sx<=a.clientarea.right) and (sy>=a.clientarea.top) and (sy<=a.clientarea.bottom) and afind(a,xfindfocus and a.enabled) then
         begin
         result:=true;
         break;
         end;
      end;//p
   end;
begin
try
//defaults
xfocusindex:=minint;//none
xhoverindex:=minint;//none
xsizemode:=sbnone;
ysizemode:=sbnone;
//init
cw:=iwidth;
ch:=iheight;

//-- out-of-range --------------------------------------------------------------
if ((sx<0) or (sx>=cw) or (sy<0) or (sy>=ch)) then
   begin
   xhoverindex:=styleindex(xsoutside);//fixed - 31mar2020
   goto skipend;
   end;

//-- windows -------------------------------------------------------------------
if (winlist.count>=1) then
   begin
   int1:=minint;//none
   for p:=(winlist.count-1) downto 0 do
   begin
   i:=winlist.list[p];
   if xvisible(i) then
      begin
      if (sx>=icore[i].clientarea.left) and (sx<=icore[i].clientarea.right) and (sy>=icore[i].clientarea.top) and (sy<=icore[i].clientarea.bottom) then
         begin
         afind(icore[i],true);
         break;
         end;
      //.go no further than current dialog
      if (icore[i].winstyle=wmdialog) then break;
      end;//i
   end;//p
   end;


//-- border resizers -----------------------------------------------------------
if (xhoverindex=xfocusindex) and xinuse(xfocusindex) then
   begin
   a:=core[xfocusindex];
   if zzok(a,7149) and a.visible and a.enabled and a.owinresizeable and (not a.winmaxed) then
      begin
      //init
      bs:=a.findbordersize;
      b:=a.clientarea;
      //x
      if (bs>=1) and (sx>=b.left) and (sx<(b.left+bs)) then
         begin
         xsizemode:=sbleft;
         if      (sy>=b.top) and (sy<(b.top+(2*bs)))       then ysizemode:=sbtop
         else if (sy>(b.bottom-(2*bs))) and (sy<=b.bottom) then ysizemode:=sbbottom;
         end
      else if (bs>=1) and (sx>(b.right-bs)) and (sx<=b.right) then
         begin
         xsizemode:=sbright;
         if      (sy>=b.top) and (sy<(b.top+(2*bs)))       then ysizemode:=sbtop
         else if (sy>(b.bottom-(2*bs))) and (sy<=b.bottom) then ysizemode:=sbbottom;
         end;
      //y
      if      (bs>=1) and (sy>=b.top) and (sy<(b.top+bs)) then
         begin
         ysizemode:=sbtop;
         if      (sx>=0) and (sx<(b.left+(2*bs)))         then xsizemode:=sbleft
         else if (sx>(b.right-(2*bs))) and (sx<=b.right)  then xsizemode:=sbright;
         end
      else if (bs>=1) and (sy>(b.bottom-bs)) and (sy<=b.bottom) then
         begin
         ysizemode:=sbbottom;
         if      (sx>=0) and (sx<(b.left+(2*bs)))         then xsizemode:=sbleft
         else if (sx>(b.right-(2*bs))) and (sx<=b.right)  then xsizemode:=sbright;
         end;
      end;
   end;
skipend:
except;end;
end;
//## wtop ##
function tbasicsystem.wtop(var x:tbasiccontrol;var xindex:longint):boolean;
var
   p:longint;
begin
try
//xxxxxxxxxxxxxxxxxxxxx//?????????????????????
//defaults
result:=false;
x:=nil;
xindex:=0;
//get
if (icorecount>=1) then
   begin
   for p:=(icorecount-1) downto 0 do if zzok(icore[p],4006) and (icore[p].parent=nil) and icore[p].visible then
      begin
      x:=icore[p];
      xindex:=p;
      result:=true;
      break;
      end;//p
   end;
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxx//ssssssssssssssssssssssssssssssssssss
//## _onnotify ##
procedure tbasicsystem._onnotify(sender:tobject;xstyle:char);
label
   skipend;
var
   a:tbasiccontrol;
   rec1,b:trect;
   s:tbasiccontrol;
   xfocusstyle,xhoverstyle,xfocussizemodex,xfocussizemodey,xval,yval,int1:longint;
   bol1,xmustpaint:boolean;
   xhelp:string;
   //## xnotify ##
   procedure xnotify(s:tbasiccontrol);
   label
      skipend,redo;
   var
      xonce,xhandled:boolean;
      xhelp:string;
      a:tbasiccontrol;
   begin
   //defaults
   xhandled:=false;
   xonce:=true;
   xhelp:='';
   //check
   if zznil(s,2300) then goto skipend;
   //get
   redo:
   if s.visible then
      begin
      xhandled:=s._onnotify(self);
      if xonce then
         begin
         xonce:=false;
         xhelp:=s.helpline;
         end;
      end;
   if (not xhandled) and zzok(s.parent,7150) then
      begin
      s:=s.parent;
      goto redo;
      end;
   //last -> form based handler -> used for shortcuts etc or for doing something above and beyond the controls themselves -> hence the "ok=true=handled" - 31mar2020
   skipend:
   //root form
   _onnotifylast(self,xhandled);
   //update realtime help - 07sep2020
   if zzok(s,7151) and s.visible and s.xwindow(a) and zzok(a,7409) and (a as tbasicscroll).xhavehelp then (a as tbasicscroll).xhelp.text:=xhelp;
   end;
   //## xshortcut ##
   procedure xshortcut(s:tbasiccontrol);
   var
      p:longint;
      xhandled:boolean;
   begin
   //defaults
   xhandled:=false;
   //check
   if not low__shortcutok(ikey) then exit;
   //s "focused control" as priority
   if (not xhandled) and zzok(s,7152) and s._onshortcut(self) then xhandled:=true;
   //all other controls as second priority
   if (not xhandled) and (icorecount>=1) then
      begin
      for p:=0 to (icorecount-1) do if zzok(icore[p],7154) and (icore[p]<>s) and icore[p]._onshortcut(self) then
         begin
         xhandled:=true;
         break;
         end;//p
      end;
   //root form
   if (not xhandled) then xhandled:=_onshortcut(self);
   end;
begin
try
//defaults
xmustpaint:=false;
xfocusstyle:=indexstyle(ifocusindex);
xhoverstyle:=indexstyle(ihoverindex);
xfocussizemodex:=ifocussizemodex;
xfocussizemodey:=ifocussizemodey;

//-- mouse ---------------------------------------------------------------------
if (xstyle='m') or (xstyle='M') then
   begin
   if mouseupstroke then sizestop;//stop

   if imousedown then
      begin
      if (xfocusstyle=xscontrol) and zzok(core[ifocusindex],7157) then
         begin
         if (xfocussizemodex<>sbnone) or (xfocussizemodey<>sbnone) then core[ifocusindex].xresizer else xnotify(core[ifocusindex]);
         end
      else xnotify(nil);
      end
   else
      begin
      if      (xhoverstyle=xscontrol) and zzok(core[ihoverindex],7158) then xnotify(core[ihoverindex])
      else                                                                  xnotify(nil);
      end;
   end
//-- keyboard ------------------------------------------------------------------
else if (xstyle='k') or (xstyle='K') then
   begin
   //init
   if (xfocusstyle=xscontrol) and zzok(core[ifocusindex],7159) then s:=core[ifocusindex] else s:=nil;
   //get
   case low__shortcutok(ikey) of
   true:xshortcut(s);//key is a shortcut -> use shortcut handler instead of "_onnotify()" procs
   false:xnotify(s);//fire normal "_onnotify()" procs
   end;
   end
//-- wheel ---------------------------------------------------------------------
else if (xstyle='w') or (xstyle='W') then
   begin
   if (xfocusstyle=xscontrol) and zzok(core[ifocusindex],7160) then xnotify(core[ifocusindex])
   else xnotify(nil);
   end;
//.unknown -> ignore
goto skipend;


//xmustpaint
if xmustpaint then paintnow;
skipend:
except;end;
end;
//## _onnotifylast ##
procedure tbasicsystem._onnotifylast(sender:tobject;xhandled:boolean);
var
   x:tbasiccontrol;
begin
try
//close form
case key of
akescape:if xdlg(x) and x.mkescape then
   begin
   x.ocode:=0;
   x.visible:=false;
   end;
akreturn:if xdlg(x) and x.mkreturn then
   begin
   x.ocode:=1;
   x.visible:=false;
   end;
end;//case
except;end;
end;
//## _onshortcut ##
function tbasicsystem._onshortcut(sender:tobject):boolean;
begin
try;result:=false;except;end;
end;
//## setfocusindex ##
procedure tbasicsystem.setfocusindex(x:longint);
var
   xwas:longint;
   a:tbasiccontrol;
begin
try
//get
if (x=ifocusindex) then exit;
xwas:=ifocusindex;
ifocusindex:=x;
//.winfocus/layer
if xinuse(x) then icore[x].xwindow(a) else a:=nil;
if zzok(a,7161) then
   begin
   iwinfocus:=a.coreindex;
   xwinfindlayer(a.coreindex,iwinfocuslayer);
   end
else
   begin
   iwinfocus:=-1;
   iwinfocuslayer:=-1;
   end;
//was
if zzok(core[xwas],7162)    then core[xwas]._onfocus(self);
//new
if zzok(core[x],7163)       then core[x]._onfocus(self);
except;end;
end;
//## setwinfocus ##
procedure tbasicsystem.setwinfocus(x:longint);
var
   int1,int2,p:longint;
begin
try
//defaults
int1:=-1;
int2:=-1;
//find
if (winlist.count>=1) then
   begin
   for p:=0 to (winlist.count-1) do if (winlist.list[p]=x) then
      begin
      int1:=x;
      int2:=p;
      break;
      end;
   end;
//set
if (iwinfocus<>int1) or (iwinfocuslayer<>int2) then
   begin
   iwinfocus:=int1;
   iwinfocuslayer:=int2;
   paintallnow;
   end;
except;end;
end;
//## sethoverindex ##
procedure tbasicsystem.sethoverindex(x:longint);
begin
try;ihoverindex:=x;except;end;
end;
//## getfocuscontrol ##
function tbasicsystem.getfocuscontrol:tbasiccontrol;
begin
try;result:=core[ifocusindex];except;end;
end;
//## setfocuscontrol ##
procedure tbasicsystem.setfocuscontrol(x:tbasiccontrol);
var
   p,int1:longint;
begin
try
//defaults
int1:=minint;//none
//get
if zzok(x,7164) and (icorecount>=1) then
   begin
   for p:=0 to (icorecount-1) do if (x=icore[p]) then
      begin
      int1:=p;
      break;
      end;//p
   end;
//set
focusindex:=int1;
except;end;
end;
//## xrootok ##
function tbasicsystem.xrootok(x:tbasiccontrol):boolean;
begin
try;result:=zzok(x,2301) and (x.parent=nil);except;end;
end;
//## xsafeown ##
function tbasicsystem.xsafeown(var xownlist:townlist):boolean;
begin
try
result:=true;
if (xownlist.count<0) then xownlist.count:=0;
if (xownlist.count>(high(xownlist.list)+1)) then xownlist.count:=high(xownlist.list)+1;
except;end;
end;
//## xownhave ##
function tbasicsystem.xownhave(var xownlist:townlist;x:tbasiccontrol):boolean;
var
   int1:longint;
begin
try;result:=xownfind(xownlist,x,int1);except;end;
end;
//## xownfind ##
function tbasicsystem.xownfind(var xownlist:townlist;x:tbasiccontrol;var xownslot:longint):boolean;
var
   v,p:longint;
begin
try
//defaults
result:=false;
xownslot:=0;
xsafeown(xownlist);
//check
if (xownlist.count<=0) or zznil(x,2302) then exit;
//find
for p:=0 to (xownlist.count-1) do
begin
v:=xownlist.list[p];
if xinuse(v) and (x=icore[v]) then
   begin
   xownslot:=p;
   result:=true;
   break;
   end;
end;//p
except;end;
end;
//## xownfindcount ##
function tbasicsystem.xownfindcount(var xownlist:townlist):longint;
var
   p:longint;
begin
try
result:=0;
if xsafeown(xownlist) and (xownlist.count>=1) then for p:=0 to (xownlist.count-1) do if (xownlist.list[p]<>omfree) then result:=p+1;
except;end;
end;
//## xownadd ##
function tbasicsystem.xownadd(var xownlist:townlist;x:tbasiccontrol):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
//check
if zznil(x,2303) or xownhave(xownlist,x) then exit;
//find first empty slot "omfree=maxword"
for p:=0 to (xownlist.count-1) do
begin
if (xownlist.list[p]=omfree) then//previously used slot but now FREE - 19mar2020
   begin
   xownlist.list[p]:=x.coreindex;
   result:=true;
   break;
   end;
end;//p
//add a slot
if (not result) and (xownlist.count<=high(xownlist.list)) then
   begin
   //enlarge ownlist + store + fill new free slots with "omfree"
   xownlist.list[xownlist.count]:=x.coreindex;//store control in first new slot
   inc(xownlist.count,1);//inc
   result:=true;
   end;
except;end;
end;
//## xowndel ##
procedure tbasicsystem.xowndel(var xownlist:townlist;x:tbasiccontrol);
var
   p:longint;
begin
try
if zzok(x,7165) and xownfind(xownlist,x,p) then
   begin
   //delete
   xownlist.list[p]:=omfree;
   //shrink "xowncount"
   xownlist.count:=xownfindcount(xownlist);
   end;
except;end;
end;
//## xownget ##
function tbasicsystem.xownget(var xownlist:townlist;xownslot:longint;var x:tbasiccontrol):boolean;
var
   v:longint;
begin
try
//defaults
result:=false;
x:=nil;
//get
if xsafeown(xownlist) and (xownslot>=0) and (xownslot<xownlist.count) then
   begin
   v:=xownlist.list[xownslot];
   if xinuse(v) then
      begin
      x:=icore[v];
      result:=true;
      end;
   end;
except;end;
end;
//## xowndel__fast ##
function tbasicsystem.xowndel__fast(var xownlist:townlist;xownslot:longint):boolean;//04may2021
var
   v:longint;
   x:tbasiccontrol;
begin
try
//defaults
result:=false;
//get
if xsafeown(xownlist) and (xownslot>=0) and (xownslot<xownlist.count) then
   begin
   v:=xownlist.list[xownslot];
   if xinuse(v) then
      begin
      x:=icore[v];
      //close slot
      xownlist.list[v]:=omfree;
      icore[v]:=nil;
      //close control
      freeobj(@x);
      result:=true;
      end;
   end;
except;end;
end;
//## ownadd ##
procedure tbasicsystem.ownadd(xhost,xcontrol:tobject);
begin
try
//check
if zznil(xcontrol,2305) or (not (xcontrol is tbasiccontrol)) then exit;
//get
if zznil(xhost,2306) or (xhost=self) then xownadd(ownlist,xcontrol as tbasiccontrol)//add to form as a root control
else if (xhost is tbasiccontrol)     then xownadd((xhost as tbasiccontrol).ownlist,xcontrol as tbasiccontrol)
else                                      showerror('Invalid ownadd host');
//inc
low__iroll(ownid,1);
if zzok(xhost,7170) and (xhost is tbasiccontrol) then (xhost as tbasiccontrol).ownidInc;
except;end;
end;
//## owndel ##
procedure tbasicsystem.owndel(xhost,xcontrol:tobject);
begin
try
//check
if zznil(xcontrol,2307) or (not (xcontrol is tbasiccontrol)) then exit;
//get
if      zznil(xhost,2308) or (xhost=self) then xowndel(ownlist,xcontrol as tbasiccontrol)//del from form
else if (xhost is tbasiccontrol)    then xowndel((xhost as tbasiccontrol).ownlist,xcontrol as tbasiccontrol)
else                                     showerror('Invalid owndel host');
//inc
low__iroll(ownid,1);
if zzok(xhost,7171) and (xhost is tbasiccontrol) then (xhost as tbasiccontrol).ownidInc;
except;end;
end;
//## xareaok ##
function tbasicsystem.xareaok(var x:trect):boolean;
begin
try;result:=(x.right>=x.left) and (x.bottom>=x.top);except;end;
end;
//## xareaokb ##
function tbasicsystem.xareaokb(x:trect):boolean;
begin
try;result:=(x.right>=x.left) and (x.bottom>=x.top);except;end;
end;
//## getcore ##
function tbasicsystem.getcore(x:longint):tbasiccontrol;
begin
try
result:=nil;
if (x>=0) and (x<=high(icore)) and (x<icorecount) then result:=icore[x];
except;end;
end;
//## xinuse ##
function tbasicsystem.xinuse(xcoreindex:longint):boolean;
begin
try;result:=(xcoreindex>=0) and (xcoreindex<=high(icore)) and (xcoreindex<icorecount) and zzok(icore[xcoreindex],7172);except;end;
end;
//## xvisible ##
function tbasicsystem.xvisible(xcoreindex:longint):boolean;
begin
try;result:=(xcoreindex>=0) and (xcoreindex<=high(icore)) and (xcoreindex<icorecount) and zzok(icore[xcoreindex],7173) and icore[xcoreindex].visible;except;end;
end;
//## xadd ##
function tbasicsystem.xadd(x:tbasiccontrol;var xcoreindex:longint):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
xcoreindex:=0;
//check
if zznil(x,2309) then exit;
//find existing
if not result then
   begin
   for p:=0 to high(icore) do if (x=icore[p]) then
      begin
      xcoreindex:=p;
      result:=true;
      break;
      end;//p
   end;
//add new
if not result then
   begin
   for p:=0 to high(icore) do if (nil=icore[p]) then
      begin
      icore[p]:=x;
      xcoreindex:=p;
      if (p>=icorecount) then icorecount:=p+1;
      result:=true;
      break;
      end;//p
   end;
except;end;
end;
//## xdel ##
function tbasicsystem.xdel(xcoreindex:longint;xfree:boolean):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
//check
if (xcoreindex<0) or (xcoreindex>high(icore)) then exit;
//get
//.already deleted
if zznil(icore[xcoreindex],4007) then
   begin
   result:=true;
   exit;
   end;
//.delete
if xfree then freeobj(@icore[xcoreindex]);
icore[xcoreindex]:=nil;
//.shrink icorecount
if (icorecount>=1) and ((xcoreindex+1)=icorecount) then dec(icorecount);
//successful
result:=true;
except;end;
end;
//## rows ##
function tbasicsystem.rows:tstr8;
begin
try;result:=ibuffer.rows;except;end;
end;

//## tbasiccontrol #############################################################
//xxxxxxxxxxxxxxxxxxxxxxxxxxxx//bbbbbbbbbbbbbbbbbbbbbbbbbbb
//## create ##
constructor tbasiccontrol.create(xparent:tobject);
begin
create2(xparent,true);
end;
//## create2 ##
constructor tbasiccontrol.create2(xparent:tobject;xstart:boolean);
begin
//self
zzadd(self);
icreating:=true;
idestroying:=false;
imakemode:=0;//default control, 1=imageviewer
omade:=made_none;//23mar2022
ominimal:=false;
ioffloading:=false;//07mar2021
osoftclose:=false;
obold:=false;//03mar2021
otab:=tbNone;
oparentcorners:=true;//07oct2020
owinresizeable:=false;//25feb2021
owinLdrCOLOR:=clnone;//07mar2022
oframebrightness:=100;//01mar2022
oframebrightnessDARK:=0;//01mar2022
fontimer2:=nil;
fonalign:=nil;
fonvalue:=nil;
fonfindheight:=nil;//06jul2021
iwinstyle:=wmControl;
oroundstyle:=corRound;
ishowmenu:=nil;//optional menu pointer -> for displaying "popup" menus
ocanshowmenu:=false;//disable "showmenu" by default
iid:=low__newid;//system id
iaid:=0;
iidleREF64:=ms64;
satinc(satControl,1);
iwoundtime:=0;
iwoundtimer:=ms64;
inherited create;
//defaults
osafearea:=true;//28aug2020
oborderstyle:=bsInternal;
//.makeImageViewer support
iimagebuffer:=nil;//12jan2022
iimagebufferi:=nil;//07feb2022
iimagebuffertimer:=0;//22may2022
iimagebuffermustfile:='';
iimagebufferlastfile:='';
iimagebufferinfo:='';
//.special color overriders
ospbackcolor:=clnone;
ospbackname:='';
//.direct color overriders
obackcolor:=clnone;//22mar2021
otextcolor:=clnone;//22mar2021
oframecolor:=clnone;
oframecolor2:=clnone;
oframesparkle:=-1;//27mar2021
//.continue
oautotop:=true;
oalignvert:=true;
oimagealign:=iaNormal;//19mar2021
ipainting:=false;
ipainted:=false;
imustpaint:=false;
imustalign:=false;
ialigned:=false;
ialigning:=false;
itiming:=false;
itimer:=false;
//.own support
ownlist.count:=0;
ownid:=0;
//.window support
ocode:=0;
ocode2:='';
otepcolor:=clnone;
mkescape:=false;
mkreturn:=false;
//.other
tag:=0;
tagstr:='';
tagobj:=nil;
bc1:=nil;//15mar2021
bc2:=nil;
bc3:=nil;
bc4:=nil;
iheightref:=-1;
icaption:='';
ihelp:='';
ihelp2:='';
isubhelp:='';//19aug2020
isubhelp2:='';//07sep2020
inormal:=true;
ibordersize:=1;
ivisible:=false;
ienabled:=false;
iclientarea:=rect(0,0,7,7);//8x8
//.options
owinname:='';
opagename:='';
oautofocus:=false;
oautoheight:=false;
oautowidth:=false;
ominheight:=0;
ominwidth:=0;
oseph:=0;
osepv:=0;
//init
if zznil(xparent,2311) then//invalid value -> can't function with this!
   begin
   iparent:=nil;
   igui:=nil;
   end
else if (xparent is tbasicsystem) then
   begin
   iparent:=nil;
   igui:=(xparent as tbasicsystem);
   end
else if (xparent is tbasiccontrol) then
   begin
   iparent:=(xparent as tbasiccontrol);
   igui:=iparent.gui;
   end;
//check
if zznil(gui,2312) then showerror('GUI not set for "'+classname+'"');
if not gui.xadd(self,icoreindex) then showerror('GUI at capacity');
//add
gui.ownadd(iparent,self);
if zzok(iparent,7173) and (iparent is tbasiccontrol) then iparentcoreindex:=(iparent as tbasiccontrol).coreindex else iparentcoreindex:=-1;
enabled:=true;
visible:=true;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasiccontrol.destroy;
begin
try
//stop
idestroying:=true;
//external events
fontimer2:=nil;//01mar2021
fonalign:=nil;
ocanshowmenu:=false;
//disconnect timer
timer:=false;
low__timerdel(self,__onimageviewertimer);
//remove ourselves from the window list "gui.winlist"
if (winstyle>wmcontrol) then winstyle:=wmcontrol;
//destroy children - child controls visible on this control
destroychildren;
//destroy other - support controls etc
destroyothers;
//controls
if (iimagebuffer<>nil) then freeobj(@iimagebuffer);
//self -> disconnect from GUI and destroy ourself - 04apr2020
gui.xdel(icoreindex,false);//no need to "freeobj" since we are already "destroying" ourself
inherited destroy;
//delete special vars
if zzok(ishowmenu,7174) then bfree(ishowmenu);
//update system stats
satinc(satControl,-1);
except;end;
end;
//## destroychildren ##
procedure tbasiccontrol.destroychildren;
var
   p:longint;
begin
try
if gui.xsafeown(ownlist) and (ownlist.count>=1) then
   begin
   for p:=(ownlist.count-1) downto 0 do gui.xowndel__fast(ownlist,p);
   end;
except;end;
end;
//## destroyothers ##
procedure tbasiccontrol.destroyothers;
begin
try
//called after "destroychildren", use to destroy special support controls etc
except;end;
end;
//## xwound_wheel ##
procedure tbasiccontrol.xwound_wheel(xtimems:longint);//04oct2022
begin
try
if viautoscroll and (xtimems<>0) then
   begin
   if not xwound_dirmatch(xtimems,iwoundtime) then xwound_off;
   iwoundtime:=iwoundtime+xtimems;
   end;
except;end;
end;
//## xwound_mousevert ##
procedure tbasiccontrol.xwound_mousevert(xmaxtime:longint;xforce:boolean);
begin
try;xwound_mousevert2(xmaxtime,xforce,false);except;end;
end;
//## xwound_mousevert2 ##
procedure tbasiccontrol.xwound_mousevert2(xmaxtime:longint;xforce,xinvert:boolean);
begin
try;xwound_mousevert3(xmaxtime,xforce,xinvert,true);except;end;
end;
//## xwound_mousevert3 ##
procedure tbasiccontrol.xwound_mousevert3(xmaxtime:longint;xforce,xinvert,xvertical:boolean);
begin
try
case xvertical of
true :if viautoscroll and (xmaxtime<>0) and (gui.woundrateypert100>=12) and (xforce or (gui.mouseupstroke and gui.mousedragging and gui.mouseleft)) then iwoundtime:=gui.woundrateytime(xmaxtime,xforce)*low__aorb(1,-1,xinvert);
false:if viautoscroll and (xmaxtime<>0) and (gui.woundratexpert100>=12) and (xforce or (gui.mouseupstroke and gui.mousedragging and gui.mouseleft)) then iwoundtime:=gui.woundratextime(xmaxtime,xforce)*low__aorb(1,-1,xinvert);
end;//case
except;end;
end;
//## xwound_mustpaint ##
function tbasiccontrol.xwound_mustpaint(spos,xrowsperpaint:longint;var dpos,ddir:longint):boolean;
const
   xtimeblock=30;//30ms
begin
try
//defaults
result:=false;
dpos:=spos;
ddir:=low__aorb(-1,1,iwoundtime>=0);
//check
if not viautoscroll then exit;
//get
if (ms64>=iwoundtimer) then
   begin
   if (iwoundtime<>0) then
      begin
      if (not gui.mousedown) then
         begin
         dpos:=spos+round( frcmin(xrowsperpaint,1) * (frcrange(-iwoundtime,-500,500)/500) );
         if (dpos<>spos) then result:=true;
         end;
      //.shrink time
      iwoundtime:=frcmin(low__posn(iwoundtime)-xtimeblock,0)*low__aorb(1,-1,iwoundtime<0);
      end;
   iwoundtimer:=ms64+xtimeblock;
   end;
except;end;
end;
//## xwound_mustpaint2 ##
function tbasiccontrol.xwound_mustpaint2(spos,xrowsperpaint:longint):longint;
var
   int1:longint;
begin
try;xwound_mustpaint(spos,xrowsperpaint,result,int1);except;end;
end;
//## xwound_off ##
function tbasiccontrol.xwound_off:boolean;
begin
try;result:=(iwoundtime<>0);iwoundtime:=0;except;end;
end;
//## xwound_autooff ##
procedure tbasiccontrol.xwound_autooff(spos,xdir,xmin,xmax:longint);
begin
try;if ((xdir>=1) and (spos>=xmax)) or ((xdir<=-1) and (spos<=xmin)) then xwound_off;except;end;
end;
//## xwound_finddir ##
function tbasiccontrol.xwound_finddir(xtime:longint):longint;
begin
try;if (xtime>=0) then result:=1 else result:=-1;except;end;
end;
//## xwound_dirmatch ##
function tbasiccontrol.xwound_dirmatch(xtime1,xtime2:longint):boolean;
begin
try;result:=(xwound_finddir(xtime1)=xwound_finddir(xtime2));except;end;
end;
//## notidle ##
procedure tbasiccontrol.notidle;
begin
try;iidleREF64:=ms64;except;end;
end;
//## idletime ##
function tbasiccontrol.idletime:comp;
begin
try;result:=low__sub64(ms64,iidleREF64);except;end;
end;
//## xfaster ##
procedure tbasiccontrol.xfaster;
begin
try;app__turbo;except;end;
end;
//## minimal ##
function tbasiccontrol.minimal:boolean;
begin
try;result:=ominimal;except;end;
end;
//-- Make Image Viewer Support - 22may2022 -------------------------------------
//## makeimageviewerfromfile ##
procedure tbasiccontrol.makeimageviewerfromfile(x:string;xuseai:boolean);
begin
try
iimagebuffermustfile:=inttostr(low__aorb(0,1,xuseai))+x;
low__timerset(self,__onimageviewertimer,50);
except;end;
end;
//## makeimageviewer ##
procedure tbasiccontrol.makeimageviewer(x:tstr8);
begin
try;makeimageviewer2(x,false);except;end;
end;
//## makeimageviewer2 ##
procedure tbasiccontrol.makeimageviewer2(x:tstr8;xuseai:boolean);
begin
try;xmakeimageviewer(x,low__aorb(1,2,xuseai),true,true);except;end;
end;
//## _makeimageviewer ##
procedure tbasiccontrol.xmakeimageviewer(x:tstr8;xstyle:longint;xreset,xpaintnow:boolean);
const
   sep=' | ';
var
   str1,e:string;
   sbits,sw,sh,scellcount,scellw,scellh,sdelay:longint;
   shasai,stransparent:boolean;
begin
try
//init
block(x);
//range
xstyle:=frcrange(xstyle,1,2);//22may2022, 12jan2022
//get
if (iimagebuffer=nil) then iimagebuffer:=misimg32(1,1);
//if (imakemode=2) then
iimagebuffer.ai.use32:=(xstyle=2);//22may2022
if (x=nil) or (x.len<=0) or (not misfromdata(iimagebuffer,x,e)) then missize(iimagebuffer,1,1);
imakemode:=frcrange(xstyle,1,2);//22may2022, 12jan2022
if (imakemode=2) and (iimagebuffer<>nil) then iimagebuffer.ai.itemindex:=0;
low__timerset(self,__onimageviewertimer,50);
//info
if (iimagebuffer<>nil) and (misw(iimagebuffer)>=2) and (mish(iimagebuffer)>=2) then
   begin
   miscells(iimagebuffer,sbits,sw,sh,scellcount,scellw,scellh,sdelay,shasai,stransparent);
   str1:=low__64(scellw)+'w x '+low__64(scellh)+'h';
   if (misai(iimagebuffer).bpp>=1) then str1:=str1+sep+inttostr(misai(iimagebuffer).bpp)+' bit';
   if (scellcount>=2) then str1:=str1+sep+low__64(scellcount)+' cells';
   iimagebufferinfo:=str1;
   end
else iimagebufferinfo:='';
//reset
if xreset then
   begin
   iimagebuffertimer:=0;
   iimagebuffermustfile:='';
   end;
//paint
if xpaintnow then paintnow;
except;end;
try;bunlockautofree(x);except;end;
end;
//## makeimagevieweri ##
procedure tbasiccontrol.makeimagevieweri(x:tbasicimage);
begin
try
iimagebufferi:=x;
imakemode:=1;//12jan2022
paintnow;
except;end;
end;
//-- Other ---------------------------------------------------------------------
//## canaccept ##
function tbasiccontrol.canaccept:boolean;
begin
try;result:=visible and enabled and assigned(fonaccept);except;end;
end;
//## ## accept_passthru ##
function tbasiccontrol.accept_passthru(sender:tobject;xfolder,xfilename:string;xindex,xcount:longint):boolean;
begin
try
result:=false;
if assigned(fonaccept) then result:=fonaccept(self,xfolder,xfilename,xindex,xcount);
except;end;
end;
//## autoshowmenu ##
procedure tbasiccontrol.autoshowmenu;
begin
try;autoshowmenu2('');except;end;
end;
//## autoshowmenu2 ##
procedure tbasiccontrol.autoshowmenu2(xstyle:string);
begin
try;if mustshowmenu then showmenu2(xstyle);except;end;
end;
//## mustshowmenu ##
function tbasiccontrol.mustshowmenu:boolean;
begin
try;result:=canshowmenu and gui.mouseupstroke and gui.mouseright;except;end;
end;
//## canshowmenu ##
function tbasiccontrol.canshowmenu:boolean;
begin
try;result:=ocanshowmenu and zznil(ishowmenu,2312) and enabled;except;end;
end;
//## showmenu ##
procedure tbasiccontrol.showmenu;
begin
try;showmenu2('');except;end;
end;
//## showmenu2 ##
procedure tbasiccontrol.showmenu2(xstyle:string);
label
   skipdone;
var
   ximagealign,xcode,xtepcolor:longint;
   xmenuname,xcode2:string;
   xfocuscontrol:tbasiccontrol;
begin
try
//check
if not canshowmenu then exit;
//init
gui.closelock;//prevent shutdown of system while proc in use - 03apr2021
xstyle:=low__lowercase(xstyle);//03jun2021
xcode:=0;
xtepcolor:=clnone;
xcode2:='';
ishowmenu:=bnew;
xmenuname:='';
xfocuscontrol:=gui.focuscontrol;
ximagealign:=iaNormal;
//fill
//.start
low__menuinit(ishowmenu);
//.optional external fillter #1
if assigned(fshowmenuFill1) then fshowmenuFill1(self,xstyle,ishowmenu,ximagealign,xmenuname);
//.internal menu filler
showmenuFill(xstyle,ishowmenu,ximagealign,xmenuname);//can override this and place our code before it and after it to extend the built-in menu's function - 15mar2021
if assigned(fshowmenuFillINT) then fshowmenuFillINT(self,xstyle,ishowmenu,ximagealign,xmenuname);
//.optional external fillter #2
if assigned(fshowmenuFill2) then fshowmenuFill2(self,xstyle,ishowmenu,ximagealign,xmenuname);
//.finalise
low__menuend(ishowmenu);
//show
if (low__menucount(ishowmenu)>=1) and gui.popmenu2(pmNormal,ximagealign,ishowmenu,xmenuname,0,xcode,xcode2,xtepcolor) then
   begin
   //click handlers
   //.internal click handlers - 12jan2022
   if assigned(fshowmenuClick1) and fshowmenuClick1(self,xstyle,xcode,xcode2,xtepcolor) then goto skipdone;//permitts override of ALL internal functions by PRECEEDING BOTH internal handlers
   if showmenuClick(self,xstyle,xcode,xcode2,xtepcolor) then goto skipdone;//primary internal handler
   if assigned(fshowmenuClickINT) and fshowmenuClickINT(self,xstyle,xcode,xcode2,xtepcolor) then goto skipdone;//additional internal handler
   if assigned(fshowmenuClick2) and fshowmenuClick2(self,xstyle,xcode,xcode2,xtepcolor) then goto skipdone;//secondary optional handler
   end;
skipdone:
//onshowmenu
if assigned(fonshowmenu) then fonshowmenu(self);//26mar2021
//restore
gui.focuscontrol:=xfocuscontrol;
except;end;
try
bfree(ishowmenu);
gui.closeunlock;
except;end;
end;
//## showmenuFill ##
procedure tbasiccontrol.showmenuFill(xstyle:string;xmenudata:tstr8;var ximagealign:longint;var xmenuname:string);
begin
try
//override to populate menu
except;end;
end;
//## showmenuClick ##
function tbasiccontrol.showmenuClick(sender:tobject;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean;
begin
try
result:=false;//not handled -> override to process menu click
except;end;
end;
//## xfromsys ##
function tbasiccontrol.xfromsys(xname:string):boolean;
begin
try;result:=visyssettingsloaded and zzok(syssettings,7175) and xfrom(self,syssettings,low__udv(xname,'control'));except;end;
end;
//## xfromprg ##
function tbasiccontrol.xfromprg(xname:string):boolean;
begin
try;result:=viprgsettingsloaded and zzok(prgsettings,7176) and xfrom(self,prgsettings,low__udv(xname,'control'));except;end;
end;
//## xfromprg2 ##
function tbasiccontrol.xfromprg2(xname:string;dvars:tvars8):boolean;//prgsettings -> control -> dvars (allows for filtering of value) - 25mar2021
begin
try
result:=viprgsettingsloaded and zzok(prgsettings,7177) and xfrom(self,prgsettings,low__udv(xname,'control'));
if result and zzok(dvars,7177) then result:=xto(self,dvars,xname);
except;end;
end;
//## xtosys ##
function tbasiccontrol.xtosys(xname:string):boolean;
begin
try;result:=visyssettingsloaded and zzok(syssettings,7178) and xto(self,syssettings,low__udv(xname,'control'));except;end;
end;
//## xtoprg ##
function tbasiccontrol.xtoprg(xname:string):boolean;
begin
try;result:=viprgsettingsloaded and zzok(prgsettings,7179) and xto(self,prgsettings,low__udv(xname,'control'));except;end;
end;
//## xfrom ##
function tbasiccontrol.xfrom(sender:tbasiccontrol;xvars:tvars8;xname:string):boolean;
begin
try
result:=true;//handled
except;end;
end;
//## xto ##
function tbasiccontrol.xto(sender:tbasiccontrol;xvars:tvars8;xname:string):boolean;
begin
try
result:=true;//handled
except;end;
end;
//## setbc14 ##
function tbasiccontrol.setbc14(v1,v2,v3,v4:tbasiccontrol):boolean;//15mar2021
begin
try
result:=false;
if low__setbc(bc1,v1) then result:=true;
if low__setbc(bc2,v2) then result:=true;
if low__setbc(bc3,v3) then result:=true;
if low__setbc(bc4,v4) then result:=true;
except;end;
end;
//## winmaxed ##
function tbasiccontrol.winmaxed:boolean;//14mar2021
begin
try;result:=(winstyle=wmFullwin) and (gui.gstate=gsMax);except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//bbbbbbbbbbbbbbbbbbbbbbbbbbbb
//-- Offloaders ----------------------------------------------------------------
//Note: These procs/functions will offload their work to other, generally more
//      centralised objects of the same type inorder to minimise GUI clutter or
//      waste screen space by combining multiple objects into a single handler,
//      for instance a main toolbar that might controla navbox, options, several
//      menus and pages - 07mar2021
//## xoff_toolbaradd ##
function tbasiccontrol.xoff_toolbaradd(x:tbasictoolbar):boolean;
begin
try;result:=stableobj(x) and _xoff_toolbaradd(x);except;end;
end;
//## xoff_toolbarsync ##
function tbasiccontrol.xoff_toolbarsync(x:tbasictoolbar):boolean;
begin
try;result:=stableobj(x) and _xoff_toolbarsync(x);except;end;
end;
//## xoff_toolbarevent ##
function tbasiccontrol.xoff_toolbarevent(x:tbasictoolbar):boolean;
begin
try;result:=stableobj(x) and _xoff_toolbarevent(x);except;end;
end;
//## _xoff_toolbaradd ##
function tbasiccontrol._xoff_toolbaradd(x:tbasictoolbar):boolean;
begin
result:=false;
end;
//## _xoff_toolbarsync ##
function tbasiccontrol._xoff_toolbarsync(x:tbasictoolbar):boolean;
begin
result:=false;
end;
//## _xoff_toolbarevent ##
function tbasiccontrol._xoff_toolbarevent(x:tbasictoolbar):boolean;
begin
result:=false;
end;
//-- Other ---------------------------------------------------------------------
//## canautoheight ##
function tbasiccontrol.canautoheight:boolean;
begin
try;result:=oautoheight;except;end;
end;
//## xresizer ##
procedure tbasiccontrol.xresizer;//25feb2021
var
   s,d:trect;
   xval,yval,xm,ym:longint;
begin
try
//init
xm:=gui.focussizemodex;
ym:=gui.focussizemodey;
xval:=(gui.screenmovexy.x-gui.screendownxy.x);
yval:=(gui.screenmovexy.y-gui.screendownxy.y);
if  (not owinresizeable) or ((xm=sbnone) and (ym=sbnone)) or (not enabled) or (not visible) then exit;
if (winstyle=wmfullwin) then
   begin
   if vilockposition then exit;//27feb2022
   s:=gui.hostdownrect;
   end
else s:=gui.downrect;
d:=s;
app__turbo;//high speed timing
//get
if (xm=sbleft)    then inc(d.left,xval);//left
if (xm=sbright)   then inc(d.right,xval);//right
if (ym=sbtop)     then inc(d.top,yval);//top
if (ym=sbbottom)  then inc(d.bottom,yval);//bottom

//start
if gui.mousedown and gui.screendraggingfine then gui.sizestart(gui.focusindex);

//set
if (d.left<d.right) and (d.top<d.bottom) then
   begin
   if (winstyle=wmfullwin) then
      begin
      if zzok(gui.host,7179) then gui.setbounds(d.left,d.top,d.right-d.left+1,d.bottom-d.top+1);
      end
   else setbounds(d.left,d.top,d.right-d.left+1,d.bottom-d.top+1);
   end;
except;end;
end;
//## headheight ##
function tbasiccontrol.headheight:longint;
begin
try;result:=0;except;end;
end;
//## client ##
function tbasiccontrol.client:tbasiccontrol;
begin
try;result:=self;except;end;
end;
//## ainc ##
procedure tbasiccontrol.ainc;
begin
try;low__iroll(iaid,1);except;end;
end;
//## setwinstyle ##
procedure tbasiccontrol.setwinstyle(x:longint);
begin
try;if low__setint(iwinstyle,frcrange(x,0,wmmax)) then gui.xwinnil(self);except;end;
end;
//## setcaption ##
procedure tbasiccontrol.setcaption(x:string);
begin
try;if low__setstr(icaption,x) then paintnow;except;end;
end;
//## xonvalue ##
procedure tbasiccontrol.xonvalue;
begin
try;if assigned(fonvalue) then fonvalue(self);except;end;
end;

//-- new control makers --------------------------------------------------------
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxx//bbbbbbbbbbbbbbbbbbbbbbbbbbb
//## ntea ##
function tbasiccontrol.ntea(xmaxW,xmaxH:longint;xcap,xhelp:string):tbasictea;
begin
try;result:=tbasictea.create(self);result.setparams(xmaxW,xmaxH);result.caption:=xcap;result.help:=xhelp;except;end;
end;
//## nimageviewer ##
function tbasiccontrol.nimageviewer(xdata:tstr8;xhelp:string):tbasiccontrol;//12jan2022
begin
try;result:=tbasiccontrol.create(self);result.help:=xhelp;result.oautoheight:=true;result.makeimageviewer(xdata);except;end;
end;
//## nimageviewer2 ##
function tbasiccontrol.nimageviewer2(xfilename:string;xuseai:boolean;xhelp:string):tbasiccontrol;//22may2022
begin
try;result:=tbasiccontrol.create(self);result.help:=xhelp;result.oautoheight:=true;result.makeimageviewerfromfile(xfilename,xuseai);except;end;
end;
//## ntitle ##
function tbasiccontrol.ntitle(xlarge:boolean;xcap,xhelp:string):tbasictitle;
begin
try;result:=tbasictitle.create(self,xlarge,false,xcap);result.help:=xhelp;except;end;
end;
//## ntitlebar ##
function tbasiccontrol.ntitlebar(xlarge:boolean;xcap,xhelp:string):tbasictoolbar;
begin
try;result:=tbasictoolbar.create(self);result.maketitle3(xcap,xlarge,false);result.help:=xhelp;except;end;
end;
//## ntitlebar2 ##
function tbasiccontrol.ntitlebar2(xlarge,xright:boolean;xcap,xhelp:string):tbasictoolbar;
begin
try;result:=tbasictoolbar.create(self);result.maketitle3(xcap,xlarge,xright);result.help:=xhelp;except;end;
end;
//## ninfo ##
function tbasiccontrol.ninfo(xtitle,xhead,xtext,xhelp:string):tbasicinfo;
begin
try;result:=tbasicinfo.create(self);result.help:=xhelp;result.setdata(xtitle,xhead,xtext);except;end;
end;
//## ncontrol ##
function tbasiccontrol.ncontrol:tbasiccontrol;
begin
try;result:=tbasiccontrol.create(self);except;end;
end;
//## nlabel ##
function tbasiccontrol.nlabel(xcap,xhelp:string):tbasiccontrol;
begin
try;result:=tbasictitle.create(self,false,true,xcap);result.help:=xhelp;except;end;
end;
//## njump ##
function tbasiccontrol.njump(xcap,xhelp:string;xpos,xlen:longint):tbasicjump;
begin
try;result:=tbasicjump.create(self,xcap);result.help:=xhelp;result.setparams(xpos,xlen);except;end;
end;
//## nint ##
function tbasiccontrol.nint(xcap,xhelp:string;xmin,xmax,xdef,xval:longint):tbasicint;
begin
try;result:=tbasicint.create(self);result.caption:=xcap;result.help:=xhelp;result.setparams(xmin,xmax,xdef,xval);except;end;
end;
//## nint2 ##
function tbasiccontrol.nint2(xcap,xhelp:string;xmin,xmax,xdef,xval:longint;xbackname:string):tbasicint;//26feb2021
begin
try;result:=tbasicint.create(self);result.caption:=xcap;result.help:=xhelp;result.ospbackname:=xbackname;result.setparams(xmin,xmax,xdef,xval);except;end;
end;
//## nint3 ##
function tbasiccontrol.nint3(xcap,xhelp:string;xmin,xmax,xdef,xval:longint;xbackname,xloadfromname:string):tbasicint;
begin
try;result:=tbasicint.create(self);result.caption:=xcap;result.help:=xhelp;result.ospbackname:=xbackname;result.setparams3(xmin,xmax,xdef,xval,xloadfromname);except;end;
end;
//## nmidivol ##
function tbasiccontrol.nmidivol(xcap,xhelp:string):tbasicint;//23mar2022, 29mar2021
begin
try
result:=tbasicint.create(self);
result.makemidivol;
if (xcap<>'') then result.caption:=xcap;
if (xhelp<>'') then result.help:=xhelp;
except;end;
end;
//## nwavevol ##
function tbasiccontrol.nwavevol(xcap,xhelp:string):tbasicint;//23mar2022, 29mar2021
begin
try
result:=tbasicint.create(self);
result.makewavevol;
if (xcap<>'') then result.caption:=xcap;
if (xhelp<>'') then result.help:=xhelp;
except;end;
end;
//## nmidi ##
function tbasiccontrol.nmidi(xcap,xhelp:string):tbasicsel;//05mar2022
begin
try
result:=tbasicsel.create(self);
result.makemididevice;
if (xcap<>'') then result.caption:=xcap;
if (xhelp<>'') then result.help:=xhelp;
except;end;
end;
//## nwave ##
function tbasiccontrol.nwave(xcap,xhelp:string):tbasicsel;//05mar2022
begin
try
result:=tbasicsel.create(self);
result.makewavedevice;
if (xcap<>'') then result.caption:=xcap;
if (xhelp<>'') then result.help:=xhelp;
except;end;
end;
//## nset ##
function tbasiccontrol.nset(xcap,xhelp:string;xdef,xval:longint):tbasicset;
begin
try;result:=tbasicset.create(self);result.caption:=xcap;result.help:=xhelp;result.setparams(xdef,xval);except;end;
end;
//## nsel ##
function tbasiccontrol.nsel(xcap,xhelp:string;xdef:longint):tbasicsel;
begin
try;result:=tbasicsel.create(self);result.caption:=xcap;result.help:=xhelp;result.setparams(xdef,0);except;end;
end;
//## nsel3 ##
function tbasiccontrol.nsel3(xcap,xhelp:string;xdef:longint;xloadfromname:string):tbasicsel;
begin
try;result:=tbasicsel.create(self);result.caption:=xcap;result.help:=xhelp;result.setparams3(xdef,0,result.itemsperline,xloadfromname);except;end;
end;
//## ntick ##
function tbasiccontrol.ntick(xcap,xhelp:string):tbasictick;
begin
try;result:=ntick2(xcap,xhelp,true);except;end;
end;
//## ntick2 ##
function tbasiccontrol.ntick2(xcap,xhelp:string;xvert:boolean):tbasictick;
begin
try;result:=tbasictick.create(self,xcap);result.help:=xhelp;result.oalignvert:=xvert;except;end;
end;
//## nedit ##
function tbasiccontrol.nedit(xcap,xhelp:string):tbasicedit;
begin
try;result:=nedit2(xcap,xhelp,true);except;end;
end;
//## nedit2 ##
function tbasiccontrol.nedit2(xcap,xhelp:string;xvert:boolean):tbasicedit;
begin
try;result:=tbasicedit.create(self,xcap);result.help:=xhelp;result.oalignvert:=xvert;except;end;
end;
//## ndropstatic ##
function tbasiccontrol.ndropstatic(xhelp:string;xtep:longint):tbasicedit;
begin
try
result:=tbasicedit.create(self,'');
result.help:='Select file format';
result.tep:=tepFNew20;
result.makedropstatic;
//xxxxxxxxxxxxxxxxxresult.onclick2:=filter__onclick;
except;end;
end;
//## npass ##
function tbasiccontrol.npass(xcap,xhelp:string):tbasicedit;
begin
try;result:=tbasicedit.create(self,xcap);result.makepass;result.help:=xhelp;result.oalignvert:=true;except;end;
end;
//## ncolor ##
function tbasiccontrol.ncolor(xcap,xhelp:string):tbasiccolor;
begin
try;result:=ncolor2(xcap,xhelp,true,0);except;end;
end;
//## ncolor2 ##
function tbasiccontrol.ncolor2(xcap,xhelp:string;xvert:boolean;hsp:longint):tbasiccolor;
begin
try;result:=tbasiccolor.create(self,xcap);result.help:=xhelp;result.oalignvert:=xvert;result.oseph:=hsp;except;end;
end;
//## nscrollbar ##
function tbasiccontrol.nscrollbar(xhelp:string;xvert:boolean):tbasicscrollbar;
begin
try;result:=tbasicscrollbar.create(self);result.help:=xhelp;result.oalignvert:=xvert;except;end;
end;
//## nscroll ##
function tbasiccontrol.nscroll(xhelp:string):tbasicscroll;//06oct2020
begin
try;result:=tbasicscroll.create(self);result.help:=xhelp;result.bordersize:=1;result.normal:=true;except;end;
end;
//## ntoolbar ##
function tbasiccontrol.ntoolbar(xhelp:string):tbasictoolbar;//29may2021
begin
try;result:=tbasictoolbar.create(self);result.help:=xhelp;result.normal:=true;except;end;
end;
//## ntoolbar_buttons ##
function tbasiccontrol.ntoolbar_buttons(xhelp:string):tbasictoolbar;//29may2021
begin
try
result:=tbasictoolbar.create(self);
result.help:=xhelp;
with result do
begin
omarkcleanly:=false;//03mar2021
bordersize:=0;
oasbuttons:=true;
normal:=true;
osepv:=1;//11oct2020
end;
except;end;
end;
//## ncols ##
function tbasiccontrol.ncols:tbasiccols;//columns - 06oct2020
begin
try;result:=tbasiccols.create(self);except;end;
end;
//## ncolors ##
function tbasiccontrol.ncolors:tbasiccolors;//colors set - 07oct2020
begin
try;result:=tbasiccolors.create(self);except;end;
end;
//## nbwp ##
function tbasiccontrol.nbwp(xhelp:string;xdata:tstr8):tbasicbwp;
begin
try;result:=nbwp4(xhelp,xdata,wwsWindow,false,false,false,false,false);except;end;
end;
//## nbwp2 ##
function tbasiccontrol.nbwp2(xhelp:string;xdata:tstr8;xwrap:longint;xrows,xautoheight:boolean):tbasicbwp;//17mar2021
begin
try;result:=nbwp4(xhelp,xdata,xwrap,xrows,xautoheight,false,false,false);except;end;
end;
//## nbwp3 ##
function tbasiccontrol.nbwp3(xhelp:string;xdata:tstr8;xwrap:longint;xrows,xautoheight,xretaindata:boolean):tbasicbwp;//17mar2021
begin
try;result:=nbwp4(xhelp,xdata,xwrap,xrows,xautoheight,xretaindata,false,false);except;end;
end;
//## nbwp4 ##
function tbasiccontrol.nbwp4(xhelp:string;xdata:tstr8;xwrap:longint;xrows,xautoheight,xretaindata,xtransform,xwebimages:boolean):tbasicbwp;//15may2021
var
   a:tstr8;
begin
try
a:=nil;
result:=tbasicbwp.create(self);
result.help:=xhelp;
result.wrap:=frcrange(xwrap,0,wwsMax);
result.oautoheight:=xautoheight;
result.orows:=xrows;
if xretaindata then//by default "low__wordcore..4()" wipes or alters inbound datastream handler "xdata", with xretaindata=true a copy is used thus preserving original data stream - 17mar2021
   begin
   a:=bnew;
   a.add(xdata);
   result.ioset3(a,-1,-1,-1,-1,xtransform,xwebimages);
   end
else result.ioset3(xdata,-1,-1,-1,-1,xtransform,xwebimages);
except;end;
try;bfree(a);except;end;
end;
//## nmenu ##
function tbasiccontrol.nmenu(xcap,xhelp:string):tbasicmenu;
begin
try;result:=tbasicmenu.create(self);result.help:=xhelp;except;end;
end;
//## npoplist ##
function tbasiccontrol.npoplist(xcap,xhelp:string;xlistdata:tstr8):tbasicmenu;
begin
try
block(xlistdata);
result:=tbasicmenu.create(self);
result.help:=xhelp;
result.makepoplist;
result.data:=xlistdata;
except;end;
try;bunlockautofree(xlistdata);except;end;
end;
//## nlist ##
function tbasiccontrol.nlist(xcap,xhelp:string;xlistdata:tstr8;xrowcount:longint):tbasicmenu;
begin
try;result:=nlist3(xcap,xhelp,xlistdata,xrowcount,'');except;end;
end;
//## nlist3 ##
function tbasiccontrol.nlist3(xcap,xhelp:string;xlistdata:tstr8;xrowcount:longint;xloadfromname:string):tbasicmenu;
begin
try
block(xlistdata);
if (xcap<>'') then nlabel(xcap,xhelp);//14nov2022
result:=tbasicmenu.create(self);
result.help:=xhelp;
result.makelist;
result.orowcount:=xrowcount;
result.oautoclose:=false;
result.data:=xlistdata;
result.oloadfromname:=xloadfromname;
result.oautoreload:=true;
if (xloadfromname<>'') then result.reload;
except;end;
try;bunlockautofree(xlistdata);except;end;
end;
//## nlistx ##
function tbasiccontrol.nlistx(xcap,xhelp:string;xcount,xrowcount:longint;xongetitem:tbasicmenu_getitem):tbasicmenu;
begin
try;result:=nlistx3(xcap,xhelp,xcount,xrowcount,xongetitem,'');except;end;
end;
//## nlistx3 ##
function tbasiccontrol.nlistx3(xcap,xhelp:string;xcount,xrowcount:longint;xongetitem:tbasicmenu_getitem;xloadfromname:string):tbasicmenu;
begin
try
if (xcap<>'') then nlabel(xcap,xhelp);//14nov2022
result:=tbasicmenu.create(self);
result.help:=xhelp;
result.makelistx(xcount);
result.orowcount:=xrowcount;
result.oautoclose:=false;//22sep2020
result.ongetitem:=xongetitem;
result.oloadfromname:=xloadfromname;
result.oautoreload:=true;
if (xloadfromname<>'') then result.reload;
except;end;
end;
//## nnav ##
function tbasiccontrol.nnav:tbasicnav;
begin
try;result:=tbasicnav.create(self);except;end;
end;
//## ncolormatrix ##
function tbasiccontrol.ncolormatrix:tbasiccolormatrix;//26feb2021
begin
try;result:=tbasiccolormatrix.create(self);except;end;
end;
//## nsetcolor ##
function tbasiccontrol.nsetcolor:tbasicsetcolor;//27feb2021
begin
try;result:=tbasicsetcolor.create(self);except;end;
end;
//## nbreak ##
function tbasiccontrol.nbreak(xheight:longint):tbasicbreak;
begin
try;result:=tbasicbreak.create(self,xheight);except;end;
end;
//## start ##
procedure tbasiccontrol.start;
begin
try;timer:=true;icreating:=false;except;end;
end;
//## info ##
function tbasiccontrol.info:pvirtualinfo;
begin
try;if inormal then result:=@vinormal else result:=@vititle;except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxx//bbbbbbbbbbbbbbbbbbbbbbb
//## rounded ##
function tbasiccontrol.rounded:boolean;//05aug2020
begin
//was: try;if (winstyle=wmfullwin) then result:=false else result:=viround;except;end;
try;result:=viround and (oroundstyle>=corRound);except;end;
end;
//## info_round ##
function tbasiccontrol.info_round:boolean;
begin
try;result:=rounded;except;end;
end;
//## info_cs ##
function tbasiccontrol.info_cs:trect;
begin
try;result:=clientspace;except;end;
end;
//## info_bs ##
function tbasiccontrol.info_bs:longint;
begin
try;result:=findbordersize;except;end;
end;
//## info_ci ##
function tbasiccontrol.info_ci:trect;
var
   bs:longint;
begin
try
bs:=info_bs;
result:=clientspace;
if (bs>=1) then
   begin
   inc(result.left);
   dec(result.right);
   inc(result.top);
   dec(result.bottom);
   end;
except;end;
end;
//## findback ##
function tbasiccontrol.findback:longint;//find background color - 25feb2021
var
   xinfo:pvirtualinfo;
   xclientspace,xclientinner:trect;
   fn,fb,fnH,fbH,fnbH,xclientwidth,xclientheight,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xenabled,xround,xnormal:boolean;
begin
try;infovars(xinfo,xclientspace,xclientinner,fn,fb,fnH,fbH,fnbH,xclientwidth,xclientheight,xfont,xfontdisable,result,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);except;end;
end;
//## findbackRound ##
procedure tbasiccontrol.findbackRound(var xback:longint;var xround:boolean);
var
   xinfo:pvirtualinfo;
   xclientspace,xclientinner:trect;
   fn,fb,fnH,fbH,fnbH,xclientwidth,xclientheight,xfont,xfontdisable,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xenabled,xnormal:boolean;
begin
try;infovars(xinfo,xclientspace,xclientinner,fn,fb,fnH,fbH,fnbH,xclientwidth,xclientheight,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);except;end;
end;
//## findtext ##
function tbasiccontrol.findtext:longint;//find text color - 22mar2021
begin
try;result:=otextcolor;if (result=clnone) then result:=info.font;except;end;
end;
//## findframe ##
function tbasiccontrol.findframe:longint;//find frame color - 17mar2021
begin
try;result:=oframecolor;if (result=clnone) then result:=info.frame;except;end;
end;
//## findframe2 ##
function tbasiccontrol.findframe2:longint;//find frame2 color - 17mar2021
begin
try;result:=oframecolor2;if (result=clnone) then result:=info.frame2;except;end;
end;
//## infovars ##
procedure tbasiccontrol.infovars(var xinfo:pvirtualinfo;var xclientspace,xclientinner:trect;var fn,fb,fnH,fbH,fnbH,xclientwidth,xclientheight,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize:longint;var xenabled,xround,xnormal:boolean);
begin
try
xinfo:=info;
xclientspace:=clientspace;
fn:=xinfo.fn;
fb:=xinfo.fb;
fnH:=xinfo.fnH;
fbH:=xinfo.fbH;//heights
fnbH:=largest(fnH,fbH);
if obold then//03mar2021
   begin
   fn:=fb;
   fnH:=fbH;
   end;
xclientwidth:=clientwidth;
xclientheight:=clientheight;
xenabled:=enabled;
xround:=rounded;
xnormal:=inormal;
xfontdisable:=xinfo.disablefont;
xfont:=low__aorb(xfontdisable,xinfo.font,xenabled);
xback:=low__aorb(xinfo.disable,xinfo.background,xenabled);
xborder:=low__aorb(xinfo.disableborder,xinfo.border,xenabled);
xhover:=low__aorb(xinfo.disable,xinfo.hover,xenabled);
xbordersize:=findbordersize;
xfontheight:=vifontheight;
xfeather:=vifeather;
xclientinner:=rect(xbordersize,xbordersize,xclientwidth-xbordersize-1,xclientheight-xbordersize-1);
//.override handlers
if xenabled and vispecialcolors then
   begin
   //back
   //.primary override
   if (ospbackcolor<>clnone) then xback:=ospbackcolor
   //.secondary override
   else if (ospbackname<>'') then xback:=low__color(ospbackname);
   end;
if (otextcolor<>clnone) then
   begin
   xfont:=otextcolor;
   xfontdisable:=low__dc(xfont,-30);
   xhover:=low__dc(xfont,10);
   end;
if (obackcolor<>clnone) then
   begin
   xback:=obackcolor;
   xborder:=low__dc(xback,-30);
   end;
except;end;
end;
//## infovars2 ##
procedure tbasiccontrol.infovars2(var xinfo:pvirtualinfo;var xclientspace,xclientinner:trect;var fn,fb,fnH,fbH,fnbH,xclientwidth,xclientheight,xfont,xfontdisable,xfont2,xback,xback2,xborder,xhover,xfontheight,xfeather,xbordersize:longint;var xenabled,xround,xnormal:boolean);
var
   xcolortheshade:boolean;
begin
try
infovars(xinfo,xclientspace,xclientinner,fn,fb,fnH,fbH,fnbH,xclientwidth,xclientheight,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);
//.for gradient shading -> font needs more contrast due to generally smaller area shading - 18aug2020
xcolortheshade:=xenabled and vispecialcolors and ((ospbackcolor<>clnone) or (ospbackname<>''));
if xcolortheshade then xfont:=low__dc(xback,-200);
xfont2:=xfont;
xback2:=xback;
if vienhanced then
   begin
//was: if (xfont2<>clnone) then xfont2:=low__dc(xfont2,100);
   if (xfont2<>clnone) then xfont2:=low__dc(xfont2,60);
   if (xback2<>clnone) then xback2:=low__dc(xback2,-20);//was -30 -> a bit too heavy - 18aug2020
   if xcolortheshade then xfont2:=low__dc(xback,-140);//xback;//low__dc(xfont,xback);
   end;
except;end;
end;
//## ownidInc ##
procedure tbasiccontrol.ownidInc;
begin
try;low__iroll(ownid,1);except;end;
end;
//## stable ##
function tbasiccontrol.stable:boolean;
begin
try;result:=(not icreating) and (not idestroying) and (not gui.creating) and (not gui.destroying);except;end;
end;
//## xresetcanvas ##
procedure tbasiccontrol.xresetcanvas(x:tcanvas;xenabled:boolean);
var
   a:pvirtualinfo;
begin
try
//check
if (x=nil) then exit;
//get
exit;///xxxxxxxxxxxxx
{
a:=info;
x.font.style  :=[];
x.font.name   :=a.fontname;
x.font.size   :=a.fontmap.font.size;
x.font.color  :=low__aorb(a.disablefont,a.font,xenabled);
x.pen.color   :=low__aorb(a.disablefont,a.font,xenabled);
x.brush.style :=bssolid;
x.brush.color :=low__aorb(a.disable,a.background,xenabled);
{}//xxxxxxxxxx
except;end;
end;
//## mousedownxy ##
function tbasiccontrol.mousedownxy:tpoint;
begin
try
result:=gui.mousedownxy;
dec(result.x,iclientarea.left);
dec(result.y,iclientarea.top);
except;end;
end;
//## mousemovexy ##
function tbasiccontrol.mousemovexy:tpoint;
begin
try
result:=gui.mousemovexy;
dec(result.x,iclientarea.left);
dec(result.y,iclientarea.top);
except;end;
end;
//## mouseinside ##
function tbasiccontrol.mouseinside:boolean;
begin
try;result:=xinside(mousemovexy);except;end;
end;
//## mouseinsideclientarea ##
function tbasiccontrol.mouseinsideclientarea:boolean;
begin
try;result:=xinsideclientarea(mousemovexy);except;end;
end;
//## setparent ##
procedure tbasiccontrol.setparent(x:tbasiccontrol);
begin//Note: GUI is set once, and remains unchanged for the life of the control -> maximum stability - 19mar2020
try
if (x<>iparent) then
   begin
   gui.owndel(iparent,self);
   iparent:=x;
   if zzok(iparent,7180) then iparentcoreindex:=x.coreindex else iparentcoreindex:=-1;
   gui.ownadd(x,self);
   end;
except;end;
end;
//## visibletohost ##
function tbasiccontrol.visibletohost:boolean;
label
   redo;
var
   a:tbasiccontrol;
begin
try
result:=false;
a:=self;
redo:
if zzok(a,2312) and a.visible then
   begin
   if zznil(a.parent,2312) then result:=true
   else
      begin
      a:=a.parent;
      goto redo;
      end;
   end;
except;end;
end;
//## enabledtohost ##
function tbasiccontrol.enabledtohost:boolean;
label
   redo;
var
   a:tbasiccontrol;
begin
try
result:=false;
a:=self;
redo:
if zzok(a,2313) and a.enabled then
   begin
   if zznil(a.parent,2313) then result:=true
   else
      begin
      a:=a.parent;
      goto redo;
      end;
   end;
except;end;
end;
//## rootparent ##
function tbasiccontrol.rootparent:tbasiccontrol;
label
   redo;
begin
try
result:=self;
redo:
if zzok(result,2312) and result.visible then
   begin
   if zzok(result.parent,2312) then
      begin
      result:=result.parent;
      goto redo;
      end;
   end;
except;end;
try;if (result=self) then result:=nil;except;end;
end;
//## areatohost ##
function tbasiccontrol.areatohost(da:trect):trect;
label
   redo;
var
   a:tbasiccontrol;
   aa:trect;
begin
try
result:=rect(0,0,-1,-1);//invalid area
a:=self;
redo:
if zzok(a,4001) and a.visible then
   begin
   //limit
   if zzok(a.parent,4002)   then aa:=a.parent.clientinner2(a) else aa:=a.clientarea;//detect useable area within parent -> e.g. don't paint over the parent's border area etc
   if (da.left<aa.left)     then da.left:=aa.left;
   if (da.right>aa.right)   then da.right:=aa.right;
   if (da.top<aa.top)       then da.top:=aa.top;
   if (da.bottom>aa.bottom) then da.bottom:=aa.bottom;
   //loop
   if gui.xareaok(da) then
      begin
      if zznil(a.parent,2114) then result:=da
      else
         begin
         a:=a.parent;
         goto redo;
         end;
      end;
   end;
except;end;
end;
//## setvisible ##
procedure tbasiccontrol.setvisible(x:boolean);
var
   a:trect;
begin
try
if (x<>ivisible) then
   begin
   ivisible:=x;
   //.tell paint system to repaint screen area the window "had" occupied - 21may2020
   if (winstyle>wmcontrol) and (not x) then
      begin
      gui.paintallnow;
      end
   else parentpaintnow;
   end;
except;end;
end;
//## setenabled ##
procedure tbasiccontrol.setenabled(x:boolean);
begin
try
if (x<>ienabled) then
   begin
   ienabled:=x;
   parentpaintnow;
   end;
except;end;
end;
//## setbounds ##
function tbasiccontrol.setbounds(x,y,w,h:longint):boolean;
begin
try
if zzok(parent,7181) then
   begin
   inc(x,parent.clientarea.left);
   inc(y,parent.clientarea.top);
   end;
result:=xsetclientarea(rect(x,y,x+w-1,y+h-1));
except;end;
end;
//## setclientarea ##
procedure tbasiccontrol.setclientarea(a:trect);
begin
try;xsetclientarea(a);except;end;
end;
//## setclientarea ##
function tbasiccontrol.xsetclientarea(a:trect):boolean;
var
   bs:longint;
begin
try
//defaults
result:=false;
//range
if (a.left>minint) then a.right:=frcmin(a.right,a.left-1);
if (a.top>minint)  then a.bottom:=frcmin(a.bottom,a.top-1);
//decide
if (winstyle>=wmFullwin) then//01mar2021, 25feb2021
   begin
   bs:=findbordersize;
   low__minwh(a,frcmin(frcmin(ominwidth,2*bs),minwinsize),frcmin(frcmin(ominheight,2*bs),minwinsize));
   end;
//Note: We MUST allow controls to have an invalid area so they do not show on the screen under important circumstances - 01mar2021
//was: else low__minwh(a,ominwidth,ominheight);
//get
if (iclientarea.left<>a.left) or (iclientarea.right<>a.right) or
   (iclientarea.top<>a.top) or (iclientarea.bottom<>a.bottom) then
   begin
   iclientarea.left:=a.left;
   iclientarea.right:=a.right;
   iclientarea.top:=a.top;
   iclientarea.bottom:=a.bottom;
   ainc;
   result:=true;
   end;
except;end;
end;
//## xlimitsize ##
function tbasiccontrol.xlimitsize:boolean;
var
   a:trect;
begin
try
result:=false;
a:=iclientarea;
if ((a.right-a.left+1)>gui.width) then
   begin
   a.left:=0;
   a.right:=gui.width-1;
   result:=true;
   end;
if ((a.bottom-a.top+1)>gui.height) then
   begin
   a.top:=0;
   a.bottom:=gui.height-1;
   result:=true;
   end;
if result then xsetclientarea(a);
except;end;
end;
//## getleft ##
function tbasiccontrol.getleft:longint;
begin
try;result:=iclientarea.left;if zzok(iparent,7182) then dec(result,iparent.clientarea.left);except;end;
end;
//## gettop ##
function tbasiccontrol.gettop:longint;
begin
try;result:=iclientarea.top;if zzok(iparent,7183) then dec(result,iparent.clientarea.top);except;end;
end;
//## clientspace ##
function tbasiccontrol.clientspace:trect;
begin
try;result:=rect(0,0,iclientarea.right-iclientarea.left,iclientarea.bottom-iclientarea.top);except;end;
end;
//## clientinner ##
function tbasiccontrol.clientinner:trect;
begin
try;result:=clientinner2(nil);except;end;
end;
//## clientinner2 ##
function tbasiccontrol.clientinner2(x:tbasiccontrol):trect;
var
   a:trect;
   bs:longint;
begin
try
a:=iclientarea;
bs:=findbordersize;
result:=rect(a.left+bs,a.top+bs,a.right-bs,a.bottom-bs);
except;end;
end;
//## getclientwidth ##
function tbasiccontrol.getclientwidth:longint;
begin
try;result:=iclientarea.right-iclientarea.left+1;except;end;
end;
//## getclientheight ##
function tbasiccontrol.getclientheight:longint;
begin
try;result:=iclientarea.bottom-iclientarea.top+1;except;end;
end;
//## setclientwidth ##
procedure tbasiccontrol.setclientwidth(x:longint);
begin
try;setbounds(iclientarea.left,iclientarea.top,x,clientheight);except;end;
end;
//## setclientheight ##
procedure tbasiccontrol.setclientheight(x:longint);
begin
try;setbounds(iclientarea.left,iclientarea.top,clientwidth,x);except;end;
end;
//## xinside ##
function tbasiccontrol.xinside(x:tpoint):boolean;
begin
try;result:=xinside2(x.x,x.y);except;end;
end;
//## xinside2 ##
function tbasiccontrol.xinside2(sx,sy:longint):boolean;
var
   a:tbasiccontrol;
begin
try
result:=false;
if xwindow(a) and (gui.winhover=a.coreindex) then//cursor is on our form
   begin
   inc(sx,iclientarea.left);
   inc(sy,iclientarea.top);
   result:=(sx>=ipaintarea.left) and (sx<=ipaintarea.right) and (sy>=ipaintarea.top) and (sy<=ipaintarea.bottom);
   end;
except;end;
end;
//## xinsideclientarea ##
function tbasiccontrol.xinsideclientarea(x:tpoint):boolean;
begin
try;result:=xinsideclientarea2(x.x,x.y);except;end;
end;
//## xinsideclientarea2 ##
function tbasiccontrol.xinsideclientarea2(sx,sy:longint):boolean;
var
   a:tbasiccontrol;
   bs:longint;
begin
try
result:=false;
if xwindow(a) and (gui.winhover=a.coreindex) then//cursor is on our form
   begin
   bs:=findbordersize;
   inc(sx,iclientarea.left);
   inc(sy,iclientarea.top);
   result:=(sx>=(ipaintarea.left+bs)) and (sx<=(ipaintarea.right-bs)) and (sy>=(ipaintarea.top+bs)) and (sy<=(ipaintarea.bottom-bs));
   end;
except;end;
end;
//## xwinfocused ##
function tbasiccontrol.xwinfocused:boolean;
var
   a:tbasiccontrol;
begin
try;result:=xwindow(a) and (a.coreindex=gui.winfocus);except;end;
end;
//## xwindow ##
function tbasiccontrol.xwindow(var x:tbasiccontrol):boolean;//return our containing window
label
   redo;
var
   a:tbasiccontrol;
begin
try
//defaults
result:=false;
a:=self;
//find
redo:
if zzok(a,7185) and (a.winstyle<=wmcontrol) and zzok(a.parent,7186) then
   begin
   a:=a.parent;
   goto redo;
   end;
//get
if zzok(a,7186) and (a.winstyle>wmcontrol) then
   begin
   x:=a;
   result:=true;
   end;
except;end;
end;
//## xwindowindex ##
function tbasiccontrol.xwindowindex:longint;
var
   a:tbasiccontrol;
begin
try;result:=-1;if xwindow(a) then result:=a.coreindex;except;end;
end;
//## gethelpline ##
function tbasiccontrol.gethelpline:string;
var
   str1,str2:string;
begin
try
str1:=low__udv(ihelp2,ihelp);
str2:=low__udv(isubhelp2,isubhelp);
result:=str1+low__insstr(' | ',(str1<>'') and (str2<>''))+str2;
except;end;
end;
//## xfindheight ##
function tbasiccontrol.xfindheight(xclientwidth:longint;var xheight:longint):boolean;
begin
try
//defaults
result:=false;
xheight:=0;
//event
if assigned(fonfindheight) then
   begin
   xheight:=fonfindheight(self,xclientwidth);
   result:=true;
   end;
except;end;
end;
//## getalignheight ##
function tbasiccontrol.getalignheight(xclientwidth:longint):longint;
begin
try;if not xfindheight(xclientwidth,result) then result:=frcmin(frcmin(clientheight,ominheight),0);except;end;
end;
//## getalignwidth ##
function tbasiccontrol.getalignwidth(xclientheight:longint):longint;
begin
try;result:=frcmin(frcmin(clientwidth,ominwidth),0);except;end;
end;
//## setbordersize ##
procedure tbasiccontrol.setbordersize(x:longint);
begin
try;ibordersize:=frcrange(x,0,72);except;end;
end;
//## findbordersize ##
function tbasiccontrol.findbordersize:longint;
begin
try
case oborderstyle of
bsInternal:result:=ibordersize*vizoom;
bsSystem100:result:=vibordersize;
bsSystem50:result:=frcmin(vibordersize div 2,low__insint(1,vibordersize>=1));
bsSystem20:result:=frcmin(vibordersize div 5,low__insint(1,vibordersize>=1));
else result:=ibordersize*vizoom;
end;
except;end;
end;
//## settimer ##
procedure tbasiccontrol.settimer(x:boolean);
begin
try
//check
if (x=itimer) then exit;
//get
itimer:=x;
except;end;
end;
//## _ontimer ##
procedure tbasiccontrol._ontimer(sender:tobject);
begin
try
//nil
except;end;
end;
//## __onimageviewertimer ##
procedure tbasiccontrol.__onimageviewertimer(sender:tobject);//22may2022
var
   int1:longint;
   str1,e:string;
   a:tstr8;
begin
try
//defaults
a:=nil;
//check
if (not stable) then exit;

//.iimagebuffermustfile
if (iimagebuffermustfile<>'') and (not low__comparetext(iimagebufferlastfile,iimagebuffermustfile)) then
   begin
   iimagebufferlastfile:=iimagebuffermustfile;
   int1:=strint(strcopy1(iimagebufferlastfile,1,1));
   str1:=strcopy1(iimagebufferlastfile,2,length(iimagebufferlastfile));
   a:=bnew;
   if (str1<>'') then low__fromfile(str1,a,e);
   makeimageviewer2(a,int1=1);
   end;

//.imagebuffertimer - 22may2022
if (imakemode=2) and (iimagebuffer<>nil) and (ms64>=iimagebuffertimer) then
   begin
   int1:=frcrange(iimagebuffer.ai.itemindex,0,frcmin(iimagebuffer.ai.count-1,0));
   if (iimagebuffer.ai.delay<=0) or (iimagebuffer.ai.count<=1) then int1:=0 else inc(int1);
   if (int1>=iimagebuffer.ai.count) then int1:=0;
   if low__setint(iimagebuffer.ai.itemindex,int1) then paintnow;
   iimagebuffertimer:=ms64+frcrange(iimagebuffer.ai.delay,50,1000);
   end;
except;end;
try;if (a<>nil) then bfree(a);except;end;
end;
//## xtimer ##
procedure tbasiccontrol.xtimer;
begin
try
//check
if itiming or (not stable) then exit else itiming:=true;
//event
if itimer then
   begin
   _ontimer(self);
   if assigned(fontimer2) then fontimer2(self);
   end;
except;end;
try;itiming:=false;except;end;
end;
//## alignpaintnow__heightcheck ##
procedure tbasiccontrol.alignpaintnow__heightcheck(xalign,xpaint:boolean;xclientwidth:longint);
var
   xmustparent:boolean;
begin
try
//get
xmustparent:=false;
if (xalign or xpaint) and (getalignheight(xclientwidth)<>clientheight) then
   begin
   xmustparent:=true;
   xalign:=true;
   xpaint:=true;
   end;
//set
if xalign then
   begin
   if xmustparent then alignallnow else alignnow;
   end;
if xpaint then
   begin
   if xmustparent then paintallnow else paintnow;
   end;
except;end;
end;
//## alignallnow ##
procedure tbasiccontrol.alignallnow;
begin//host does all alignment at once as a whole -> slower but easier and reliable
try;gui.alignallnow;except;end;
end;
//## alignnow ##
procedure tbasiccontrol.alignnow;
begin//host does all alignment at once as a whole -> slower but easier and reliable
try
if not visibletohost then exit;
imustalign:=true;
gui.alignnow;
except;end;
end;
//## parentalignnow ##
procedure tbasiccontrol.parentalignnow;
begin//host does all alignment at once as a whole -> slower but easier and reliable
try;if zzok(iparent,7187) and iparent.visibletohost then iparent.alignnow else alignnow;except;end;
end;
//## _onalign ##
procedure tbasiccontrol._onalign(sender:tobject);
begin
try
//We are expected to size and child controls we own - no need to tell host
//of a size or paint request -> this is automatic when done within this proc.
//But outside of this proc a paintnow / alignnow request will probably be
//required for the GUI to update properly - 20mar2020
if assigned(onalign) then onalign(self);
except;end;
end;
//## xalign ##
procedure tbasiccontrol.xalign;//called by central host "tbasicform" only -> do not call directly - 20mar2020
var
   a:tbasiccontrol;
   p:longint;
begin
try
//check
if ialigning or (not stable) then exit else ialigning:=true;
//init
ialigned:=false;
//.wmfullmode -> parentless window only
if zznil(parent,2315) and (winstyle=wmfullwin) then
   begin
   if setbounds(0,0,gui.width,gui.height) then imustalign:=true;
   end;
if imustalign or parentaligned then
   begin
   ialigned:=true;
   _onalign(self);//self
   end;
//align children
if (ownlist.count>=1) then
   begin
   for p:=0 to (ownlist.count-1) do if gui.xownget(ownlist,p,a) then
      begin
      if a.visible then a.xalign;
      a.xmustalign:=false;
      end;//p
   end;
except;end;
try
ialigned:=false;
ialigning:=false;
except;end;
end;
//## paintallnow ##
procedure tbasiccontrol.paintallnow;
begin
try;gui.paintallnow;except;end;
end;
//## paintnow ##
procedure tbasiccontrol.paintnow;
begin//mark ourselves as needing to repaint AND tell the host to fire up the GUI paint proc
try
//check - detect if control is "not visible" or "scrolled out of sight" etc - 05apr2020
if (not visibletohost) or (not xcanpaint) then exit;
imustpaint:=true;
gui.paintnow;
except;end;
end;
//## paintimmediate ##
procedure tbasiccontrol.paintimmediate;//use sparingly - 09sep2021
begin
try
paintnow;
gui.pumptimer2;
except;end;
end;
//## parentpaintnow ##
procedure tbasiccontrol.parentpaintnow;
begin//mark ourselves as needing to repaint AND tell the host to fire up the GUI paint proc
try;if zzok(iparent,7188) and parent.visibletohost then parent.paintnow else paintnow;except;end;
end;
//## alignpaintnow ##
procedure tbasiccontrol.alignpaintnow;//05oct2020
begin
try;alignnow;paintnow;except;end;
end;
//## alignpaintallnow ##
procedure tbasiccontrol.alignpaintallnow;//05oct2020
begin
try;alignallnow;paintallnow;except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxx//bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
//## _onpaint ##
procedure tbasiccontrol._onpaint(sender:tobject);
var
   //infovars
   a:pvirtualinfo;
   cs,ci:trect;
   fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xenabled,xround,xnormal:boolean;
   //other
   xsparkle:longint;
   //## xpaint_imageviewer ##
   procedure xpaint_imageviewer;
   var
      i:tbasicimage;
   var
      cpos,cw,ch,sw,sh,dw,dh:longint;
      a:trect;
      xtrans:boolean;
      n:string;
   begin
   try
   i:=iimagebuffer;
   if (iimagebufferi<>nil) then i:=iimagebufferi;
   cw:=ci.right-ci.left+1;
   ch:=ci.bottom-ci.top+1;
   a:=miscellarea(i,0);
   sw:=a.right-a.left+1;
   sh:=a.bottom-a.top+1;
   if ((sw>=2) and (sh>=1)) or ((sw>=1) and (sh>=2)) then
      begin
      low__scaledown(cw,ch,sw,sh,dw,dh);
      case imakemode of
      //.supports SOLID and 32bit image display
      1:ldc2(ci,(cw-dw) div 2,(ch-dh) div 2,dw,dh,miscellarea(i,0),i,255,0,clnone,clnone,0,true);
      //.supports CELLS and TRANSPARENCY and 32bit image display
      2:begin
         n:=low__lowercase(i.ai.format);
         xtrans:=i.ai.transparent and (n<>'png') and (n<>'gif') and (n<>'ani') and (n<>'ico') and (n<>'cur') and (n<>'');//don't use old top-left transparency method for formats that accidently fail to provide a format value - 23may2022
         cpos:=frcrange(i.ai.itemindex,0,frcmin(i.ai.count-1,0));
         ldc2(ci,(cw-dw) div 2,(ch-dh) div 2,dw,dh,miscellarea(i,cpos),i,255,low__aorb(0,1,xtrans),low__aorb(clnone,mispixel24VAL(i,0,0),xtrans),clnone,0,true);
         end;
      end;//case
      end;
   except;end;
   end;
begin
try
//external event override
if assigned(fonpaint) then
   begin
   fonpaint(sender);
   exit;
   end;

//init
infovars(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);

//cls
if      (winstyle=wmfullwin)                       then lds(cs,xback,false)
else if (winstyle>wmfullwin) and (winstyle<=wmmax) then lds(cs,xback,xround)
else                                                    lds(cs,xback,false);

//makers
case imakemode of
1:xpaint_imageviewer;
2:xpaint_imageviewer;
end;//case

//frame
if (xbordersize>=1) then
   begin
   //init
   xsparkle:=low__aorb(visparkle,oframesparkle,oframesparkle>=0);
   //window frame -> needs "dround" for roundness override feature//xxxxxxxxxxxxxx add this back in...xxxxxxxxxxxxxxxxxxxx//was:...
//was: if      (winstyle=wmfullwin)                       then ldf2(cs,vinormal.frame,vinormal.frame2,vinormal.frame,xbordersize,visparkle,'',false)//fill out the corners incase MS stuffs up
   if      (winstyle=wmfullwin)                       then//01aug2020
      begin
      ldf4(cs,findframe,findframe2,info.framefindcol,xbordersize,oframebrightness,oframebrightnessDARK,xsparkle,'',viFramecode,xround);
      end
   else if (winstyle>wmfullwin) and (winstyle<=wmmax) then
      begin
      //was: ldf3(cs,findframe,findframe2,clnone,xbordersize,xsparkle,'',viframecode,xround);
      ldf4(cs,findframe,findframe2,clnone,xbordersize,oframebrightness,oframebrightnessDARK,xsparkle,'',viFramecode,xround);
      end
   //control frame
   else
      begin
      ldf(cs,xborder,low__dc(xback,-20),xbordersize,nil,xround);//26feb2022
      end;
   end;
xparentcorners;
except;end;
end;
//## xparentcorners ##
procedure tbasiccontrol.xparentcorners;
var//Note: Draws the control's corners with parent's background color - not perfect but a good fix - 07oct2020
   int1:longint;
begin
try
if oparentcorners and (winstyle=wmcontrol) and info_round and zzok(parent,7190) then
   begin
   int1:=parent.findback;
   ldr2(info_cs,int1,int1,int1,int1,0,'',true);
   end;
except;end;
end;
//## xcanpaint ##
function tbasiccontrol.xcanpaint:boolean;
begin
try;result:=ivisible and visibletohost and gui.xareaok(iclientarea) and gui.xareaokb(areatohost(iclientarea));except;end;
end;
//## xcanpaint_fast ##
function tbasiccontrol.xcanpaint_fast:boolean;//checks only the current layer -> assumes all previous layers have already been checked -> done for maximum speed - 05apr2020
begin
try;result:=ivisible and gui.xareaok(iclientarea);except;end;
end;
//## parentpainted ##
function tbasiccontrol.parentpainted:boolean;
begin
try;result:=zzok(iparent,7191) and iparent.painted;except;end;
end;
//## parentaligned ##
function tbasiccontrol.parentaligned:boolean;
begin
try;result:=zzok(iparent,7192) and iparent.aligned;except;end;
end;
//## xpaint ##
function tbasiccontrol.xpaint:boolean;//called by central host "tbasicform" only -> do not call directly - 21mar2020
var
   p:longint;
   a:tbasiccontrol;
   xmustfinish,xmustpaint:boolean;
begin
try
//defaults
result:=false;
//check
if ipainting or (not stable) then exit else ipainting:=true;
//init
xmustpaint:=imustpaint;
imustpaint:=false;
ipainted:=false;
xmustfinish:=false;
//get
if xcanpaint then
   begin
   ipaintarea:=areatohost(iclientarea);
   if (not gui.paintingpart) or (xmustpaint or parentpainted) then
      begin
      ipainted:=true;
      xmustfinish:=true;
      _onpaint(self);
      if gui.paintingpart then gui.ppincludearea(ipaintarea);
      end;
   //paint children
   if (ownlist.count>=1) then
      begin
      for p:=0 to (ownlist.count-1) do if gui.xownget(ownlist,p,a) then
         begin
         if a.visible then a.xpaint;
         a.xmustpaint:=false;
         end;//p
      end;
   //patch inner frame when round
   if (parent=nil) and (winstyle>wmControl) then winLdr;

   //successful
   result:=true;
   end;
except;end;
try
ipainted:=false;
ipainting:=false;
except;end;
end;
//## xmustpaintcount ##
function tbasiccontrol.xmustpaintcount:longint;
var
   p:longint;
   a:tbasiccontrol;
begin
try
//check
result:=0;
if not stable then exit;
//get
if xmustpaint then inc(result);
//.children
if (ownlist.count>=1) then
   begin
   for p:=0 to (ownlist.count-1) do if gui.xownget(ownlist,p,a) and a.visible then inc(result,a.xmustpaintcount);
   end;
except;end;
end;
//## yshift ##
function tbasiccontrol.yshift:longint;
begin
try;result:=ipaintarea.top-iclientarea.top;except;end;
end;
//## xshift ##
function tbasiccontrol.xshift:longint;
begin
try;result:=ipaintarea.left-iclientarea.left;except;end;
end;
//## mousex ##
function tbasiccontrol.mousex:longint;
begin
try;result:=mousexy.x;except;end;
end;
//## mousey ##
function tbasiccontrol.mousey:longint;
begin
try;result:=mousexy.y;except;end;
end;
//## mousexy ##
function tbasiccontrol.mousexy:tpoint;
var
   a,b:tpoint;
begin
try
result:=low__point(0,0);
b:=gui.clienttoscreen(low__point(0,0));
low__getcursorpos(a);
result.x:=a.x-b.x-iclientarea.left;
result.y:=a.y-b.y-iclientarea.top;
except;end;
end;
//## _onnotify ##
function tbasiccontrol._onnotify(sender:tobject):boolean;
begin
try
//defaults
result:=false;
//external event override
if assigned(fonnotify) then result:=fonnotify(sender)
//showmenu - 11oct2020
else if mustshowmenu then
   begin
   showmenu;
   result:=true;
   end;
except;end;
end;
//## _onshortcut ##
function tbasiccontrol._onshortcut(sender:tobject):boolean;
begin
try;result:=false;except;end;
end;
//## _onfocus ##
procedure tbasiccontrol._onfocus(sender:tobject);
begin
try

except;end;
end;
//## focused ##
function tbasiccontrol.focused:boolean;
begin
try;result:=(gui.focuscontrol=self);except;end;
end;
//## setfocus ##
procedure tbasiccontrol.setfocus;
begin
try;if visible and enabled then gui.focuscontrol:=self;except;end;
end;
//-- draw support --------------------------------------------------------------
//## ldv ##
procedure tbasiccontrol.ldv(dx,dy,dy2,dcol:longint;xround:boolean);
begin
try;ldv2(dx,dy,dy2,dcol,false,xround);except;end;
end;
//## ldv2 ##
procedure tbasiccontrol.ldv2(dx,dy,dy2,dcol:longint;xdot,xround:boolean);
begin
try;if gui.painting then low__draw(true,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,low__aorbchar('v','V',xdot),iclientarea,ipaintarea,rect(dx+iclientarea.left,dy+iclientarea.top,dx+iclientarea.left,dy2+iclientarea.top),dcol,clnone,clnone,0,0,0,0,nil,nil,oroundstyle,xround);except;end;
end;
//## ldh ##
procedure tbasiccontrol.ldh(dx,dx2,dy,dcol:longint;xround:boolean);
begin
try;ldh2(dx,dx2,dy,dcol,false,xround);except;end;
end;
//## ldh2 ##
procedure tbasiccontrol.ldh2(dx,dx2,dy,dcol:longint;xdot,xround:boolean);
begin
try;if gui.painting then low__draw(true,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,low__aorbchar('h','H',xdot),iclientarea,ipaintarea,rect(dx+iclientarea.left,dy+iclientarea.top,dx2+iclientarea.left,dy+iclientarea.top),dcol,clnone,clnone,0,0,0,0,nil,nil,oroundstyle,xround);except;end;
end;
//## ldso ##
procedure tbasiccontrol.ldso(darea:trect;dborder,dback:longint;xround:boolean);
begin
try;ldso2(darea,dborder,clnone,dback,clnone,clnone,0,'',xround);except;end;
end;
//## ldso2 ##
procedure tbasiccontrol.ldso2(darea:trect;dborder,dborder2,dback,dback2,dback3,drich:longint;xoptions:string;xround:boolean);
begin
try;ldso3(true,darea,dborder,dborder2,dback,dback2,dback3,drich,xoptions,xround,false);except;end;
end;
//## ldso3 ##
procedure tbasiccontrol.ldso3(xdyanmicCorners:boolean;darea:trect;dborder,dborder2,dback,dback2,dback3,drich:longint;xoptions:string;xround,xdarktolight:boolean);
var//Note: dback3 is the outside-corner fill color - optional
   str2:tstr8;
   p:longint;
begin
try
if not gui.painting then exit;
str2:=nil;
if (xoptions<>'') then str2:=bnewstr(xoptions);
inc(darea.left,iclientarea.left);
inc(darea.right,iclientarea.left);
inc(darea.top,iclientarea.top);
inc(darea.bottom,iclientarea.top);
if xdarktolight then
   begin
   if (low__brightness2b(dborder2)<low__brightness2b(dborder)) then low__swapint(dborder,dborder2);//27mar2021
   if (low__brightness2b(dback2)<low__brightness2b(dback)) then low__swapint(dback,dback2);//27mar2021
   end;
if (dback<>clnone)   then low__draw(xdyanmicCorners,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,'s',iclientarea,ipaintarea,darea,dback,dback2,dback3,0,0,0,drich,nil,str2,oroundstyle,xround);
if (dborder<>clnone) then
   begin
   for p:=0 to (vizoom-1) do low__draw(xdyanmicCorners,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,'o',iclientarea,ipaintarea,rect(darea.left+p,darea.top+p,darea.right-p,darea.bottom-p),dborder,dborder2,dback3,0,0,0,drich,nil,str2,oroundstyle,xround);
   end;
except;end;
try;freeobj(@str2);except;end;
end;
//## ldsOUTSIDE ##
procedure tbasiccontrol.ldsOUTSIDE(dx,dy,dw,dh,dcol:longint);
label
   skipend;
var
   cw,ch:longint;
begin
try
//init
dw:=frcmin(dw,0);
dh:=frcmin(dh,0);
cw:=clientwidth;
ch:=clientheight;
//left
lds(rect(0,0,dx-1,ch-1),dcol,false);
//right
lds(rect(dx+dw,0,cw-1,ch-1),dcol,false);
//top
lds(rect(dx,0,dx+dw-1,dy-1),dcol,false);
//bottom
lds(rect(dx,dy+dh,dx+dw-1,ch-1),dcol,false);
except;end;
end;
//## lds ##
procedure tbasiccontrol.lds(darea:trect;dcol:longint;xround:boolean);
begin
try;lds2(darea,dcol,clnone,clnone,0,'',xround);except;end;
end;
//## lds2 ##
procedure tbasiccontrol.lds2(darea:trect;dcol,dcol2,dcol3,drich:longint;xoptions:string;xround:boolean);
begin
try;lds3(true,darea,dcol,dcol2,dcol3,drich,xoptions,xround,false);except;end;
end;
//## lds3 ##
procedure tbasiccontrol.lds3(xdyanmicCorners:boolean;darea:trect;dcol,dcol2,dcol3,drich:longint;xoptions:string;xround,xdarktolight:boolean);
var
   str2:tstr8;
begin
try
if not gui.painting then exit;
str2:=nil;
if (xoptions<>'') then str2:=bnewstr(xoptions);
inc(darea.left,iclientarea.left);
inc(darea.right,iclientarea.left);
inc(darea.top,iclientarea.top);
inc(darea.bottom,iclientarea.top);
if xdarktolight and (low__brightness2b(dcol2)<low__brightness2b(dcol)) then low__swapint(dcol,dcol2);//27mar2021
low__draw(xdyanmicCorners,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,'s',iclientarea,ipaintarea,darea,dcol,dcol2,dcol3,0,0,0,drich,nil,str2,oroundstyle,xround);
except;end;
try;freeobj(@str2);except;end;
end;
//## ldo ##
procedure tbasiccontrol.ldo(darea:trect;dcol:longint;xround:boolean);
begin
try;ldo2(darea,dcol,clnone,clnone,0,'',xround);except;end;
end;
//## ldo2 ##
procedure tbasiccontrol.ldo2(darea:trect;dcol,dcol2,dcol3,drich:longint;xoptions:string;xround:boolean);
begin
try;ldo3(true,darea,dcol,dcol2,dcol3,drich,xoptions,xround,false);except;end;
end;
//## ldo3 ##
procedure tbasiccontrol.ldo3(xdyanmicCorners:boolean;darea:trect;dcol,dcol2,dcol3,drich:longint;xoptions:string;xround,xdarktolight:boolean);
var
   str2:tstr8;
   p:longint;
begin
try
if not gui.painting then exit;
str2:=nil;
if (xoptions<>'') then str2:=bnewstr(xoptions);
inc(darea.left,iclientarea.left);
inc(darea.right,iclientarea.left);
inc(darea.top,iclientarea.top);
inc(darea.bottom,iclientarea.top);
if xdarktolight and (low__brightness2b(dcol2)<low__brightness2b(dcol)) then low__swapint(dcol,dcol2);//27mar2021
for p:=0 to (vizoom-1) do low__draw(xdyanmicCorners,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,'o',iclientarea,ipaintarea,rect(darea.left+p,darea.top+p,darea.right-p,darea.bottom-p),dcol,dcol2,dcol3,0,0,0,drich,nil,str2,oroundstyle,xround);
except;end;
try;freeobj(@str2);except;end;
end;
//## ldr ##
procedure tbasiccontrol.ldr(darea:trect;dcol:longint;xround:boolean);
begin
try;if xround then ldr2(darea,dcol,dcol,dcol,dcol,0,'',xround);except;end;
end;
//## ldr2 ##
procedure tbasiccontrol.ldr2(darea:trect;dcolTL,dcolTR,dcolBL,dcolBR,drich:longint;xoptions:string;xround:boolean);
begin
try;ldr3(true,darea,dcolTL,dcolTR,dcolBL,dcolBR,drich,xoptions,xround);except;end;
end;
//## ldr3 ##
procedure tbasiccontrol.ldr3(xdynamicCorners:boolean;darea:trect;dcolTL,dcolTR,dcolBL,dcolBR,drich:longint;xoptions:string;xround:boolean);
var
   str2:tstr8;
begin
try
if (not gui.painting) or (not xround) then exit;//must be round to work
str2:=nil;
if (xoptions<>'') then str2:=bnewstr(xoptions);
inc(darea.left,iclientarea.left);
inc(darea.right,iclientarea.left);
inc(darea.top,iclientarea.top);
inc(darea.bottom,iclientarea.top);
//all at once
if (dcolTL=dcolTR) and (dcolTL=dcolBL) and (dcolTL=dcolBR) then
   begin
   if (dcolTL<>clnone) then low__draw(xdynamicCorners,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,'r',iclientarea,ipaintarea,darea,dcolTL,clnone,clnone,0,0,0,drich,nil,str2,oroundstyle,xround);
   end
else
   begin//one at a time
   if (dcolTL<>clnone) then low__draw(xdynamicCorners,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,'0',iclientarea,ipaintarea,darea,dcolTL,clnone,clnone,0,0,0,drich,nil,str2,oroundstyle,xround);
   if (dcolTR<>clnone) then low__draw(xdynamicCorners,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,'1',iclientarea,ipaintarea,darea,dcolTR,clnone,clnone,0,0,0,drich,nil,str2,oroundstyle,xround);
   if (dcolBL<>clnone) then low__draw(xdynamicCorners,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,'2',iclientarea,ipaintarea,darea,dcolBL,clnone,clnone,0,0,0,drich,nil,str2,oroundstyle,xround);
   if (dcolBR<>clnone) then low__draw(xdynamicCorners,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,'3',iclientarea,ipaintarea,darea,dcolBR,clnone,clnone,0,0,0,drich,nil,str2,oroundstyle,xround);
   end;
except;end;
try;freeobj(@str2);except;end;
end;
//## winLdrCOLOR ##
function tbasiccontrol.winLdrCOLOR:longint;
begin
try
result:=info.framefindcol2;
if assigned(fonwinLdrcolor) then fonwinLdrcolor(self,result);//get the color right now - 15mar2022
except;end;
end;
//## winLdr ##
procedure tbasiccontrol.winLdr;
var
   darea:trect;
   a:tbasiccontrol;
   xround:boolean;
   drich,dcol,bs:longint;
begin
try
if (not gui.painting) or (not xwindow(a)) then exit;
xround:=a.info_round;
if not xround then exit;//must be round to work
//was: dcol:=a.info.frame2;
if (owinLdrCOLOR<>clnone) then dcol:=owinLdrCOLOR else dcol:=winLdrCOLOR;//a.info.framefindcol2;///low__framecol12(a.info.frame,a.info.frame2,false);
//.dim the brightness of the frame - 01mar2022
if (oframebrightness<100) then dcol:=low__colsplice(oframebrightness,dcol,oframebrightnessDARK);//dbrightness,int1,dbrightnessDARK - 01mar2022
drich:=0;
bs:=a.findbordersize;
darea:=a.paintarea;
inc(darea.left,bs);
dec(darea.right,bs);
inc(darea.top,bs);
dec(darea.bottom,bs);
//all at once
low__draw(true,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,'r',a.clientarea,a.paintarea,darea,dcol,clnone,clnone,0,0,0,drich,nil,nil,a.oroundstyle,xround);
except;end;
end;
//## ldf ##
procedure tbasiccontrol.ldf(darea:trect;dcol,dcol2,dsize:longint;xframecode:tstr8;xround:boolean);
begin
try;ldf3(darea,dcol,dcol2,clnone,dsize,0,'',xframecode,xround);except;end;
end;
//## ldf2 ##
procedure tbasiccontrol.ldf2(darea:trect;dcol,dcol2,dcol3,dsize,drich:longint;xoptions:string;xframecode:tstr8;xround:boolean);
begin
try;ldf3(darea,dcol,dcol2,dcol3,dsize,drich,xoptions,xframecode,xround);except;end;
end;
//## ldf3 ##
procedure tbasiccontrol.ldf3(darea:trect;dcol,dcol2,dcol3,dsize,drich:longint;xoptions:string;xframecode:tstr8;xround:boolean);
begin
try;ldf4(darea,dcol,dcol2,dcol3,dsize,100,0,drich,xoptions,xframecode,xround);except;end;
end;
//## ldf4 ##
procedure tbasiccontrol.ldf4(darea:trect;dcol,dcol2,dcol3,dsize,dbrightness,dbrightnessDARK,drich:longint;xoptions:string;xframecode:tstr8;xround:boolean);
var
   str2:tstr8;
begin
try
if not gui.painting then exit;
dbrightness:=frcrange(dbrightness,0,100);
str2:=nil;
if (xoptions<>'') then str2:=bnewstr(xoptions);
inc(darea.left,iclientarea.left);
inc(darea.right,iclientarea.left);
inc(darea.top,iclientarea.top);
inc(darea.bottom,iclientarea.top);
case (xframecode<>nil) and (xframecode.len>=1) of
true: low__draw(true,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,'g',iclientarea,ipaintarea,darea,dcol,dcol2,dcol3,dsize,dbrightness,dbrightnessDARK,drich,xframecode,str2,oroundstyle,xround);
false:low__draw(true,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,'f' ,iclientarea,ipaintarea,darea,dcol,dcol2,dcol3,dsize,dbrightness,dbrightnessDARK,drich,nil,str2,oroundstyle,xround);
end;//case
except;end;
try;freeobj(@str2);except;end;
end;
//## ldm ##
procedure tbasiccontrol.ldm(darea:trect;xround:boolean);//draw color matrix
begin
try;ldm2(darea,clnone,xround);except;end;
end;
//## ldm2 ##
procedure tbasiccontrol.ldm2(darea:trect;dcol3:longint;xround:boolean);//draw color matrix
begin//Note: dcol3=corner color
try
if not gui.painting then exit;
inc(darea.left,iclientarea.left);
inc(darea.right,iclientarea.left);
inc(darea.top,iclientarea.top);
inc(darea.bottom,iclientarea.top);
low__draw(true,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,'m',iclientarea,ipaintarea,darea,clnone,clnone,dcol3,0,0,0,0,nil,nil,oroundstyle,xround);
except;end;
end;
//## ldi ##
procedure tbasiccontrol.ldi(darea:trect;dx,dy,dcol,dtep:longint;xfocus,xgrey,xround:boolean);
begin
try
if (not gui.painting) or (dtep=tepnone) then exit;
inc(dx,iclientarea.left);
inc(dy,iclientarea.top);
inc(darea.left,iclientarea.left);
inc(darea.right,iclientarea.left);
inc(darea.top,iclientarea.top);
inc(darea.bottom,iclientarea.top);
low__draw2(true,tbnone,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,'i',iclientarea,ipaintarea,darea,dcol,dcol,clnone,dx,dy,dtep,clnone,clnone,0,nil,nil,oroundstyle,xround,xfocus,xgrey,false,false);
except;end;
end;
//## ldi2 ##
procedure tbasiccontrol.ldi2(darea:trect;dx,dy,dcol,dcol2,dtep:longint;xfocus,xgrey,xround:boolean);//02mar2021
begin
try
if (not gui.painting) or (dtep=tepnone) then exit;
inc(dx,iclientarea.left);
inc(dy,iclientarea.top);
inc(darea.left,iclientarea.left);
inc(darea.right,iclientarea.left);
inc(darea.top,iclientarea.top);
inc(darea.bottom,iclientarea.top);
low__draw2(true,tbnone,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,'i',iclientarea,ipaintarea,darea,dcol,dcol,clnone,dx,dy,dtep,dcol2,clnone,0,nil,nil,oroundstyle,xround,xfocus,xgrey,false,false);
except;end;
end;
//## ldis ##
procedure tbasiccontrol.ldis(darea:trect;dx,dy,dcol,dtep:longint;xfocus,xgrey,xround:boolean);
begin
try
if (not gui.painting) or (dtep=tepnone) then exit;
inc(dx,iclientarea.left);
inc(dy,iclientarea.top);
inc(darea.left,iclientarea.left);
inc(darea.right,iclientarea.left);
inc(darea.top,iclientarea.top);
inc(darea.bottom,iclientarea.top);
low__draw3(true,vicoloriseimages,true,tbnone,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,'j',iclientarea,ipaintarea,darea,dcol,dcol,clnone,dx,dy,dtep,low__aorb(clnone,info.background,vicoloriseimages),clnone,0,nil,nil,oroundstyle,xround,xfocus,xgrey,false,false);
except;end;
end;
//## ldis2 ##
procedure tbasiccontrol.ldis2(darea:trect;dx,dy,dcol,dcol2,dtep:longint;xfocus,xgrey,xround:boolean);//02mar2021
begin
try
if (not gui.painting) or (dtep=tepnone) then exit;
inc(dx,iclientarea.left);
inc(dy,iclientarea.top);
inc(darea.left,iclientarea.left);
inc(darea.right,iclientarea.left);
inc(darea.top,iclientarea.top);
inc(darea.bottom,iclientarea.top);
low__draw3(true,vicoloriseimages,true,tbnone,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,'j',iclientarea,ipaintarea,darea,dcol,dcol,clnone,dx,dy,dtep,dcol2,clnone,0,nil,nil,oroundstyle,xround,xfocus,xgrey,false,false);
except;end;
end;
//## ltea ##
procedure tbasiccontrol.ltea(xdynamicCorners,xcolorise,xsyszoom:boolean;darea:trect;dx,dy,dcol:longint;xteadata:tstr8;xfocus,xgrey,xround:boolean);//07apr2021
begin
try
if (not gui.painting) or zznil(xteadata,2316) then exit;
inc(dx,iclientarea.left);
inc(dy,iclientarea.top);
inc(darea.left,iclientarea.left);
inc(darea.right,iclientarea.left);
inc(darea.top,iclientarea.top);
inc(darea.bottom,iclientarea.top);
low__draw3(xdynamicCorners,xcolorise,xsyszoom,tbnone,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,'a',iclientarea,ipaintarea,darea,dcol,dcol,clnone,dx,dy,0,clnone,clnone,0,xteadata,nil,oroundstyle,xround,xfocus,xgrey,false,false);
except;end;
end;
//## lteas ##
procedure tbasiccontrol.lteas(darea:trect;dx,dy,dcol,dcol2:longint;xteadata:tstr8;xfocus,xgrey,xround:boolean);//07apr2021
begin
try;ltea(true,true,true,darea,dx,dy,dcol,xteadata,xfocus,xgrey,xround);except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//bbbbbbbbbbbbbbbbbbb
//## ldc ##
procedure tbasiccontrol.ldc(darea:trect;ddx,ddy,ddw,ddh:currency;sa:trect;s:tobject;xpower255,xtrans,xtc:longint;xoptions:currency);
begin
try;ldc2(darea,ddx,ddy,ddw,ddh,sa,s,xpower255,xtrans,xtc,clnone,xoptions,false);except;end;
end;
//## ldc2 ##
procedure tbasiccontrol.ldc2(darea:trect;ddx,ddy,ddw,ddh:currency;sa:trect;s:tobject;xpower255,xtrans,xtc,xwriteShadesofcolor:longint;xoptions:currency;xusealpha:boolean);
var
   xs,ys:longint;
begin
try
//check
if (not gui.painting) or (not gui.xareaok(sa)) or (not gui.xareaok(darea)) then exit;
//init
xs             :=xshift;
ys             :=yshift;
darea.left     :=frcrange(low__sum32([darea.left   ,ipaintarea.left-xs])  ,ipaintarea.left ,ipaintarea.right);
darea.right    :=frcrange(low__sum32([darea.right  ,ipaintarea.left-xs])  ,ipaintarea.left ,ipaintarea.right);
darea.top      :=frcrange(low__sum32([darea.top    ,ipaintarea.top-ys])   ,ipaintarea.top  ,ipaintarea.bottom);
darea.bottom   :=frcrange(low__sum32([darea.bottom ,ipaintarea.top-ys])   ,ipaintarea.top  ,ipaintarea.bottom);
//check
if (darea.right<darea.left) or (darea.bottom<darea.top) then exit;
//get
ddx:=ddx+ipaintarea.left-xs;
ddy:=ddy+ipaintarea.top-ys;
//miscopyareaxx8(darea,ddx,ddy,ddw,ddh,sa,gui.buffer,s,nil,nil,nil,nil,nil,gui.mask,gui.maskval,0,false,xpower255,xtrans,xtc,xoptions,0,0,nil,nil,nil,nil,nil,nil,nil,xusealpha);
//miscopyareaxx9(clnone,clnone,da_clip,ddx,ddy,ddw,ddh,sa,d,s,dm,dm2,sm,sm2,sselshow,dmask,dmaskval,xselshowSTRIDE,xselshowEVENINIT,xpower255,xtrans,xtc,xoptions,xscroll,yscroll,refOP,refRGB,refR,refG,refB,refX,refY,xusealpha);except;end;
miscopyareaxx10(clnone,clnone,darea,ddx,ddy,ddw,ddh,sa,gui.buffer,s,nil,nil,nil,nil,nil,gui.mask,gui.maskval,0,false,xpower255,xtrans,xtc,xwriteShadesofcolor,xoptions,0,0,nil,nil,nil,nil,nil,nil,nil,xusealpha);

except;end;
end;
//## ldcs ##
procedure tbasiccontrol.ldcs(xcolorise1,xcolorise2:longint;darea:trect;ddx,ddy,ddw,ddh:currency;sa:trect;s:tobject;xpower255,xtrans,xtc:longint;xoptions:currency);
begin
try;ldcs2(xcolorise1,xcolorise2,darea,ddx,ddy,ddw,ddh,sa,s,xpower255,xtrans,xtc,xoptions,false);except;end;
end;
//## ldcs2 ##
procedure tbasiccontrol.ldcs2(xcolorise1,xcolorise2:longint;darea:trect;ddx,ddy,ddw,ddh:currency;sa:trect;s:tobject;xpower255,xtrans,xtc:longint;xoptions:currency;xusealpha:boolean);
var
   xs,ys:longint;
begin
try
//check
if (not gui.painting) or (not gui.xareaok(sa)) or (not gui.xareaok(darea)) then exit;
//init
xs             :=xshift;
ys             :=yshift;
darea.left     :=frcrange(low__sum32([darea.left   ,ipaintarea.left-xs])  ,ipaintarea.left ,ipaintarea.right);
darea.right    :=frcrange(low__sum32([darea.right  ,ipaintarea.left-xs])  ,ipaintarea.left ,ipaintarea.right);
darea.top      :=frcrange(low__sum32([darea.top    ,ipaintarea.top-ys])   ,ipaintarea.top  ,ipaintarea.bottom);
darea.bottom   :=frcrange(low__sum32([darea.bottom ,ipaintarea.top-ys])   ,ipaintarea.top  ,ipaintarea.bottom);
//check
if (darea.right<darea.left) or (darea.bottom<darea.top) then exit;
//get
ddx:=ddx+ipaintarea.left-xs;
ddy:=ddy+ipaintarea.top-ys;
miscopyareaxx9(low__aorb(clnone,xcolorise1,vicoloriseimages),low__aorb(clnone,xcolorise2,vicoloriseimages),darea,ddx,ddy,ddw,ddh,sa,gui.buffer,s,nil,nil,nil,nil,nil,gui.mask,gui.maskval,0,false,xpower255,xtrans,xtc,xoptions,0,0,nil,nil,nil,nil,nil,nil,nil,xusealpha);
//xxxxxxxxxxx debug only => miscopyareaxx7(darea,ddx,ddy,ddw,ddh,sa,gui.buffer,s,nil,nil,nil,nil,nil,nil,-1,0,false,xpower255,xtrans,xtc,xoptions,0,0,nil,nil,nil,nil,nil,nil,nil);
except;end;
end;
//## ldt ##
procedure tbasiccontrol.ldt(darea:trect;dx,dy,dcol:longint;xline:string;xfontindex,xfeather:longint;xround:boolean);
begin
try;ldtTAB2(tbnone,darea,dx,dy,dcol,xline,xfontindex,xfeather,false,false,false,false,xround);except;end;
end;
//## ldtTAB ##
procedure tbasiccontrol.ldtTAB(xtab:longint;darea:trect;dx,dy,dcol:longint;xline:string;xfontindex,xfeather:longint;xround:boolean);
begin
try;ldtTAB2(xtab,darea,dx,dy,dcol,xline,xfontindex,xfeather,false,false,false,false,xround);except;end;
end;
//## ldt2 ##
procedure tbasiccontrol.ldt2(darea:trect;dx,dy,dcol:longint;xline:string;xfontindex,xfeather:longint;xbold,xitalic,xunderline,xstrikeout,xround:boolean);
begin
try;ldtTAB2(tbnone,darea,dx,dy,dcol,xline,xfontindex,xfeather,xbold,xitalic,xunderline,xstrikeout,xround);except;end;
end;
//## ldtTAB2 ##
procedure tbasiccontrol.ldtTAB2(xtab:longint;darea:trect;dx,dy,dcol:longint;xline:string;xfontindex,xfeather:longint;xbold,xitalic,xunderline,xstrikeout,xround:boolean);
var
   str2:tstr8;
begin
try
if not gui.painting then exit;
str2:=nil;
if (xline<>'') then
   begin
   str2:=bnewstr(xline);
   ldtTAB4(xtab,darea,dx,dy,dcol,str2,xfontindex,xfeather,xbold,xitalic,xunderline,xstrikeout,xround);
   end;
except;end;
try;freeobj(@str2);except;end;
end;
//## ldt3 ##
procedure tbasiccontrol.ldt3(darea:trect;dx,dy,dcol:longint;xline:tstr8;xfontindex,xfeather:longint;xround:boolean);
begin
try;ldtTAB4(tbnone,darea,dx,dy,dcol,xline,xfontindex,xfeather,false,false,false,false,xround);except;end;
end;
//## ldtTAB3 ##
procedure tbasiccontrol.ldtTAB3(xtab:longint;darea:trect;dx,dy,dcol:longint;xline:tstr8;xfontindex,xfeather:longint;xround:boolean);
begin
try;ldtTAB4(xtab,darea,dx,dy,dcol,xline,xfontindex,xfeather,false,false,false,false,xround);except;end;
end;
//## ldt4 ##
procedure tbasiccontrol.ldt4(darea:trect;dx,dy,dcol:longint;xline:tstr8;xfontindex,xfeather:longint;xbold,xitalic,xunderline,xstrikeout,xround:boolean);
begin
try;ldtTAB4(tbnone,darea,dx,dy,dcol,xline,xfontindex,xfeather,xbold,xitalic,xunderline,xstrikeout,xround);except;end;
end;
//## ldtTAB4 ##
procedure tbasiccontrol.ldtTAB4(xtab:longint;darea:trect;dx,dy,dcol:longint;xline:tstr8;xfontindex,xfeather:longint;xbold,xitalic,xunderline,xstrikeout,xround:boolean);
label
   skipend;
begin
try
block(xline);
if (not gui.painting) or zznil(xline,2317) or (xline.count<=0) then goto skipend;
inc(dx,iclientarea.left);
inc(dy,iclientarea.top);
inc(darea.left,iclientarea.left);
inc(darea.right,iclientarea.left);
inc(darea.top,iclientarea.top);
inc(darea.bottom,iclientarea.top);
xfontindex:=low__fontdata(xfontindex);
if (xfontindex<>0) and (sysfont_data[xfontindex].count<=0) then xfontindex:=0;//revert to "root/0" font when something goes wrong
low__draw2(true,xtab,gui.bits,gui.width,gui.height,gui.rows,gui.mask,gui.maskval,'t',iclientarea,ipaintarea,darea,dcol,dcol,clnone,dx,dy,xfeather,0,0,0,sysfont_data[xfontindex],xline,oroundstyle,xround,xbold,xitalic,xunderline,xstrikeout);
skipend:
except;end;
try;bunlockautofree(xline);except;end;
end;

//## tbasichead ##############################################################
//## create2 ##
constructor tbasichead.create2(xparent:tobject;xstart:boolean);
var
   int1,int2,p:longint;
   //## xadd ##
   function xadd(xtep:longint;xcmd,xhlp:string;xvis,xenb:boolean):longint;
   var
      p:longint;
      e:string;
      bol1,bol2:boolean;
   begin
   //defaults
   result:=0;
   //check
   if (xtep=tepnone) then exit;
   //get
   for p:=0 to high(ibuttep) do if (ibuttep[p]=tepnone) then
      begin
      ibuttep[p]:=xtep;
      ibutcmd[p]:=xcmd;
      ibuthlp[p]:=xhlp;
      ibutvis[p]:=xvis;
      ibutenb[p]:=xenb;
      tepinfo(xtep,false,ibutw[p],ibuth[p],bol1,bol2);
      result:=p;
      break;
      end;//p
   end;
begin
//self
satinc(satHead,1);
inherited create2(xparent,false);
//vars
ocanshowmenu:=true;
osmall:=false;
istyle:=wuClose;
itep:=tepNone;
iimg:=misimg(24,1,1);
itranscol:=clnone;
tep:=tepicon32;//default icon -> program icon - 13may2020
iinfostate:='';
iinforef:='';
caption:='';//use internal programnname by default
icaption2:='';//18jun2021
ihelp:=programslogan+low__insstr(' | ',programslogan<>'')+'Click and drag to position window';//annoying for such a large HINT to display -> need realtime help if we're going to use this help: rthtranslate('Click and drag to position window');
ilongperiod:=30000;//30 seconds
ishortperiod:=1500;//1.5 seconds
idragref64:=0;//off
idragref64check:=0;//off
iformrect:=rect(0,0,0,0);
ibordersize:=1;//subtle border
osafepos:=true;
oiconpad:=1;
inormal:=false;
itimer250:=ms64;
idownindex:=-1;
ihoverindex:=-1;
ianicount:=0;//30apr2022
ianipos:=0;
ianiplay64:=0;
ianinext64:=0;
//buttons
for p:=0 to high(ibuttep) do
begin
ibuttep[p]:=tepnone;
ibutare[p]:=rect(0,0,0,0);
ibutcmd[p]:='';
ibutw[p]:=0;
ibuth[p]:=0;
ibutvis[p]:=false;
end;//p
//.system buttons
vinf:=xadd(tepinf,'i',translate('Show program menu'),true,true);
vmin:=xadd(tepmin,'-',translate('Minimise (hide) window'),true,true);
vmax:=xadd(tepmax,'+',translate('Toggle between Window or Maximised'),true,true);
vclo:=xadd(tepclo,'x',translate('Close'),true,true);
//controls
clientheight:=displaysize;
//defaults
xcmd('sync');
//start
if xstart then start;
end;
//## destroy ##
destructor tbasichead.destroy;
begin
try
//disconnect timer
timer:=false;
//controls
freeobj(@iimg);
//self
inherited destroy;
satinc(satHead,-1);
except;end;
end;
//## aniAdd ##
function tbasichead.aniAdd(xtep,xms:longint):boolean;//16sep2022
var
   p:longint;
   xdata:tlistptr;
begin
try
//defaults
result:=false;
if (ianicount>high(ianitep)) then exit;
//get
if tepfind3(xtep,xdata,true) then//fixed - 16sep2022
   begin
   p:=ianicount;
   ianitep[p]:=xtep;
   ianims[p]:=frcrange(xms,50,10000);
   inc(ianicount,1);
   end;
//successful
result:=true;
except;end;
end;
//## aniClear ##
procedure tbasichead.aniClear;
begin
try
if (ianicount>=1) then
   begin
   tep:=ianitep[0];
   ianicount:=0;
   end;
except;end;
end;
//## aniPlay ##
procedure tbasichead.aniPlay;
begin
try;if (ianicount>=1) then ianiplay64:=ms64+2000;except;end;
end;
//## make_bare ##
function tbasichead.make_bare:tbasichead;
begin
try
result:=self;//pass-thru - 24jul2021
tep:=tepNone;
style:=wuNone;
except;end;
end;
//## setcaption2 ##
procedure tbasichead.setcaption2(x:string);
begin
try;if low__setstr(icaption2,x) then paintnow;except;end;
end;
//## setstyle ##
procedure tbasichead.setstyle(x:longint);
begin
try;if low__setint(istyle,frcrange(x,0,wumax)) then paintnow;except;end;
end;
//## settep ##
procedure tbasichead.settep(x:longint);
var
   int1,int2:longint;
begin
try
if low__setint(itep,x) then
   begin
   low__teatoimg(tepfind2(itep),iimg,int1,int2);//23may2020
   itranscol:=low__teaTLpixel(tepfind2(itep));//01aug2020
   paintnow;
   end;
except;end;
end;
//## _ontimer ##
procedure tbasichead._ontimer(sender:tobject);
const
   xspace=64;
   xminorspace=20;
var
   b:trect;
   bol1,xmustpaint:boolean;
   sw,sh,dx,dy,p:longint;
   str1:string;
   xms64:comp;
begin
try
//defaults
xmustpaint:=false;
xms64:=ms64;

//.itimer250
if (xms64>itimer250) then
   begin
   //window state
   xcmd('sync');
   //control info
   str1:='';
   for p:=0 to high(ibuttep) do str1:=str1+inttostr(p)+pcRefsep+inttostr(ibuttep[p])+pcRefsep+bnc(ibutenb[p])+bnc(ibutvis[p])+pcRefsep;
   if low__setstr(iinforef,str1+pcRefsep+bnc(xwindowindex=gui.winfocus)+bnc(inormal)+pcRefsep+inttostr(oiconpad)+pcRefsep+inttostr(findbordersize)+pcRefsep+inttostr(displaysize)) then xmustpaint:=true;
   //reset
   itimer250:=xms64+250;
   end;

//.idragref64
if (idragref64<>0) then
   begin
   //init
   bol1:=true;
   //drag checking off
   if gui.mousedown then idragref64:=xms64+ilongperiod//extend overal check period until mouse is nolonger down
   else if (xms64>idragref64) then
      begin
      idragref64:=0;
      idragref64check:=0;
      bol1:=false;
      end;
   //check
   if bol1 and (xms64>=idragref64check) then
      begin
      //reset
      idragref64check:=xms64+ishortperiod;
      //action
      if osafepos and (not gui.mousedown) and (not sysmouse_down) then
         begin
{//was:
         if (gui.host<>nil) and (not isiconic(gui.host.handle)) then
            begin
            dx:=gui.host.left;
            dy:=gui.host.top;
            b:=misworkarea;
            //-- Smart Screen Detection -----------------------------------------
            //Note: if user drags window off workarea and off the screen by at least "xminor pixels" then let window stay there (e.g. assumed to be a another screen) - 14mar2020
            //.init
            sw:=misscreenw;
            sh:=misscreenh;
            //.dx
            if      ((dx+gui.width)<(b.left+xspace)) and (not ((dx+gui.width)<-xminorspace)) then dx:=b.left+xspace-gui.width
            else if (dx>(b.right-xspace)) and (not (dx>(sw+xminorspace)))                then dx:=b.right-xspace;
            //.dy
            if      (dy<b.top) and (not ((dy+gui.height)<-xminorspace))                               then dy:=b.top
            else if (dy>(b.bottom-xspace)) and (not (dy>(sh+xminorspace)))               then dy:=b.bottom-xspace;
            //set
            if (gui.host<>nil) and ((dx<>gui.host.left) or (dy<>gui.host.top)) then gui.host.setbounds(dx,dy,gui.host.width,gui.host.height);
            end;
{}
         end;
      end;
   end;

//.aniPlay
if (ianicount>=1) and (ianiplay64<>0) then
   begin
   if (xms64>ianiplay64) then//stopped
      begin
      ianiplay64:=0;//stop
      ianipos:=0;
      tep:=ianitep[0];//restore default icon - 1st in the set
      end
   else if (xms64>=ianinext64) then
      begin
      p:=ianipos+1;
      if (p>=ianicount) then p:=0;
      ianinext64:=xms64+ianims[p];
      ianipos:=p;
      tep:=ianitep[p];//paint new icon
      end;
   end;

//paint
if xmustpaint then paintnow;
except;end;
end;
//## getalignheight ##
function tbasichead.getalignheight(xclientwidth:longint):longint;
begin
try;result:=frcmin((displaysize*vizoom)+(2*findbordersize),0);except;end;
end;
//## displaysize ##
function tbasichead.displaysize:longint;
begin
try
{
if osyssize then
   begin
   if vititlelarge then result:=34 else result:=26;//01mar2022
   end
else if osmall then result:=24
else result:=34;
{}//xxxxxxxxxxx
if osmall                then result:=24
else if not viheadlarge  then result:=26//01mar2022
else                          result:=34;
except;end;
end;
//## xfind ##
function tbasichead.xfind(sx,sy:longint):longint;
var
   p:longint;
begin
try
//defaults
result:=-1;
//find
for p:=0 to high(ibuttep) do if ibutvis[p] and (ibutw[p]>=1) and (ibuth[p]>=1) and (ibuttep[p]<>tepnone) and (ibutare[p].left<ibutare[p].right) and (ibutare[p].top<ibutare[p].bottom) then
   begin
   if (sx>=ibutare[p].left) and (sx<=ibutare[p].right) and (sy>=ibutare[p].top) and (sy<=ibutare[p].bottom) then
      begin
      result:=p;
      break;
      end;
   end;//p
except;end;
end;
//## xfindcmd ##
function tbasichead.xfindcmd(xcmd:string;var xindex:longint):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
xindex:=0;
//find
for p:=0 to high(ibuttep) do if (ibuttep[p]<>tepnone) and low__comparetext(xcmd,ibutcmd[p]) then
   begin
   xindex:=p;
   result:=true;
   break;
   end;
except;end;
end;
//## _onpaint ##
procedure tbasichead._onpaint(sender:tobject);//28may2021, 26apr2021
var
   //infovars
   a:pvirtualinfo;
   xparent:tbasiccontrol;
   cs,ci:trect;
   fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xenabled,xround,xnormal:boolean;
   //other
   dbutw,xfonthighlight,xzoom,wback,xhoverindex,fc,int1,xstyle,xdownoffset,p,dh,xiconpad,xtc,xsize,ddx,ddy,dx,dy:longint;
   xcaption,str1,e:string;
   xheadcenter,xtouch,xfocused,xhavefocus,xfocus,xdown,xact,bol1:boolean;
   shiftby,sp,xpad,xbutpad,xbutclickw:longint;
   //## xcandraw ##
   function xcandraw(xindex:longint):boolean;
   var
      a:tcommonform;
   begin
   result:=xok(xindex);
   if result then
      begin
      //system buttons
      if (xindex=vmax) or (xindex=vmin) or (xindex=vclo) or (xindex=vinf) then
         begin
         case xstyle of
         2:result:=true;
         1:result:=(xindex=vclo);
         else result:=false;
         end;//case
         //special override cases
         if (xindex=vmin) or (xindex=vmax) then
            begin
            //xxxxxxxxxxxxxxxxxxxxxxxxxxxx if (gui.ishowmode<>gui.smnone) then result:=false;//can't minimise application when showing in modal mode - 18mar2020
            end;
         end;
      end;
   end;
begin
try
//init
xzoom      :=vizoom;//14mar2021
xheadcenter:=viheadcenter;//11oct2022
xtouch     :=vitouch;
shiftby    :=2*xzoom;
sp         :=2*xzoom;
xpad       :=4*xzoom;//was 7
xbutpad    :=20*xzoom;
xbutclickw :=5*xzoom;
infovars(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);
dh:=frcmin(ch-(2*xbordersize),1);
xiconpad:=frcrange(oiconpad*xzoom,0,round(dh*0.5));
xsize:=frcmax(frcmin(dh-(2*xiconpad),1),32*xzoom);
xact:=(xwindowindex=gui.winfocus);
xstyle:=istyle;
xfocused:=focused;//28may2021
//.font
fc:=low__font0(a.fontname,-frcmin(round(dh*0.90),5));
//.special color handling -> disable this when custom override colors are used - 22mar2021
if (obackcolor=clnone) then
   begin
   xback:=low__aorb(low__dc(a.background,-7),a.background,xact);
   xborder:=a.border;
   end;
if (otextcolor=clnone) then
   begin
   xfonthighlight:=a.fonthighlight;
   xfont:=low__aorb(a.disablefont,a.font,xact);
   xhover:=a.hover;
   if not low__cv(xhover,xback,90) then xhover:=low__dc(xhover,90);
   end
else
   begin
   //simple color use inversion -> for built-in "About" splash mode -> where only limited system colors specified - 26apr2021
   xfonthighlight:=xback;
   xhover:=xfont;
   end;
xhoverindex:=xfind(mousemovexy.x,mousemovexy.y);//need update-to-date info because "normalise/max" button can make window change size causing the cursor to be suddenly outside of this control with a correct update - 18apr2020

//cls
lds2(cs,low__dc(xback,-20),xback,clnone,visparkle,'g50',xround);

//dx
dx:=xbordersize+(1*xzoom);//minor left-side pad -> space it spaced away from inner edge of round corner curve for neatness - 11apr2020
//icon -> supports full color icon transparent and non-transparent - 12mar2020
if (itep<>tepnone) then
   begin
   ldcs(xfont,xback,ci,ci.left+xiconpad,ci.top+xiconpad,xsize,xsize,low__rect(0,0,iimg.width-1,iimg.height-1),iimg,255,low__aorb(0,1,itranscol<>clnone),itranscol,0);
   //need to switch to "ldc(.....<iraw24>.......)"
   inc(dx,xiconpad);
   dy:=(ch-xsize) div 2;
   inc(dx,xsize);
   end;
//title
xcaption:=low__udv(caption,low__programname)+icaption2;//18jun2021
inc(dx,xbordersize+xpad);
ldt(ci,low__aorb(dx,frcmin(dx,(cw-low__fonttextwidth2(fc,xcaption)) div 2),xheadcenter),(ch-low__fontmaxh(fc)) div 2,xfont,xcaption,fc,xfeather,xround);//06nov2022, 11oct2022

//window buttons -> right-to-left
dx:=cw-xbordersize-xbutclickw-(2*xzoom);
dy:=xbordersize+(2*xzoom);
for p:=high(ibuttep) downto 0 do
begin
if (ibuttep[p]<>tepnone) and ibutvis[p] and (ibutw[p]>=1) and (ibuth[p]>=1) and xcandraw(p) then
   begin
   //init
   dbutw:=ibutw[p]*low__aorb(1,2,xtouch);//larger window head buttons when in "touch" mode - 11oct2022
   xhavefocus:=ibutenb[p] and (p=xhoverindex) or (gui.mousedown and (p=idownindex)) and xfocused;
   xdown:=ibutenb[p] and (gui.mousedown and (p=idownindex)) and xfocused;
   if xdown then xdownoffset:=shiftby else xdownoffset:=0;
   dec(dx,dbutw*xzoom);
   ddx:=dx+xdownoffset;
   ddy:=dy+xdownoffset;
   //.color
   if xhavefocus       then int1:=xfonthighlight//xhover
   else if ibutenb[p]  then int1:=xfont
   else                     int1:=xfontdisable;
   //get
   ibutare[p]:=rect(ddx-xbutclickw,ddy,ddx+((dbutw-1)*xzoom)+xbutclickw,ddy+((ibuth[p]-1)*xzoom)+xbutclickw);//on
//was: if xhavefocus then lds(ibutare[p],low__dc(xback,30),xround);//07sep2020
   if xhavefocus then lds(ibutare[p],xhover,xround);//07sep2020
   ldis(ci,ddx+(((dbutw*xzoom)-(ibutw[p]*xzoom)) div 2),ddy+(((ibutare[p].bottom-ibutare[p].top)-(ibuth[p]*xzoom)) div 2),int1,ibuttep[p],false,false,xround);
   //sep
   dec(dx,xbutpad);
   if (p=vclo) then dec(dx,xbutpad div 2);
   end
else ibutare[p]:=rect(0,0,0,0);//off
end;//p
//frame
if (xbordersize>=1) then ldf2(cs,xborder,xborder,clnone,xbordersize,0,'',nil,xround);
xparentcorners;//Note: System._onpaint() now uses winLdr to maintain the inner roundness of it's frame
               //      and thus all controls are free to paint square and the system will correct afterwards - 01aug2021
except;end;
end;
//## xdragthewindow ##
procedure tbasichead.xdragthewindow;//force head to act as a window dragger - assuming mouse input matches up - 07mar2022
begin
try;_onnotify2(nil,true);except;end;
end;
//## _onnotify ##
function tbasichead._onnotify(sender:tobject):boolean;
begin
try;result:=_onnotify2(sender,false);except;end;
end;
//## _onnotify2 ##
function tbasichead._onnotify2(sender:tobject;xdragonly:boolean):boolean;
var
   xwinstyle,int1:longint;
   bol1,xmustpaint:boolean;
   xhelp:string;
   a:tbasiccontrol;
begin
try
//defaults
result:=true;//handled
xmustpaint:=false;

//focus - mouse down
if gui.mousedown and (not gui.mousewasdown) then
   begin
   if xdragonly then int1:=-1 else int1:=xfind(mousedownxy.x,mousedownxy.y);
   if (int1<>idownindex) then
      begin
      if xok(int1) and (not ibutenb[int1]) then int1:=-1;
      idownindex:=int1;
      xmustpaint:=true;
      end;
   end;
//hover
if xdragonly then int1:=-1 else int1:=xfind(mousemovexy.x,mousemovexy.y);
if (int1=-1) then help2:='' else help2:=buthlp[int1];

if (int1<>ihoverindex) then
   begin
   ihoverindex:=int1;
//was:   if xok(int1) and ibutenb[int1] then screen.cursor:=crHandpoint else screen.cursor:=crDefault;
   xmustpaint:=true;
   end;

//drag window
if (idownindex=-1) and gui.mousedown then
   begin
   //init
   xwinstyle:=wmcontrol;
   xwindow(a);
   if zzok(a,7195) then xwinstyle:=a.winstyle;
   //get
   if zzok(a,7196) and (xwinstyle>wmcontrol) then
      begin
      //init
      app__turbo;//high speed timing
      //get
      case xwinstyle of
      wmFullwin:begin
         //mouse down
         if not gui.mousewasdown then iformrect:=rect(gui.left,gui.top,gui.width,gui.height);
         //move                           //updated 22sep2020, 07sep2020
         if ((gui.gstate=gsnormal) or (not gui.mainappwindow)) and gui.screendraggingfine and gui.mouseleft then
            begin
            //debug only:  a.setbounds(iformrect.left+2*(iscreenmovexy.x-iscreendownxy.x),iformrect.top+10*(iscreenmovexy.y-iscreendownxy.y),iformrect.right,iformrect.bottom);
            if not vilockposition then
               begin
               gui.setbounds(iformrect.left+(gui.screenmovexy.x-gui.screendownxy.x),iformrect.top+(gui.screenmovexy.y-gui.screendownxy.y),iformrect.right,iformrect.bottom);
               idragref64:=ms64+ilongperiod;//persist with checking for 30 seconds
               idragref64check:=ms64+ishortperiod;//check form every 3 seconds within that check period
               if not gui.dragging_fullwin then gui.dragstart_fullwin;//separate drag detector -> relates to exrternal OS and not our internal system - 15apr2021
               end;
            end;
         end;//begin
      wmWindow..wmMax:begin
         //mouse down
         if not gui.mousewasdown then
            begin
            iformrect:=low__rect(a.clientarea.left,a.clientarea.top,a.clientarea.right-a.clientarea.left+1,a.clientarea.bottom-a.clientarea.top+1);
            end;
         //move
         if gui.screendraggingfine then
            begin
            a.setbounds(iformrect.left+(gui.screenmovexy.x-gui.screendownxy.x),iformrect.top+(gui.screenmovexy.y-gui.screendownxy.y),iformrect.right,iformrect.bottom);
            gui.dragstart(a.coreindex);
            alignallnow;
            paintallnow;
            end;
         end;
      end;//case
      end;
   end;

//mouse up
if (not gui.mousedown) and gui.mousewasdown then
   begin
   //drag stop
   gui.dragstop;
   //click event
   int1:=idownindex;
   if gui.mouseleft then
      begin
      //.click lock - special override for "close" button (vclo) - 14mar2020
      if (int1=vclo) then bol1:=(int1=ihoverindex)//allow user to cancel by shift cursor away on the up stroke, i.e. "clicklock is always false"
      else                bol1:=(viclicklock or (int1=ihoverindex));
      //.fire then event
      case xok(int1) of
      true:if bol1 and ibutenb[int1] and ibutvis[int1] then xcmd(ibutcmd[int1]);
      false:begin
         if (not xdragonly) and gui.mousedbclick and vidoubleclicks and xwindow(a) then
            begin
            case a.winstyle of
            wmfullwin:if (gui.gstate=gsNormal) then xcmd('+') else xcmd('n');
            end;//case
            end;
         end;
      end;//case
      end;
   //reset + paint
   idownindex:=-1;
   xmustpaint:=true;
   end;
//external event override - 01mar2021
if assigned(fonnotify) then fonnotify(sender);
//xmustpaint
if xmustpaint then paintnow;
except;end;
end;
//## canmin ##
function tbasichead.canmin:boolean;
begin
try;result:=(istyle=wuAll);except;end;
end;
//## cannor ##
function tbasichead.cannor:boolean;
begin
try;result:=(istyle=wuAll);except;end;
end;
//## canmax ##
function tbasichead.canmax:boolean;
begin
try;result:=(istyle=wuAll);except;end;
end;
//## canclo ##
function tbasichead.canclo:boolean;
begin
try;result:=(istyle=wuAll) or (istyle=wuClose);except;end;
end;
//## canmen ##
function tbasichead.canmen:boolean;
begin
try;result:=(istyle=wuAll);except;end;
end;
//## xcmd ##
procedure tbasichead.xcmd(x:string);
var
   a:tbasiccontrol;
   int1:longint;
   str1:string;
begin
try
//init
if not xwindow(a) then exit;
//filter
x:=low__lowercase(x);
//window commands
if (a.winstyle=wmfullwin) then
   begin
{$ifdef D3}
   if (x='-') and canmin then application.minimize;
   if (x='n') and cannor then gui.gstate:=gsNormal;
   if (x='+') and canmax then
      begin
      if gui.xnormal then gui.gstate:=gsMax else gui.gstate:=gsNormal;//toggle
      //was: if (gui.host.windowstate=wsNormal) then gui.gstate:=gsMax else gui.gstate:=gsNormal;//toggle
      end;
{$endif}
   if (x='i') and canmen then showmenu;
   if (x='x') and canclo then
      begin
      if (gui.host=application.mainform) then siCloseprompt(gui)//26aug2021
      else if zzok(gui.host,7197) then gui.host.visible:=false;
      end;
   end
else
   begin
//   if      (x='-') then application.minimize//03DEC2010
//   else if (x='n') then a.windowstate:=wsNormal
//   else if (x='+') then
//      begin
//      if (a.windowstate=wsNormal) then a.windowstate:=wsMaximized else a.windowstate:=wsNormal;
//      end
   if (x='i') and canmen then showmenu;
   if (x='x') and canclo then a.visible:=false;
   end;
//sync
ibutenb[vmin]:=(gui.host.windowstate<>wsMinimized);
buttep[vmax]:=low__aorb(tepNormal,tepMaximise,gui.gstate<>gsMax);//14mar2021
except;end;
end;
//## showmenuFill ##
procedure tbasichead.showmenuFill(xstyle:string;xmenudata:tstr8;var ximagealign:longint;var xmenuname:string);
var
   bol1:boolean;
begin
try
//check
if zznil(xmenudata,2318) then exit;
xmenuname:='head.1';
//checkers
scheck(programname,programname_check);
scheck(programwebname,programwebname_check);
scheck(programversion,programversion_check);

//get
low__menutitle(xmenudata,tepnone,protect_text(16771544,'Visit Blaiz Enterprises'),'');
low__menuitem2(xmenudata,tepBE20,programname+' Website','Visit '+programname+' Website','nprogram',100,aknone,true);
low__menuitem2(xmenudata,tepBE20,protect_text(16771815,'Portal - www.BlaizEnterprises.com'),'Visit Blaiz Enterprises'' Portal Website','be',100,aknone,true);
//low__menuitem2(xmenudata,tepBE20,protect_text(16771088,'Software Collection'),'Visit Blaiz Enterprises'' Software Collection','software',100,aknone,true);
//low__menuitem2(xmenudata,tepBE20,protect_text(16771434,'Vintage Software Collection'),'Visit Blaiz Enterprises'' Vintage Software Collection','vintage',100,aknone,true);

//-- Disable Social Media links as of 25feb2021 --------------------------------
//was: low__menuitem2(m,tepBE20,'Instagram','Visit Blaiz Enterprises on Instagram','instagram',100,aknone,true);
//was: low__menuitem2(m,tepBE20,'Facebook','Visit Blaiz Enterprises on Facebook','facebook',100,aknone,true);
//was: low__menuitem2(m,tepBE20,'Twitter','Visit Blaiz Enterprises on Twitter','twitter',100,aknone,true);

low__menutitle(xmenudata,tepnone,'Settings and Information','');
low__menuitem2(xmenudata,tep__yes(viOntop),protect_text(16770953,'On Top'),'Toggle On Top','toggle.ontop',100,aknone,true);
low__menuitem2(xmenudata,tep__yes(viTouch),protect_text(16771309,'Touch'),'Toggle Touch','toggle.touch',100,aknone,true);
low__menuitem2(xmenudata,tepOptions20,protect_text(16770856,'Options'),'Show Options window','options',100,aknone,true);
if mm_ok or mid_ok or wav_ok then low__menuitem2(xmenudata,tepVol20,'Mixer','Show Mixer','mixer',100,aknone,low__canshowvol);

low__menuitem2(xmenudata,tepHelp20,protect_text(16771312,'Help'),'Show / Hide Built-in Help','help',100,aknone,true);//24jul2021
low__menuitem2(xmenudata,tepAbout20,protect_text(16770837,'About'),'Show About window','about',100,aknone,true);
low__menuitem2(xmenudata,tepRefresh20,protect_text(16771388,'Restore Default Zoom...'),'Restore default zoom','defaultzoom',100,aknone,vizoom__root<>0);
low__menuitem2(xmenudata,tepRefresh20,protect_text(16771396,'Restore Defaults...'),'Restore default settings','defaults',100,aknone,true);

//.position
bol1:=gui.canposition;
low__menutitle(xmenudata,tepnone,'Position','Position program on screen');
low__menuitem2(xmenudata,tepTop20,'Top of Screen','Position at top of screen','position.t',100,aknone,bol1);
low__menuitem2(xmenudata,tepLeft20,'Left of Screen','Position at left of screen','position.l',100,aknone,bol1);
low__menuitem2(xmenudata,tepRight20,'Right of Screen','Position at right of screen','position.r',100,aknone,bol1);
low__menuitem2(xmenudata,tepBottom20,'Bottom of Screen','Position at bottom of screen','position.b',100,aknone,bol1);
//was: low__menuitem2(xmenudata,tep__yes(vilockposition),'Lock Position',protect_text(16773065,'Ticked: Lock main window in place - disallow resize, disallow move | Not Ticked: Allow main window to resize and move'),'position.lt',100,aknone,bol1);

if canmax or cannor or canmin or canclo then
   begin
   low__menutitle(xmenudata,tepnone,'Window','Window options');
   case canmax and (gui.gstate<>gsmax) of
   true:low__menuitem2(xmenudata,tepmax,'Maximise','Maximise window','win.max',100,aknone,canmax and (gui.gstate<>gsmax));
   false:if cannor and (gui.gstate<>gsnormal) then low__menuitem2(xmenudata,tepnor,'Normalise','Normalise window','win.nor',100,aknone,cannor and (gui.gstate<>gsnormal));
   end;
   low__menuitem2(xmenudata,tepmin,'Minimise','Minimise window','win.min',100,aknone,canmin and (gui.gstate<>gsmin));
   low__menuitem2(xmenudata,tepclo,'Close','Close program','win.clo',100,aknone,canclo);
   end;

//.additional
low__menutitle(xmenudata,tepnone,protect_text(16771160,'Additional'),'');
if (programnewinstance<>0) then low__menuitem2(xmenudata,tepexe20,protect_text(16771177,'New Program Instance'),'Launch new instance of '+programname,'newinstance',100,aknone,true);
low__menuitem2(xmenudata,tepFolder20,protect_text(16771208,'Show Program Folder'),'Show Program Folder for '+programname,'folder',100,aknone,true);
except;end;
end;
//## showmenuClick ##
function tbasichead.showmenuClick(sender:tobject;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean;
begin
try
//handled
result:=true;

//information
if (xcode2='about') then gui.xshowabout
else if (xcode2='toggle.ontop') then
   begin
   syssettings.b['ontop']:=not syssettings.b['ontop'];
   viSyncandsave;
   end
else if (xcode2='toggle.touch') then//27mar2022
   begin
   syssettings.b['touch']:=not syssettings.b['touch'];
   viSyncandsave;
   end
else if (xcode2='options') then gui.xshowoptions
else if (xcode2='mixer') then low__showvol//06nov2022
else if (xcode2='help') then gui.xshowhelp
else if (xcode2='defaultzoom') then gui.xdefaultzoom
else if (xcode2='defaults') then gui.xdefaults
//visit blaiz enterprises
else if (xcode2='be') then low__plat('portal','',true)
else if (xcode2='vintage') then low__plat('vintage','',true)
else if (xcode2='software') then low__plat('software','',true)
else if (xcode2='nprogram') then low__plat('nprogram','',true)//new program
else if (xcode2='vprogram') then low__plat('vprogram','',true)//vintage program
else if (xcode2='instagram') then low__plat('instagram','',true)
else if (xcode2='facebook') then low__plat('facebook','',true)
else if (xcode2='twitter') then low__plat('twitter','',true)
//position
else if low__comparetext(strcopy1(xcode2,1,9),'position.') then gui.position(xcode2)//27feb2022
//window - 06nov2022
else if (xcode2='win.max') then xcmd('+')
else if (xcode2='win.nor') then xcmd('n')
else if (xcode2='win.min') then xcmd('-')
else if (xcode2='win.clo') then xcmd('x')
//additional
else if (xcode2='newinstance') then low__plat('newinstance','',true)
else if (xcode2='folder') then low__plat('showroot','',true)
//not handled
else result:=false;
except;end;
end;
//## xok ##
function tbasichead.xok(xindex:longint):boolean;
begin
try;result:=(xindex>=0) and (xindex<=high(ibuttep));except;end;
end;
//## setbuttep ##
procedure tbasichead.setbuttep(xindex:longint;xtep:longint);
begin
try;if xok(xindex) and (xtep<>ibuttep[xindex]) then ibuttep[xindex]:=xtep;except;end;
end;
//## getbuttep ##
function tbasichead.getbuttep(xindex:longint):longint;
begin
try;result:=tepnone;if xok(xindex) then result:=ibuttep[xindex];except;end;
end;
//## getbuthlp ##
function tbasichead.getbuthlp(xindex:longint):string;
begin
try
result:='';
if xok(xindex) then result:=ibuthlp[xindex];
except;end;
end;

//## tbasicscrollbar ###########################################################
//## create2 ##
constructor tbasicscrollbar.create2(xparent:tobject;xstart:boolean);
var
   int1,int2,p:longint;
   e:string;
begin
//self
satinc(satToolbar,1);
inherited create2(xparent,false);
//options
overtical:=true;
owheelchange:=1;
osmallchange:=1;
olargechange:=10;
oassistedscroll:=10;
ofullhandling:=true;
//vars
inormal:=true;
ipos:=0;
imin:=0;
imax:=0;
idownpos:=0;
idownbutindex:=-1;//off
iscrollscope:=0;
ibordersize:=1;
idowntime64:=0;//off
itimer100:=ms64;
itimerscroll:=ms64;
ilessbut:=rect(0,0,-1,-1);
imorebut:=rect(0,0,-1,-1);
idragbut:=rect(0,0,-1,-1);
idragzone:=rect(0,0,-1,-1);
idragbutdown:=false;//09feb2022
fonpos:=nil;
fonarrow:=nil;
//controls
clientheight:=5;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasicscrollbar.destroy;
begin
try
//disconnect timer
timer:=false;
//disconnect events
fonpos:=nil;
//self
inherited destroy;
satinc(satToolbar,-1);
except;end;
end;
//## minimal ##
function tbasicscrollbar.minimal:boolean;
begin
try;result:=ominimal or viminimal__scrollbar;except;end;
end;
//## makeMinimal ##
procedure tbasicscrollbar.makeMinimal;
begin
try;ominimal:=true;except;end;
end;
//## setpos ##
procedure tbasicscrollbar.setpos(x:longint);
begin
try;setparams(x,imin,imax);except;end;
end;
//## setparams ##
procedure tbasicscrollbar.setparams(xpos,xmin,xmax:longint);
begin
try;setparams2(xpos,xmin,xmax,true);except;end;
end;
//## setparams2 ##
procedure tbasicscrollbar.setparams2(xpos,xmin,xmax:longint;xevent:boolean);
begin//Note: paint handled via "ontimer()" proc
try
//range
xmax:=frcmin(xmax,xmin);
xpos:=frcrange(xpos,xmin,xmax);
//get
if (xpos<>ipos) or (xmin<>imin) or (xmax<>imax) then
   begin
   ipos:=xpos;
   imin:=xmin;
   imax:=xmax;
   iposref64:=ms64+2000;//faster tracking - 08feb2022
   xfaster;
   if xevent and assigned(fonpos) then fonpos(self);
   end;
except;end;
end;
//## _ontimer ##
procedure tbasicscrollbar._ontimer(sender:tobject);
var
   xmustpaint:boolean;
   xdir,xlimit,int1:longint;
   str1:string;
   bol1:boolean;
   cur1:currency;
begin
try
//defaults
xmustpaint:=false;

//.itimer100
if (ms64>itimer100) then
   begin
   //control info
   if low__setstr(iinforef,bnc(minimal)+bnc(gui.hoverindex=icoreindex)+bnc(overtical)+bnc(inormal)+pcRefsep+inttostr(findbordersize)+pcRefsep+inttostr(ipos)+pcRefsep+inttostr(imin)+pcRefsep+inttostr(imax)+pcRefsep+inttostr(viscrollsize)) then xmustpaint:=true;
   //reset
   itimer100:=ms64+low__aorb(100,10,iposref64>=ms64);//08feb2022
   end;

//.itimerscroll
if (ms64>itimerscroll) then
   begin
   //slow
   int1:=250;
   //get
   if gui.mousedown and (ms64>=idowntime64) then
      begin
      case idownbutindex of
      0:pos:=pos+xmoveval(-osmallchange);//less
      1:pos:=pos+xmoveval(osmallchange);//more
      end;//case
      //variable autoscroll speed
      xlimit:=20000;
      cur1:=frcrange64(low__sub64(ms64,idowntime64),0,xlimit);
      int1:=10+round(160*(1-(cur1/xlimit)));
      end;
   //reset
   itimerscroll:=ms64+int1;
   end;

//wound scroller - 28sep2022
if (oassistedscroll<>0) and xwound_mustpaint(pos,oassistedscroll,int1,xdir) then
   begin
   if (int1<>pos) then pos:=int1;
   xwound_autooff(pos,xdir,min,max);
   end;
   
//paint
if xmustpaint then paintnow;
except;end;
end;
//## getalignheight ##
function tbasicscrollbar.getalignheight(xclientwidth:longint):longint;
begin
try
case overtical of
true:result:=clientheight;
false:result:=frcmin((2*findbordersize)+low__instouch(viscrollsize,low__touchsmall),0);
end;
result:=frcmin(result,ominheight);//25jul2021
except;end;
end;
//## getalignwidth ##
function tbasicscrollbar.getalignwidth(xclientheight:longint):longint;
begin
try
case overtical of
true:result:=frcmin((2*findbordersize)+low__instouch(viscrollsize,low__touchsmall),0);
false:result:=clientwidth;
end;
result:=frcmin(result,ominwidth);//25jul2021
except;end;
end;
//## xmoveval ##
function tbasicscrollbar.xmoveval(x:longint):longint;
begin
try
result:=x;
if assigned(fonarrow) then fonarrow(self,result);
except;end;
end;
//## _onnotify ##
function tbasicscrollbar._onnotify(sender:tobject):boolean;
var
   int1,dx,dy:longint;
   xminimal:boolean;
begin
try
//defaults
result:=ofullhandling;//not handled
xminimal:=false;//was: minimal;//08feb2022

//wheel
if ofullhandling and (gui.wheel<>0) then
   begin
   if enabled then
      begin
      pos:=pos-(gui.wheel*owheelchange);
      xwound_wheel(gui.wheel*70);
      end;
   end;

//key
if ofullhandling and (gui.key<>aknone) then
   begin
   case gui.key of
   akhome:begin
      if enabled then pos:=imin;
      result:=true;
      end;
   akend:begin
      if enabled then pos:=imax;
      result:=true;
      end;
   akleft,akup:begin
      if enabled then pos:=pos+xmoveval(-1);
      result:=true;
      end;
   akright,akdown:begin
      if enabled then pos:=pos+xmoveval(1);
      result:=true;
      end;
   akprev:begin
      if enabled then pos:=pos+xmoveval(-olargechange);
      result:=true;
      end;
   aknext:begin
      if enabled then pos:=pos+xmoveval(olargechange);
      result:=true;
      end;
   end;//case
   end;

//mousedownstroke
if gui.mousedownstroke then
   begin
   idowntime64:=ms64+500;
   idownpos:=pos;
   dx:=mousex;
   dy:=mousey;
   idragbutdown:=low__xyinarea(dx,dy,idragbut);
   if      (not xminimal) and low__xyinarea(dx,dy,ilessbut)  then idownbutindex:=0//less
   else if (not xminimal) and low__xyinarea(dx,dy,imorebut)  then idownbutindex:=1//more
   else if low__xyinarea(dx,dy,idragzone) then idownbutindex:=2//drag
   else                                        idownbutindex:=-1;//off
   end;

//mouse down
if gui.mousedown then
   begin
   result:=true;
   end;

//mouse move
if gui.mousedown and gui.mousemoved and (not gui.mousedownstroke) then
   begin
//dbstatus(3,'Scrollbar>'+bnc(enabled)+bnc(iscrollscope>=1)+bnc(idownbutindex=2)+bnc(gui.mouseleft)+'>'+inttostr(mousex)+'x'+inttostr(mousey)+'>>'+low__rectstr(idragzone)+'<<'+inttostr(low__getcursorposb.x)+'x'+inttostr(low__getcursorposb.y)+'__'+inttostr(gui.clienttoscreen(point(0,0)).x)+'x'+inttostr(gui.clienttoscreen(point(0,0)).y)+'<<<'+ms64str);//xxxxxxxxxxxxxxxxxx
   result:=true;
   if enabled and (iscrollscope>=1) and (idownbutindex=2) and gui.mouseleft then
      begin
      if overtical then int1:=gui.mousemovexy.y-gui.mousedownxy.y else int1:=gui.mousemovexy.x-gui.mousedownxy.x;
      case xminimal of
      false:pos:=round(idownpos+((int1)*iscrollscope));//normal
      true:begin
         case idragbutdown of
         true:pos:=round(idownpos+((int1)*iscrollscope));//normal
         false:pos:=round(idownpos+(-(int1)*iscrollscope));//special: drag in the direction of touch movement - 09feb2022
         end;
         end;
      end;//case
      end;
   end;

//mouse up - wound support - 04oct2022
if gui.mouseupstroke and gui.mousedragging and gui.mouseleft then xwound_mousevert3(3000,true,true,overtical);

//mouse up
if gui.mouseupstroke then
   begin
   result:=true;
   idowntime64:=0;
   if enabled and (not gui.mousedragging) and gui.mouseleft then
      begin
      case idownbutindex of
      0:pos:=pos+xmoveval(-osmallchange);//less
      1:pos:=pos+xmoveval(osmallchange);//more
      end;//case
      end;
   idownbutindex:=-1;//off
   end;

//external event override - 01mar2021
if assigned(fonnotify) then fonnotify(sender);
except;end;
end;
//## _onpaint ##
procedure tbasicscrollbar._onpaint(sender:tobject);
label
   dovertical,dohorizontal,done;
const
   xmindrag=24;
var
   //infovars
   a:pvirtualinfo;
   cs,ci:trect;
   fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xborder2,xhover,xfontheight,xfeather,xbordersize:longint;
   xenabled,xround,xnormal:boolean;
   //other
   str1,str2,e:string;
   dw,dh,pad1,xzoom,xframe,xback2,p,int1,int2,int3,int4,int5,dx,dy,xw,xh,xpos,xmin,xmax,xindex,xcount:longint;
   xminimal,xtransparent,xsyscolors,xenhanced,xhoverok,xtouch,xvertical:boolean;
begin
try
//init
xminimal:=minimal;//08feb2022
xenhanced:=vienhanced;
xzoom:=vizoom;
pad1:=5*xzoom;
infovars(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);
xpos:=ipos;
xmin:=imin;
xmax:=imax;
xcount:=xmax-xmin+1;//1..N
xindex:=xpos-xmin+1;//1..N
xenabled:=xenabled and (xmax>xmin);//adjust value
xtouch:=vitouch;
xvertical:=overtical;
dw:=(cs.right-cs.left+1)-(2*xbordersize);
dh:=(cs.bottom-cs.top+1)-(2*xbordersize);

//.redefine
xfont:=low__aorb(a.disablefont,a.font,xenabled);
case xminimal of
false:xback:=low__aorb(a.disable,a.background,xenabled);
true:xback:=a.background;
end;
xback2:=low__dc(xback,low__aorb(-5,-30,xenabled));
xhoverok:=xenabled and (gui.hoverindex=icoreindex);
xborder2:=xborder;
if xhoverok then xborder2:=xhover;
xframe:=low__aorb(xback2,xhover,xhoverok);
//cls
lds(cs,xback,xround);

//decide
if xvertical then goto dovertical else goto dohorizontal;

//-- vertical ------------------------------------------------------------------
dovertical:
//.up
if xminimal then
   begin
   ilessbut:=rect(0,0,cw-1,0);
   imorebut:=rect(0,ch-1,cw-1,ch-1);
   idragzone:=rect(ilessbut.left,ilessbut.bottom+1,ilessbut.right,imorebut.top);//11oct2020
   end
else
   begin
   xh:=0;
   tepinfosys(tepUp,xw,xh,xtransparent,xsyscolors);
   int1:=xbordersize+pad1+xh+pad1;
   int2:=frcmin(low__instouch(int1,low__touchsmall),1);
   dx:=(cw-xw) div 2;
   dy:=xbordersize+pad1+((int2-int1) div 2);
   if (not xminimal) and ((int1*2)<=dh) then ldis(ci,dx,dy,xfont,tepUp,false,false,xround);
   ilessbut:=rect(0,0,cw-1,int2);
   //.down
   xh:=0;
   tepinfosys(tepDown,xw,xh,xtransparent,xsyscolors);
   int1:=xbordersize+pad1+xh+pad1;
   int2:=frcmin(low__instouch(int1,low__touchsmall),1);
   dx:=(cw-xw) div 2;
   dy:=(ch-1)-(xh-1)-pad1-xbordersize-((int2-int1) div 2);
   if (not xminimal) and ((int1*2)<=dh) then ldis(ci,dx,dy,xfont,tepDown,false,false,xround);
   imorebut:=rect(0,ch-1-int2,cw-1,ch-1);
   //.inner frame
   ldso(rect(ilessbut.left+xbordersize,ilessbut.bottom,ilessbut.right-xbordersize,imorebut.top),xframe,clnone,xround);
   //.drag
   idragzone:=rect(ilessbut.left+xbordersize,ilessbut.bottom+1,ilessbut.right-xbordersize,imorebut.top);//11oct2020
   end;
//.iscrollscope
int4:=frcmin(imax-imin+1,1);//count
int1:=frcmin(idragzone.bottom-idragzone.top+1,0);
int2:=frcmin(int1-int4,low__instouch(xmindrag,low__touchsmall));
int3:=frcmin(int1-int2,0);
int5:=frcmin(int1-int2,0);
if (int5<=0) then iscrollscope:=0 else iscrollscope:=int4/int5;
if (int3>=1) then
   begin
   p:=round(((pos-imin)/int4)*int3);
   idragbut:=rect(idragzone.left,idragzone.top+p,idragzone.right,idragzone.top+int2-1+p);
   case xminimal of
   false:ldso(idragbut,low__aorb(xback2,xhover,xhoverok),low__aorb(clnone,xhover,xhoverok),xround);
//was:   true:ldso(idragbut,low__aorb(clnone,xhover,xhoverok),low__aorb(xback2,xhover,xhoverok),xround);
   true:ldso(idragbut,low__aorb(xback2,xhover,xhoverok),low__aorb(clnone,xhover,xhoverok),xround);
   end;//case
   end
else idragbut:=rect(0,0,-1,-1);
goto done;

//-- horizontal ----------------------------------------------------------------
dohorizontal:
if xminimal then
   begin
   ilessbut:=rect(0,0,0,ch-1);
   imorebut:=rect(cw-1,0,cw-1,ch-1);
   idragzone:=rect(ilessbut.right+1,ilessbut.top,imorebut.left,ilessbut.bottom);//17mar2021, 11oct2020
   end
else
   begin
   //.left
   xw:=0;
   tepinfosys(tepLeft,xw,xh,xtransparent,xsyscolors);
   int1:=xbordersize+pad1+xw+pad1;
   int2:=frcmin(low__instouch(int1,low__touchsmall),1);
   dx:=xbordersize+pad1+((int2-int1) div 2);
   dy:=(ch-xh) div 2;
   if (not xminimal) and ((int1*2)<=dw) then ldis(ci,dx,dy,xfont,tepLeft,false,false,xround);
   ilessbut:=rect(0,0,int2,ch-1);
   //.right
   xw:=0;
   tepinfosys(tepRight,xw,xh,xtransparent,xsyscolors);
   int1:=xbordersize+pad1+xw+pad1;
   int2:=frcmin(low__instouch(int1,low__touchsmall),1);
   dx:=(cw-1)-(xw-1)-pad1-xbordersize-((int2-int1) div 2);
   dy:=(ch-xh) div 2;
   if (not xminimal) and ((int1*2)<=dw) then ldis(ci,dx,dy,xfont,tepRight,false,false,xround);
   imorebut:=rect(cw-1-int2,0,cw-1,ch-1);
   //.inner frame
   ldso(rect(ilessbut.right,ilessbut.top+xbordersize,imorebut.left,ilessbut.bottom-xbordersize),xframe,clnone,xround);
   //.drag
   idragzone:=rect(ilessbut.right+1,ilessbut.top+xbordersize,imorebut.left,ilessbut.bottom-xbordersize);//17mar2021, 11oct2020
   end;
//.iscrollscope
int4:=frcmin(imax-imin+1,1);//count
int1:=frcmin(idragzone.right-idragzone.left+1,0);
int2:=frcmin(int1-int4,low__instouch(xmindrag,low__touchsmall));
int3:=frcmin(int1-int2,0);
int5:=frcmin(int1-int2,0);
if (int5<=0) then iscrollscope:=0 else iscrollscope:=int4/int5;
if (int3>=1) then
   begin
   p:=round(((pos-imin)/int4)*int3);
   idragbut:=rect(idragzone.left+p,idragzone.top,idragzone.left+int2-1+p,idragzone.bottom);
   case xminimal of
   false:ldso(idragbut,low__aorb(xback2,xhover,xhoverok),low__aorb(clnone,xhover,xhoverok),xround);
//was:   true:ldso(idragbut,low__aorb(clnone,xhover,xhoverok),low__aorb(xback2,xhover,xhoverok),xround);
   true:ldso(idragbut,low__aorb(xback2,xhover,xhoverok),low__aorb(clnone,xhover,xhoverok),xround);
   end;//case
   end
else idragbut:=rect(0,0,-1,-1);
goto done;

//-- done ----------------------------------------------------------------------
done:
//frame
//was: if (xbordersize>=1) then ldf(cs,xborder,xback,xbordersize,xround);
if (xbordersize>=1) and (not xminimal) then ldf(cs,xborder,low__dc(xback,-20),xbordersize,nil,xround);
//was: xparentcorners;//not required for a round control
except;end;
end;

//## tbasicsplash ##############################################################
//## splash__findvalue ##
function splash__findvalue(x:longint;xreverse,xsep:boolean;var xvalue:string):boolean;
var
   b:tstr8;
   str2:string;
   xcount:longint;
   //## xadd ##
   procedure xadd(x:array of byte);
   begin
   if (b=nil) then b:=bnew;
   b.clear;
   b.aadd(x);
   low__cdmix(b);
   xvalue:=xvalue+b.text;
   end;
   //## sadd ##
   procedure sadd(x:string;xcheckval:longint);
   begin
   scheck(x,xcheckval);
   xvalue:=xvalue+x;
   end;
   //## sadd2 ##
   procedure sadd2(x:string);
   begin
   xvalue:=xvalue+x;
   end;
   //## saddVer ##
   procedure saddVer;
   begin
   try
   xadd([20,0,0,0,159,214,17,48,48,177,74,58,74,15,121,35,234,93,197,240,107,83,233,140,48,71,183,18,133,78,215,44,29,62,118,44,168,84,41,5,195,210,122,218,56,50,246,255]);
   //.actual program version - 05oct2020
   scheck(programversion,programversion_check);
   sadd2(programversion);
   if xsep then sadd2(programsplash_scrollsep);
   except;end;
   end;
   //## saddEdition ##
   procedure saddEdition;
   begin
   try
   //'Edition: ' - 27jun2022
   xadd([60,0,0,0,156,85,14,56,176,109,170,228,156,80,164,186,67,238,97,85,154,150,132,247,115,35,247,6,109,106,91,32,97,233,40,176,32,18,142,87,92,124,118,2,168,86,145,125,171,191,221,47,126,211,250,99,115,198,108,149,141,55,244,12,163,177,159,39,208,89,188,55,59,87,14,117,174,227,115,181,56,228,5,178,19,58,153,35,210,48,57,223,71,103,42,140,50,124,239,0,4,51,56,205,15,57,94,244,236,170,191,196,20,146,166,46,163,158,115,47,57,101,201,246,210,111,246,255]);
   case programplus of
   //.Enhanced Plus Multi-Panel
   //was: true:xadd([72,0,0,0,226,161,243,14,102,31,162,241,205,18,90,151,46,11,232,93,82,209,165,46,13,66,187,81,55,40,2,6,174,84,142,72,108,23,202,142,32,197,142,66,66,249,25,58,108,213,214,88,108,252,32,21,75,246,66,246,235,6,11,239,27,124,45,110,232,231,27,224,37,197,161,61,69,204,192,63,7,238,238,10,154,102,12,253,180,134,253,243,38,191,21,45,83,201,82,189,206,111,206,51,53,117,79,158,34,170,163,212,64,207,199,140,121,74,182,45,35,179,139,28,254,57,206,209,144,22,176,107,147,126,232,181,240,203,205,187,193,1,31,225,223,185,98,144,114,206,183,255]);

   //.Plus Multi-Panel
   true:xadd([27,0,0,0,159,214,17,48,48,177,74,58,81,15,121,35,234,93,197,240,107,83,233,140,48,71,183,12,133,78,215,94,29,62,118,227,134,84,41,12,198,222,248,33,174,38,210,227,58,73,197,22,194,122,125,1,46,226,160,234,143,255]);

   //.Standard
   false:xadd([19,0,0,0,159,214,17,48,48,177,74,58,89,15,121,35,234,93,197,240,107,83,233,135,48,71,183,15,133,78,215,86,29,62,118,39,154,84,41,9,178,210,167,64,240,255]);
   //was: Standard Single Panel
   //was: false:xadd([47,0,0,0,218,171,175,83,137,204,1,160,98,97,77,9,103,162,13,253,242,152,3,162,205,138,180,84,59,166,3,127,41,251,132,153,249,109,92,71,195,64,64,221,130,190,86,184,95,188,218,42,232,223,236,252,170,221,0,213,91,56,23,136,236,86,171,239,181,16,71,81,191,204,188,84,26,100,111,115,228,5,240,154,225,2,134,255,105,86,170,120,241,226,200,219,17,128,3,107,229,255]);
   end;
   if xsep then sadd2(programsplash_scrollsep);
   except;end;
   end;
   //## saddMode ##
   procedure saddMode;
   begin
   try
   //'Mode: ' - 30mar2022
   xadd([53,0,0,0,37,111,182,135,214,101,92,41,151,10,23,78,144,184,133,221,116,71,242,48,75,95,155,51,136,113,201,170,168,13,192,30,237,214,181,12,112,124,194,114,7,32,59,175,186,254,58,202,112,35,27,208,105,150,22,239,172,22,152,90,243,204,10,181,159,11,250,199,60,144,228,215,216,63,197,115,32,114,121,11,131,157,10,238,38,12,142,128,93,133,191,115,110,156,102,106,174,213,51,22,52,218,100,67,161,234,92,4,224,255]);//'Type: '
   case system_storeapp of
   true:xadd([28,0,0,0,159,214,17,48,48,177,74,58,78,15,121,35,234,93,197,240,107,83,233,125,48,71,183,19,133,78,215,18,29,62,118,50,176,84,41,10,191,222,248,5,7,38,210,4,92,73,197,26,149,122,125,253,13,226,210,185,248,56,164,255]);//Windows Store App
//was:   [53,0,0,0,14,119,43,220,214,166,98,231,215,81,43,167,214,101,144,222,104,193,92,112,39,137,221,29,63,30,231,121,103,26,71,196,222,158,232,37,51,66,8,42,248,53,242,178,28,200,31,229,241,72,209,143,76,227,165,91,117,84,12,238,73,231,240,2,96,182,56,134,51,237,52,240,135,30,200,114,45,171,166,30,107,181,135,115,247,9,18,222,133,104,131,145,250,222,96,218,155,73,36,76,189,178,140,69,103,72,148,228,248,255]);//Store App
   false:xadd([49,0,0,0,53,229,146,110,86,19,85,182,29,82,246,133,235,84,180,225,69,228,126,146,172,133,212,45,40,226,41,186,186,117,183,97,126,159,141,149,146,225,194,211,250,74,183,24,38,38,96,171,55,144,141,134,110,205,240,84,145,50,121,81,125,225,208,253,250,226,220,248,126,222,56,106,79,230,48,93,231,188,175,202,12,227,63,152,63,147,11,188,250,99,204,249,146,111,228,113,65,89,55,28,187,255]);//Desktop Application
   end;
   if xsep then sadd2(programsplash_scrollsep);
   except;end;
   end;
   //## saddCodeFoundation ##
   procedure saddCodeFoundation;//11oct2022, 17sep2022, 19mar2022
   begin
   try
   xadd([67,0,0,0,32,139,185,78,174,120,187,101,4,163,31,36,130,130,65,125,190,59,34,84,24,76,52,204,151,250,247,183,149,59,206,65,199,181,241,232,48,51,142,208,41,254,227,3,217,91,116,152,157,107,43,8,122,195,253,58,247,254,102,158,29,31,27,49,156,50,179,71,215,93,238,148,202,54,111,146,6,54,159,163,0,244,5,188,151,155,57,211,120,49,254,1,166,48,127,116,29,8,35,58,80,146,40,93,237,176,128,75,164,27,186,192,186,237,212,212,139,86,195,20,120,120,54,63,42,170,145,17,211,167,184,245,63,14,82,196,151,255]);//'Code Foundation: '
   xadd([36,0,0,0,159,214,17,48,48,177,74,58,89,15,121,35,234,93,197,240,107,83,233,57,48,71,183,240,133,78,215,87,29,62,118,10,158,84,41,186,185,222,248,157,166,38,210,9,83,2,197,36,227,122,125,220,189,226,210,222,163,5,35,132,5,151,127,85,155,5,36,72,221,73,197,44,8,71,221,255]);//4th Generation (Gossamer)
   xvalue:=strcopy1(xvalue,1,length(xvalue)-1)+#32+low__verstr+strcopy1(xvalue,length(xvalue),1);
//was:  xadd([36,0,0,0,159,214,17,48,48,177,74,58,84,15,121,35,234,93,197,240,107,83,233,140,48,71,183,3,133,78,215,100,29,62,118,36,166,84,41,168,196,222,248,157,109,38,210,201,94,2,197,29,149,122,125,3,250,226,210,5,153,5,35,131,252,151,127,104,151,5,36,82,217,73,197,218,130,192,195,255]);//'Gossamer (4th Generation)'
//was:  xadd([43,0,0,0,135,225,221,94,97,135,164,50,198,248,163,234,159,100,71,98,233,82,81,157,230,237,139,60,184,0,239,16,116,149,39,231,108,108,183,20,90,184,18,49,149,155,50,64,191,139,245,17,44,254,30,99,45,218,159,161,101,93,252,165,252,207,70,125,182,220,24,151,13,124,166,59,224,47,96,30,124,227,240,125,115,125,218,114,240,240,188,246,143,255]);//'4th Generation'
   if xsep then sadd2(programsplash_scrollsep);
   except;end;
   end;
   //## saddLicense ##
   procedure saddLicense;
   begin
   try
   xadd([20,0,0,0,159,214,17,48,48,177,74,58,78,15,121,35,234,93,197,240,107,83,233,126,48,71,183,8,133,78,215,44,29,62,118,49,172,84,41,252,180,210,122,218,92,186,147,255]);
   case system_paid of
   true:sadd('Paid',16771269);//check the value has not been tampered with
   false:sadd('Free to use',16771285);//was: sadd('Free To Use',16771301);//check the value has not been tampered with
   end;
   if xsep then sadd2(programsplash_scrollsep);
   except;end;
   end;
   //## saddCopyright ##
   procedure saddCopyright;
   begin
   try
   //'Copyright (c) 1997-'
   xadd([65,0,0,0,111,124,139,119,184,130,24,229,49,93,206,50,36,27,19,229,32,145,252,115,122,140,108,90,111,200,148,179,143,229,77,145,16,196,229,191,62,102,71,120,18,235,65,148,158,169,254,14,177,110,102,89,185,140,224,81,123,132,181,21,203,65,44,171,166,46,210,239,80,155,93,201,103,39,34,220,204,227,14,217,31,9,131,121,75,228,189,148,152,240,234,96,221,244,144,235,246,126,218,249,59,84,75,65,168,37,157,243,83,247,97,104,234,1,22,124,13,205,214,175,220,104,5,140,13,101,93,64,147,187,151,45,233,255]);
   sadd2(low__yearstr(2020));
   //=' Blaiz Enterprises  All Rights Reserved'
   xadd([50,0,0,0,159,214,17,48,48,177,74,58,39,15,121,35,234,93,197,240,107,83,233,122,48,71,183,220,133,78,215,55,29,62,118,44,179,84,41,103,189,222,248,198,185,38,210,250,92,2,197,37,231,122,180,37,8,226,210,252,167,5,35,49,183,36,127,53,26,5,151,79,139,73,243,40,236,165,196,12,237,125,142,154,160,52,21,230,238,151,197,59,51,164,254,170,171,62,172,60,131,75,173,83,209,126,156,255]);
   if xsep then sadd2(programsplash_scrollsep);
   except;end;
   end;
   //## saddInternet ##
   procedure saddInternet;
   var
      str2:string;
   begin
   try
   //was: 0=Internet:
   //was: xadd([21,0,0,0,159,214,17,48,48,177,74,58,83,15,121,35,234,93,197,240,107,83,233,126,48,71,183,5,133,78,215,102,29,62,118,53,167,84,41,252,197,210,122,244,101,38,61,139,182,255]);
   //0=Internet Portal:
   xadd([28,0,0,0,159,214,17,48,48,177,74,58,83,15,121,35,234,93,197,240,107,83,233,126,48,71,183,5,133,78,215,102,29,62,118,53,167,84,41,252,197,222,248,207,183,38,210,4,92,73,197,41,214,122,125,40,218,226,210,149,26,215,223,255]);
   str2:=low__plat('portal','',false);
   if low__comparetext(strcopy1(str2,1,7),'http://') then strdel1(str2,1,7);
   xvalue:=xvalue+str2;//27mar2022
   except;end;
   end;
begin
try
//defaults
result:=false;
b:=nil;
str2:='';
xvalue:='';
xcount:=7;
//init
if xreverse then x:=(xcount-1)-x;
//get
result:=true;
case x of
0:saddVer;
1:saddLicense;
2:saddMode;
3:saddEdition;//27jun2022
4:saddCodeFoundation;
5:saddCopyright;
6:saddInternet;
else result:=false;
end;//case


except;end;
try;bfree(b);except;end;
end;

//## create ##
constructor tbasicsplash.create(xparent:tobject);
begin
create2(xparent,true);
end;
//## create ##
constructor tbasicsplash.create2(xparent:tobject;xstart:boolean);
var
   e:string;
begin
//self
satinc(satSplash,1);
inherited create2(xparent,false,false);
//vars
iiconartref:='';
ilastframecol2:=0;
ilastframeid:=-1;
ishowstyle:=0;//splash
idelaytimer:=0;
ostyle:=programsplash_style;
iscrolltext:='';
ipreviousfocus:=-1;//off
ilink:=nilrect;
itimeout:=0;//off
oroundstyle:=corToSquare;
mkescape:=true;
mkreturn:=true;
ocode:=0;//cancelled
ocode2:='';
otepcolor:=clnone;
bordersize:=0;
winstyle:=wmdialog;
static:=true;
xhead.visible:=false;
xhead.style:=wuClose;
xhead.caption:='About';
xhelp;
xhelp.showhelp:=false;//don't show realtime help
normal:=(ostyle=2);
//.screen -> image viewer
iscreen:=ncontrol;
iscreen.oautoheight:=true;
iscreen.oborderstyle:=bsInternal;//internal bordersize
iscreen.bordersize:=0;
iscreen.normal:=(ostyle=2);
iimage:=misimg24(1,1);
acheck(programsplash,programsplash_check);//check
if (ostyle<>2) then misfromdata(iimage,bcopyarray(programsplash),e);
//controls

//events
iscreen.onnotify:=onnotify__screen;
iscreen.onpaint:=onpaint__screen;

//start
if xstart then start;
end;
//## destroy ##
destructor tbasicsplash.destroy;
begin
try
freeobj(@iimage);
inherited destroy;
satinc(satSplash,-1);
//restore previous focus -> splash only - 05sep2020
if (ipreviousfocus>=0) then
   begin
   gui.winfocus:=ipreviousfocus;
   ipreviousfocus:=-1;
   end;
except;end;
end;
//## winLdrCOLOR ##
function tbasicsplash.winLdrCOLOR:longint;
var
   xminsize,int1:longint;
begin
try
if (ostyle=2) then
   begin
   result:=inherited winLdrCOLOR;
   end
else
   begin
   if low__setint(ilastframeid,viframeID) then low__framecols(programsplash_framecol,programsplash_framecol,programsplash_framecol2,xminsize,int1,ilastframecol2);
   result:=ilastframecol2;
   end;
except;end;
end;
//## _ontimer ##
procedure tbasicsplash._ontimer(sender:tobject);
begin
try
//check
if not visible then exit;
//get
if (ostyle=1) and (ms64>=idelaytimer) then iscreen.paintnow;
except;end;
end;
//## onnotify__screen ##
function tbasicsplash.onnotify__screen(sender:tobject):boolean;
begin
try
//defaults
result:=false;
//mouse up
if gui.mouseupstroke and low__withinrect2(iscreen.mousedownxy,ilink) then
   begin
   result:=true;
   low__plat('portal','',true);
   end;
except;end;
end;
//## onpaint__screen ##
procedure tbasicsplash.onpaint__screen(sender:tobject);
label
   doIconArt,dostatic,doscroll,skipdone;
var
   //infovars
   a:pvirtualinfo;
   b:tstr8;
   cs,ci:trect;
   fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xsep,xaslink,xenabled,xround,xnormal:boolean;
   //other
   sx1,sx2,sy1,sy2,xzoom,fs,fsH,dx,dy,p:longint;
   str1,str2:string;
begin
try
//defaults
b:=nil;
xzoom:=vizoom;
xsep:=false;
sx1:=0;
sx2:=0;
sy1:=0;
sy2:=0;
//init
iscreen.infovars(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);

//IconArt ----------------------------------------------------------------------
if (ostyle=2) then
   begin
   if low__setstr(iiconartref,inttostr(ishowstyle)+'|'+inttostr(iscreen.clientwidth)+'|'+inttostr(iscreen.clientheight)) then
      begin
      case ishowstyle of//0=splash, 1=about
      0:mismakesplashart2432(iimage,xfont,xfont,xborder,xback,low__dc(xback,-30),iscreen.clientwidth,iscreen.clientheight,iscreen.clientwidth,iscreen.clientheight);//0,0,-1,-1);
      1:mismakesplashart2432(iimage,xfont,xfont,clnone,xback,low__dc(xback,-30),iscreen.clientwidth,iscreen.clientheight,iscreen.clientwidth,iscreen.clientheight);
      end;//case
      end;
   iscreen.ldc(ci,ci.left,ci.top,ci.right-ci.left+1,ci.bottom-ci.top+1,misarea(iimage),iimage,255,0,0,0);
   goto skipdone;
   end;

//init
if (programsplash_fontcol<>clnone) then xfont:=programsplash_fontcol;
//draw
if (programsplash_shifstyle=ishowstyle) or (programsplash_shifstyle=2) then
   begin
   sx1:=xzoom*programsplash_shiftx1;
   sx2:=xzoom*programsplash_shiftx2;
   sy1:=xzoom*programsplash_shifty1;
   sy2:=xzoom*programsplash_shifty2;
   end;
iscreen.ldc(ci,ci.left-sx1,ci.top-sy1,ci.right-ci.left+1+(sx1+sx2),ci.bottom-ci.top+1+(sy1+sy2),misarea(iimage),iimage,255,0,0,0);

//special font
fs:=low__font2('','$fontname',8*xzoom,true);
fsH:=low__fontmaxh(fs);
case ostyle of
2:goto skipdone;
1:goto doscroll;
else goto dostatic;
end;

//scrolling overlay of information text ----------------------------------------
doscroll:
xsep:=true;
if (iscrolltext='') then
   begin
   //init
   str1:='';
   //get
   for p:=0 to 99 do if splash__findvalue(p,false,xsep,str2) then str1:=str1+str2 else break;
   //set
   iscrolltext:=str1;
   end;

//draw text
dy:=ci.bottom-fsH;
iscreen.ldt(rect(frcmin(ci.left+programsplash_scrollML*xzoom-sx1,0),ci.top,frcmax(ci.right-programsplash_scrollMR*xzoom+sx2,ci.right),ci.bottom),iscrollpos,dy-(programsplash_YPOS*xzoom)+sy2,xfont,iscrolltext,fs,1,false);
if (ms64>=idelaytimer) then
   begin
   dec(iscrollpos,frcmin(programsplash_scrollstep,1)*xzoom);
   idelaytimer:=ms64+100;//26may2021
   end;
if ((iscrollpos+low__fonttextwidth2(fs,iscrolltext))<programsplash_scrollML) then iscrollpos:=cw-programsplash_scrollMR;//21sep2021
goto skipdone;

//static overlay of information text -------------------------------------------
dostatic:
dy:=ci.bottom-fsH-(programsplash_YPOS*xzoom);
for p:=0 to 99 do
begin
xaslink:=false;
dx:=(5+programsplash_XPOS)*xzoom;
if not splash__findvalue(p,true,xsep,str1) then break;
//.normal text
if (str1<>'') then
   begin
   iscreen.ldt(ci,dx,dy,xfont,str1,fs,1,false);
   inc(dx,low__fonttextwidth2(fs,str1));
   end;
//.up next line
dec(dy,fsH);
end;//p
goto skipdone;

skipdone:
//corner patch
iscreen.xparentcorners;
except;end;
try;bfree(b);except;end;
end;
//## xmustclose ##
function tbasicsplash.xmustclose:boolean;
begin
try;result:=false;if (itimeout<>0) and ((ms64>=itimeout) or (gui.focuscontrol<>self)) then result:=true;except;end;
end;
//## xsplash ##
procedure tbasicsplash.xsplash;
var
   da:trect;
   int1:longint;
begin
try
//app__processmessages;
ishowstyle:=0;//splash
iiconartref:='';
oframesparkle:=programsplash_framespark;
oframecolor:=programsplash_framecol;
oframecolor2:=programsplash_framecol2;
idelaytimer:=ms64+programsplash_scrollpause;
iscrollpos:=(programsplash_scrollstart*vizoom)-low__insint(programsplash_shiftx1*vizoom,(programsplash_shifstyle=0) or (programsplash_shifstyle=2));
iscrolltext:='';
ipreviousfocus:=frcmin(gui.winfocus,0);
winstyle:=wmontop;
oborderstyle:=bsInternal;//internal bordersize
bordersize:=low__insint(programsplash_framesize,programsplash_framed and (ostyle<>2));
oroundstyle:=corNone;//square
iscreen.oroundstyle:=oroundstyle;
xhead.visible:=false;
xtoolbar2.visible:=false;//27apr2022
//xhelp.ohelp:=false;
int1:=2*findbordersize;
case ostyle of
2:da:=rect(0,0,(iconart_width*vizoom)-1+int1,(iconart_height*vizoom)-1+int1);
else da:=rect(0,0,(iimage.width*vizoom)-1+int1,(iimage.height*vizoom)-1+int1);
end;
xsetclientarea(da);
gui.xcenter(self);
gui.focuscontrol:=self;
itimeout:=ms64+2000;//on
except;end;
end;
//## xabout ##
procedure tbasicsplash.xabout;
var
   int1,xpreviousfocus:longint;
   da:trect;
begin
try
ishowstyle:=1;//about
iiconartref:='';
idelaytimer:=ms64+programsplash_scrollpause;
iscrolltext:='';
if (ostyle<>2) then
   begin
   oframesparkle:=programsplash_framespark;
   oframecolor:=programsplash_framecol;
   oframecolor2:=programsplash_framecol2;
   obackcolor:=programsplash_framecol2;
   end;
iscrollpos:=(programsplash_scrollstart*vizoom)-low__insint(programsplash_shiftx1*vizoom,(programsplash_shifstyle=1) or (programsplash_shifstyle=2));
ipreviousfocus:=gui.winfocus;
itimeout:=0;//off
winstyle:=wmdialog;
oroundstyle:=low__aorb(corNone,corRound,programsplash_aboutround or (ostyle=2));
iscreen.oroundstyle:=oroundstyle;
if programsplash_framed then
   begin
   oborderstyle:=bsInternal;
   bordersize:=programsplash_framesize;
   end
else oborderstyle:=bsSystem50;
if (ostyle<>2) then
   begin
   xhead.oroundstyle:=oroundstyle;
   xhead.obackcolor:=programsplash_headback;
   xhead.otextcolor:=programsplash_headtext;
   end;
xhead.visible:=true;
int1:=2*findbordersize;
xtoolbar2.visible:=(ostyle=2);
xtoolbar2.normal:=(ostyle=2);
xtoolbar2.cadd(ntranslate(protect_text(16770871,'OK')),tepYes20,1,scdlg,rthtranslate('Close window'),60*5);
case ostyle of
2:da:=rect(0,0,(iconart_width*vizoom)-1+int1,(iconart_height*vizoom)-1+int1+xhead.getalignheight(0)+xtoolbar2.getalignheight(0));
else da:=rect(0,0,(iimage.width*vizoom)-1+int1,(iimage.height*vizoom)-1+int1+xhead.getalignheight(0));
end;
xsetclientarea(da);
gui.xcenter(self);
gui.focuscontrol:=self;
gui.xshowwait(self,ipreviousfocus);
visible:=false;//hide
itimeout:=ms64+1;
ipreviousfocus:=-1;//off
except;end;
end;
//## iconart_width ##
function tbasicsplash.iconart_width:longint;
const
   xminsize=5;
begin
try
result:=750;
//was:
//if (sysprogram<>nil) and (sysprogram.rootwin<>nil) then result:=frcmax(result,sysprogram.rootwin.clientwidth-(2*sysprogram.rootwin.findbordersize));
if (sysprogram<>nil) and (sysprogram.rootwin<>nil) then result:=frcmax(result,sysprogram.rootwin.clientwidth-frcmin(low__insint(2*sysprogram.rootwin.findbordersize,programsplash_framed and (ostyle<>2)),xminsize*vizoom));
except;end;
end;
//## iconart_height ##
function tbasicsplash.iconart_height:longint;
const
   xminsize=5;
begin
try
result:=300;
//was:
//if (sysprogram<>nil) and (sysprogram.rootwin<>nil) then result:=frcmax(result,sysprogram.rootwin.clientheight-(2*sysprogram.rootwin.findbordersize));
if (sysprogram<>nil) and (sysprogram.rootwin<>nil) then result:=frcmax(result,sysprogram.rootwin.clientheight-frcmin(low__insint(2*sysprogram.rootwin.findbordersize,programsplash_framed and (ostyle<>2)),xminsize*vizoom));
//.helps to scale down splash/about to fit window properly - 27apr2022
result:=round(result*(iconart_width/750));
except;end;
end;

//## tbasiccols ################################################################
//## create ##
constructor tbasiccols.create(xparent:tobject);
begin
create2(xparent,true);
end;
//## create ##
constructor tbasiccols.create2(xparent:tobject;xstart:boolean);
var
   int1,int2,p:longint;
   e:string;
begin
//self
satinc(satCols,1);
inherited create2(xparent,false);
//vars
omakeautoheight:=false;//26feb2021
ofillheight:=false;//punches through all the bullshit and JUST makes it the full height of the parent's remainging vertical height - 07mar2022
ofullarea:=true;
oroundstyle:=corToSquare;
inormal:=true;
ibordersize:=0;
itimer250:=ms64;
iinforef:='';
istyle:=bcVertical;
ihsp:=5;
ivsp:=5;
//controls
for p:=0 to high(icols) do
begin
icols[p]:=nil;
isize[p]:=20;//20% each
iwratio[p]:=true;
end;//p

//defaults
clientheight:=5;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasiccols.destroy;
begin
try
inherited destroy;
satinc(satCols,-1);
except;end;
end;
//## makeautoheight ##
procedure tbasiccols.makeautoheight;//sets self and all STATIC children to oautoheight=true - 01mar2021, 26feb2021
var
   p:longint;
begin
try
omakeautoheight:=true;//signals all references to "getcols/2" to run THIS proc each time to maintain consistent autoheight expectation -> allows for code like this "rootwin.xhigh.xcolsh.cols[..]" where both "xcolsh" and "cols[..]" check and maintain autoheight for self and all children
oautoheight:=true;
for p:=0 to high(icols) do if zzok(icols[p],7200) and icols[p].static then icols[p].oautoheight:=true;
except;end;
end;
//## canautoheight ##
function tbasiccols.canautoheight:boolean;
var
   p:longint;
begin
try
result:=false;
if oautoheight then
   begin
   for p:=0 to high(icols) do if zzok(icols[p],7201) and icols[p].visible and icols[p].static and icols[p].oautoheight then
      begin
      result:=true;
      break;
      end;//p
   end;
except;end;
end;
//## getalignheight ##
function tbasiccols.getalignheight(xclientwidth:longint):longint;
var
   int1,v,p:longint;
   xok:boolean;
begin
try
//defaults
result:=0;
xok:=false;
if omakeautoheight then makeautoheight;
//get
if canautoheight then
   begin
   for p:=0 to high(icols) do if zzok(icols[p],7202) and icols[p].visible and icols[p].static and icols[p].oautoheight then
      begin
      v:=icols[p].getalignheight(xclientwidth);
      if (v>result) then result:=v;
      xok:=true;//atleast one panel has a autoheight value we can use - 26feb2021
      end;//p
   end;
//fallback
if not xok then inherited getalignheight(xclientwidth);
//min
result:=frcmin(result,ominheight);
//external - 06jul2021
if xfindheight(xclientwidth,int1) then result:=frcmin(result,int1);
except;end;
end;
//## setstyle ##
procedure tbasiccols.setstyle(x:longint);
begin
try;istyle:=frcrange(x,0,bcMax);except;end;
end;
//## getcols ##
function tbasiccols.getcols(x:longint):tbasicscroll;
begin
try;result:=getcols2(x,50,false);except;end;
end;
//## getcols2 ##
function tbasiccols.getcols2(x,xsize:longint;xscroll:boolean):tbasicscroll;
begin
try
//defaults
result:=nil;
//range
x:=frcrange(x,0,high(icols));
//init
if zznil(icols[x],2319) then
   begin
   icols[x]:=nscroll('');
   icols[x].static:=not xscroll;
   icols[x].bordersize:=0;
   size[x]:=xsize;
   end;
//get
result:=icols[x];
if omakeautoheight then makeautoheight;
except;end;
end;
//## setvis ##
procedure tbasiccols.setvis(x:longint;xval:boolean);
begin
try
x:=frcrange(x,0,high(icols));
if zzok(icols[x],7204) and (icols[x].visible<>xval) then
   begin
   icols[x].visible:=xval;
   alignpaintnow;
   end;
except;end;
end;
//## getvis ##
function tbasiccols.getvis(x:longint):boolean;
begin
try
x:=frcrange(x,0,high(icols));
result:=zzok(icols[x],7205) and icols[x].visible;
except;end;
end;
//## setsize ##
procedure tbasiccols.setsize(x,xval:longint);
begin
try;isize[frcrange(x,0,high(icols))]:=frcmax(xval,100);except;end;
end;
//## getsize ##
function tbasiccols.getsize(x:longint):longint;
begin
try;result:=isize[frcrange(x,0,high(icols))];except;end;
end;
//## xfindsize ##
function tbasiccols.xfindsize(x,cw:longint):longint;
var
   int1:longint;
begin
try
//defaults
result:=0;
//range
cw:=frcmin(cw,0);
//check
if (cw<=0) then exit;
//init
x:=frcrange(x,0,high(icols));
int1:=isize[x];
//get
//.size as percentage of "cw"
if (int1>=1) then
   begin
   int1:=frcrange(int1,1,100);//1..100%
   result:=frcrange(round((int1/100)*cw),1,cw);
   end
//.size as fixed size + optional wration "fontwidth" scaling
else if (int1<=-1) then
   begin
   int1:=-int1;
   if iwratio[x] then int1:=round(int1*vifontwidthratio);
   result:=frcrange(int1,1,cw);
   end;
except;end;
end;
//## setwratio ##
procedure tbasiccols.setwratio(x:longint;xval:boolean);
begin
try;iwratio[frcrange(x,0,high(icols))]:=xval;except;end;
end;
//## getwratio ##
function tbasiccols.getwratio(x:longint):boolean;
begin
try;result:=iwratio[frcrange(x,0,high(icols))];except;end;
end;
//## sethsp ##
procedure tbasiccols.sethsp(x:longint);
begin
try;ihsp:=frcrange(x,0,500);except;end;
end;
//## setvsp ##
procedure tbasiccols.setvsp(x:longint);
begin
try;ivsp:=frcrange(x,0,500);except;end;
end;
//## _ontimer ##
procedure tbasiccols._ontimer(sender:tobject);
var
   ca:trect;
   cw,ch,p:longint;
   str1:string;
   xmustalignpaint:boolean;
begin
try
//defaults
xmustalignpaint:=false;

//timer250
if (ms64>=itimer250) then
   begin
   //get
   ca:=clientinner;
   cw:=frcmin(ca.right-ca.left+1,0);
   ch:=frcmin(ca.bottom-ca.top+1,0);
   str1:=inttostr(istyle)+'|';
   for p:=0 to high(icols) do if zzok(icols[p],7205) and icols[p].visible and (isize[p]<>0) then str1:=str1+inttostr(p)+'_'+inttostr(xfindsize(p,cw))+'_'+inttostr(xfindsize(p,ch))+'|';
   if low__setstr(iinforef,str1) then xmustalignpaint:=true;
   //reset
   itimer250:=ms64+250;
   end;

//xmustalignpaint
if xmustalignpaint then alignpaintnow;
except;end;
end;
//## _onalign ##
procedure tbasiccols._onalign(sender:tobject);
label
   dodone,dovertical,dohorizontal,dovertical2,dohorizontal2;
var
   ca:trect;
   xlast,xlast2,cw,ch,p,dx,dy,dw,dh,xhsp,xvsp:longint;
   xfullarea:boolean;
   //## sok ##
   function sok(x:longint):boolean;
   begin
   result:=(x>=0) and (x<=high(icols)) and zzok(icols[x],7206) and icols[x].visible and (isize[x]<>0);
   end;
   //## sa ##
   procedure sa(x:tbasiccontrol;da:trect);
   begin
   //check
   if zznil(x,2320) then exit;
   //range
   if (da.left<ca.left)     then da.left:=ca.left;
   if (da.right>ca.right)   then da.right:=ca.right;
   if (da.top<ca.top)       then da.top:=ca.top;
   if (da.bottom>ca.bottom) then da.bottom:=ca.bottom;
   //set
   x.xsetclientarea(da);
   end;
begin
try
//init
xfullarea:=ofullarea;
xhsp:=ihsp;
xvsp:=ivsp;
ca:=clientinner;
cw:=frcmin(ca.right-ca.left+1,0);
ch:=frcmin(ca.bottom-ca.top+1,0);
//.xlast
xlast:=0;
xlast2:=high(icols);
for p:=0 to high(icols) do if sok(p) then xlast:=p;
for p:=high(icols) downto 0 do if sok(p) then xlast2:=p;

//decide
case istyle of
bcVertical:goto dovertical;
bcVertical2:goto dovertical2;
bcHorizontal:goto dohorizontal;
bcHorizontal2:goto dohorizontal2;
end;
goto dovertical;

//vertical----------------------------------------------------------------------
dovertical:
dx:=ca.left;
for p:=0 to high(icols) do if sok(p) then
   begin
   dw:=xfindsize(p,cw);
   if xfullarea and (p=xlast) then dw:=cw;//use up all remaining space
   sa(icols[p],rect(dx,ca.top,dx+dw,ca.bottom));
   inc(dx,dw+xhsp);
   end;//p
goto dodone;

//vertical2---------------------------------------------------------------------
dovertical2:
dx:=ca.left;
for p:=high(icols) downto 0 do if sok(p) then
   begin
   dw:=xfindsize(p,cw);
   if xfullarea and (p=xlast2) then dw:=cw;//use up all remaining space
   sa(icols[p],rect(dx,ca.top,dx+dw,ca.bottom));
   inc(dx,dw+xhsp);
   end;//p
goto dodone;

//horizontal--------------------------------------------------------------------
dohorizontal:
dy:=ca.top;
for p:=0 to high(icols) do if sok(p) then
   begin
   dh:=xfindsize(p,ch);
   if xfullarea and (p=xlast) then dh:=ch;//use up all remaining space
   sa(icols[p],rect(ca.left,dy,ca.right,dy+dh));
   inc(dy,dh+xvsp);
   end;//p
goto dodone;

//horizontal2-------------------------------------------------------------------
dohorizontal2:
dy:=ca.top;
for p:=high(icols) downto 0 do if sok(p) then
   begin
   dh:=xfindsize(p,ch);
   if xfullarea and (p=xlast2) then dh:=ch;//use up all remaining space
   sa(icols[p],rect(ca.left,dy,ca.right,dy+dh));
   inc(dy,dh+xvsp);
   end;//p
goto dodone;

dodone:
except;end;
end;

//## tbasiccells ###############################################################
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//333333333333333333333333333333
//## create ##
constructor tbasiccells.create(xparent:tobject);
begin
create2(xparent,true);
end;
//## create2 ##
constructor tbasiccells.create2(xparent:tobject;xstart:boolean);
var
   p:longint;
begin
//self
inherited create2(xparent,false);
//vars
ilastzoom:=vizoom;
itimer100:=ms64;
ilastpaintid:=0;
ipaintid:=0;
ithumbw:=48;
ithumbh:=48;
istartx:=0;
istopx:=0;
istarty:=0;
iref:='';
iref2:='';
idragref:='';
itoppad:=10;
ibotpad:=10;
iseppad:=10;
ifocus:=0;
icount:=0;
ilastscrollpos:=0;
ilastfocus:=0;
iprevscrollpos:=0;
iprevfocus:=0;
//.scroll
iscroll:=nscrollbar('Scroll thumbnails',true);
iscroll.overtical:=false;
iscroll.ofullhandling:=false;
iscroll.makeminimal;
//events
iscroll.onpos:=_onpos;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasiccells.destroy;
var
   p:longint;
begin
try

inherited destroy;
except;end;
end;
//## _onpos ##
procedure tbasiccells._onpos(sender:tobject);
begin
try
if (sender=iscroll) then
   begin
   xfaster;
   xincpaint;
   end;
except;end;
end;
//## getalignheight ##
function tbasiccells.getalignheight(xclientwidth:longint):longint;
begin
try;result:=(2*frcmin(findbordersize,1))+(vizoom*itoppad)+(vizoom*ithumbH)+(vizoom*ibotpad)+iscroll.getalignheight(0);except;end;
end;
//## _onalign ##
procedure tbasiccells._onalign(sender:tobject);
var
   ci:trect;
   sh:longint;
begin
try
//defaults
ci:=clientinner;
sh:=iscroll.getalignheight(0);
iscroll.xsetclientarea(rect(ci.left,ci.bottom-sh,ci.right,ci.bottom));
except;end;
end;
//## findcell ##
function tbasiccells.findcell(mx:longint;var xindex:longint;xpastend:boolean):boolean;
var
   xarea,xarea2:trect;
begin
try;result:=findcell2(mx,xindex,xarea,xarea2,xpastend);except;end;
end;
//## findcell2 ##
function tbasiccells.findcell2(mx:longint;var xindex:longint;var xarea,xinnerarea:trect;xpastend:boolean):boolean;//09feb2022
var//xpastend=false=strictly xindex=0..(xcount-1), true=xindex=0..xcount (allow +1 past end of list)
   xspace,xcellwidth,si,sx,sy,p,xzoom,xseppad,xthumbW,xthumbH,xcount,xscrollpos:longint;
begin
try
//defaults
result:=false;
xindex:=0;
xarea:=nilarea;
xinnerarea:=xarea;
//init
xzoom:=vizoom;
xscrollpos:=scrollpos;
xcount:=count;
xseppad:=(xzoom*iseppad);
xthumbW:=(xzoom*thumbW);
xthumbH:=(xzoom*thumbH);
xcellwidth:=xthumbw+xseppad;
xspace:=(xcellwidth-xthumbw) div 2;
si:=xscrollpos div xcellwidth;
sx:=istartx+(si*xcellwidth)-xscrollpos;
sy:=istarty;
//find
for p:=si to low__aorb(xcount-1,xcount,xpastend) do
begin
if (mx>=sx) and (mx<(sx+xcellwidth)) then
   begin
   xindex:=p;
   //.xarea
   xarea.left:=sx;
   xarea.right:=sx+xcellwidth-1;
   xarea.top:=sy;
   xarea.bottom:=sy+xthumbH;
   //.xinnerarea
   xinnerarea.left:=sx+(xspace-1);
   xinnerarea.right:=sx+xcellwidth-1-(xspace-1);
   xinnerarea.top:=xarea.top-1;
   xinnerarea.bottom:=xarea.bottom+1;
   //.ok
   result:=true;
   break;
   end;
//.inc
inc(sx,xcellwidth);
end;//p
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxx//33333333333333333333333333333333//44444444444444444
//## _onpaint ##
procedure tbasiccells._onpaint(sender:tobject);
var
   //infovars
   a:pvirtualinfo;
   cs,ci:trect;
   fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xenabled,xround,xnormal:boolean;
   //other
   za,ta,fa,da,ia,ca:trect;
   xdropindex,xdrag,xspace,xcellwidth,si,sx,sy,p,xzoom,xseppad,xtoppad,xbotpad,xthumbW,xthumbH,xfocus,xcount,xscrollpos,xindex:longint;
   //cell support
   simage:tbasicimage;//pointer only
   scaption:string;
   stranscol,sbits,sw,sh:longint;
   shasai:boolean;
begin
try
//init
xzoom:=vizoom;
infovars(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);
ca:=ci;
ca.bottom:=iscroll.top-1;
xscrollpos:=scrollpos;
xfocus:=focus;
xdropindex:=idropindex;
xdrag:=low__aorb(xfocus,idropindex,xdropindex>=0);
xcount:=count;
xseppad:=(xzoom*iseppad);
xthumbW:=(xzoom*thumbW);
xthumbH:=(xzoom*thumbH);
xtoppad:=(xzoom*itoppad);
xbotpad:=(xzoom*ibotpad);
xcellwidth:=xthumbw+xseppad;
ia.top:=ca.top+xtoppad;
ia.bottom:=ca.top+xtoppad+xthumbH;
da.top:=ia.top-1;
da.bottom:=ia.bottom+1;
xspace:=(xcellwidth-xthumbw) div 2;
fa:=da;
fa.top    :=da.top   -xspace;
fa.bottom :=da.bottom+xspace;
ta.top    :=da.top   -(2*xspace);
ta.bottom :=da.bottom+(2*xspace);
za.top    :=da.top   -(2*xspace);
za.bottom :=da.top;
si:=xscrollpos div xcellwidth;
istartx:=ca.left+xspace;
istopx:=ca.right;
sx:=ca.left+(si*xcellwidth)-xscrollpos+xspace;
sy:=ca.top+xtoppad;
istarty:=sy;
//cls
lds(cs,xback,xround);
//get
for p:=si to (xcount-1) do
begin
ia.left:=sx+xspace;//image area
ia.right:=sx+xcellwidth-1-xspace;
da.left:=ia.left-1;//frame around outside edge of image
da.right:=ia.right+1;
fa.left:=da.left-xspace;//focus area
fa.right:=da.right+xspace;
//.drag highlight
if (xdrag<>xfocus) and (p=xdrag) then
   begin
   if (xdrag>xfocus) then
      begin
      ta.left:=sx+xcellwidth-1-xspace;
      ta.right:=ta.left+(2*xspace);
      end
   else
      begin
      ta.right:=sx+xspace;
      ta.left:=ta.right-(2*xspace);
      end;
   lds(ta,xhover,xround);
   end;
//.focus highlight
if (p=xfocus) then ldf(fa,xhover,xhover,xspace,nil,false);
//.focus dot
if (xdropindex=-1) and (p=xfocus) then
   begin
   za.right:=sx+xspace;
   za.left:=za.right-(2*xspace);
   lds(za,low__dc(xhover,20),xround);
   end;
//.draw cell image
simage:=nil;
stranscol:=clnone;
scaption:='';
if assigned(fonimage) and fonimage(self,p,xfocus,xcount,simage,stranscol,scaption) then
   begin
   if misinfo82432(simage,sbits,sw,sh,shasai) then
      begin
      ldc2(ca,da.left,da.top,da.right-da.left+1,da.bottom-da.top+1,miscellarea(simage,0),simage,255,low__aorb(0,1,stranscol<>clnone),stranscol,clnone,0,true);
      end
   else if (scaption<>'') then
      begin
      ldt(da,da.left,da.top+(((da.bottom-da.top)-fnH) div 2),xfont,scaption,fn,vifeather,false);
    //procedure ldt(darea:trect;dx,dy,dcol:longint;xline:string;xfontindex,xfeather:longint;xround:boolean);
      end;
   end;

//.frame
ldo(da,xfont,false);
//.inc
inc(sx,xcellwidth);
if (sx>ca.right) then break;
end;//p

//.terminator item
if (sx<=ca.right) then
   begin
   da.left:=sx+xspace;
   da.right:=sx+(xspace*4);
   fa.left:=da.left-xspace;//focus area
   fa.right:=da.right+xspace;
   //.focus highlight
   if (xcount=xfocus) then ldf(fa,xhover,xhover,xspace,nil,false);
   //.focus dot
   if (xdropindex=-1) and (p=xfocus) then
      begin
      za.right:=sx+xspace;
      za.left:=za.right-(2*xspace);
      lds(za,low__dc(xhover,20),xround);
      end;
   //.frame
   ldo(da,xfont,false);
   end;

//frame
if (xbordersize>=1) then ldf2(cs,xborder,xborder,xback,xbordersize,0,'',nil,xround);
except;end;
end;
//## getscrollpos ##
function tbasiccells.getscrollpos:longint;
begin
try;result:=iscroll.pos;except;end;
end;
//## setscrollpos ##
procedure tbasiccells.setscrollpos(x:longint);
begin
try;setparams(x,focus,count);except;end;
end;
//## scrollmax ##
function tbasiccells.scrollmax:longint;
begin
try;result:=iscroll.max;except;end;
end;
//## xsetfocus ##
procedure tbasiccells.xsetfocus(x:longint);
begin
try;setparams(scrollpos,x,count);except;end;
end;
//## setcount ##
procedure tbasiccells.setcount(x:longint);
begin
try;setparams(scrollpos,focus,x);except;end;
end;
//## setthumbsize ##
procedure tbasiccells.setthumbsize(w,h:longint);
begin
try;setparams2(scrollpos,focus,count,w,h);except;end;
end;
//## setparams ##
function tbasiccells.setparams(xscroll,xfocus,xcount:longint):boolean;
begin
try;result:=setparams2(xscroll,xfocus,xcount,ithumbW,ithumbH);except;end;
end;
//## setparams2 ##
function tbasiccells.setparams2(xscroll,xfocus,xcount,xthumbW,xthumbH:longint):boolean;
var
   xcellwidth,xseppad,xzoom,xscrollmax:longint;
begin
try
//defaults
result:=false;
xzoom:=vizoom;
//range
xcount:=frcrange(xcount,0,maxint);
xfocus:=frcrange(xfocus,0,xcount);
xseppad:=xzoom*iseppad;
xthumbW:=frcrange(xthumbW,20,200);
xthumbH:=frcrange(xthumbH,20,200);
xcellwidth:=(xzoom*xthumbW)+xseppad;
xscrollmax:=xcount*xcellwidth;
xscroll:=frcrange(xscroll,0,xscrollmax);
//get
if low__setstr(iref,inttostr(xzoom)+'|'+inttostr(xscroll)+'|'+inttostr(xscrollmax)+'|'+inttostr(xfocus)+'|'+inttostr(xcount)+'|'+inttostr(xthumbW)+'|'+inttostr(xthumbH)) then
   begin
//   if (ifocus<>xfocus) and (xscrollmax<>iscroll.max) and (xthumbW=ithumbW) then xscroll:=frcmin((xfocus-1)*xcellwidth,0);

   ifocus:=xfocus;
   icount:=xcount;
   ithumbW:=xthumbW;
   ithumbH:=xthumbH;
   iscroll.setparams(xscroll,0,xscrollmax);
   case visible and low__setstr(iref2,inttostr(xzoom)+'|'+inttostr(xthumbW)+'|'+inttostr(xthumbH)) of
   true:gui.fullalignpaint;
   false:xincpaint;
   end;
   end;
except;end;
end;
//## xincpaint ##
procedure tbasiccells.xincpaint;
begin
try;low__iroll(ipaintid,1);except;end;
end;
//## xprev ##
procedure tbasiccells.xprev;
begin
try;focus:=focus-1;except;end;
end;
//## xnext ##
procedure tbasiccells.xnext;
begin
try;focus:=focus+1;except;end;
end;
//## xcanmove ##
function tbasiccells.xcanmove:boolean;
begin
try;result:=assigned(fonmove);except;end;
end;
//## xmove ##
function tbasiccells.xmove(s,d:longint):boolean;
begin
try
result:=false;
if (s<>d) and (s>=0) and (s<count) and (d>=0) and (d<count) and xcanmove then
   begin
   result:=fonmove(self,s,d,focus,count);
   focus:=d;
   xincpaint;
   end;
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxx//33333333333333333333333333333333//44444444444444444
//## _onnotify ##
function tbasiccells._onnotify(sender:tobject):boolean;
var
   dp:tpoint;
   int1,int2,dx,dy:longint;
   xmustpaint:boolean;
   xarea:trect;
begin
try
//defaults
result:=false;
xmustpaint:=false;

//wheel
if (gui.wheel<>0) and enabled then
   begin
   scrollpos:=scrollpos-(gui.wheel*(ithumbW div 2));
   result:=true;//own the wheel
   end;


//key
if (gui.key<>aknone) then
   begin
   case gui.key of
   akhome:begin
      if enabled then focus:=0;
      result:=true;
      end;
   akend:begin
      if enabled then focus:=frcmin(count-1,0);
      result:=true;
      end;
   akleft,akup:begin
      if enabled then xprev;
      result:=true;
      end;
   akright,akdown:begin
      if enabled then xnext;
      result:=true;
      end;
   akprev:begin
      if enabled then xprev;
      result:=true;
      end;
   aknext:begin
      if enabled then xnext;
      result:=true;
      end;
   end;//case
   end;

//mouse down
if gui.mousedownstroke then
   begin
   idownxy:=mousedownxy;
   idropindex:=-1;//off
   idragarea:=nilarea;
   if findcell2(idownxy.x,int1,xarea,idragarea,true) then focus:=int1;
   //prev support
//   if (ilastscrollpos<>scrollpos) and (ilastfocus<>focus) then
   if (ilastfocus<(focus-2)) or (ilastfocus>(focus+2)) then
      begin
      iprevscrollpos:=ilastscrollpos;
      iprevfocus:=ilastfocus;
      ilastscrollpos:=scrollpos;
      ilastfocus:=focus;
      end;
   //paint
   xmustpaint:=true;
   end;

//mouse move
if gui.mousedown and gui.mousemoved and (not gui.mousedownstroke) then
   begin
   if gui.mousedragging and (focus>=0) and (focus<count) and xcanmove then
      begin
      if low__setstr(idragref,inttostr(mousemovexy.x)+'='+inttostr(mousemovexy.y)) then xmustpaint:=true;
      if findcell(mousemovexy.x,int1,false) and low__setint(idropindex,int1) then xmustpaint:=true;//0..xcount
      if drop_init2(gui.buffer,low__shiftarea(idragarea,paintarea.left,paintarea.top),'drag.layer') then xmustpaint:=true;//once only
      if drop_show(gui.mousemovexy.x,gui.mousemovexy.y) then
         begin
         xfaster;//smooth drop mode - 26jul2021
         xmustpaint:=true;
         end;
      end;
   end;

//mouse up
if gui.mouseupstroke then
   begin
   if (idropindex>=0) then
      begin
      if xmove(focus,idropindex) then xmustpaint:=true;
      end;
   if low__setint(idropindex,-1) then xmustpaint:=true;
   if drop_hide then xmustpaint:=true;
   end;

//external event override - 01mar2021
//if assigned(fonnotify) then fonnotify(sender);
{}
//paint
if xmustpaint then xincpaint;

except;end;
end;
//## xprevlocation ##
procedure tbasiccells.xprevlocation;
var
   int1,int2:longint;
begin
try
int1:=scrollpos;
int2:=focus;
setparams(iprevscrollpos,iprevfocus,icount);
ilastscrollpos:=iprevscrollpos;
ilastfocus:=iprevfocus;
iprevscrollpos:=int1;
iprevfocus:=int2;
except;end;
end;
//## _ontimer ##
procedure tbasiccells._ontimer(sender:tobject);
var
   xmustpaint:boolean;
begin
try
xmustpaint:=false;

//timer100
if (ms64>=itimer100) then
   begin
   if low__setint(ilastzoom,vizoom) then setparams(scrollpos,focus,count);
   itimer100:=ms64+100;
   end;

//delayed paint
if (ilastpaintid<>ipaintid) then
   begin
   ilastpaintid:=ipaintid;
   xmustpaint:=true;
   end;

//paint
if xmustpaint then paintnow;
except;end;
end;

//## tbasicscroll ##############################################################
//xxxxxxxxxxxxxxxxxxxxxxxxxxx//rrrrrrrrrrrrrrrrrrrrrrrrrrrrr
//## create ##
constructor tbasicscroll.create(xparent:tobject);
begin
create2(xparent,true,true);
end;
//## create ##
constructor tbasicscroll.create2(xparent:tobject;xscroll,xstart:boolean);
var
   int1,int2,p:longint;
   e:string;
begin
//self
satinc(satScroll,1);
inherited create2(xparent,false);
//vars
//.right support - 24jul2021
irightmax:=false;
irightgap:=0;
irightminwidth:=-50;
irightmaxwidth:=350;//uses viZoom as well
iright:=nil;
//.continue
otopspace:=0;
iscroll:=xscroll;
istatic:=false;
oroundstyle:=corToSquare;
ofirstpos:=minint;//off
osmallchange:=10;
olargechange:=50;
imainhelp:=nil;//optional
ihead:=nil;//optional
ihelp:=nil;//optional
itoolbar:=nil;//optional
itoolbar2:=nil;//optional
ihigh:=nil;//optional
ihigh2:=nil;//optional
istatus:=nil;//optional
istatus2:=nil;//optional
icols:=nil;//optional
imenu:=nil;//optional
inormal:=true;
ibordersize:=1;//30;//10;//no border -> can't repaint the controls in the clientarea without overwriting the border!!! - reconfirmed on 01aug2020
itimer100:=ms64;
itimer250:=ms64;
iinforef:='';
iposref:='';
idownpos:=0;
ipage:='';
//controls
iv:=tbasicscrollbar.create(self);
iv.overtical:=true;
iv.ofullhandling:=false;//allow our "_onnotify()" to handle the sensitive parts of scrolling and navigation etc - 04apr2020
iv.osmallchange:=10;

//defaults
clientheight:=5;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasicscroll.destroy;
begin
try
inherited destroy;
satinc(satScroll,-1);
except;end;
end;
//## destroychildren ##
procedure tbasicscroll.destroychildren;
var
   b:tbasiccontrol;
   i,i2,p:longint;
begin
try
//children
i:=-1;
i2:=-1;
if gui.xsafeown(ownlist) and (ownlist.count>=1) then
   begin
   for p:=(ownlist.count-1) downto 0 do if gui.xownget(ownlist,p,b) then
      begin
      if (b=iv) then i:=p
      else if (b=iright) and (iright<>nil) then i2:=p
      else gui.xowndel__fast(ownlist,p);
      end;//p
   end;
//finalise
if (i2>=0) and gui.xowndel__fast(ownlist,i2) then iright:=nil;
if (i>=0) and gui.xowndel__fast(ownlist,i) then iv:=nil;
except;end;
end;
//## findbordersize ##
function tbasicscroll.findbordersize:longint;
begin
try;if winmaxed and (not viframemax) then result:=0 else result:=inherited findbordersize;except;end;
end;
//## makeautohigh ##
function tbasicscroll.makeautohigh:boolean;
begin
try
result:=false;
ominheight:=2;
owinresizeable:=false;
oautoheight:=true;
setbounds(clientarea.left,clientarea.top,clientarea.right-clientarea.left+1,getalignheight(clientarea.right-clientarea.left+1));
gui.xcenter(self);
result:=true;
except;end;
end;
//## makedlg ##
function tbasicscroll.makedlg(da:trect;xshowhead:boolean):tbasicscroll;//27feb2021
begin
try;result:=makedlg2(da,xshowhead,false,true,true);except;end;
end;
//## makedlg2 ##
function tbasicscroll.makedlg2(da:trect;xshowhead,xstatic,xcancel,xok:boolean):tbasicscroll;
begin
try;result:=makedlg3(da,tepnone,'',xshowhead,xstatic,0,120);except;end;
end;
//## makedlg3 ##
function tbasicscroll.makedlg3(da:trect;xtep:longint;xtitle:string;xshowhead,xstatic:boolean;xcanceltime,xoktime:longint):tbasicscroll;
begin
try
result:=self;
result.winstyle:=wmdialog;
result.oroundstyle:=corRound;
result.oborderstyle:=bsSystem100;
result.owinresizeable:=true;//25feb2021
result.mkescape:=true;
result.mkreturn:=true;
result.ocode:=0;//cancelled
result.ocode2:='';
result.otepcolor:=clnone;
result.static:=xstatic;//17aug2020
if xshowhead then
   begin
   if (xtep<>tepnone) then result.xhead.tep:=xtep;
   if (xtitle<>'')    then result.xhead.caption:=xtitle;
   result.xhead.style:=wuClose;
   end;
result.xhelp;//every normal window has help by default
result.xsetclientarea(da);
gui.focuscontrol:=result;
//.buttons
with result.xtoolbar2 do
begin
if (xoktime>=0) then cadd(ntranslate('OK'),tepYes20,1,scdlg,rthtranslate('OK'),xoktime);
if (xcanceltime>=0) then cadd(ntranslate('Cancel'),tepClose20,0,scdlg,rthtranslate('Cancel'),xcanceltime);
end;
except;end;
end;
//## setpage ##
procedure tbasicscroll.setpage(x:string);
var
   a:tbasiccontrol;
   p:longint;
   str1:string;
   xmustalign,bol1:boolean;
begin
try
//filter
x:=low__lowercase(x);
if (x='')                         then x:='user';
//check
if low__comparetext(x,ipage) then exit;
//get
ipage:=x;
str1:=ipage;
xmustalign:=false;
if (ownlist.count>=1) then
   begin
   for p:=0 to (ownlist.count-1) do if gui.xownget(ownlist,p,a) and (a.opagename<>'') then
   begin
   bol1:=low__comparetext(str1,a.opagename);
   if (bol1<>a.visible) then
      begin
      a.visible:=bol1;
      xmustalign:=true;
      end;
   end;//p
   end;
//set -> must update parent incases of height changing -> requires BOTH align and paint triggers -> 02jun2021
if xmustalign then
   begin
   parentalignnow;
   parentpaintnow;
   end;
except;end;
end;
//## _ontimer ##
procedure tbasicscroll._ontimer(sender:tobject);
var
   int1,xdir:longint;
   bol1,xmustalign,xmustpaint:boolean;
begin
try
//defaults
xmustalign:=false;
xmustpaint:=false;

//.itimer250
if (ms64>itimer250) then
   begin
   //control info
   if low__setstr(iinforef,bnc(inormal)+pcRefsep+inttostr(findbordersize)) then xmustpaint:=true;
   //reset
   itimer250:=ms64+250;
   end;

//.itimer100
if (ms64>itimer100) then
   begin
   //pos info
   if low__setstr(iposref,inttostr(pos)+#1+inttostr(iv.max)+#1+inttostr(clientwidth)+#1+inttostr(clientheight)+#1+inttostr(ownid)+#1+inttostr(parentcoreindex)) then
      begin
      xmustalign:=true;
      xmustpaint:=true;
      end;
   //reset
   itimer250:=ms64+250;
   end;

//wound scroller - 28sep2022                            //round(clientheight*0.3)
if (iv<>nil) and xwound_mustpaint(iv.pos,xsmall,int1,xdir) then
   begin
   if (int1<>pos) then pos:=int1;
   xwound_autooff(pos,xdir,iv.min,iv.max);
   end;

//paint
if xmustalign then alignnow;
if xmustpaint then paintnow;
except;end;
end;
//## clientinner2 ##
function tbasicscroll.clientinner2(x:tbasiccontrol):trect;
var
   a:trect;
   bs:longint;
begin
try
a:=iclientarea;
bs:=findbordersize;
case xbuiltinok(x) of
true:result:=rect(a.left+bs,a.top+bs,a.right-bs,a.bottom-bs);
false:result:=rect(a.left+bs,iv.clientarea.top,iv.clientarea.left-1,iv.clientarea.bottom);
end;
except;end;
end;
//## headheight ##
function tbasicscroll.headheight:longint;//25jan2021
begin
try
result:=0;
if zzok(iv,7207) and iv.visible then result:=frcmin(iv.clientarea.top-iclientarea.top,0);
except;end;
end;
//## getalignheight ##
function tbasicscroll.getalignheight(xclientwidth:longint):longint;
var
   int1:longint;
begin
try
if oautoheight then
   begin
   xcalcalign(false,xclientwidth,int1,result);
   result:=frcrange(frcmin(result,ominheight),0,gui.height);
   end
else
   begin
   result:=frcmin(frcmin(clientheight,ominheight),0);
   end;
//external - 06jul2021
if xfindheight(xclientwidth,int1) then result:=frcmin(result,int1);
except;end;
end;
//## _onalign ##
procedure tbasicscroll._onalign(sender:tobject);
var
   int1,int2:longint;
begin
try;xcalcalign(true,0,int1,int2);except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxx//rrrrrrrrrrrrr
//## xcalcalign ##
procedure tbasicscroll.xcalcalign(xalignok:boolean;xclientwidth:longint;var xoutclientheight,xoutheight:longint);
label
   skipend;
var
   a:tbasiccontrol;
   xrootca,ca:trect;
   xzoom,tmpw,xrightgap,xrightY1,xrightY2,xrightw,xtop,cy1,cy2,int1,int2,int3,xright,law,lah,lhsp,lvsp,hsp,vsp,lav,av,ldy,lineh,sh,aw,ah,tw,th,p,dx,dy,dy2,bs,sw,fcw2,fcw,cw2,cw,ch,dh,xlast:longint;
   xrightmax,xrightok,xstatic,xscroll,bol1,xok:boolean;
   //## hlimit ##
   function hlimit(x:longint):longint;
   begin
   result:=frcrange(x,0,frcmin(dy2-dy+0,0));
   end;
   //## xnextinit ##
   procedure xnextinit;
   begin
   th:=0;
   tw:=0;
   dx:=0;
   dy:=0;
   lineh:=0;
   av:=1;
   lav:=-1;
   a:=nil;
   vsp:=0;
   hsp:=0;
   lvsp:=0;
   lhsp:=0;
   law:=0;
   lah:=0;
   end;
   //## xnext ##
   procedure xnext;
   begin
   //check
   if zznil(a,2321) then exit;
   //init
   av:=low__aorb(0,1,a.oalignvert);
   if (av=1) then aw:=frcmin(cw2,0) else aw:=frcmin(frcmin(a.getalignwidth(ch-(2*bs)),a.ominwidth),0);
   ah:=a.getalignheight(cw2);
   hsp:=frcmin(a.oseph,0);
   vsp:=frcmin(a.osepv,0);//include optional vertical spacing
   //get
   case av of
   0:begin//horizontal alignment
      if (lav<>av) then
         begin
         if (lah>=1) then inc(dy,lah+lvsp);
         dx:=0;
         law:=0;
         lhsp:=0;
         end;
      if ((ah+vsp)>lineh) then lineh:=ah+vsp;
      inc(dx,law+hsp);//immediate horizontal sep
      if ((dx+aw)>=cw2) and (dx>0) then
         begin
         inc(dy,lineh);
         lineh:=ah+vsp;
         dx:=0;
         law:=aw;
         lhsp:=0;
         end
      else
         begin
         law:=aw;
         lhsp:=hsp;
         end;
       end;
   1:begin//vertical
      if (lav<>av) and (lineh>=1) then inc(dy,lineh+vsp)
      else inc(dy,lah+vsp);//imediate vertical space
      dx:=0;
      law:=0;
      lhsp:=0;
      lvsp:=0;
      end;
   end;
   //set
   aw:=frcmax(aw,cw2);//limit width to "cw2" -> no wider than scrollbar
   lav:=av;
   lah:=ah;
//   lvsp:=vsp;
   end;
   //## xnextfinish ##
   procedure xnextfinish;
   begin
   case lav of
   0:if (lineh>=1) then inc(dy,lineh);
   1:if (lah>=1)   then inc(dy,lah+lvsp);
   end;//case
   lav:=-1;
   end;
begin
try
//init
a:=nil;
xzoom:=vizoom;
xrightok:=rightvisible;
xrightmax:=irightmax;
xrightgap:=irightgap*xzoom;
xrightw:=0;
xoutclientheight:=0;
xoutheight:=0;
xstatic:=istatic;
xscroll:=iscroll;
bs:=findbordersize;
xrootca:=clientarea;
ca:=xrootca;
ch:=low__aorb(maxheight,clientheight,xalignok);
if xrightok then
   begin
   int1:=frcmin(largest(clientwidth,xclientwidth)-(2*bs),0);
   int2:=irightminwidth;
   if (int2<0) then int2:=round((-int2/100)*int1) else int2:=int2*xzoom;
   int3:=irightmaxwidth;
   if (int3<0) then int3:=round((-int3/100)*int1) else int3:=int3*xzoom;
   inc(int2,xrightgap);
   inc(int3,xrightgap);
   xrightw:=int3;
   if ((int1-xrightw)<int2) then xrightw:=frcmin(int1-int2,0);
   if (xrightw>int3) then xrightw:=int3;
   ca.right:=frcmin(xrootca.right-xrightw,0);
   end;
if xscroll and (not xstatic) then sw:=iv.getalignwidth(0) else sw:=0;
cw:=frcmin(largest(clientwidth,xclientwidth)-(2*bs)-xrightw,0);
cw2:=frcmin(cw-sw,0);
fcw:=frcmin(largest(clientwidth,xclientwidth)-(2*bs),0);
fcw2:=frcmin(fcw-sw,0);
xtop:=clientarea.top;
//static controls --------------------------------------------------------------
//init
bol1:=false;//true=mustalign=2=full align for children.controls
dy:=bs+otopspace;//17aug2020
dy2:=ch-bs;
xrightY1:=dy;
xrightY2:=dy2-1;

//Note: System controls are aligned in priority order, e.g. the most important
//      controls get first access to limited screen space, then if there is any
//      leftover, other less important controls, and so on.
//.head - (top-down)
if zzok(ihead,7210) and ihead.visible then
   begin
   tmpw:=low__aorb(fcw,cw,xrightmax);
   dh:=hlimit(ihead.getalignheight(tmpw));
   if xalignok and ihead.setbounds(bs,dy,tmpw,dh) then bol1:=true;//struc(x,y,w,h)
   inc(dy,dh);
   end;
//.help - (top-down)
if zzok(ihelp,7211) and ihelp.visible then
   begin
   tmpw:=low__aorb(fcw,cw,xrightmax);
   dh:=hlimit(ihelp.getalignheight(tmpw));
   if xalignok and ihelp.setbounds(bs,dy,tmpw,dh) then bol1:=true;//struc(x,y,w,h)
   inc(dy,dh);
   end;
//.status2 - (bottom-up)
if zzok(istatus2,7212) and istatus2.visible then
   begin
   tmpw:=low__aorb(fcw,cw,xrightmax);
   dh:=hlimit(istatus2.getalignheight(tmpw));
   if xalignok and istatus2.setbounds(bs,dy2-dh,tmpw,dh) then bol1:=true;//struc(x,y,w,h)
   dec(dy2,dh);
   end;
//.toolbar2 - (bottom-up/used for buttons on a dlg window)
if zzok(itoolbar2,7213) and itoolbar2.visible then
   begin
   tmpw:=low__aorb(fcw,cw,xrightmax);
   dh:=hlimit(itoolbar2.getalignheight(tmpw));
   if xalignok and itoolbar2.setbounds(bs,dy2-dh,tmpw,dh) then bol1:=true;//struc(x,y,w,h)
   dec(dy2,dh+itoolbar2.osepv);
   end;
//.toolbar - (top-down/main toolbar for window)
if zzok(itoolbar,7214) and itoolbar.visible then
   begin
   tmpw:=low__aorb(fcw,cw,xrightmax);
   //Note: for "getalignheight" to work correctly it needs to know the width
   dh:=hlimit(itoolbar.getalignheight(tmpw));
   if xalignok and itoolbar.setbounds(bs,dy,tmpw,dh) then bol1:=true;//struc(x,y,w,h)
   inc(dy,dh);
   end;
//.status - (top-down)
if zzok(istatus,7215) and istatus.visible then
   begin
   tmpw:=low__aorb(fcw,cw,xrightmax);
   //Note: for "getalignheight" to work correctly it needs to know the width
   dh:=hlimit(istatus.getalignheight(tmpw));
   if xalignok and istatus.setbounds(bs,dy,tmpw,dh) then bol1:=true;//struc(x,y,w,h)
   inc(dy,dh);
   end;
//.high - (bottom-up/used for controls at the top of a window)
if zzok(ihigh,7216) and ihigh.visible then
   begin
   tmpw:=low__aorb(fcw,cw,xrightmax);
   //Special Note: This panel "high" must be able to have an optional
   //              mode that allows the system to automatically detect
   //              the required height of the panel based on the controls
   //              within it -> it would probably have to be static (no scrolling)
   //              date: 19aug2020 - *** todo ***
   dh:=hlimit(ihigh.getalignheight(tmpw));
   //note: top+bottom fixed - 07oct2020
   if xalignok and ihigh.setbounds(bs,dy,tmpw,dh) then bol1:=true;//struc(x,y,w,h)
   inc(dy,dh);
   end;
//.high2 - (bottom-up/used for controls at the bottom of a window)
if zzok(ihigh2,7217) and ihigh2.visible then
   begin
   tmpw:=low__aorb(fcw,cw,xrightmax);
   //Special Note: This panel "high2" must be able to have an optional
   //              mode that allows the system to automatically detect
   //              the required height of the panel based on the controls
   //              within it -> it would probably have to be static (no scrolling)
   //              date: 19aug2020 - *** todo ***
   dh:=hlimit(ihigh2.getalignheight(tmpw));
   //note: top+bottom fixed - 07oct2020
   //was: if xalignok and ihigh2.setbounds(bs,dy2-dh+1,cw,dh) then bol1:=true;//struc(x,y,w,h)
   if xalignok and ihigh2.setbounds(bs,dy2-dh,tmpw,dh) then bol1:=true;//struc(x,y,w,h)
   dec(dy2,dh);
   end;
//.icols - (bottom-up/used for controls at the bottom of a window)
if zzok(icols,7218) and icols.visible then
   begin
   if      icols.ofillheight    then dh:=hlimit(ch)//assumes full remaining height
   else if icols.canautoheight  then dh:=hlimit(icols.getalignheight(cw))//assumes full remaining height
   else                              dh:=hlimit(ch);//assumes full remaining height
{was:
   case icols.canautoheight of
   true:dh:=hlimit(icols.getalignheight(cw));//assumes full remaining height
   false:dh:=hlimit(ch);//assumes full remaining height
   end;
{}
   //note: top+bottom fixed - 07oct2020
   //was: if xalignok and icols.setbounds(bs,dy2-dh+1,cw,dh) then bol1:=true;//struc(x,y,w,h)
   if xalignok and icols.setbounds(bs,dy2-dh,cw,dh) then bol1:=true;//struc(x,y,w,h) - 25feb2021
   dec(dy2,dh);
   end;
//.menu - (top-down)
if zzok(imenu,7218) and imenu.visible then
   begin
   //Note: for "getalignheight" to work correctly it needs to know the width
   dh:=hlimit(imenu.getalignheight(cw));
   if xalignok and imenu.setbounds(bs,dy,cw,dh) then bol1:=true;//struc(x,y,w,h)
   inc(dy,dh);
   end;
//.right - right hand side full height - 24jul2021
if zzok(iright,7219) and iright.visible then
   begin
   //special
   int2:=dy2;
   if zzok(icols,7218) and icols.visible and (icols.clientarea.top<=dy) then int2:=icols.clientarea.bottom;

   //set
   case xrightmax of
   false:begin
      xrightY1:=dy;
      xrightY2:=int2-1;
      end;
   true:begin//18dec2021
      end;
   end;//case

   //.corner patching
   if xalignok and iright.setbounds(xrootca.right-xrightw-bs+1+xrightgap,xrightY1,xrightw-xrightgap,xrightY2-xrightY1+1) then bol1:=true;//struc(x,y,w,h)
   end;

//.client area - find last client control -> we can make this fit remaining area (override getalignheight)
xlast:=-1;//none
if (ownlist.count>=1) then
   begin
   for p:=(ownlist.count-1) downto 0 do if gui.xownget(ownlist,p,a) and (not xbuiltinOK(a)) and a.visible then
      begin
      xlast:=p;
      break;
      end;
   end;
{
//.client area - align controls
if (ownlist.count>=1) then
   begin
   for p:=0 to (ownlist.count-1) do if gui.xownget(ownlist,p,a) and (not xbuiltinOK(a)) and a.visible then
      begin
      int1:=frcmin(dy2-dy+1,0);
      dh:=hlimit(largest(a.getalignheight(cw2),frcmin(a.ominheight,0)));
      if (p>=xlast) then dh:=hlimit(int1);
      if a.setbounds(bs,dy,cw2,dh) then bol1:=true;//struc(x,y,w,h)
      inc(dy,dh);
      end;//p
   end;
//.unused client area
ipainty:=dy;
ipainty2:=dy2;
//.align all children controls -> fire internal align event "_onalign()"
if (ownlist.count>=1) then
   begin
   for p:=0 to (ownlist.count-1) do if gui.xownget(ownlist,p,a) and (not xbuiltinOK(a)) and a.visible then
      begin
      xfindalign(a,low__aorb(-2,-1,bol1));//-1=align all regardless, -2=search for 1st align, then align from there up - 05apr2020
      end;//p
   end;
{}//xxxxxxxxxxxxxxxxxx


//align all children controls --------------------------------------------------

//init
int1:=dy;//remember this value
sh:=frcmin(dy2-dy,0);
cy1:=xtop+dy;//works now, used to be "top" but now uses "xtop=clientarea.top" - 01aug2020
cy2:=xtop+dy2-1;
//get
//.calculate total height required
xnextinit;
if (ownlist.count>=1) then
   begin
   for p:=0 to (ownlist.count-1) do if gui.xownget(ownlist,p,a) and (not xbuiltinOK(a)) and a.visible then xnext;
   xnextfinish;
   end;
th:=dy;

//.autoheight support - 21feb2021
xoutclientheight:=frcmin(int1+th+((ch-bs)-dy2),0);
xoutheight:=xoutclientheight+bs;//only "1x bs" as one has already been counted - 08mar2021
if not xalignok then goto skipend;
//v -> supports "ofirstpos" - 14aug2020
case xstatic of
true:iv.setparams(0,0,0);
false:iv.setparams(low__aorb(pos,ofirstpos,ofirstpos<>minint),0,frcmin(th-sh,0));
end;
if (ofirstpos<>minint) then ofirstpos:=minint;//turn off
xok:=(iv.max>=1);
iv.enabled:=xok;
iv.visible:=(sw>=1);
iv.xsetclientarea(rect(ca.right-(sw-1)-bs,cy1,ca.right-bs,cy2));

//controls
xnextinit;
dy:=cy1-iv.pos;//vertical shift pos
dx:=0;
xright:=ca.right-sw-bs;
//dbstatus(7,inttostr(th)+'__'+inttostr(iv.clientheight)+'<<_'+bnc(iv.enabled)+'>'+inttostr(iv.pos)+'__'+inttostr(iv.min)+'..'+inttostr(iv.max)+'<<POS<'+ms64str);//xxxxxxxxxxxxxx
if (ownlist.count>=1) then
   begin
   for p:=0 to (ownlist.count-1) do if gui.xownget(ownlist,p,a) and (not xbuiltinOK(a)) and a.visible then
      begin
      xnext;
      if (xstatic or (not xscroll)) and (xlast=p) and a.oautoheight then int1:=cy2 else int1:=dy+(ah-1);
      if xalignok then a.xsetclientarea(rect(ca.left+bs+dx,dy,frcmax(ca.left+bs+dx+(aw-1),xright),int1));
      end;//p
   end;
skipend:
except;end;
try;if assigned(onalign) then onalign(self);except;end;
end;
//## xbuiltinOK ##
function tbasicscroll.xbuiltinOK(x:tobject):boolean;
begin
try
//check
result:=false;
if zznil(x,2322) then exit;
//get
result:=
 (x=ihead) or (x=ihelp) or (x=imenu) or
 (x=itoolbar) or (x=itoolbar2) or
 (x=ihigh) or (x=ihigh2) or (x=icols) or
 (x=istatus) or (x=istatus2) or
 (x=imainhelp) or
 (x=iv) or (x=iright);
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxx//rrrrrrrrrrrrrrrrrrrrrrr
//## xsmall ##
function tbasicscroll.xsmall:longint;
begin
try;result:=frcmin( round((frcmin(osmallchange,1)/100)*clientheight) ,1);except;end;
end;
//## xlarge ##
function tbasicscroll.xlarge:longint;
begin
try;result:=frcmin( round((frcmin(olargechange,1)/100)*clientheight) ,1);except;end;
end;
//## _onnotify ##
function tbasicscroll._onnotify(sender:tobject):boolean;
   //## xinsideclientinner ##
   function xinsideclientinner:boolean;
   var
      a:tbasiccontrol;
      b:trect;
      sx,sy:longint;
   begin
   try
   result:=false;
   if xwindow(a) and (gui.winhover=a.coreindex) then//cursor is on our form
      begin
      sx:=gui.mousedownxy.x;
      sy:=gui.mousedownxy.y;
      b:=clientinner2(nil);
      result:=(sx>=b.left) and (sx<=b.right) and (sy>=b.top) and (sy<=b.bottom);
      end;
   except;end;
   end;
begin
try
//defaults
result:=true;

//wheel
if (gui.wheel<>0) then
   begin
   if enabled then
      begin
      pos:=pos-(gui.wheel*xsmall);
      xwound_wheel(gui.wheel*70);
      end;
   end;

//key
if (gui.key<>aknone) then
   begin
   if enabled then
      begin
      case gui.key of
      akhome:pos:=0;
      akend:pos:=iv.max;
      akleft,akup:pos:=pos-xsmall;
      akright,akdown:pos:=pos+xsmall;
      akprev:pos:=pos-xlarge;
      aknext:pos:=pos+xlarge;
      end;//case
      end;
   end;

//mousedownstroke
if gui.mousedownstroke then
   begin
   idownpos:=pos;
   end;

//mouse move
if gui.mousedown and gui.mousemoved and (not gui.mousedownstroke) then
   begin
//was: if enabled and xinsideclientinner then pos:=round(idownpos-(gui.mousemovexy.y-gui.mousedownxy.y));
   if enabled then pos:=round(idownpos-(gui.mousemovexy.y-gui.mousedownxy.y));//allows cursor to be outside of the scrollbox while down and dragging and still work - 27feb2021
   end;

//mouse up - wound support - 04oct2022
if gui.mouseupstroke and gui.mousedragging and gui.mouseleft then xwound_mousevert(3000,true);

//external event override - 01feb2021
if assigned(fonnotify) then fonnotify(sender);
except;end;
end;
//## getpos ##
function tbasicscroll.getpos:longint;
begin
try;result:=iv.pos;except;end;
end;
//## setpos ##
procedure tbasicscroll.setpos(x:longint);
begin
try;iv.pos:=x;except;end;
end;
//## setscroll ##
procedure tbasicscroll.setscroll(x:boolean);
begin
try;if low__setbol(iscroll,x) then alignnow;except;end;
end;
//## setstatic ##
procedure tbasicscroll.setstatic(x:boolean);
begin
try;if low__setbol(istatic,x) then alignnow;except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
//## setrightmax ##
procedure tbasicscroll.setrightmax(x:boolean);
begin
try;setrightparams(irightminwidth,irightmaxwidth,irightgap,x,rightvisible);except;end;
end;
//## setrightgap ##
procedure tbasicscroll.setrightgap(x:longint);
begin
try;setrightparams(irightminwidth,irightmaxwidth,x,irightmax,rightvisible);except;end;
end;
//## setrightminwidth ##
procedure tbasicscroll.setrightminwidth(x:longint);
begin
try;setrightparams(x,irightmaxwidth,irightgap,irightmax,rightvisible);except;end;
end;
//## setrightmaxwidth ##
procedure tbasicscroll.setrightmaxwidth(x:longint);
begin
try;setrightparams(irightminwidth,x,irightgap,irightmax,rightvisible);except;end;
end;
//## setrightparams ##
procedure tbasicscroll.setrightparams(xminwidth,xmaxwidth,xgap:longint;xrightmax,xvisible:boolean);
var
   xmustvisible:boolean;
begin
try
//range
xminwidth:=frcmin(xminwidth,-100);//-1..-100=percentage, 1..N=pixels
xmaxwidth:=frcmin(xmaxwidth,-100);
xgap:=frcrange(xgap,0,30);
xmustvisible:=(xvisible<>rightvisible);
//get
if (irightminwidth<>xminwidth) or (irightmaxwidth<>xmaxwidth) or (irightgap<>xgap) or (irightmax<>xrightmax) or xmustvisible then
   begin
   irightminwidth:=xminwidth;
   irightmaxwidth:=xmaxwidth;
   irightgap:=xgap;
   irightmax:=xrightmax;
   case xvisible of
   true:xright.visible:=true;//auto-create
   false:if xhaveright then xright.visible:=false;
   end;
   alignpaintnow;
   end;
except;end;
end;
//## getrightvisible ##
function tbasicscroll.getrightvisible:boolean;
begin
try;result:=zzok(iright,100) and iright.visible;except;end;
end;
//## setrightvisible ##
procedure tbasicscroll.setrightvisible(x:boolean);
begin
try;setrightparams(irightminwidth,irightmaxwidth,irightgap,irightmax,x);except;end;
end;
//## xright ##
function tbasicscroll.xright:tbasicscroll;
begin
try
//init
case zzok(iright,7218) of
true:result:=iright;
false:begin
   iright:=tbasicscroll.create(self);
   iright.static:=true;
   iright.bordersize:=0;
   result:=iright;
   end;
end;//case
except;end;
end;
//## xmainhelp ##
function tbasicscroll.xmainhelp:tmainhelp;
var
   xonce:boolean;
begin
try
//init
case zzok(imainhelp,7227) of
true:result:=imainhelp;
false:begin
   xonce:=not xhaveright;
   imainhelp:=tmainhelp.create(xright);
   imainhelp.oautoheight:=true;
   result:=imainhelp;
   if xonce then setrightparams(programhelp_minwidth,programhelp_maxwidth,programhelp_gap,programhelp_max,true);
   end;
end;//case
except;end;
end;
//## xhead ##
function tbasicscroll.xhead:tbasichead;
begin
try
//init
case zzok(ihead,7218) of
true:result:=ihead;
false:begin
   ihead:=tbasichead.create(self);
   //ihead.osyssize:=true;//01mar2022
   result:=ihead;
   end;
end;//case
except;end;
end;
//## xhelp ##
function tbasicscroll.xhelp:tbasichelp;//realtime help scroller
begin
try
//init
case zzok(ihelp,7219) of
true:result:=ihelp;
false:begin
   ihelp:=tbasichelp.create(self);
   result:=ihelp;
   end;
end;//case
except;end;
end;
//## xtoolbar ##
function tbasicscroll.xtoolbar:tbasictoolbar;
var
  str1:string;
begin
try
//init
case zzok(itoolbar,7220) of
true:result:=itoolbar;
false:begin
   itoolbar:=tbasictoolbar.create(self);
   result:=itoolbar;
   end;
end;//case
except;end;
end;
//## xtoolbar2 ##
function tbasicscroll.xtoolbar2:tbasictoolbar;
begin
try
//init
case zzok(itoolbar2,7221) of
true:result:=itoolbar2;
false:begin
   itoolbar2:=tbasictoolbar.create(self);
   result:=itoolbar2;
   with result do
   begin
   omarkcleanly:=false;//03mar2021
   bordersize:=0;
   oasbuttons:=true;
   orighttoleft:=true;
   normal:=true;
   osepv:=1;//11oct2020
   end;
   end;
end;//case
except;end;
end;
//## xhigh ##
function tbasicscroll.xhigh:tbasicscroll;
begin
try
//init
case zzok(ihigh,7222) of
true:result:=ihigh;
false:begin
   ihigh:=tbasicscroll.create(self);
   result:=ihigh;
   with result do
   begin
   bordersize:=0;
   normal:=true;
   oautoheight:=true;//21feb2021
   static:=true;
   scroll:=false;
   end;
   end;
end;//case
except;end;
end;
//## xhigh2 ##
function tbasicscroll.xhigh2:tbasicscroll;
begin
try
//init
case zzok(ihigh2,7223) of
true:result:=ihigh2;
false:begin
   ihigh2:=tbasicscroll.create(self);
   result:=ihigh2;
   with result do
   begin
   bordersize:=0;
   normal:=true;
   oautoheight:=true;//21feb2021
   static:=true;
   scroll:=false;
   end;
   end;
end;//case
except;end;
end;
//## xpage ##
function tbasicscroll.xpage(xpagename:string;xstatic:boolean):tbasicscroll;
begin
//was: try;result:=xpage3(xpagename,'','','',tepNone,1,xstatic);except;end;
try;result:=xpage3(xpagename,'','','',tepNone,0,xstatic);except;end;
end;
//## xpage2 ##
function tbasicscroll.xpage2(xpagename,xtoplink,xbotlink,xhelp:string;xtep:longint;xstatic:boolean):tbasicscroll;
begin
//was: try;result:=xpage3(xpagename,xtoplink,xbotlink,xhelp,xtep,1,xstatic);except;end;
try;result:=xpage3(xpagename,xtoplink,xbotlink,xhelp,xtep,0,xstatic);except;end;
end;
//## xpage3 ##
function tbasicscroll.xpage3(xpagename,xtoplink,xbotlink,xhelp:string;xtep,xtopspace:longint;xstatic:boolean):tbasicscroll;
begin
try
result:=tbasicscroll.create(self);
result.opagename:=xpagename;
result.oautoheight:=true;
result.static:=xstatic;
result.otopspace:=frcmin(xtopspace,0);
//.toplink
if (xtoplink<>'') then xtoolbar.add(xtoplink,xtep,0,scPage+xpagename,xhelp);
//.botlink
if (xbotlink<>'') then xtoolbar2.add(xbotlink,xtep,0,scPage+xpagename,xhelp);
except;end;
end;
//## xmenu ##
function tbasicscroll.xmenu:tbasicmenu;
begin
try
//init
case zzok(imenu,7225) of
true:result:=imenu;
false:begin
   imenu:=tbasicmenu.create(self);
   result:=imenu;
   end;
end;//case
except;end;
end;
//## xstatus ##
function tbasicscroll.xstatus:tbasicstatus;
begin
try
//init
case zzok(istatus,7226) of
true:result:=istatus;
false:begin
   istatus:=tbasicstatus.create(self);
   result:=istatus;
   end;
end;//case
except;end;
end;
//## xstatus2 ##
function tbasicscroll.xstatus2:tbasicstatus;
begin
try
//init
case zzok(istatus2,7227) of
true:result:=istatus2;
false:begin
   istatus2:=tbasicstatus.create(self);
   result:=istatus2;
   end;
end;//case
except;end;
end;
//## xcols ##
function tbasicscroll.xcols:tbasiccols;//standard
begin
try
//init
case zzok(icols,7228) of
true:result:=icols;
false:begin
   icols:=tbasiccols.create(self);
   result:=icols;
   end;
end;//case
except;end;
end;
//## xcolsh ##
function tbasicscroll.xcolsh:tbasiccols;//autoheight version
begin
try
//init
case zzok(icols,7229) of
true:result:=icols;
false:begin
   icols:=tbasiccols.create(self);
   result:=icols;
   end;
end;//case
//apply each time -> allows for each new child to be checked
if zzok(result,7230) then result.makeautoheight;//applies to self and all currently created children - 26feb2021
except;end;
end;
//## xhaveright ##
function tbasicscroll.xhaveright:boolean;
begin
try;result:=zzok(iright,7231);except;end;
end;
//## xhavemainhelp ##
function tbasicscroll.xhavemainhelp:boolean;
begin
try;result:=zzok(imainhelp,7232);except;end;
end;
//## xhavehead ##
function tbasicscroll.xhavehead:boolean;
begin
try;result:=zzok(ihead,7231);except;end;
end;
//## xhavehelp ##
function tbasicscroll.xhavehelp:boolean;
begin
try;result:=zzok(ihelp,7232);except;end;
end;
//## xhavemenu ##
function tbasicscroll.xhavemenu:boolean;
begin
try;result:=zzok(imenu,7234);except;end;
end;
//## xhavetoolbar ##
function tbasicscroll.xhavetoolbar:boolean;
begin
try;result:=zzok(itoolbar,7235);except;end;
end;
//## xhavestatus2 ##
function tbasicscroll.xhavestatus2:boolean;
begin
try;result:=zzok(istatus2,7236);except;end;
end;
//## xhavehigh ##
function tbasicscroll.xhavehigh:boolean;
begin
try;result:=zzok(ihigh,7237);except;end;
end;
//## xhavehigh2 ##
function tbasicscroll.xhavehigh2:boolean;
begin
try;result:=zzok(ihigh2,7238);except;end;
end;
//## xhavecols ##
function tbasicscroll.xhavecols:boolean;
begin
try;result:=zzok(icols,7239);except;end;
end;
//## xhavetoolbar2 ##
function tbasicscroll.xhavetoolbar2:boolean;
begin
try;result:=zzok(itoolbar2,7240);except;end;
end;
//## xhavestatus ##
function tbasicscroll.xhavestatus:boolean;
begin
try;result:=zzok(istatus,7241);except;end;
end;

//## tbasicsetcolor ############################################################
//## create2 ##
constructor tbasicsetcolor.create2(xparent:tobject;xscroll,xstart:boolean);
var
   xtmp:tbasiccontrol;
begin
satinc(satSetcolor,1);
inherited create2(xparent,false,false);//force "xscroll=false" - fixed 02aug2021
//vars
ilocksync:=false;
icanfillundo:=true;
//controls
//.toolbar
xtoolbar.add('Revert',tepRefresh20,0,'revert','Revert to orginal color');
xtoolbar.add('Menu',tepMenu20,0,'menu','Show color menu');
xtoolbar.add('Static',tepColors20,0,'static','Show static colors');
xtoolbar.add('History',tepColorHistory20,0,'history','Show color history');
xtoolbar.add('Invert',tepInvert20,0,'invert','Invert color');
xtoolbar.add('Undo',tepUndo20,0,'undo','Undo last color change');
//.color matrix
xtmp:=ntitle(false,'Color Matrix','');
im:=ncolormatrix;
im.oautoheight:=true;
xtmp.help:=im.help;//clone hlpe

//.columns
with xhigh2.xcolsh.cols2[0,50,false] do
begin
ntitle(false,'Color Levels','Click and drag to adjust the red, green and blue elements of the color');
ir:=nint2('Red','Adjust red level 0-255',0,255,127,0,'red');
ig:=nint2('Green','Adjust green level 0-255',0,255,127,0,'green');
ib:=nint2('Blue','Adjust blue level 0-255',0,255,127,0,'blue');
end;

with xhigh2.xcolsh.cols2[1,50,false] do
begin
ntitle(false,'Color / Shade','Current color and shade range');
ic:=ncolor('Color','Current color');
ic.opopcolor:=false;
ic.oautoheight:=true;
end;

//default color
icolor:=0;
irevertcolor:=0;
iundocolor:=0;
color:=low__rgb(127,127,127);//sync all controls

//events
ir.onvalue2:=__oncolor;
ig.onvalue2:=__oncolor;
ib.onvalue2:=__oncolor;
im.oncolor:=__oncolor;
ic.oncolor:=__oncolor;
xtoolbar.onclick:=__onclick;

ir.onnotify:=ext__onnotify;
ig.onnotify:=ext__onnotify;
ib.onnotify:=ext__onnotify;
im.onnotify:=ext__onnotify;
ic.onnotify:=ext__onnotify;

//defaults
clientheight:=32;
help:='Click on color matrix to acquire color | Hold down and drag to continuously acquire color | Alternatively drag outside matrix to acquire screen color';

//start
if xstart then start;//02aug2021
end;
//## destroy ##
destructor tbasicsetcolor.destroy;
begin
try
inherited destroy;
satinc(satSetcolor,-1);
except;end;
end;
//## ext__onnotify ##
function tbasicsetcolor.ext__onnotify(sender:tobject):boolean;
begin
try
result:=true;
if gui.mouseupstroke then
   begin
   icanfillundo:=true;
   end;
except;end;
end;
//## setparams ##
procedure tbasicsetcolor.setparams(xcolor,xrevertcolor:longint;xpage:string);
begin
try
iundocolor:=xrevertcolor;
irevertcolor:=xrevertcolor;
color:=xcolor;
if (xpage<>'matrix') and (xpage<>'static') then xpage:='matrix';
page:=xpage;
except;end;
end;
//## getparams ##
procedure tbasicsetcolor.getparams(var xcolor,xrevertcolor:longint;var xpage:string);
begin
try;xcolor:=color;xrevertcolor:=irevertcolor;xpage:=page;except;end;
end;
//## setcolor ##
procedure tbasicsetcolor.setcolor(x:longint);
var
   v:tint4;
begin
try
//init
if icanfillundo then
   begin
   icanfillundo:=false;
   iundocolor:=icolor;
   end;
//get
if low__setint(icolor,x) then
   begin
   v.val:=x;
   try
   ilocksync:=true;
   if zzok(ir,7250) then ir.val:=v.r;
   if zzok(ig,7251) then ig.val:=v.g;
   if zzok(ib,7252) then ib.val:=v.b;
   if zzok(im,7253) then im.color:=v.val;
   if zzok(ic,7254) then ic.color:=v.val;
   except;end;
   ilocksync:=false;
   //event
   if assigned(foncolor) then foncolor(self,v.val);
   end;
except;end;
end;
//## __onclick ##
procedure tbasicsetcolor.__onclick(sender:tobject);
var
   n:string;
   int1:longint;
begin
try
if xhavetoolbar and (sender=xtoolbar) then
   begin
   n:=low__lowercase(xtoolbar.ocode2);
   if (n='menu') then
      begin
      ic.showmenu;
      icanfillundo:=true;
      end
   else if (n='static') then
      begin
      icanfillundo:=true;
      int1:=icolor;
      if gui.popcolorstatic(int1) then color:=int1;
      icanfillundo:=true;
      end
   else if (n='history') then
      begin
      icanfillundo:=true;
      int1:=icolor;
      if gui.popcolorhistory(int1) then color:=int1;
      icanfillundo:=true;
      end
   else if (n='revert') then
      begin
      icanfillundo:=true;
      color:=revertcolor;
      icanfillundo:=true;
      end
   else if (n='invert') then
      begin
      icanfillundo:=true;
      color:=low__invertb(color);
      icanfillundo:=true;
      end
   else if (n='undo') then
      begin
      icanfillundo:=true;
      color:=iundocolor;
      icanfillundo:=true;
      end;
   end;
except;end;
end;
//## __oncolor ##
procedure tbasicsetcolor.__oncolor(sender:tobject;xval:longint);
var
   v:tint4;
begin
try
//check
if ilocksync then exit;
//init
v.val:=icolor;
//get
if      (sender=ir) then v.r:=ir.val
else if (sender=ig) then v.g:=ig.val
else if (sender=ib) then v.b:=ib.val
else if (sender=im) then v.val:=im.color
else if (sender=ic) then v.val:=ic.color;
//set
color:=v.val;
except;end;
end;

//## tbasiccolormatrix #########################################################
//xxxxxxxxxxxxxxxxxxxxxxxxx//zzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
//## create2 ##
constructor tbasiccolormatrix.create2(xparent:tobject;xstart:boolean);
begin
satinc(satColmatrix,1);
inherited create2(xparent,false);
icolor:=low__rgb(127,127,127);
clientheight:=32;
help:='Click on color matrix to acquire color | Hold down and drag to continuously acquire color | Alternatively drag outside matrix to acquire screen color';
//start
if xstart then start;//02aug2021
end;
//## destroy ##
destructor tbasiccolormatrix.destroy;
begin
try
inherited destroy;
satinc(satColmatrix,-1);
except;end;
end;
//## _onpaint ##
procedure tbasiccolormatrix._onpaint(sender:tobject);
var
   //infovars
   a:pvirtualinfo;
   cs,ci:trect;
   fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xenabled,xround,xnormal:boolean;
begin
try
//init
infovars(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);
//cls
ldm(ci,xround);
//frame
if (xbordersize>=1) then ldf2(cs,xborder,xborder,xback,xbordersize,0,'',nil,xround);
//was: xparentcorners;
except;end;
end;
//## _onnotify ##
function tbasiccolormatrix._onnotify(sender:tobject):boolean;
begin
try
//not handled
result:=true;
//event
if gui.mousedown and (gui.mousedownstroke or gui.mousemoved) then color:=low__capcolor(0,0,true);

//external event override - 01mar2021
if assigned(fonnotify) then fonnotify(sender);
except;end;
end;
//## setcolor ##
procedure tbasiccolormatrix.setcolor(x:longint);
begin
try;if low__setint(icolor,x) and assigned(foncolor) then foncolor(self,icolor);except;end;
end;

//## tbasicbwp #################################################################
//xxxxxxxxxxxxxxxxxxxxxxxxxxx//wwwwwwwwwwwwwwwwwwwwwwwwwwwww
//## create ##
constructor tbasicbwp.create(xparent:tobject);
begin
create2(xparent,true);
end;
//## create2 ##
constructor tbasicbwp.create2(xparent:tobject;xstart:boolean);
begin
//self
satinc(satBWP,1);
inherited create2(xparent,false);
//vars
fonact:=nil;//19jun2022
imustscrollv:=-1;//off
imustscrollh:=-1;//off
imustpos:=-1;//off
imustpos2:=-1;//off
vsmooth:=true;//scroll by pixels instead of by lines - 21jun2022
ousecolorise:=true;//21jun2022
ocanshowmenu:=true;
ibuildingcontrol:=true;
irevertdata:=nil;
omenustyles:=false;
ocopystyles:=true;
orows:=false;
inormal:=true;
ibordersize:=1;
islowdownref:=ms64;
itimersync:=ms64;
itimersync_fastcount:=0;
//.margin
imleft:=2;
imright:=2;
imtop:=0;
imbottom:=0;
//.h
ih:=nscrollbar('Click and drag to scroll',true);
ih.overtical:=false;
ih.ofullhandling:=false;
//.v
iv:=nscrollbar('Click and drag to scroll',true);
iv.overtical:=true;
iv.ofullhandling:=false;
//.core
low__wordcore(icore,'init',nil);
low__wordcore_str(icore,'cursorpos','0');
iusepagecolor:=false;
syncdef;

//events
iv.onpos:=_onpos;
iv.onarrow:=_onarrow;//redirect up/down scrolling to wordcore's "vwheel()" proc handler when "vsmooth=true" - 21jun2022
ih.onpos:=_onpos;

//defaults
ibuildingcontrol:=false;
clientheight:=100;
xsync;
syscols:=true;
undoenabled:=true;//21jun2022
//start
if xstart then start;
end;
//## destroy ##
destructor tbasicbwp.destroy;
begin
try
ibuildingcontrol:=true;
low__wordcore(icore,'free',nil);
bfree(irevertdata);
inherited destroy;
satinc(satBWP,-1);
except;end;
end;
//## getundoenabled ##
function tbasicbwp.getundoenabled:boolean;
begin
try;result:=icore.menabled;except;end;
end;
//## setundoenabled ##
procedure tbasicbwp.setundoenabled(x:boolean);
begin
try;low__wordcore(icore,low__aorbstr('undooff','undoon',x),nil);except;end;
end;
//## undoclear ##
procedure tbasicbwp.undoclear;
begin
try;low__wordcore(icore,'undoclear',nil);except;end;
end;
//## undoon ##
procedure tbasicbwp.undoon;
begin
try;undoenabled:=true;except;end;
end;
//## undooff ##
procedure tbasicbwp.undooff;
begin
try;undoenabled:=false;except;end;
end;
//## xcan ##
function tbasicbwp.xcan(x:string):boolean;
begin
try
//defaults
result:=false;
x:=low__lowercase(x);
//filters
if (x='canpastereplace') then x:='canpaste';
//get
if (x='canundo') or (x='canredo') or (x='cancut') or (x='cancopy') or (x='cancopyall') or (x='canpaste') or (x='canclearall') then result:=low__wordcore(icore,x,nil);
except;end;
end;
//## canundo ##
function tbasicbwp.canundo:boolean;
begin
result:=xcan('canundo');
end;
//## canredo ##
function tbasicbwp.canredo:boolean;
begin
result:=xcan('canredo');
end;
//## cancut ##
function tbasicbwp.cancut:boolean;
begin
result:=xcan('cancut');
end;
//## cancopy ##
function tbasicbwp.cancopy:boolean;
begin
result:=xcan('cancopy');
end;
//## cancopyall ##
function tbasicbwp.cancopyall:boolean;
begin
result:=xcan('cancopyall');
end;
//## canpaste ##
function tbasicbwp.canpaste:boolean;
begin
result:=xcan('canpaste');
end;
//## canpastereplace ##
function tbasicbwp.canpastereplace:boolean;
begin
result:=xcan('canpastereplace');
end;
//## candeleteall ##
function tbasicbwp.candeleteall:boolean;//has undo
begin
result:=xcan('candeleteall');
end;
//## cancopy ##
function tbasicbwp.canclearall:boolean;
begin
result:=xcan('canclearall');
end;
//## xact ##
function tbasicbwp.xact(x:string;var e:string):boolean;
label
   skipend;
var
   xformat:string;
begin
try
//defaults
result:=false;
e:=gecTaskfailed;
x:=low__lowercase(x);
//init
case frcmax(low__wordcore__findformatlevel(icore),icore.maxformatlevel) of//0=plaintext, 1=enhanced text, 2=advanced text (default) - 12jun2022
0:xformat:='txt';
1:xformat:='bwd';
2:xformat:='bwp';
else xformat:='txt';
end;

xformat:='multi';//xxxxxxxxxxxxxxxxxxxx
//get
if (x='undo') or (x='redo') or (x='copy') or (x='copyall') or (x='paste') or (x='pastereplace') or (x='deleteall') or (x='clearall') then
   begin
   if not low__wordcore_str(icore,x,xformat) then goto skipend;
   end
else goto skipend;
//events
if ((x='paste') or (x='pastereplace')) and assigned(fonact) then fonact(self,x);
//successful
result:=true;
skipend:
except;end;
end;
//## _onarrow ##
procedure tbasicbwp._onarrow(sender:tobject;var xmoveval:longint);
begin
try
if (sender=iv) and vsmooth then
   begin
   low__wordcore_str(icore,'vwheel',inttostr(-xmoveval));
   xmoveval:=0;
   end;
except;end;
end;
//## makeplaintext1 ##
procedure tbasicbwp.makeplaintext1;
begin
makexxx(0,1,false);
end;
//## maketxt1 ##
procedure tbasicbwp.maketxt1;
begin
makexxx(0,1,false);
end;
//## makebwd1 ##
procedure tbasicbwp.makebwd1;
begin
makexxx(1,1,false);
end;
//## makebwp1 ##
procedure tbasicbwp.makebwp1;
begin
makexxx(2,1,false);
end;
//## makeplaintext2 ##
procedure tbasicbwp.makeplaintext2;
begin
makexxx(0,2,false);
end;
//## maketxt2 ##
procedure tbasicbwp.maketxt2;
begin
makexxx(0,2,false);
end;
//## makebwd2 ##
procedure tbasicbwp.makebwd2;
begin
makexxx(1,2,false);
end;
//## makebwp2 ##
procedure tbasicbwp.makebwp2;
begin
makexxx(2,2,false);
end;
//## makebwpFull ##
procedure tbasicbwp.makebwpFull;
begin
makexxx(2,0,false);
end;
//## makexxx ##
procedure tbasicbwp.makexxx(xformatlevel:longint;xuseonefont:longint;xviewurl:boolean);//12jun2022
begin
try
//range
xformatlevel:=frcrange(xformatlevel,0,2);//0=txt, 1=bwd, 2=bwp
//get
omenustyles:=(xformatlevel>=1);
core.oviewurl:=false;//disable click to view http:// urls
case xuseonefont of
2:begin
   core.onefontname:='$fontname2';//05feb2022
   core.onefontsize:=1;//viFontsize2 - system size - 05feb2022
   end;
1:begin
   core.onefontname:='$fontname';//05feb2022
   core.onefontsize:=0;//viFontsize - system size - 05feb2022
   end;
else
   begin
   core.onefontname:='';
   core.onefontsize:=-1;
   end;
end;//case
core.maxformatlevel:=xformatlevel;//plain text only - 12jun2022
except;end;
end;
//## setsyscols ##
procedure tbasicbwp.setsyscols(x:boolean);
begin
try;low__wordcore_str(icore,'pageoverride2',bnc(x));except;end;
end;
//## getsyscols ##
function tbasicbwp.getsyscols:boolean;
begin
try;result:=icore.pageoverride2;except;end;
end;
//## vscrolltopos ##
procedure tbasicbwp.vscrolltopos(xpos:longint);
var
   int1:longint;
begin
try
int1:=low__wordcore_str2(icore,'pos>line',inttostr(xpos));
scrollto(int1,-1,-1,-1,false);
except;end;
end;
//## scrollto ##
procedure tbasicbwp.scrollto(_vpos,_hpos,_pos,_pos2:longint;xforcewrapall:boolean);
begin
try
if xforcewrapall then low__wordcore(icore,'wrapall',nil);//wrap will complete BEFORE any scrolling is performed - 18dec2021
imustscrollv:=_vpos;
imustscrollh:=_hpos;
imustpos:=_pos;
imustpos2:=_pos2;
except;end;
end;
//## revertinit ##
procedure tbasicbwp.revertinit(xdata:tstr8;xenable:boolean);
begin
try
block(xdata);
if xenable then
   begin
   if zznil(irevertdata,2324) then irevertdata:=bnew;
   irevertdata.clear;
   irevertdata.add(xdata);
   end
else bfree(irevertdata)
except;end;
try;bunlockautofree(xdata);except;end;
end;
//## showmenuFill ##
procedure tbasicbwp.showmenuFill(xstyle:string;xmenudata:tstr8;var ximagealign:longint;var xmenuname:string);//24sep2022
var
   m:tstr8;//pointer only
   xcode,xtepcolor:longint;
   xcode2:string;
   bol1,xhavedata,xselok,xcancut,xcancopy,xcanpaste,xcanundo,xcanredo,xreadonly:boolean;
begin
try
//check
if zznil(xmenudata,2325) then exit else m:=xmenudata;
xmenuname:='bwp.1';
//checkers

//init
xreadonly:=oreadonly;
xselok:=(low__wordcore2(icore,'selcount',nil)>=1);
xcanpaste:=low__wordcore(icore,'canpaste',nil);//xxxxxxxxxxxxlow__canpastetxt or
xcanundo:=low__wordcore(icore,'canundo',nil);
xcanredo:=low__wordcore(icore,'canredo',nil);
xhavedata:=(icore.data.len>=2);

//get
low__menutitle(m,tepNone,'Edit','Edit');
if (not xreadonly) and zzok(irevertdata,7257) then
   begin
   low__menuitem2(m,teprefresh20,'Revert...','Revert to original text','bwp.revert',100,aknone,not xreadonly);
   low__menusep(m);
   end;
if (not xreadonly) then
   begin
   if icore.menabled then
      begin
      low__menuitem2(m,tepredo20,'Redo','Redo last change','bwp.redo',100,akctrlR,xcanredo);
      low__menuitem2(m,tepundo20,'Undo','Undo last change','bwp.undo',100,akctrlU,xcanundo);
      end;
   end;
if not xreadonly then
   begin
   low__menuitem2(m,tepcut20,'Cut','Cut text to clipboard','bwp.cutmulti',100,akctrlT,xselok and (not xreadonly));//26sep2022
//was:   low__menuitem2(m,tepclose20,'Delete All','Delete all text','bwp.deleteall',100,aknone,low__wordcore(icore,'candeleteall',nil));//28jun2022, 19jun2022
   end;
//low__menuitem2(m,tepcopy20,'Copy','Copy text to clipboard','bwp.copytxt',100,akctrlC,xselok);
low__menuitem2(m,tepcopy20,'Copy','Copy text to clipboard','bwp.copymulti',100,akctrlC,xselok);//26sep2022
low__menuitem2(m,tepcopy20,'Copy as Plain Text','Copy as plain text to clipboard','bwp.copytxt',100,akctrlC,xselok);//26sep2022
low__menuitem2(m,tepcopy20,'Copy All','Copy all text to clipboard','bwp.copyallmulti',100,aknone,true);//26sep2022
if omenustyles and ocopystyles then//18jun2022
   begin
   low__menuitem2(m,tepcopy20,'Copy Enhanced','Copy enhanced text to clipboard','bwp.copybwd',100,aknone,xselok);
   low__menuitem2(m,tepcopy20,'Copy All Enhanced','Copy all enhanced text to clipboard','bwp.copyallbwd',100,aknone,true);
   low__menuitem2(m,tepcopy20,'Copy Advanced','Copy enhanced text to clipboard','bwp.copybwp',100,aknone,xselok);
   low__menuitem2(m,tepcopy20,'Copy All Advanced','Copy all enhanced text to clipboard','bwp.copyallbwp',100,aknone,true);
   end;
if not xreadonly then
   begin
   low__menuitem2(m,teppaste20,'Paste','Paste text from clipboard','bwp.paste',100,akctrlP,xcanpaste and (not xreadonly));
   low__menuitem2(m,teppaste20,'Replace All','Replace with text from clipboard','bwp.pastereplace',100,aknone,xcanpaste and (not xreadonly));
   end;
low__menuitem2(m,tepselectall20,'Select All','Select all text','bwp.selectall',100,aknone,true);
if not xreadonly then low__menuitem2(m,tepclose20,'Delete All','Delete all text','bwp.deleteall',100,aknone,low__wordcore(icore,'candeleteall',nil));//28jun2022, 19jun2022

//.menu styles
if (not xreadonly) and omenustyles then
   begin
   bol1:=true;
   low__menutitle(m,tepNone,'Style','Set style');
   low__menuitem2(m,tep__yes((not icore.cbold) and (not icore.citalic) and (not icore.cunderline) and (not icore.cstrikeout) and (icore.cbk=clnone)),'Normal','Normal','bwp.normal',100,akctrlN,bol1);
   low__menuitem2(m,tep__yes(icore.cbold),'Bold','Bold','bwp.bold',100,akctrlB,bol1);
   low__menuitem2(m,tep__yes(icore.citalic),'Italic','Italic','bwp.italic',100,akctrlI,bol1);
   low__menuitem2(m,tep__yes(icore.cunderline),'Underline','Underline','bwp.underline',100,akctrlD,bol1);
   low__menuitem2(m,tep__yes(icore.cstrikeout),'Strikeout','Strikeout','bwp.strikeout',100,akctrlK,bol1);
   low__menuitem2(m,tep__yes(icore.cbk<>clnone),'Highlight','Highlight','bwp.highlight',100,akctrlH,bol1);//19jun2022
   if (icore.maxformatlevel>=2) then
      begin
      low__menutitle(m,tepNone,'Alignment','Set alignment');
      low__menuitem2(m,tep__tick(icore.calign=0),'Left','Align left','bwp.left',100,aknone,true);
      low__menuitem2(m,tep__tick(icore.calign=1),'Center','Align center','bwp.center',100,aknone,true);
      low__menuitem2(m,tep__tick(icore.calign=2),'Right','Align right','bwp.right',100,aknone,true);
      end;
   end;
if (not xreadonly) then
   begin
   //if omenustyles then low__menutitle(m,tepNone,'Adjust','Adjustments') else low__menusep(m);
   low__menutitle(m,tepNone,'Adjust','Apply adjustment');
   low__menuitem2(m,tepUpper20,ntranslate('Upper Case'),'Make text upper case - ABCD','bwp.uppercase',100,aknone,xselok);//27mar2022
   low__menuitem2(m,tepLower20,ntranslate('Lower Case'),'Make text lower case - abcd','bwp.lowercase',100,aknone,xselok);
   end;
except;end;
end;
//## showmenuClick ##
function tbasicbwp.showmenuClick(sender:tobject;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean;
var
   e:string;
begin
try
//handled
result:=true;
//information
if (xcode2='bwp.revert') then
   begin
   if zzok(irevertdata,7258) and gui.popquery2('Revert to original text and discard any changes?','','Revert',false) then iosetbwp(irevertdata);
   end
//.undo
else if (xcode2='bwp.undo')         then low__wordcore_str(icore,'undo','')//25jun2022
else if (xcode2='bwp.redo')         then low__wordcore_str(icore,'redo','')//25jun2022
//.cut
else if (xcode2='bwp.cutmulti')     then low__wordcore_str(icore,'cut','multi')//26sep2022
else if (xcode2='bwp.cuttxt')       then low__wordcore_str(icore,'cut','txt')
else if (xcode2='bwp.cutbwd')       then low__wordcore_str(icore,'cut','bwd')
else if (xcode2='bwp.cutbwp')       then low__wordcore_str(icore,'cut','bwp')
else if (xcode2='bwp.cutrtf')       then low__wordcore_str(icore,'cut','rtf')
//.copy
else if (xcode2='bwp.copymulti')    then low__wordcore_str(icore,'copy','multi')//26sep2022
else if (xcode2='bwp.copytxt')      then low__wordcore_str(icore,'copy','txt')
else if (xcode2='bwp.copybwd')      then low__wordcore_str(icore,'copy','bwd')
else if (xcode2='bwp.copybwp')      then low__wordcore_str(icore,'copy','bwp')
else if (xcode2='bwp.copyrtf')      then low__wordcore_str(icore,'copy','rtf')
//.copy all
else if (xcode2='bwp.copyallmulti') then low__wordcore_str(icore,'copyall','multi')//26sep2022
else if (xcode2='bwp.copyalltxt')   then low__wordcore_str(icore,'copyall','txt')
else if (xcode2='bwp.copyallbwd')   then low__wordcore_str(icore,'copyall','bwd')
else if (xcode2='bwp.copyallbwp')   then low__wordcore_str(icore,'copyall','bwp')
else if (xcode2='bwp.copyallrtf')   then low__wordcore_str(icore,'copyall','rtf')//22jun2022
//.paste
else if (xcode2='bwp.paste')        then xact('paste',e)
else if (xcode2='bwp.pastereplace') then xact('pastereplace',e)

//.select
else if (xcode2='bwp.selectall')    then low__wordcore(icore,'selectall',nil)
else if (xcode2='bwp.clearall')     then//no undo
   begin
   if zzok(irevertdata,7257) or undoenabled or gui.popquery('Clear all?') then low__wordcore(icore,'clearall',nil);
   end
else if (xcode2='bwp.deleteall')     then//has undo
   begin
   if zzok(irevertdata,7257) or undoenabled or gui.popquery('Delete all?') then low__wordcore(icore,'deleteall',nil);
   end
//.menu styles
else if (xcode2='bwp.normal')       then low__wordcore_str(icore,'style','normal')
else if (xcode2='bwp.bold')         then low__wordcore_str(icore,'style','bold')
else if (xcode2='bwp.italic')       then low__wordcore_str(icore,'style','italic')
else if (xcode2='bwp.underline')    then low__wordcore_str(icore,'style','underline')
else if (xcode2='bwp.strikeout')    then low__wordcore_str(icore,'style','strikeout')
else if (xcode2='bwp.highlight')    then low__wordcore_str(icore,'style','highlight')
else if (xcode2='bwp.uppercase')    then low__wordcore_str(icore,'style','uppercase')
else if (xcode2='bwp.lowercase')    then low__wordcore_str(icore,'style','lowercase')
//.menu align
else if (xcode2='bwp.left')         then low__wordcore_str(icore,'align','l')
else if (xcode2='bwp.center')       then low__wordcore_str(icore,'align','c')
else if (xcode2='bwp.right')        then low__wordcore_str(icore,'align','r')

//not handled
else result:=false;
except;end;
end;
//## margin ##
procedure tbasicbwp.margin(xl,xt,xr,xb:longint);
const
   xmax=500;
var
   bol1:boolean;
begin
try
bol1:=false;
if low__setint(imleft,frcrange(xl,0,xmax)) then bol1:=true;
if low__setint(imtop,frcrange(xt,0,xmax)) then bol1:=true;
if low__setint(imright,frcrange(xr,0,xmax)) then bol1:=true;
if low__setint(imbottom,frcrange(xb,0,xmax)) then bol1:=true;
if bol1 then
   begin
   alignnow;
   paintnow;
   end;
except;end;
end;
//## setwrap ##
procedure tbasicbwp.setwrap(x:longint);//0=no wrap, 1=to window, 2=to page (default)
begin
try;low__wordcore_str2(icore,'wrapstyle',inttostr(x));except;end;
end;
//## getwrap ##
function tbasicbwp.getwrap:longint;
begin
try;result:=low__wordcore2(icore,'wrapstyle',nil);except;end;
end;
//## setwrapreadonly ##
procedure tbasicbwp.setwrapreadonly(x:boolean);//true=prevents wrapstyle from changing during "ioset()" operations - 12mar2021
begin
try;icore.wrapreadonly:=x;except;end;
end;
//## getwrapreadonly ##
function tbasicbwp.getwrapreadonly:boolean;
begin
try;result:=icore.wrapreadonly;except;end;
end;
//## getroundstyle ##
function tbasicbwp.getroundstyle:longint;
begin
try;result:=oroundstyle;except;end;
end;
//## setroundstyle ##
procedure tbasicbwp.setroundstyle(x:longint);
begin
try
oroundstyle:=x;
iv.oroundstyle:=x;
ih.oroundstyle:=x;
except;end;
end;
//## syncdef ##
procedure tbasicbwp.syncdef;//06oct2020
begin
try
with icore do
begin
defFontname   :=vifontname;
defFontsize   :=vifontsize__root;//non-zoomed version
defFontcolor  :=vinormal.font;
pagecolor     :=vinormal.background;
pageselcolor  :=vinormal.highlight;
pagefontselcolor:=vinormal.fonthighlight;
viewcolor     :=low__dc(pagecolor,50);
end;
except;end;
end;
//## getreadonly ##
function tbasicbwp.getreadonly:boolean;
begin
try;result:=icore.readonly;except;end;
end;
//## setreadonly ##
procedure tbasicbwp.setreadonly(x:boolean);
begin
try;icore.readonly:=x;except;end;
end;
//## makeviewonly ##
function tbasicbwp.makeviewonly:tbasicbwp;
begin
try
result:=self;
result.oautoheight:=true;
icore.readonly:=true;
icore.showcursor:=false;
except;end;
end;
//## claudesupport ##
function tbasicbwp.claudesupport:tbasicbwp;
begin
try
result:=self;
//..claude colors
if (programhelp__claudetext1<>clnone) or (programhelp__claudeheader1<>clnone) then
   begin
   icore.useclaudecolors:=true;
   icore.claude_text1:=programhelp__claudetext1;
   icore.claude_text2:=programhelp__claudetext1;
   icore.claude_text3:=programhelp__claudetext1;
   icore.claude_text4:=programhelp__claudetext1;
   icore.claude_text5:=programhelp__claudetext1;
   icore.claude_header1:=programhelp__claudeheader1;
   icore.claude_header2:=programhelp__claudeheader1;
   icore.claude_header3:=programhelp__claudeheader1;
   icore.claude_header4:=programhelp__claudeheader1;
   icore.claude_header5:=programhelp__claudeheader1;
   end;
//..other colors
icore.pagecolor:=rgb(255,255,255);
if (programhelp__bgcolor<>clnone) then icore.pagecolor:=programhelp__bgcolor;
icore.viewcolor:=icore.pagecolor;
except;end;
end;
//## getcore ##
function tbasicbwp.getcore:pwordcore;
begin
try;result:=@icore;except;end;
end;
//## ioset ##
function tbasicbwp.ioset(xdata:tstr8):boolean;
begin
try;result:=ioset3(xdata,-1,-1,-1,-1,false,false);except;end;
end;
//## ioset2 ##
function tbasicbwp.ioset2(xdata:tstr8;xvpos:longint):boolean;
begin
try;result:=ioset3(xdata,xvpos,-1,-1,-1,false,false);except;end;
end;
//## ioset3 ##
function tbasicbwp.ioset3(xdata:tstr8;xvpos,xhpos,xpos,xpos2:longint;xtransform,xwebimages:boolean):boolean;
begin
try
low__wordcore_str(icore,'clear2','');//leaves UNDO alone - 27sep2022
result:=low__wordcore(icore,'ioset',xdata);
if xtransform then low__wordcore(icore,'transform'+low__insstr('.webimages',xwebimages),nil);//25jul2021, 15may2021
low__wordcore_str(icore,'cursorpos','0');
low__wordcore_str(icore,'vpos',inttostr(frcmin(xvpos,0)));//may not always work due to wordwrap needing to calc in realtime before this can be probably applied - 06oct2020
low__wordcore_str(icore,'hpos',inttostr(frcmin(xhpos,0)));//may not always work due to wordwrap needing to calc in realtime before this can be probably applied - 06oct2020
undoclear;//wipe undo - 26sep2022
xsync;//12mar2021
//.delayed scroll - 18dec2021
if (xvpos>=0) or (xhpos>=0) or (xpos>=0) or (xpos2>=0) then scrollto(xvpos,xhpos,xpos,xpos2,true);
itimersync_fastcount:=20;//20 fast cycles
except;end;
end;
//## ioget ##
function tbasicbwp.ioget(xdata:tstr8;xformat:string):boolean;
var
   str2,e:string;
begin
try
result:=false;
block(xdata);
if zzok(xdata,7259) then
   begin
   xdata.clear;
   result:=low__wordcore4(icore,'ioget',bcopystr1(low__udv(xformat,'txt')+' all',1,maxint),xdata,str2,e);
   if not result then xdata.clear;
   end;
except;end;
try;bunlockautofree(xdata);except;end;
end;
//## iosettxt ##
function tbasicbwp.iosettxt(xdata:tstr8):boolean;
begin
try;result:=ioset2(xdata,0);except;end;
end;
//## iosetbwd ##
function tbasicbwp.iosetbwd(xdata:tstr8):boolean;
begin
try;result:=ioset2(xdata,0);except;end;
end;
//## iosetbwp ##
function tbasicbwp.iosetbwp(xdata:tstr8):boolean;
begin
try;result:=ioset2(xdata,0);except;end;
end;
//## iosetrtf ##
function tbasicbwp.iosetrtf(xdata:tstr8):boolean;
begin
try;result:=ioset2(xdata,0);except;end;
end;
//## iogettxt ##
function tbasicbwp.iogettxt(xdata:tstr8):boolean;
begin
try;result:=ioget(xdata,'txt');except;end;
end;
//## iogetbwd ##
function tbasicbwp.iogetbwd(xdata:tstr8):boolean;
begin
try;result:=ioget(xdata,'bwd');except;end;
end;
//## iogetbwp ##
function tbasicbwp.iogetbwp(xdata:tstr8):boolean;
begin
try;result:=ioget(xdata,'bwp');except;end;
end;
//## iogetrtf ##
function tbasicbwp.iogetrtf(xdata:tstr8):boolean;
begin
try;result:=ioget(xdata,'rtf');except;end;
end;
//## setpos ##
procedure tbasicbwp.setpos(x:longint);
begin
try;low__wordcore_str(icore,'vpos',inttostr(x));except;end;
end;
//## getpos ##
function tbasicbwp.getpos:longint;
begin
try;result:=low__wordcore_str2(icore,'vpos','');except;end;
end;
//## getposh ##
function tbasicbwp.getposh:longint;
begin
//try;result:=ih.pos;except;end;
try;result:=low__wordcore_str2(icore,'hpos','');except;end;
end;
//## setposh ##
procedure tbasicbwp.setposh(x:longint);
begin
try;low__wordcore_str(icore,'hpos',inttostr(x));except;end;
//try;ih.pos:=x;except;end;
end;
//## getposc ##
function tbasicbwp.getposc:longint;
begin
try;result:=low__wordcore2(icore,'cursorpos',nil);except;end;
end;
//## setposc ##
procedure tbasicbwp.setposc(x:longint);
begin
try;low__wordcore_str(icore,'cursorpos',inttostr(frcmin(x,0)));except;end;
end;
//## getposc2 ##
function tbasicbwp.getposc2:longint;
begin
try;result:=low__wordcore2(icore,'cursorpos2',nil);except;end;
end;
//## setposc2 ##
procedure tbasicbwp.setposc2(x:longint);
begin
try;low__wordcore_str(icore,'cursorpos2',inttostr(frcmin(x,0)));except;end;
end;
//## _onpos ##
procedure tbasicbwp._onpos(sender:tobject);
begin
try
if      (sender=iv) then low__wordcore_str(icore,'vpos'+low__insstr('.px',vsmooth),inttostr(iv.pos))
else if (sender=ih) then low__wordcore_str(icore,'hpos',inttostr(ih.pos));
//faster
xfaster;
except;end;
end;
//## setshowcursor ##
procedure tbasicbwp.setshowcursor(x:boolean);
begin
try;icore.showcursor:=x;except;end;
end;
//## getshowcursor ##
function tbasicbwp.getshowcursor:boolean;
begin
try;result:=icore.showcursor;except;end;
end;
//## setusepagecolor ##
procedure tbasicbwp.setusepagecolor(x:boolean);
begin
try
if (x<>iusepagecolor) then
   begin
   iusepagecolor:=x;
   paintnow;
   end;
except;end;
end;
//## _onshortcut ##
function tbasicbwp._onshortcut(sender:tobject):boolean;
begin
try
result:=false;//not handled
if enabled and (not oreadonly) and (gui.key<>aknone) and low__wordcore_str(icore,'haveshortcut',inttostr(gui.key)) then
   begin
   low__wordcore__keyboard2(icore,gui.key);
   result:=true;//handled
   end;
except;end;
end;
//## _onnotify ##
function tbasicbwp._onnotify(sender:tobject):boolean;
begin
try
//not handled
result:=true;//take control -> cancels system drag up/down and allows for screen color grab based dragging - 28jul2020

//wheel
if (gui.wheel<>0) then
   begin
   if enabled then
      begin
      case vsmooth of
      true:low__wordcore_str(icore,'vwheel',inttostr(gui.wheel));//move Y row.pixels
      false:vpos:=vpos-gui.wheel;
      end;//case
      end;
   xfaster;
   end;

//key
if (gui.key<>aknone) then
   begin
   if enabled and (gui.key<>aknone) and (gui.key<>akreturn) then low__wordcore__keyboard2(icore,gui.key);
   xfaster;
   end;

//mouse
if gui.mousedownstroke then
   begin
   low__wordcore__mouse(icore,mousex-imleft,mousey-imtop,true,gui.mouseright);
   xfaster;
   end
else if gui.mouseupstroke then
   begin
   low__wordcore__mouse(icore,mousex-imleft,mousey-imtop,false,gui.mouseright);
   autoshowmenu;
   xfaster;
   end
else if gui.mousemoved then
   begin
   low__wordcore__mouse(icore,mousex-imleft,mousey-imtop,gui.mousedown,gui.mouseright);
   if gui.mousedown then xfaster;
   end;

//external event override - 01mar2021
if assigned(fonnotify) then fonnotify(sender);
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//wwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
//## _ontimer ##
procedure tbasicbwp._ontimer(sender:tobject);
begin
try;xwordcoretimer(false);except;end;
end;
//## xwordcoretimer ##
procedure tbasicbwp.xwordcoretimer(xsyncnow:boolean);
var
   int1,xdir:longint;
begin
try
//check
if ibuildingcontrol then exit;

//slow down checking when not visible to user -> check the "visibletohost" chain for this -> reduces number of calls made using "bnew" each second -  05jul2022
if not xsyncnow then
   begin
   if (islowdownref>ms64) then exit else islowdownref:=ms64+low__insint(500,not visibletohost);
   end;

//timer event - high speed
icore.hostsizing:=gui.resizing;
low__wordcore(icore,'timer',nil);

//v+h scrollbars
if ((ms64>=itimersync) or (itimersync_fastcount>=1) or xsyncnow) then
   begin
   //check
   if (itimersync_fastcount>=1) then dec(itimersync_fastcount);
   //get
   if low__setstr(iref,bnc(orows)) then low__wordcore_str(icore,'mustpaint','1');
   xsync;
   //reset
   itimersync:=ms64+low__aorb(200,50,itimersync_fastcount>=1);//fastcount allows for a short but fast period of rapid repeat checking for important GUI changes, usually after a call to "ioset()" - 12mar2021
   end;

//paint event
if low__wordcore(icore,'canpaint',nil) and low__wordcore(icore,'mustpaint',nil) then
   begin
   low__wordcore_str(icore,'mustpaint','0');
   paintnow;
   end;
except;end;
end;
//## xsync ##
procedure tbasicbwp.xsync;
var//Note: Using "breuse()" proc greatly reduces the number of tstr8 objects needed to be created per second - 05jul2022
   int1,int2,int3,int4:longint;
   xmousedown:boolean;
   v:tstr8;
begin
try
//init
v:=nil;
xmousedown:=gui.mousedown;
//get
//.imustscrollto - delayed vertical scroll - 18dec2021
if ((imustscrollv>=0) or (imustscrollh>=0) or (imustpos>=0) or (imustpos2>=0)) and (low__wordcore2(icore,'wrapbusy',nil)=0) then
   begin
   int1:=imustscrollv; imustscrollv:=-1;
   int2:=imustscrollh; imustscrollh:=-1;
   int3:=imustpos;     imustpos:=-1;
   int4:=imustpos2;    imustpos2:=-1;
   if (int3>=0) then low__wordcore(icore,'cursorpos',breuse(v,inttostr(int3)));
   if (int4>=0) then low__wordcore(icore,'cursorpos2',breuse(v,inttostr(int4)));
   if (int1>=0) then low__wordcore(icore,'vpos',breuse(v,inttostr(int1)));
   if (int2>=0) then low__wordcore(icore,'hpos',breuse(v,inttostr(int2)));
   end;

//.havefocus
//was: low__wordcore(icore,'havefocus',bn(focused or scrollbar1.focused or scrollbar2.focused));
low__wordcore(icore,'havefocus',breuse(v,bnc(focused or iv.focused or ih.focused)));
//.v
if low__wordcore(icore,'vhostsync',nil) then
   begin
   //int2:=low__wordcore2(icore,'vmax'+low__insstr('.px',vsmooth),nil);
   if low__wordcore(icore,'wrapdone',nil) then//or (int2>iv.max) then
      begin
      low__wordcore(icore,'vhostsync',breuse(v,'0'));
      int1:=low__wordcore2(icore,'vpos'+low__insstr('.px',vsmooth),nil);
      int2:=low__wordcore2(icore,'vmax'+low__insstr('.px',vsmooth),nil);
      iv.setparams2(int1,0,frcmin(int2-low__insint(icore.viewheight-1,vsmooth),0),false);//prevent feedback loop to "_onpos => wordcore.set.vpos"
      end;
   end;
//.h
if (not xmousedown) and low__wordcore(icore,'hhostsync',nil) then
   begin
   low__wordcore(icore,'hhostsync',breuse(v,'0'));
   int1:=low__wordcore2(icore,'hpos',nil);
   int2:=low__wordcore2(icore,'hmax',nil);
   ih.setparams2(int1,0,int2,false);//prevent feedback loop to "_onpos => wordcore.set.hpos"
   end;
//.h.visible -> check rapidly -> hides control BEFORE screen is painting - 12mar2021
ih.visible:=low__wordcore(icore,'hshow',nil);
//.line + column status
//   ilncount:=low__wordcore2(icore,'linecount','');
//   iln:=low__wordcore2(icore,'line','');
//   icol:=low__wordcore2(icore,'col','');

//wound scroller - 04oct2022
iv.oassistedscroll:=frcmin(low__aorb(vifontsize,(clientheight div 5),vsmooth),1);//different scroll rates when vsmooth is ON or OFF

//.system colors
low__wordcore(icore,'pageselcolor',breuse(v,inttostr(vinormal.highlight)));
low__wordcore(icore,'pagefontselcolor',breuse(v,inttostr(vinormal.fonthighlight)));
//..override colors for pagecolor2 and pagefontcolor2 (overrides all font colors) when "pageoverride2=true"
low__wordcore(icore,'pagecolorise2',breuse(v,bnc(vicoloriseimages and ousecolorise)));//21jun2022
low__wordcore(icore,'pagecolor2',breuse(v,inttostr(vinormal.background)));
low__wordcore(icore,'pagefontcolor2',breuse(v,inttostr(vinormal.font)));//overrides internal font colors
except;end;
try;bfree(v);except;end;
end;
//## _onpaint ##
procedure tbasicbwp._onpaint(sender:tobject);
var
   //infovars
   a:pvirtualinfo;
   cs,ci:trect;
   fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xenabled,xround,xnormal:boolean;
   //other
   da:trect;
   xrowcolor,xroundstyle,int1:longint;
begin
try
//check
if ibuildingcontrol or (not low__wordcore_str(icore,'paintlock','1')) then
   begin
   low__wordcore_str(icore,'mustpaint','1');//retry later
   exit;
   end;

//init
xsync;
infovars(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);
xroundstyle:=oroundstyle;
if orows then xrowcolor:=low__dc(xback,-10) else xrowcolor:=clnone;

//cls
if ousepagecolor and (not icore.pageoverride2) and (icore.pagecolor<>clnone) then xback:=icore.pagecolor;
lds(cs,xback,xround);

//paint -> updated to handle wwsNone, wwsWindow and wwsPage - 12mar2021
case icore.wrapstyle of
wwsPage:begin
   da.left:=iclientarea.left+xbordersize+imleft;
   if (icore.pagewidth<icore.viewwidth) then inc(da.left,(icore.viewwidth-icore.pagewidth) div 2);//center the page when page is smaller than the viewing width
   end;
else    da.left:=iclientarea.left+xbordersize+imleft;
end;
da.right:=iv.clientarea.left-1-imright;//12mar2021
da.top:=iclientarea.top+xbordersize+imtop;
if ih.visible then da.bottom:=ih.clientarea.top-1-imbottom else da.bottom:=iclientarea.bottom-xbordersize-imbottom;

case gui.bits of
32:low__wordcore__paint2432(icore,gui.width,gui.height,da,ipaintarea,nil             ,gui.rows.prows32,gui.buffer,gui.mask,gui.maskval,xround,xroundstyle,xrowcolor);
24:low__wordcore__paint2432(icore,gui.width,gui.height,da,ipaintarea,gui.rows.prows24,nil             ,gui.buffer,gui.mask,gui.maskval,xround,xroundstyle,xrowcolor);
end;

//frame
if (xbordersize>=1) then ldf(cs,xborder,low__dc(xback,-20),xbordersize,nil,xround);
//required as THIS control doesn't limit it's painting to a round area due to "low__wordcore__paint2432()" not currently supporting round corners fully e.g. cursor - 25feb2021
xparentcorners;
except;end;
try;low__wordcore_str(icore,'paintlock','0');except;end;//unlock paint
end;
//## _onalign ##
procedure tbasicbwp._onalign(sender:tobject);
var
   ci:trect;
   mleft,mright,vwidth,xbordersize,hheight,int1:longint;
   hok:boolean;
begin
try
//defaults
hheight:=0;
xbordersize:=findbordersize;
//get
//.v
vwidth:=iv.getalignwidth(0);
ci:=clientinner;
iv.xsetclientarea(rect(ci.right-vwidth-1,ci.top,ci.right,ci.bottom));
//.h -> size it always even when NOT visible -> paint system relies on it having valid coordinates at ALL times - 12mar2021
hok:=ih.visible;
hheight:=ih.getalignheight(0);
ih.xsetclientarea(rect(ci.left,ci.bottom-(hheight-1),iv.clientarea.left-1,ci.bottom));
//.viewwidth
int1:=frcmin(ci.right-ci.left+1-vwidth-imleft-imright,0);
low__wordcore_str(icore,'viewwidth',inttostr(int1));
//.viewheight
int1:=frcmin(ci.bottom-ci.top+1-hheight-imtop-imbottom,0);
low__wordcore_str(icore,'viewheight',inttostr(int1));
//.update wordcore with current clientwidth immediately for BEST screen start - 29may2021
xwordcoretimer(true);
except;end;
end;

//## tbasiccolor ###############################################################
//## create ##
constructor tbasiccolor.create(xparent:tobject;xcaption:string);
begin
create2(xparent,true,xcaption);
end;
//## create2 ##
constructor tbasiccolor.create2(xparent:tobject;xstart:boolean;xcaption:string);
var
   int1,int2,p:longint;
   e:string;
begin
//self
satinc(satColor,1);
inherited create2(xparent,false);
//vars
foncolor:=nil;
ishadearea:=nilrect;
ishadeused:=false;
opopcolor:=true;
oshaderange:=true;//false;
inormal:=true;
icolor:=low__rgb(255,255,255);
ibordersize:=1;
//defaults
clientheight:=20;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasiccolor.destroy;
begin
try
inherited destroy;
satinc(satColor,-1);
except;end;
end;
//## setcolor ##
procedure tbasiccolor.setcolor(x:longint);
var
   bol1,bol2:boolean;
begin
try
bol1:=low__setint(icolor,x);
if ishadeused then bol2:=false else bol2:=low__setint(ishadecolor,x);
if bol1 or bol2 then
   begin
   if assigned(foncolor) then foncolor(self,icolor);//26feb2021
   paintnow;
   end;
except;end;
end;
//## _setcolor ##
procedure tbasiccolor._setcolor(x:longint);
begin
try
if low__setint(icolor,x) then
   begin
   if assigned(foncolor) then foncolor(self,icolor);//26feb2021
   paintnow;
   end;
except;end;
end;
//## getalignheight ##
function tbasiccolor.getalignheight(xclientwidth:longint):longint;
begin
//was: try;result:=frcmin((2*findbordersize)+(2*vifontheight),0);except;end;
try;result:=frcmin(frcmin(2+(2*vifontheight)+(2*frcmin(findbordersize,1)),ominheight),2*20);except;end;//matches "tbasicint" height - 27feb2021
end;
//## getalignwidth ##
function tbasiccolor.getalignwidth(xclientheight:longint):longint;
begin
try;result:=100;except;end;
end;
//## _onshortcut ##
function tbasiccolor._onshortcut(sender:tobject):boolean;
var
   xcode2:string;
begin//store shortcut so we can transmitt it to our host form later (once we've closed the menu) - 02apr2020
try
//defaults
result:=false;
xcode2:='';
//get
case gui.key of
akctrlP:xcode2:='paste';
akctrlH:xcode2:='copyhex';
akctrlR:xcode2:='copyrgb';
akctrlN:xcode2:='copynum';
akctrlI:xcode2:='copypix';
akctrlV:xcode2:='invert';
end;//case
//set
if (xcode2<>'') then
   begin
   result:=true;
   xdomenu(xcode2);
   end;
except;end;
end;
//## _onnotify ##
function tbasiccolor._onnotify(sender:tobject):boolean;
var
   int1:longint;
begin
try
//handled
result:=true;//take control -> cancels system drag up/down and allows for screen color grab based dragging - 28jul2020

//mouse down
if gui.mousedownstroke then
   begin
   ishadeused:=oshaderange and low__withinrect(mousex,mousey,ishadearea);
   end;

//mouse move
if gui.mousemoved and enabled and gui.mousedown and gui.mouseleft then
   begin
   case oshaderange and ishadeused of
   true:color:=low__capcolor(0,0,true);
   false:if gui.mousedraggingout(self,true,true) then color:=low__capcolor(0,0,true);
   end;//case
   end;

//mouse up
if gui.mouseupstroke and enabled and gui.mouseleft and (not gui.mousewasdraggingout) then
   begin
   if oshaderange then color:=low__capcolor(0,0,true)
   else if opopcolor then
      begin
      int1:=icolor;
      if gui.popcolor(int1) then color:=int1;
      end;
   end;

//showmenu
if gui.mouseupstroke and enabled and ( ((not opopcolor) and (not ishadeused) and gui.mouseleft) or gui.mouseright) and (not gui.mousewasdraggingout) then showmenu;

//update shadecolor
if gui.mouseupstroke and oshaderange then
   begin
   ishadeused:=false;
   if low__setint(ishadecolor,icolor) then paintnow;
   end;

//external event override - 01mar2021
if assigned(fonnotify) then fonnotify(sender);
except;end;
end;
//## showmenu ##
procedure tbasiccolor.showmenu;
var
   m:tstr8;
   bol1:boolean;
   xcode,xtepcolor:longint;
   xcode2:string;
begin
try
//defaults
m:=nil;
//init
bol1:=clipboard.hasformat(cf_text);
m:=bnew;
low__menuinit(m);
low__menuitem2(m,tepCopy20,translate('Copy as HEX'),'Copy color to clipboard in hex format','copyhex',100,aknone,true);
low__menuitem2(m,tepCopy20,translate('Copy as RGB'),'Copy color to clipboard in red green blue format','copyrgb',100,aknone,true);
low__menuitem2(m,tepCopy20,translate('Copy as Number'),'Copy color to clipboard as whole number','copynum',100,aknone,true);
low__menusep(m);
//no support yet: low__menuitem2(m,tepCopy20,translate('Copy as Pixel'),'Copy color to clipboard as a 1 pixel image','copypix',100,aknone,true);
low__menuitem2(m,tepPaste20,ntranslate('Paste'),'Paste color from clipboard','paste',100,aknone,bol1);
low__menuitem2(m,tepInvert20,translate('Invert'),'Invert color','invert',100,aknone,true);
low__menuend(m);
//get
if gui.popmenu(pmNormal,iaNormal,m,xcode,xcode2,xtepcolor) then xdomenu(xcode2);
except;end;
try;freeobj(@m);except;end;
end;
//## xdomenu ##
procedure tbasiccolor.xdomenu(xcode2:string);
var
   a:tint4;
   b:tbitmap;
   c:tstringlist;
   z:string;
begin
try
//defaults
b:=nil;
c:=nil;
//get
if      (xcode2='paste') then
   begin
{//no support yet
   if clipboard.hasformat(cf_bitmap) then
      begin
      b:=ccs.newbmp(1,1);
      b.assign(clipboard);
      if ccs.valid24(b) then color:=ccs.pixels[b,0,0];
      end
{}
   if clipboard.hasformat(cf_text) then
      begin
      //get
      z:=low__pastetxt2b;;
      z:=low__firstline(z);
      //decide
      //.hex
      if (strcopy1(z,1,1)='#') then color:=low__hextorgb(z,low__rgb(127,127,127))
      //.rgb
      else if (low__findchar(z,',')>=1) then
         begin
         //init
         c:=createstringlist;
         swapchars(z,',',#10);
         c.text:=z+rcode+'0'+rcode+'0'+rcode+'0';
         if (c.count>=3) then
            begin
            a.a:=0;
            a.r:=frcrange(strint(c.strings[0]),0,255);
            a.g:=frcrange(strint(c.strings[1]),0,255);
            a.b:=frcrange(strint(c.strings[2]),0,255);
            color:=a.val;
            end;
         end
      //.number
      else
         begin
         a.val:=frcmin(strint(z),0);//0..maxint
         a.a:=0;
         color:=a.val;
         end;
      end;
   end
//was:
else if (xcode2='copyhex') then low__copytxt2b(low__rgbtohex(icolor))
else if (xcode2='copyrgb') then
   begin
   a.val:=icolor;
   low__copytxt2b(inttostr(a.r)+','+inttostr(a.g)+','+inttostr(a.b));
   end
else if (xcode2='copynum') then low__copytxt2b(inttostr(icolor))
else if (xcode2='copypix') then
   begin
//Windows only:
{
   if (oscode=oswindows) then
      begin
      b:=low__newbmp24CLS(1,1,icolor);
      clipboard.assign(b);
      end;
{}//xxxxxxxxxxx

   end
else if (xcode2='invert') then color:=low__invertb(color);
except;end;
try
freeobj(@b);
freeobj(@c);
except;end;
end;
//## _onpaint ##
procedure tbasiccolor._onpaint(sender:tobject);
const
   sp=2;
var
   //infovars
   a:pvirtualinfo;
   cs,ci:trect;
   fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xenabled,xround,xnormal:boolean;
   //other
   pcount,xcolor,xshadecolor,int1,int2,xlast,c1,c2,xtextheight,tw,dx,dy,p:longint;
   z,e:string;
   a1,a2,a3:trect;
   //## pdraw ##
   procedure pdraw(sc,dc:longint);
   var
      ppert,p:longint;
   begin
   try
   //check
   if (pcount<1) then pcount:=1;
   //get
   for p:=1 to pcount do
   begin
   ppert:=frcrange(round((p*100)/pcount),0,100);
   ldv(dx,a2.top,a2.bottom,low__colsplice(ppert,dc,sc),xround);
   inc(dx);
   if (dx>ci.right) then break;
   end;//p
   except;end;
   end;
begin
try
//init
infovars(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);
xcolor:=icolor;
xshadecolor:=ishadecolor;
//cls
if oshaderange then
   begin
   //init
   int1:=((ci.bottom-ci.top+1) div 2);
   a1:=ci;
   a1.bottom:=a1.top+int1;
   a2:=ci;
   a2.top:=a1.bottom+1;
   a2.bottom:=ci.bottom;
   pcount:=frcmin(ci.left+((ci.right-ci.left+1) div 4),1);
   ishadearea:=rect(ci.left+2,a2.top,ci.right-2,ci.bottom-1);
   //actual color
   lds(a1,xcolor,false);
   //shade ranges
   dx:=ci.left;
   pdraw(0,xshadecolor);
   pdraw(xshadecolor,low__rgb(255,255,255));
   pdraw(low__rgb(255,255,255),low__invertb(xshadecolor));
   pdraw(low__invertb(xshadecolor),0);
//   pdraw(low__rgb(127,127,127),xshadecolor);
//   pdraw(xshadecolor,low__invertb(xshadecolor));
   end
else
   begin
   lds(ci,xcolor,xround);
   end;

//frame
if (xbordersize>=1) then ldf2(cs,xborder,xborder,xback,xbordersize,0,'',nil,xround);
//was: xparentcorners;
except;end;
end;

//## tbasichelp ################################################################
//## create2 ##
constructor tbasichelp.create2(xparent:tobject;xstart:boolean);
var
   p:longint;
   bol1,bol2:boolean;
begin
//self
satinc(satHelp,1);
inherited create2(xparent,false);
//vars
ishowhelp:=true;//19mar2021, 19aug2020
iimg:=tepHelphint;
inormal:=false;
ipos:=1;
itext:='';
itextid:=0;
ibordersize:=0;
itimer250:=ms64;
ipostime:=ms64;
ideftext:=rthtranslate('Hover cursor over program for realtime help');
tepinfo(iimg,false,iimgw,iimgh,bol1,bol2);
//defaults
text:='';
clientheight:=20;
//sync
xsync;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasichelp.destroy;
begin
try
inherited destroy;
satinc(satHelp,-1);
except;end;
end;
//## setshowhelp ##
procedure tbasichelp.setshowhelp(x:boolean);
begin
try
ishowhelp:=x;
xsync;
except;end;
end;
//## xsync ##
procedure tbasichelp.xsync;
var
   bol1:boolean;
begin
try
bol1:=ishowhelp and vihelp;
if (visible<>bol1) then
   begin
   visible:=bol1;
   gui.fullalignpaint;
   end;
except;end;
end;
//## _ontimer ##
procedure tbasichelp._ontimer(sender:tobject);
var
   xmustpaint:boolean;
   int1,p:longint;
   str1:string;
   bol1:boolean;
begin
try
//defaults
xmustpaint:=false;

//.itimer250
if (ms64>itimer250) then
   begin
   //control info
   if low__setstr(iinforef,bnc(inormal)+pcRefsep+inttostr(findbordersize)+pcRefsep+inttostr(vifontheight)+pcRefsep+inttostr(itextid)) then xmustpaint:=true;
   //.scroll
   if (itext<>'') and (ms64>ipostime) then paintscroll;//time reset internally
   //.sync -> detects change in "vihelp" and "ohelp" - 19mar2021
   xsync;

   //reset
   itimer250:=ms64+250;
   end;

//paint
if xmustpaint then paintnow;
except;end;
end;
//## paintscroll ##
function tbasichelp.paintscroll:boolean;
var
   i,p:longint;
begin
try
//defaults
result:=false;
//check
if (itext='') or (not visibletohost) then exit;
//scan - never to end (as we should always have content)
i:=ipos+3;//6 chars per second
if (i>=length(itext)) then i:=1;
ipos:=i;
ipostime:=ms64+low__aorb(350,2000,ipos=1);
//paint
paintnow;
//successful
result:=true;
except;end;
end;
//## settext ##
procedure tbasichelp.settext(x:string);
begin
try
//filter
if (x='') then x:=ideftext;
//get
if (x<>itext) then
   begin
   //set
   itext:=x;
   low__iroll(itextid,1);
   //reset
   ipostime:=ms64+2000;
   ipos:=1;
   paintnow;
   end;
except;end;
end;
//## getalignheight ##
function tbasichelp.getalignheight(xclientwidth:longint):longint;
begin
try;result:=frcmin((2*findbordersize)+largest(vifontheight,iimgh),0);except;end;
end;
//## _onpaint ##
procedure tbasichelp._onpaint(sender:tobject);
var
   //infovars
   a:pvirtualinfo;
   cs,ci:trect;
   fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xenabled,xround,xnormal:boolean;
   //other
   dimgw,dimgh,dx:longint;
begin
try
//init
infovars(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);
dimgw:=iimgw*vizoom;
dimgh:=iimgh*vizoom;
//cls
//was:
//lds2(cs,xback,clnone,clnone,0,'h-12',false);
lds2(cs,low__dc(xback,-10),xback,clnone,0,'g20',xround);

//image
dx:=1;
if (iimg<>tepnone) then
   begin
   ldis(ci,dx,(ch-dimgh) div 2,xfont,iimg,false,false,xround);
   inc(dx,dimgw+2);
   end;
//text
ldt(ci,dx,(ch-fnH) div 2,xfont,strcopy1(itext,ipos,length(itext)),fn,xfeather,xround);
//was: xparentcorners; and all procs did use "false" for "xround"
except;end;
end;

//## tbasicnav #################################################################
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//nnnnnnnnnnnnnnnnnnn
//## create2 ##
constructor tbasicnav.create2(xparent:tobject;xstart:boolean);
begin
//self
satinc(satNav,1);
inherited create2(xparent,false);
//vars
ominsize:=mincomp;
omaxsize:=maxcomp;
ifolderid:=0;
onumber:=false;
ipreview:=false;//22may2022
icanpreview:=false;
isyspreview:=false;
ilastpreview:=false;
ilastpreviewfile:='';//22may2022
ocansort:=true;//12jan2022
ofindname:=false;
ifavlimit:=100;//limit the number of items in favourities list to 100 -> faster "folderimg" loading - 14apr2021
iownerid:=low__newid1;//navlist - 06apr2021
iownerid2:=low__newid1;//favlist - 14apr2021
bordersize:=0;//21feb2021
ihisname:='';//21mar2021
iprevnextcode:=':';//used to signal to history that a PREV or NEXT is in action and not to store the value - 04apr2021
ifavfolder:='';
isortstyle:=nlName;
oretainpos:=true;
itimer100:=ms64;//22may2022
itimer250:=ms64;
ifolderidREF:='?';//triggers an initial update for "ifolderid" - 27sep2022
ilistfolder:='';
imustfolder:='';
imustname  :='';     
imustreload:=false;
omasklist  :='';//defaults to "*"
oemasklist :='';//defaults to "nil" = off/disabled
ominmax_emasklist:='';//off
findex     :=0;
fcount     :=0;
ilastmask  :=omasklist;
ilastemask :=oemasklist;
ilastemask_minmax:=ominmax_emasklist;
//controls
ifav:=nil;
ifavcore:=nil;
ifavteps:=nil;
ifavlabel:=nil;
ipreviewlabel:=nil;
ipreviewbox:=nil;
ilist:=nil;
ilistcore:=nil;
ilistlabel:=nil;
iname:=nil;
inamelabel:=nil;
ifilter:=nil;
ifilterlabel:=nil;
ibar:=nil;
ibut:=nil;
//defaults
istyle:=bnNil;
clientheight:=200;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasicnav.destroy;
begin
try
//controls
freeobj(@ifavcore);
freeobj(@ifavteps);//14apr2021
freeobj(@ilistcore);
tep__delall20(iownerid);//delete any images done by use - 06apr2021
tep__delall20(iownerid2);//delete any images done by use - 14apr2021
//other
inherited destroy;
satinc(satNav,-1);
except;end;
end;
//## getitemindex ##
function tbasicnav.getitemindex:longint;
begin
try
result:=-1;
if (ilist<>nil) then result:=ilist.itemindex
else if (ifav<>nil) then result:=ifav.itemindex;
except;end;
end;
//## setitemindex ##
procedure tbasicnav.setitemindex(x:longint);
begin
try
if (ilist<>nil) then ilist.itemindex:=frcrange(x,0,frcmin(ilist.count-1,0))
else if (ifav<>nil) then ifav.itemindex:=frcrange(x,0,frcmin(ifav.count-1,0));
except;end;
end;
//## idletime ##
function tbasicnav.idletime:comp;//21feb2022
begin
try
result:=inherited idletime;
if (ilist<>nil)    then result:=smallest64(result,ilist.idletime);
if (ifav<>nil)     then result:=smallest64(result,ifav.idletime);
if (iname<>nil)    then result:=smallest64(result,iname.idletime);
if (ifilter<>nil)  then result:=smallest64(result,ifilter.idletime);
except;end;
end;
//## xfrom ##
function tbasicnav.xfrom(sender:tbasiccontrol;xvars:tvars8;xname:string):boolean;
begin
try
result:=zzok(xvars,7260);//handled
if result then
   begin
   sortstyle:=frcrange(xvars.idef(xname+'.sort',nlName),0,nlMax);
   if isyspreview then preview:=xvars.bdef(xname+'.preview',false);
   end;
except;end;
end;
//## xto ##
function tbasicnav.xto(sender:tbasiccontrol;xvars:tvars8;xname:string):boolean;
begin
try
result:=zzok(xvars,7261);//handled
if result then
   begin
   xvars.i[xname+'.sort']:=frcrange(sortstyle,0,nlMax);
   if isyspreview then xvars.b[xname+'.preview']:=preview;
   end;
except;end;
end;
//## sethisname ##
procedure tbasicnav.sethisname(x:string);
var
   bol1:boolean;
begin
try
bol1:=not low__comparetext(ihisname,x);
ihisname:=x;
if zzok(ilist,7262) then xhisadd(folder,ilist.pos,ilist.selstart,bol1);
except;end;
end;
//## xshowmenuFill1 ##
procedure tbasicnav.xshowmenuFill1(sender:tobject;xstyle:string;xmenudata:tstr8;var ximagealign:longint;var xmenuname:string);
begin
try;if assigned(showmenuFill1) then showmenuFill1(sender,xstyle,xmenudata,ximagealign,xmenuname);except;end;
end;
//## xshowmenuFill2 ##
procedure tbasicnav.xshowmenuFill2(sender:tobject;xstyle:string;xmenudata:tstr8;var ximagealign:longint;var xmenuname:string);
begin
try;if assigned(showmenufill2) then showmenuFill2(sender,xstyle,xmenudata,ximagealign,xmenuname);except;end;
end;
//## xshowmenuFill ##
procedure tbasicnav.xshowmenuFill(sender:tobject;xstyle:string;xmenudata:tstr8;var ximagealign:longint;var xmenuname:string);
var
   int1,astyle,xsortval:longint;
   bol1,xfileok,xfolderok,xanyfolderok,xcansort:boolean;
   xanyfolder:string;
   //## xsort ##
   procedure xsort(xcap:string;xval:longint);
   begin
   low__menuitem2(xmenudata,tep__tick(xsortval=xval),xcap,'Sort by '+xcap,'nav.sort.'+inttostr(xval),100,aknone,xcansort);
   end;
begin
try
//check
if zznil(xmenudata,2326) then exit;
xmenuname:=low__udv('nav.1',hisname);
//init
astyle:=style;
xsortval:=sortstyle;
xcansort:=ocansort;
//sort
if (astyle=bnOpen) or (astyle=bnSave) or (astyle=bnNav) or (astyle=bnNavlist) or (astyle=bnNamelist) then
   begin
   //init
   xfileok:=(valuestyle=nltFile);
   xfolderok:=(folder<>'');
   xanyfolder:=selectedfolder;
   xanyfolderok:=(xanyfolder<>'');

   //sort by
   low__menutitle(xmenudata,tepnone,'Sort By','Change sort order');
   xsort('Name (A-Z)',nlName);
   xsort('Name (Z-A)',nlNameD);
   xsort('Date (Old-New)',nlDate);
   xsort('Date (New-Old)',nlDateD);
   xsort('Size (Small-Large)',nlSize);
   xsort('Size (Large-Small)',nlSizeD);
   xsort('Type (.AAA-.ZZZ)',nlType);
   xsort('Type (.ZZZ-.AAA)',nlTypeD);
   xsort('As Is (A-Z)',nlAsis);
   xsort('As Is (Z-A)',nlAsisD);
   //folder options
   if (astyle<>bnNamelist) then
      begin
      low__menutitle(xmenudata,tepFolder20,'Folder Options','Folder options');
      low__menuitem2(xmenudata,tepNewfolder20,'New Folder...','Create a new folder','nav.newfolder',100,aknone,xfolderok);
      low__menuitem2(xmenudata,tepFolderimage20,'Change Folder Image...','Set a custom image for the folder','nav.folderimage',100,aknone,xanyfolderok);
      low__menuitem2(xmenudata,tepFolder20,'Show Folder','Show selected folder or folder of selected file','nav.showfolder',100,aknone,low__canshowfolder(xanyfolder));
      low__menuitem2(xmenudata,tepCopy20,'Copy Filename','Copy selected filename to Clipboard','nav.copy',100,aknone,xfileok);
      low__menuitem2(xmenudata,tepCopy20,'Copy All Filenames','Copy all filenames to Clipboard','nav.copyall',100,aknone,xfileok);
      //select options
      if (ilist<>nil) and (ilist.ostyle=lsmany) then
         begin
         low__menutitle(xmenudata,tepSelectAll20,'Selection Options','Selection options');
         low__menuitem2(xmenudata,tepSelectAll20,'To Start','To Start','nav.selectstart',100,aknone,ilist.selcount>=2);
         low__menuitem2(xmenudata,tepSelectAll20,'To End','To End','nav.selectend',100,aknone,ilist.selcount>=2);
         low__menuitem2(xmenudata,tepSelectAll20,'Select Range','Select range','nav.selectrange',100,aknone,ilist.canselectrange);
         low__menuitem2(xmenudata,tepSelectAll20,'Select All','Select All','nav.selectall',100,aknone,ilist.count>=2);
         end;
      end;
   end;
except;end;
end;
//## xshowmenuClick1 ##
function tbasicnav.xshowmenuClick1(sender:tbasiccontrol;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean;
begin
try;if assigned(showmenuclick1) then result:=showmenuclick1(sender,xstyle,xcode,xcode2,xtepcolor) else result:=false;except;end;
end;
//## xshowmenuClick2 ##
function tbasicnav.xshowmenuClick2(sender:tbasiccontrol;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean;
begin
try;if assigned(showmenuclick2) then result:=showmenuclick2(sender,xstyle,xcode,xcode2,xtepcolor) else result:=false;except;end;
end;
//## xshowmenuClick ##
function tbasicnav.xshowmenuClick(sender:tbasiccontrol;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean;
begin
try;result:=xcmd(xcode,xcode2,clnone);except;end;
end;
//## _xoff_toolbaradd ##
function tbasicnav._xoff_toolbaradd(x:tbasictoolbar):boolean;
var
   xstyle:longint;
   //## xadd ##
   procedure xadd(n:string);
   begin
   n:=low__lowercase(n);
   if (n='prev')                        then x.add('Prev',tepPrev20,0,'nav.prev','Previous folder')
   else if (n='next')                   then x.add('Next',tepNext20,0,'nav.next','Next folder')
   else if (n='home')                   then x.add('Home',tepHome20,0,'nav.home','Home folder')
   else if (n='up')                     then x.add('Up',tepUpOne20,0,'nav.up','Up one folder')
   else if (n='fav.add') or (n='add')   then x.add('Add',tepFavadd20,0,'nav.favadd','Add current folder to favourites list')
   else if (n='fav.edit') or (n='edit') then x.add('Edit',tepFavedit20,0,'nav.favedit','Edit favourites list')
   else if (n='fav')                    then x.add('Fav',tepFav20,0,'nav.fav','Show favourites list')
   else if (n='newfolder')              then x.add('New Folder',tepNewfolder20,0,'nav.newfolder','Create a new folder')
   else if (n='explore')                then x.add('Explore',tepFolder20,0,'nav.explore','Explore current folder')
   else if (n='menu')                   then x.add('Menu',tepMenu20,0,'nav.showmenu','Show menu')
   else if (n='refresh')                then x.add('Refresh',tepRefresh20,0,'nav.refresh','Refresh list')
   else if (n='selectall')              then x.add('Select All',tepSelectall20,0,'nav.selectall','Select All')//28sep2022
   else if (n='preview')                then x.add('Preview',tepScreen20,0,'nav.preview','Toggle preview display')
   else if (n='sep')                    then x.add('-',tepNone,0,'','');
   end;
begin
try
//defaluts
result:=false;
xstyle:=istyle;
//get
if (xstyle=bnNav) or (xstyle=bnNavlist) or (xstyle=bnNamelist) then//Special Note: bnNavlist/bnNamelist=does not show internal toolbar, rather the links are for a host's toolbar should it "xoff load" this control's toolbar duty - 08mar2021
   begin
   xadd('prev');
   xadd('next');
   xadd('fav');
   xadd('menu');
   xadd('refresh');
   end
else if (xstyle=bnOpen) or (xstyle=bnSave) or (xstyle=bnFolder) then
   begin
   xadd('fav.add');
   xadd('fav.edit');
   xadd('prev');
   xadd('next');
   xadd('home');
   xadd('up');
   xadd('menu');
   xadd('refresh');
   xadd('newfolder');
   xadd('explore');
   if (xstyle=bnOpen) or (xstyle=bnSave) then xadd('preview');//22may2022
   end
else if (xstyle=bnFav) then
   begin
   xadd('add');
   xadd('edit');
   end;

//successful
result:=true;
except;end;
end;
//## _xoff_toolbarsync ##
function tbasicnav._xoff_toolbarsync(x:tbasictoolbar):boolean;
var
   xfolder:string;
begin
try
result:=false;
xfolder:=folder;
x.benabled2['nav.favadd']:=(xfavfolder<>'');//changes depending on if it's a open/save/nav etc box
x.benabled2['nav.prev']:=canprev;
x.benabled2['nav.next']:=cannext;
x.benabled2['nav.home']:=(xfolder<>'');
x.benabled2['nav.up']:=(xfolder<>'');
x.benabled2['nav.newfolder']:=(xfolder<>'');
x.benabled2['nav.explore']:=(xfolder<>'');
x.bvisible2['nav.preview']:=canpreview;
x.bmarked2['nav.preview']:=canpreview and preview;
x.benabled2['nav.commonfolder']:=(ocommonfolder<>'');
if (istyle=bnOpen) and zzok(iname,7263) then x.benabled2['nav.openprompt']:=(ilistfolder<>'') and (iname.value<>'');
if (istyle=bnSave) and zzok(iname,7264) then x.benabled2['nav.saveprompt']:=(ilistfolder<>'') and (iname.value<>'');
//was: x.benabled2['nav.commonfolder']:=(ocommonfolder<>'') and (not low__comparetext(xfolder,ocommonfolder));
except;end;
end;
//## xfavfolder ##
function tbasicnav.xfavfolder:string;
begin
try
if (istyle=bnFav) or (istyle=bnFavlist) then result:=ifavfolder
else if (istyle=bnOpen) or (istyle=bnSave) then result:=asfoldernil(ilistfolder)
else if (istyle=bnFolder) then result:=asfoldernil(ilistfolder)
else if (istyle=bnNav) or (istyle=bnNavlist) or (istyle=bnNamelist) then result:=asfoldernil(ilistfolder)
else result:='';
except;end;
end;
//## _xoff_toolbarevent ##
function tbasicnav._xoff_toolbarevent(x:tbasictoolbar):boolean;
begin
try;result:=zzok(x,7265) and xcmd(x.ocode,x.ocode2,x.otepcolor);except;end;
end;
//## popfav ##
function tbasicnav.popfav:string;
begin
try
result:=folder;
if gui.popfav(result) then folder:=result;
except;end;
end;
//## xcmd ##
function tbasicnav.xcmd(xcode:longint;xcode2:string;xtepcolor:longint):boolean;
label
   skipend;
var
   a:tbasiccontrol;
   b:tstr8;
   int1,p,xstyle,xtep:longint;
   xsize:comp;
   xname,xlabel,e,xfolder,str1:string;
   bol1:boolean;
begin
try
//defaults
result:=true;//handled
b:=nil;
//init
xfolder:=folder;
//get
if (xcode2='nav.home') then imustfolder:='home'
else if (xcode2='nav.refresh') then reload
else if (xcode2='nav.commonfolder') then imustfolder:=ocommonfolder
else if (xcode2='nav.prev') then prev
else if (xcode2='nav.next') then next
else if (xcode2='nav.fav') then popfav
else if (xcode2='nav.favadd') then
   begin
   if (xfavfolder<>'') then addfav(xfavfolder);//02jun2021
   end
else if (xcode2='nav.favedit') then
   begin
   if zzok(ifavcore,7266) then
      begin
      str1:=ifavcore.text;
      if gui.poptxt(str1,wwsNone,'Edit Favourites List','Type one complete folder name per line including the trailing slash - e.g. C:\Windows\') then
         begin
         savefav(bcopystrall(low__remdup2(str1,true,false)));
         loadfav;
         end;
      end;
   end
else if (xcode2='nav.up') then
   begin
   if (xfolder<>'') then
      begin
      str1:='home';
      if (length(xfolder)>=2) then
         begin
         for p:=(length(xfolder)-1) downto 1 do if (strcopy1x(xfolder,p,1)='\') or (strcopy1x(xfolder,p,1)='/') then
            begin
            str1:=strcopy1(xfolder,1,p);
            break;
            end;//p
         end;
      folder:=str1;
      end;
   end
else if (xcode2='nav.showfolder') then
   begin
   str1:=selectedfolder;
   if (str1<>'') then runlow(str1,'');
   end
else if (xcode2='nav.copy') then low__copytxt2b(value)//30mar2022
else if (xcode2='nav.copyall') then
   begin
   b:=bnew;
   if zzok(ilistcore,7284) then
      begin
      for p:=0 to maxint do
      begin
      if not low__navget(ilistcore,p,xstyle,xtep,xsize,xname,xlabel) then break;
      if (xstyle=nltFile) then b.sadd(ilistfolder+xname+rcode);
      end;//p
      low__copytxt2b(b.text);
      end;
   end
else if (xcode2='nav.selectall') then
   begin
   if (ilist<>nil) then ilist.setsel(0,ilist.count);
   end
else if (xcode2='nav.selectrange') then
   begin
   if (ilist<>nil) then ilist.selectrange;
   end
else if (xcode2='nav.selectstart') then
   begin
   if (ilist<>nil) then ilist.pos:=ilist.selstart-(ilist.vcount div 2);
   end
else if (xcode2='nav.selectend') then
   begin
   if (ilist<>nil) then ilist.pos:=ilist.selstart+frcmin(ilist.selcount-1,0)-(ilist.vcount div 2);
   end
else if low__comparetext(strcopy1(xcode2,1,9),'nav.sort.') then
   begin
   sortstyle:=frcrange(strint(strcopy1(xcode2,10,length(xcode2))),0,nlMax);
   end
else if (xcode2='nav.newfolder') then
   begin
   if gui.popnewfolder(xfolder,str1) then folder:=str1;//14apr2021
   end
else if (xcode2='nav.folderimage') then
   begin
   str1:=selectedfolder;
   if (str1<>'') and low__driveexists(str1) and gui.popfolderimg(str1) then imustreload:=true;//12apr2021
   end
else if (xcode2='nav.openprompt') then
   begin
   str1:=value;
   if not low__fileexists(str1) then
      begin
      gui.poperror('File not found "'+low__extractfilename(str1)+'"');
      goto skipend;
      end;
   //close the dlg window with the "open" button as clicked - 03mar2021
   if gui.xdlg(a) then
      begin
      a.ocode:=1;
      a.ocode2:='open';
      a.visible:=false;
      end;
   end
else if (xcode2='nav.saveprompt') then
   begin
   str1:=value;
   if low__fileexists(str1) then
      begin
      if not gui.popquery2('Replace existing file "'+low__extractfilename(str1)+'" ?','','Replace',false) then goto skipend;
      end;
   //close the dlg window with the "save" button as clicked - 03mar2021
   if gui.xdlg(a) then
      begin
      a.ocode:=1;
      a.ocode2:='save';
      a.visible:=false;
      end;
   end
else if (xcode2='nav.explore') then
   begin
   if (xfolder<>'') then runlow(xfolder,'');
   end
else if (xcode2='nav.preview') then preview:=not preview//22may2022
else if (xcode2='nav.showmenu') then
   begin
   if zzok(ilist,7267) and ilist.ocanshowmenu then ilist.showmenu
   else if zzok(ifav,7268) and ifav.ocanshowmenu then ifav.showmenu;
   end
else result:=false;//not handled
skipend:
except;end;
try;bfree(b);except;end;
end;
//## canshowmenu ##
function tbasicnav.canshowmenu:boolean;
begin
try
result:=false;
if zzok(ilist,7267)     then result:=ilist.ocanshowmenu
else if zzok(ifav,7268) then result:=ifav.ocanshowmenu
else                         result:=inherited canshowmenu;
except;end;
end;
//## showmenu ##
procedure tbasicnav.showmenu;//20mar2022
begin
try
if zzok(ilist,7267) and ilist.ocanshowmenu then ilist.showmenu
else if zzok(ifav,7268) and ifav.ocanshowmenu then ifav.showmenu
else inherited showmenu;
except;end;
end;
//## getdownindex ##
function tbasicnav.getdownindex:longint;
begin
try
result:=0;
if zzok(ilist,7269) then result:=ilist.downindex;
except;end;
end;
//## setdownindex ##
procedure tbasicnav.setdownindex(x:longint);
begin
try
if zzok(ilist,7270) then ilist.downindex:=x;
except;end;
end;
//## findinfoBrief ##
procedure tbasicnav.findinfoBrief(var xisnav,xisfolder,xisfile:boolean);
var
   xselstart,xselcount,xdownindex,xnavindex,xfolderindex,xfileindex,xnavcount,xfoldercount,xfilecount:longint;
begin
try;findinfo(xselstart,xselcount,xdownindex,xnavindex,xfolderindex,xfileindex,xnavcount,xfoldercount,xfilecount,xisnav,xisfolder,xisfile);except;end;
end;
//## findinfo ##
function tbasicnav.findinfo(var xselstart,xselcount,xdownindex,xnavindex,xfolderindex,xfileindex,xnavcount,xfoldercount,xfilecount:longint;var xisnav,xisfolder,xisfile:boolean):boolean;
var
   xsize:comp;
   xfilename:string;
begin
try;result:=findinfo2(maxint,xselstart,xselcount,xdownindex,xnavindex,xfolderindex,xfileindex,xnavcount,xfoldercount,xfilecount,xisnav,xisfolder,xisfile,xsize,xfilename,false);except;end;
end;
//## findinfo2 ##
function tbasicnav.findinfo2(xindex:longint;var xselstart,xselcount,xdownindex,xnavindex,xfolderindex,xfileindex,xnavcount,xfoldercount,xfilecount:longint;var xisnav,xisfolder,xisfile:boolean;var xsize:comp;var xvalue:string;xfindvalue:boolean):boolean;
label
   skipend;
var//Note: xindex=maxint=used internal value form list or value provided by xselstart, else OVERRIDE no matter what - 28sep2022
   xitemindex,xnav1,xnav2,xfolder1,xfolder2,xfile1,xfile2:longint;
   xstyle2,xtep2:longint;
   xname2,xlabel2:string;
begin
try
//defaults
result:=false;
xselstart:=0;
xselcount:=0;
xdownindex:=0;
xnavindex:=0;
xfolderindex:=0;
xfileindex:=0;
xisnav:=false;
xisfolder:=false;
xisfile:=false;
xvalue:='';
xsize:=-1;
//init
if zzok(ilist,7271) then
   begin
   xselstart:=ilist.selstart;
   xselcount:=ilist.selcount;
   //.override with this index value - 28sep2022
   if (xindex<maxint) then
      begin
      if (xindex<0) or (xindex>=ilist.count) then goto skipend;
      end
   else xindex:=ilist.selstart;
   //.xsize
   if zzok(ilistcore,7284) then low__navget(ilistcore,xindex,xstyle2,xtep2,xsize,xname2,xlabel2);
   end
else xindex:=0;

xdownindex:=getdownindex;
xitemindex:=xselstart;//22mar2021
xnavcount:=navcount;
xfoldercount:=foldercount;
xfilecount:=filecount;
xnav1:=0;
xnav2:=xnav1+(xnavcount-1);
xfolder1:=xnav2+1;
xfolder2:=xfolder1+(xfoldercount-1);
xfile1:=xfolder2+1;
xfile2:=xfile1+(xfilecount-1);
//nav
xisnav:=(xindex>=xnav1) and (xindex<=xnav2);
if xisnav then xnavindex:=xindex-xnav1;
//folder
xisfolder:=(xindex>=xfolder1) and (xindex<=xfolder2);
if xisfolder then xfolderindex:=xindex-xfolder1;
//file
xisfile:=(xindex>=xfile1) and (xindex<=xfile2);
if xisfile then xfileindex:=xindex-xfile1;
//value
if xfindvalue then xvalue:=valuelist[xindex];
//successful
result:=true;
skipend:
except;end;
end;
//## getfiledownindex ##
function tbasicnav.getfiledownindex:longint;
begin
try;result:=getdownindex-navcount-foldercount;except;end;
end;
//## getfolderdownindex ##
function tbasicnav.getfolderdownindex:longint;
begin
try;result:=getdownindex-navcount;except;end;
end;
//## getnavdownindex ##
function tbasicnav.getnavdownindex:longint;
begin
try;result:=getdownindex;except;end;
end;
//## setsortstyle ##
procedure tbasicnav.setsortstyle(x:longint);
begin
try;if low__setint(isortstyle,frcrange(x,0,nlMax)) then imustreload:=true;except;end;
end;
//## setfilterlist ##
procedure tbasicnav.setfilterlist(x:string);
var//Note: expects a list of KNOWN extensions e.g. "bat;txt;bmp;tea" etc
   dcount,dindex,xlen,lp,p:longint;
   dlabel,dext,dmask:string;
   c:char;
begin
try
//init
dindex:=0;
dcount:=0;
//get
xlen:=length(x);
if (xlen>=1) then
   begin
   //init
   lp:=1;
   x:=x+fesep;
   xlen:=length(x);
   //get
   for p:=1 to xlen do
   begin
   c:=x[p-1+stroffset];
   if (c=fesep) then
      begin
      //add
      if low__findext(strcopy1(x,lp,p-lp),dlabel,dext,dmask) then
         begin
         if (dcount>=high(fcap)) then break;
         fcap[dcount]:=dlabel;
         fext[dcount]:=dext;
         fmsk[dcount]:=dmask;
         ftep[dcount]:=tepext('.'+dext);
         inc(dcount);
         end;
      //reset
      lp:=p+1;
      end;
   end;//p
   end;//if
//set
fcount:=dcount;
findex:=frcrange(dindex,0,frcmin(dcount-1,0));
findex_tep;
except;end;
end;
//## findex_tep ##
procedure tbasicnav.findex_tep;
var
   int1,dtep:longint;
begin
try
dtep:=tepXXX20;
if (fcount>=1) then dtep:=tepext('.'+fext[frcrange(findex,0,fcount-1)]);
if zzok(ifilter,7272) and (ifilter.tep<>dtep) then ifilter.tep:=dtep;
except;end;
end;
//## getfilterlist ##
function tbasicnav.getfilterlist:string;
var
   p:longint;
begin
try
result:='';
if (fcount>=1) then for p:=0 to (fcount-1) do if (fext[p]<>'') then result:=result+fext[p]+fesep;
except;end;
end;
//## getfilter ##
function tbasicnav.getfilter:string;
var
   p:longint;
begin
try
//defaults
result:='';
if (fcount>=1) then result:=fext[0];
//active filter
if (fcount>=1) then result:=fext[frcrange(findex,0,fcount-1)];
except;end;
end;
//## getfilter ##
function tbasicnav.getfilterindex:longint;
begin
try;result:=frcrange(findex,0,frcmin(fcount-1,0));except;end;
end;
//## setfilter ##
procedure tbasicnav.setfilterindex(x:longint);
begin
try;findex:=frcrange(x,0,frcmin(fcount-1,0));findex_tep;except;end;
end;
//## setfilter ##
procedure tbasicnav.setfilter(x:string);
var
   p:longint;
begin
try
//check
if (fcount<=0) then exit;
//find
for p:=0 to (fcount-1) do if low__comparetext(x,fext[p]) then
   begin
   findex:=p;
   findex_tep;
   break;
   end;
except;end;
end;
//## setfilterfromfilename ##
procedure tbasicnav.setfilterfromfilename(x:string);//used by "popsave()" to automatically choose save filter by filename extension - 18jun2021
begin
try;filter:=readfileext(x,false);except;end;
end;
//## setvalue ##
procedure tbasicnav.setvalue(x:string);
var
   f,n,xmustfolder,xmustname:string;
   p:longint;
begin
try
//defaults
if (strcopy1(x,2,1)=':') then//fixed - 09aug2021
   begin
   xmustfolder:=x;
   xmustname:='';
   end
else
   begin
   xmustfolder:='';
   xmustname:=x;
   end;
//get
if (x<>'') then
   begin
   for p:=length(x) downto 1 do if (strbyte1(x,p)=ssBackslash) or (strbyte1(x,p)=ssSlash) then
      begin
      xmustfolder:=strcopy1(x,1,p);
      xmustname:=strcopy1(x,p+1,length(x));
      break;
      end;
   end;
//filter
if (xmustfolder='') then xmustfolder:='home';
//set
imustfolder:=xmustfolder;
imustname:=xmustname;
except;end;
end;
//## xfiltername ##
function tbasicnav.xfiltername(xnewname:string;xaddfilterext:boolean):string;
var
   xcaplabel,xfilter:string;
   //## xmultimaskORanymask ##
   function xmultimaskORanymask:boolean;
   var
      xlen,p:longint;
   begin//Note: detects presence of mask "*" or "*;" as a part of a series of masks -> this mask changes how filenames and their extensions are treated - 09mar2021
   try
   result:=false;
   xlen:=length(xfilter);
   if (xlen>=1) then
      begin
      for p:=1 to xlen do if (strcopy1x(xfilter,p,1)='*') or (strcopy1x(xfilter,p,1)=fesepX) then
         begin
         result:=true;
         break;
         end;//p
      end;
   except;end;
   end;
begin
try
//init
xfilter:=filter;
//get
case xmultimaskORanymask of
true:begin
   result:=safename(low__extractfilename(xnewname));//filename with extension assumed
   end;
false:begin
   case xaddfilterext of
   false:result:=safename(remlastext(low__extractfilename(xnewname)));
   true:begin
      result:=safename(low__extractfilename(xnewname));
      if (xfilter<>'') and (not low__comparetext(xfilter,low__lastext(result))) then
         begin
         result:=result+'.?';//fake ext for "low__forceext2()" to work with - 09mar2021
         result:=low__forceext2(result,xfilter,false);//use currently active filter - 03mar2021
         end;
      end;
   end;//case
//   if not xaddfilterext then result:=remlastext(result);//only remove ext if value is being assigned to internal "iname.value" else it might be a name with a user defined extension that must be preserved - 09mar2021
//   result:=safename(result);
//   if xaddfilterext and (xfilter<>'') then result:=low__forceext2(result,xfilter,false);//use currently active filter - 03mar2021
   end;
end;//case
except;end;
end;
//## getvalue ##
function tbasicnav.getvalue:string;//06apr2021
begin
try;result:=valuelist[maxint];except;end;
end;
//## getvaluelist ##
function tbasicnav.getvaluelist(xindex:longint):string;//28sep2022
var//Note: xindex=maxint => switches to internal list focusindex - 28sep2022
   xtab,xtep,xtepcolor:longint;
   xcaption,xcaplabel,xhelp,xcode2:string;
   xcode,xshortcut,xindent:longint;
   xflash,xenabled,xtitle,xsep:boolean;
begin
try
//defaults
result:='';
//get
if (istyle=bnOpen) or (istyle=bnSave) then
   begin
   if zzok(iname,7273) then result:=ilistfolder+xfiltername(iname.value,true);
   end
else if (istyle=bnNav) or (istyle=bnNavlist) or (istyle=bnNamelist) then//06apr2021
   begin
   //special
   if (xindex=maxint) then xindex:=ilist.selstart;
   //folder or folder+filename
   result:=ilistfolder;
   if __ongetitem2(ilist,false,xindex,xtab,xtep,xtepcolor,xcaption,xcaplabel,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep) then
      begin
      case xcode of
      nltFile:result:=result+xcaption;
      nltFolder:result:=asfoldernil(result+xcaption);
      nltNav,nltSysfolder:begin
         result:=xcaption;
         if low__comparetext(result,'home') then result:='';
         end;
      end;//case
      end;
   end
else if (istyle=bnFolder) then
   begin
   result:=ilistfolder;
   end
else if (istyle=bnFav) or (istyle=bnFavlist) then
   begin
   //special
   if (xindex=maxint) then xindex:=ifav.selstart;
   //get
   if zzok(ifav,7275) and __ongetitem2(ifav,false,xindex,xtab,xtep,xtepcolor,xcaption,xcaplabel,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep) then result:=xcaption;
   end;
except;end;
end;
//## selectedfolder ##
function tbasicnav.selectedfolder:string;
var
   xtab,xtep,xtepcolor:longint;
   xcaption,xcaplabel,xhelp,xcode2:string;
   xcode,xshortcut,xindent:longint;
   xflash,xenabled,xtitle,xsep:boolean;
begin
try
result:='';
if (istyle=bnFav) or (istyle=bnFavlist) then
   begin
   if zzok(ifav,7276) and __ongetitem2(ifav,false,ifav.selstart,xtab,xtep,xtepcolor,xcaption,xcaplabel,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep) then result:=xcaption;
   end
else
   begin
   result:=ilistfolder;
   if __ongetitem2(ilist,false,ilist.selstart,xtab,xtep,xtepcolor,xcaption,xcaplabel,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep) then
      begin
      case xcode of
      nltFile:;
      nltFolder:result:=asfoldernil(result+xcaption);
      nltNav,nltSysfolder:begin
         result:=xcaption;
         if low__comparetext(result,'home') then result:='';
         end;
      end;//case
      end;
   end;
except;end;
end;
//## getvalueEXT ##
function tbasicnav.getvalueEXT:string;//12jan2022
begin
try
//defaults
result:='';
//get
if (valuestyle=nltFile) and (value<>'') then result:=lowercase__readfileext(value);
except;end;
end;
//## getvaluestyle ##
function tbasicnav.getvaluestyle:longint;
var
   xtab,xtep,xtepcolor:longint;
   xcaption,xcaplabel,xhelp,xcode2:string;
   xcode,xshortcut,xindent:longint;
   xflash,xenabled,xtitle,xsep:boolean;
begin
try
result:=nltNone;//none
if (istyle=bnOpen) or (istyle=bnSave) then
   begin
   result:=nltFile;
   end
else if (istyle=bnNav) or (istyle=bnNavlist) or (istyle=bnNamelist) then
   begin
   if __ongetitem2(ilist,false,ilist.selstart,xtab,xtep,xtepcolor,xcaption,xcaplabel,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep) then result:=xcode;
   end
else if (istyle=bnFolder) then
   begin
   if __ongetitem2(ilist,false,ilist.selstart,xtab,xtep,xtepcolor,xcaption,xcaplabel,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep) then result:=xcode;
   end
else if (istyle=bnFav) or (istyle=bnFavlist) then
   begin
   if zzok(ifav,7277) and __ongetitem2(ifav,false,ifav.selstart,xtab,xtep,xtepcolor,xcaption,xcaplabel,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep) then result:=xcode;
   end;
except;end;
end;
//## getfolder ##
function tbasicnav.getfolder:string;
begin
try;if (istyle=bnFav) or (istyle=bnFavlist) then result:='' else result:=ilistfolder;except;end;
end;
//## setfolder ##
procedure tbasicnav.setfolder(x:string);
begin
try
if (istyle=bnFav) or (istyle=bnFavlist) then
   begin
   //nil
   end
else
   begin
   if (x='') or low__comparetext(x,'home') then x:='home' else x:=asfoldernil(x);
   imustfolder:=x;
   end;
except;end;
end;
//## xenhancednames ##
function tbasicnav.xenhancednames(x:string):string;
begin
try
result:='home';
if (x<>'') then result:=x;
except;end;
end;
//## xhisadd ##
procedure tbasicnav.xhisadd(xval:string;xpos,xitemindex:longint;xstorev12:boolean);//22mar2021
begin
try
//filter -> enforce trailing slash for folders -> ensures history does not duplicate entries based on a trailing slash or not - 31mar2021
xval:=asfoldernil(xenhancednames(xval));
//get
if (ihisname<>'') and (strcopy1(xval,1,1)<>iprevnextcode) then his__add2(ihisname,xval,xpos,xitemindex,xstorev12);
except;end;
end;
//## canhome ##
function tbasicnav.canhome:boolean;
begin
try;result:=(folder<>'');except;end;
end;
//## home ##
procedure tbasicnav.home;
begin
try;folder:='home';except;end;
end;
//## filter__onclick ##
procedure tbasicnav.filter__onclick(sender:tobject);
var
   m:tstr8;
   xcode:longint;
   xcode2:string;
   int1,p,i:longint;
begin
try
//defaults
m:=nil;
//check
if (fcount<=0) or zznil(ifilter,2327) or ((istyle<>bnOpen) and (istyle<>bnSave))then exit;
//init
m:=bnew;

//get
low__menuinit(m);
low__menutitle(m,tepnone,'Available Formats','');
for p:=0 to (fcount-1) do low__menuitem2(m,ftep[p],fcap[p],'','mask',1+p,aknone,true);
low__menuend(m);

//set
int1:=findex+1;
if gui.popdroplist(m,ifilter,int1,xcode,xcode2,'') then
   begin
   if (xcode2='mask') then
      begin
      i:=frcmax(frcrange(xcode-1,0,frcmin(fcount-1,0)),high(fcap));
      if (i>=0) and (i<fcount) then
         begin
         findex:=i;
         findex_tep;
         end;
      end;
   end;
   
//filter value
if zzok(iname,7278) and ((istyle=bnOpen) or (istyle=bnSave)) then iname.value:=xfiltername(iname.value,false);
except;end;
try;bfree(m);except;end;
end;
//## __onclick ##
procedure tbasicnav.__onclick(sender:tobject);
label
   skipend;
var
   xtab,xtep,xtepcolor:longint;
   xcode2,xcaption,xcaplabel,xhelp:string;
   xcode,xshortcut,xindent:longint;
   xflash,xenabled,xtitle,xsep:boolean;
   xdblclickDisabled,xdbclick:boolean;
begin
try
//check
if zznil(sender,2329) then exit;
xdbclick:=gui.mousedbclick;
//get
if (sender is tbasictoolbar) then xoff_toolbarevent(sender as tbasictoolbar)//07mar2021
else if (sender=ifav) then
   begin
   if __ongetitem2(ifav,false,ifav.selstart,xtab,xtep,xtepcolor,xcaption,xcaplabel,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep) then imustfolder:=xcaption;
   end
else if (sender=ilist) then
   begin
   if __ongetitem2(ilist,false,ilist.selstart,xtab,xtep,xtepcolor,xcaption,xcaplabel,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep) then
      begin
      //.fix for "single click" lists running in "lsMany" mode -> single click restricted to image on left side of list (first ~40px) - 11oct2022
      xdblclickDisabled:=(not vidoubleclicks) and ((ilist.ostyle<>lsmany) or (ilist.mousex<=(largest(40*vizoom,ilist.rowheight))));
      case xcode of
      nltFolder:begin
         if xdblclickDisabled or xdbclick then imustfolder:=ilistfolder+xcaption;
         end;
      nltNav,nltSysfolder:begin
         if xdblclickDisabled or xdbclick then imustfolder:=xcaption;
         end;
      nltFile:if zzok(iname,7279) and ((style=bnOpen) or (style=bnSave)) then iname.value:=xfiltername(xcaption,false);
      end;//case
      //his-sync
      if zzok(ilist,7280) then xhisadd(ilistfolder,ilist.pos,ilist.selstart,true);//22mar2021
      end;
   end;
skipend:
gui.xfireevent(self,fonclick);//supports closelock - 03apr2021
except;end;
end;
//## _onalign ##
procedure tbasicnav._onalign(sender:tobject);
var
   ci:trect;
   xzoom,vsp,hsp,int1,xsplit,xsplit2,xtop,xbot,ltop,ly,cw,xstyle:longint;
   dpreviewattop,dpreview,bol1:boolean;
   a1,a2,b1,b2:tbasiccontrol;
   //## sok ##
   function sok(x:tbasiccontrol):boolean;
   begin
   result:=zzok(x,7281);
   end;
   //## sa ##
   procedure sa(x:tbasiccontrol;da:trect);
   begin
   //check
   if zznil(x,2330) then exit;
   //range
   if (da.left<ci.left)     then da.left:=ci.left;
   if (da.right>ci.right)   then da.right:=ci.right;
   if (da.top<ci.top)       then da.top:=ci.top;
   if (da.bottom>ci.bottom) then da.bottom:=ci.bottom;
   //set
   x.xsetclientarea(da);
   end;
begin
try
//init
xzoom:=vizoom;
vsp:=2*xzoom;
hsp:=2*xzoom;
xstyle:=istyle;
ci:=clientinner;
cw:=ci.right-ci.left+1;
xtop:=ci.top;
xbot:=ci.bottom;
xsplit:=frcrange(ci.left+round(0.35*(ci.right-ci.left)),ci.left,ci.right);
xsplit2:=xsplit+hsp;
dpreview:=canpreview and preview and sok(ipreviewbox);//22may2022
dpreviewattop:=true;//set to TOP by default, but can be switched to bottom - 23may2022
//but
if sok(ibut) and ibut.visible then
   begin
   sa(ibut,rect(ci.left,xbot-ibut.getalignheight(cw),ci.right,xbot));
   xbot:=ibut.clientarea.top-vsp;
   end;
//bar
if sok(ibar) and ibar.visible then
   begin
   sa(ibar,rect(ci.left,xtop,ci.right,xtop+ibar.getalignheight(cw)));
   xtop:=ibar.clientarea.bottom+1;
   end;
//get
if (xstyle=bnFav) or (xstyle=bnFavlist) then
   begin
   if sok(ifav) then sa(ifav,rect(ci.left,xtop,ci.right,xbot));
   end
else if (xstyle=bnNav) or (xstyle=bnNavlist) or (xstyle=bnNamelist) then
   begin
   if sok(ilist) then sa(ilist,rect(ci.left,xtop,ci.right,xbot));
   end
else if (xstyle=bnFolder) then
   begin
   if sok(ifav)  then sa(ifav,rect(ci.left,xtop,xsplit,xbot));
   if sok(ilist) then sa(ilist,rect(xsplit2,xtop,ci.right,xbot));
   end
else if (xstyle=bnOpen) or (xstyle=bnSave) then
   begin
   //name
   if sok(iname) then sa(iname,rect(xsplit2,xbot-iname.getalignheight(cw),ci.right,xbot));
   //filter
   if sok(ifilter) then sa(ifilter,rect(ci.left,xbot-ifilter.getalignheight(cw),xsplit,xbot));
   //.new xbot
   if sok(ifilter) then xbot:=ifilter.clientarea.top-1 else if sok(iname) then xbot:=iname.clientarea.top-1;
   //filterlabel + namelabel
   if sok(ifilterlabel) then sa(ifilterlabel,rect(ci.left,xbot-ifilterlabel.getalignheight(cw),xsplit,xbot));
   if sok(inamelabel) then sa(inamelabel,rect(xsplit2,xbot-inamelabel.getalignheight(cw),ci.right,xbot));
   //.new xbot
   if sok(ifilterlabel) then xbot:=ifilterlabel.clientarea.top-vsp else if sok(inamelabel) then xbot:=inamelabel.clientarea.top-vsp;
   //fav + preview -------------------------------------------------------------
   //.get
   if dpreviewattop and dpreview then
      begin
      a1:=ipreviewlabel;
      a2:=ipreviewbox;
      b1:=ifavlabel;
      b2:=ifav;
      end
   else
      begin
      a1:=ifavlabel;
      a2:=ifav;
      b1:=ipreviewlabel;
      b2:=ipreviewbox;
      end;
   //.set
   ltop:=xtop;
   if sok(a1) then
      begin
      int1:=a1.getalignheight(xsplit-ci.left+1);
      sa(a1,rect(ci.left,xtop,xsplit,xtop+int1-1));
      inc(ltop,int1);
      end;
   if sok(a2) then
      begin
      if dpreview then int1:=xtop+((xbot-xtop) div 2) else int1:=xbot;//23may2022
      sa(a2,rect(ci.left,ltop,xsplit,int1));
      ltop:=int1+1;
      end;
   //preview - optional- 22may2022
   if dpreview then
      begin
      if sok(b1) then
         begin
         int1:=b1.getalignheight(xsplit-ci.left+1);
         sa(b1,rect(ci.left,ltop,xsplit,ltop+int1-1));
         inc(ltop,int1);
         end;
      if sok(b2) then sa(b2,rect(ci.left,ltop,xsplit,xbot));
      end;
   //list
   int1:=0;
   if sok(ilistlabel) then
      begin
      int1:=ilistlabel.getalignheight(ci.right-xsplit2+1);
      sa(ilistlabel,rect(xsplit2,xtop,ci.right,xtop+int1-1));
      end;
   if sok(ilist) then sa(ilist,rect(xsplit2,xtop+int1,ci.right,xbot));
   end;
except;end;
end;
//## __ongetitem ##
function tbasicnav.__ongetitem(sender:tobject;xindex:longint;var xtab,xtep,xtepcolor:longint;var xcaption,xcaplabel,xhelp,xcode2:string;var xcode,xshortcut,xindent:longint;var xflash,xenabled,xtitle,xsep:boolean):boolean;
begin
try;result:=__ongetitem2(sender,true,xindex,xtab,xtep,xtepcolor,xcaption,xcaplabel,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep);except;end;
end;
//## __ongetitem2 ##
function tbasicnav.__ongetitem2(sender:tobject;xdisplayonly:boolean;xindex:longint;var xtab,xtep,xtepcolor:longint;var xcaption,xcaplabel,xhelp,xcode2:string;var xcode,xshortcut,xindent:longint;var xflash,xenabled,xtitle,xsep:boolean):boolean;
const
   xindentstep=5;
var
   xsortstyle:longint;
   xascending:boolean;
   int1,xstyle:longint;
   xsize:comp;
   str1,xname,xlabel:string;
begin
try
//defaults
result:=false;
//init
xsortstyle:=0;
xascending:=true;
xindent:=0;
xtab:=otab;
xtepcolor:=clnone;
xflash:=false;
//get
if zznil(sender,2131) then exit
else if (sender=ifav) then
   begin
   xcaplabel:='';
   if zzok(ifavcore,7282) and (xindex>=0) and (xindex<ifavcore.count) then xcaption:=low__readportablefilename(ifavcore.items[xindex]^) else xcaption:='?';
   if xdisplayonly then xcaption:=low__folderaslabel(xcaption);
   xtep:=tepFolder20;
   if zzok(ifavteps,7283) and (xindex>=0) and (xindex<ifavteps.count) then
      begin
      int1:=ifavteps.value[xindex];
      if (int1<>tepNone) then xtep:=int1;
      end;
   result:=true;
   end
else if (sender=ilist) then
   begin
   if zzok(ilistcore,7284) and low__navget(ilistcore,xindex,xstyle,xtep,xsize,xname,xlabel) then
      begin
      xcode:=xstyle;
      xcaption:=xname;
      case xstyle of//0=nav, 1=folder, 2=file, 3=full folder
      nltTitle:begin
         if (xindex=0) and (xcaption='') then
            begin
            xcaption:=low__insstr(caption+'  ',caption<>'')+low__thousands64(ifoldercount)+' folder'+low__insstr('s',ifoldercount<>1)+', '+low__thousands64(ifilecount)+' file'+low__insstr('s',ifilecount<>1);
            xindent:=0;//xindentstep;
            end;
         xtep:=tepNone;
         xtitle:=true;
         end;
      nltNav:xindent:=frcmin(xindex-1,0)*xindentstep;
      nltFolder,nltSysfolder:;
      nltFile:;
      else xtep:=tepUnknown20;
      end;//case

      //caption filter
      if ((xstyle=nltNav) or (xstyle=nltSysfolder)) and xdisplayonly and (xcaption<>'') then xcaption:=low__folderaslabel(xcaption);

      //special overrides
      if (xstyle=nltNav) and (xname='') then
         begin
         xindent:=0;
         xcaption:='Home';
         xcaplabel:=xlabel;
         xtep:=tepHome20;
         end
      else if (xstyle=nltTitle) then
         begin
         xcaplabel:=xlabel;
         end
      else if (length(xname)=3) and (strbyte1(xname,2)=ssColon) and ((strbyte1(xname,3)=ssbackslash) or (strbyte1(xname,3)=ssSlash)) then//05apr2021
         begin
         xcaption:=low__uppercase(xcaption);
         xcaplabel:=xlabel;
         end
      else if (xstyle=nltNav) or (xstyle=nltSysfolder) then xcaplabel:=xlabel
      else if (xstyle=nltFolder) then xcaplabel:=xlabel
      end
   else
      begin
      xcaption:='list__'+inttostr(xindex);
      xcaplabel:='list.label__'+inttostr(xindex);
      if (xtep=tepnone) then xtep:=tepNew20;
      end;
   result:=true;
   end;
except;end;
end;
//## xbar ##
function tbasicnav.xbar:tbasictoolbar;
begin
try
result:=ibar;
if zznil(result,2340) then
   begin
   ibar:=tbasictoolbar.create(self);
   result:=ibar;
   result.onclick:=__onclick;
   _xoff_toolbaradd(result);
   end;
except;end;
end;
//## xbut ##
function tbasicnav.xbut:tbasictoolbar;
begin
try
result:=ibut;
if zznil(result,2341) then
   begin
   ibut:=tbasictoolbar.create(self);
   with ibut do
   begin
   omarkcleanly:=false;//03mar2021
   bordersize:=0;
   oasbuttons:=true;
   orighttoleft:=true;
   normal:=true;
   end;
   ibut.onclick:=__onclick;
   result:=ibut;
   end;
except;end;
end;
//## xfav ##
function tbasicnav.xfav:tbasicmenu;
begin
try
result:=ifav;
if zznil(result,2342) then
   begin
   ifav:=tbasicmenu.create(self);
   ifav.oautoclose:=false;
   ifav.help:='Jump to favourite folder';
   ifav.ongetitem:=__ongetitem;
   ifav.onclick:=__onclick;
   result:=ifav;
   end;
except;end;
end;
//## xfavlabel ##
function tbasicnav.xfavlabel:tbasiccontrol;
begin
try
result:=ifavlabel;
if zznil(result,2343) then
   begin
   ifavlabel:=ntitle(false,'Favourites','Jump to favourite folder');
   result:=ifavlabel;
   result.obold:=true;
   end;
except;end;
end;
//## xlist ##
function tbasicnav.xlist:tbasicmenu;
begin
try
result:=ilist;
if zznil(result,2344) then
   begin
   ilist:=tbasicmenu.create(self);
   ilist.oautoclose:=false;
   ilist.help:='Select a file or folder';
   ilist.makelistx(0);
   ilist.ongetitem:=__ongetitem;
   ilist.onclick:=__onclick;
   result:=ilist;
   end;
except;end;
end;
//## xlistlabel ##
function tbasicnav.xlistlabel:tbasiccontrol;
begin
try
result:=ilistlabel;
if zznil(result,2345) then
   begin
   ilistlabel:=ntitle(false,'Navigation','Select a file or folder');
   result:=ilistlabel;
   result.obold:=true;
   end;
except;end;
end;
//## xpreviewbox ##
function tbasicnav.xpreviewbox:tbasiccontrol;//22may2022
begin
try
result:=ipreviewbox;
if zznil(result,2344) then
   begin
   ipreviewbox:=ncontrol;
   result:=ipreviewbox;
   result.makeimageviewerfromfile('',true);//22may2022
   ipreviewbox.help:='Preview';
   end;
except;end;
end;
//## xpreviewlabel ##
function tbasicnav.xpreviewlabel:tbasiccontrol;//22may2022
begin
try
result:=ipreviewlabel;
if zznil(result,2345) then
   begin
   ipreviewlabel:=ntitle(false,'Preview','File Preview');
   result:=ipreviewlabel;
   result.obold:=true;
   end;
except;end;
end;
//## xname ##
function tbasicnav.xname:tbasicedit;
begin
try
result:=iname;
if zznil(result,2346) then
   begin
   iname:=tbasicedit.create(self,'');
   iname.help:='Type a filename';
   result:=iname;
   end;
except;end;
end;
//## xfilter ##
function tbasicnav.xfilter:tbasicedit;
begin
try
result:=ifilter;
if zznil(result,2347) then
   begin
   ifilter:=tbasicedit.create(self,'');
   ifilter.help:='Select file format';
   ifilter.tep:=tepFNew20;
   ifilter.makedropstatic;
   ifilter.onclick2:=filter__onclick;
   result:=ifilter;
   end;
except;end;
end;
//## xnamelabel ##
function tbasicnav.xnamelabel:tbasiccontrol;
begin
try
result:=inamelabel;
if zznil(result,2348) then
   begin
   inamelabel:=ntitle(false,'Name','Type a filename');
   result:=inamelabel;
   result.obold:=true;
   end;
except;end;
end;
//## xfilterlabel ##
function tbasicnav.xfilterlabel:tbasiccontrol;
begin
try
result:=ifilterlabel;
if zznil(result,2349) then
   begin
   ifilterlabel:=ntitle(false,'Format','Select file format');
   result:=ifilterlabel;
   result.obold:=true;
   end;
except;end;
end;
//## xvaluefile ##
function tbasicnav.xvaluefile(xdef:string):string;//28jun2022
begin
try;result:=low__udv(low__insstr(value,valuestyle=nltFile),xdef);except;end;
end;
//## setstyle ##
procedure tbasicnav.setstyle(x:longint);
const
   xcountdown=300;//5 minutes
label
   redo;
   //## xhide ##
   procedure xhide(x:tbasiccontrol);
   begin
   if zzok(x,7285) then x.visible:=false;
   end;
   //## xshow ##
   procedure xshow(x:tbasiccontrol);//22may2022
   begin
   if zzok(x,7286) then
      begin
      if (x=ipreviewbox) or (x=ipreviewlabel) then x.visible:=(canpreview and preview) else x.visible:=true;
      end;
   end;
   //## xfavcore ##
   procedure xfavcore;
   begin
   if zznil(ifavcore,2349) then ifavcore:=tdynamicstring.create;
   if zznil(ifavteps,2350) then ifavteps:=tdynamicinteger.create;
   end;
   //## xlistcore ##
   procedure xlistcore;
   begin
   if zznil(ilistcore,2351) then ilistcore:=bnew;
   end;
begin
try
//init
redo:
if not low__setint(istyle,x) then exit;
//get
if (x=bnNil) then
   begin
   xhide(ipreviewbox);//22may2022
   xhide(ipreviewlabel);
   xhide(ifav);
   xhide(ifavlabel);
   xhide(ilist);
   xhide(ilistlabel);
   xhide(iname);
   xhide(inamelabel);
   xhide(ifilter);
   xhide(ifilterlabel);
   xhide(ibar);
   xhide(ibut);
   if zzok(ibut,7287) then ibut.clear;
   end
else if (x=bnFav) then
   begin
   xhide(ipreviewbox);//22may2022
   xhide(ipreviewlabel);
   xshow(xfav);
   xshow(xfavlabel);
   xhide(ilist);
   xhide(ilistlabel);
   xhide(iname);
   xhide(inamelabel);
   xhide(ifilter);
   xhide(ifilterlabel);
   xshow(xbar);
   xshow(xbut);
   //.buttons
   xbut.clear;
   xbut.cadd('Close',tepClose20,0,scdlg,'Close window',xcountdown);
   //.other
   xfavcore;
   end
else if (x=bnFavlist) then
   begin
   xhide(ipreviewbox);//22may2022
   xhide(ipreviewlabel);
   xshow(xfav);
   xshow(xfavlabel);
   xhide(ilist);
   xhide(ilistlabel);
   xhide(iname);
   xhide(inamelabel);
   xhide(ifilter);
   xhide(ifilterlabel);
   xhide(ibar);
   xhide(ibut);
   if zzok(ibut,7288) then ibut.clear;
   //.other
   xfavcore;
   end
else if (x=bnNav) then
   begin
   xhide(ipreviewbox);//22may2022
   xhide(ipreviewlabel);
   xhide(ifav);
   xhide(ifavlabel);
   xshow(xlist);
   xshow(xlistlabel);
   xhide(iname);
   xhide(inamelabel);
   xhide(ifilter);
   xhide(ifilterlabel);
   xshow(xbar);
   xshow(xbut);
   //.buttons
   xbut.clear;
   xbut.add('Select',tepOK20,1,scdlg,'Select folder');
   xbut.cadd('Cancel',tepClose20,0,scdlg,'Close window',xcountdown);
   xbut.add('Common Folder',tepHome20,0,'nav.commonfolder','Goto common folder');
   //.other
   xlistcore;
   end
else if (x=bnNavlist) then
   begin
   xhide(ipreviewbox);//22may2022
   xhide(ipreviewlabel);
   xhide(ifav);
   xhide(ifavlabel);
   xshow(xlist);
   xshow(xlistlabel);
   xhide(iname);
   xhide(ifilter);
   xhide(inamelabel);
   xhide(ifilterlabel);
   xhide(ibar);
   xhide(ibut);
   if zzok(ibut,7289) then ibut.clear;
   //.other
   xlistcore;
   end
else if (x=bnNamelist) then//12jan2022
   begin
   xhide(ipreviewbox);//22may2022
   xhide(ipreviewlabel);
   xhide(ifav);
   xhide(ifavlabel);
   xshow(xlist);
   xshow(xlistlabel);
   xhide(iname);
   xhide(ifilter);
   xhide(inamelabel);
   xhide(ifilterlabel);
   xhide(ibar);
   xhide(ibut);
   if zzok(ibut,7289) then ibut.clear;
   //.other
   xlistcore;
   end
else if (x=bnFolder) then
   begin
   xhide(ipreviewbox);//22may2022
   xhide(ipreviewlabel);
   xshow(xfav);
   xshow(xfavlabel);
   xshow(xlist);
   xshow(xlistlabel);
   xhide(iname);
   xhide(inamelabel);
   xhide(ifilter);
   xhide(ifilterlabel);
   xshow(xbar);
   xshow(xbut);
   //.buttons
   xbut.clear;
   xbut.add('Select',tepOK20,1,scdlg,'Select folder');
   xbut.cadd('Cancel',tepClose20,0,scdlg,'Close window',xcountdown);
   xbut.add('Common Folder',tepHome20,0,'nav.commonfolder','Goto common folder');
   //.other
   xfavcore;
   xlistcore;
   end
else if (x=bnOpen) then
   begin
   xshow(xpreviewbox);//22may2022
   xshow(xpreviewlabel);
   xshow(xfav);
   xshow(xfavlabel);
   xshow(xlist);
   xshow(xlistlabel);
   xshow(xname);
   xshow(xnamelabel);
   xshow(xfilter);
   xshow(xfilterlabel);
   xshow(xbar);
   xshow(xbut);
   //.buttons
   xbut.clear;
//was:   xbut.add('Open',tepOpen20,1,scdlg+'open','Open file');
   xbut.add('Open',tepOpen20,0,'nav.openprompt','Open file');
   xbut.cadd('Cancel',tepClose20,0,scdlg,'Close window',xcountdown);
   xbut.add('Common Folder',tepHome20,0,'nav.commonfolder','Goto common folder');
   //.other
   xfavcore;
   xlistcore;
   end
else if (x=bnSave) then
   begin
   xshow(xpreviewbox);//22may2022
   xshow(xpreviewlabel);
   xshow(xfav);
   xshow(xfavlabel);
   xshow(xlist);
   xshow(xlistlabel);
   xshow(xname);
   xshow(xnamelabel);
   xshow(xfilter);
   xshow(xfilterlabel);
   xshow(xbar);
   xshow(xbut);
   //.buttons
   xbut.clear;
//was:   xbut.add('Save',tepSave20,1,scdlg+'save','Save file'); ..but we need to prompt the filename for save replace - 03mar2021
   xbut.add('Save',tepSave20,0,'nav.saveprompt','Save file');
   xbut.cadd('Cancel',tepClose20,0,scdlg,'Close window',xcountdown);
   xbut.add('Common Folder',tepHome20,0,'nav.commonfolder','Goto common folder');
   //.other
   xfavcore;
   xlistcore;
   end
else
   begin
   x:=bnNil;
   goto redo;
   end;
except;end;
//.finalise
try
if zzok(ilist,7290) then
   begin
   ilist.showmenuFill1:=xshowmenuFill1;
   ilist.showmenuFill2:=xshowmenuFill2;
   ilist.showmenuFillINT:=xshowmenuFill;
   ilist.showmenuClick1:=xshowmenuClick1;
   ilist.showmenuClickINT:=xshowmenuClick;
   ilist.showmenuClick2:=xshowmenuClick2;
   ilist.ocanshowmenu:=true;
   end;
reload;
except;end;
end;
//## reload ##
procedure tbasicnav.reload;
begin
try;imustreload:=true;except;end;
end;
//## xautoclose ##
function tbasicnav.xautoclose(x:boolean):tbasicnav;
begin
try
result:=self;
if zzok(ifav,7291) then ifav.oautoclose:=x and (istyle=bnFav);
except;end;
end;
//## makenil ##
function tbasicnav.makenil:tbasicnav;
begin
try;result:=self;style:=bnNil;except;end;
end;
//## makefav ##
function tbasicnav.makefav:tbasicnav;
begin
try;result:=self;style:=bnFav;except;end;
end;
//## makefavlist ##
function tbasicnav.makefavlist:tbasicnav;
begin
try;result:=self;style:=bnFavlist;except;end;
end;
//## makenav ##
function tbasicnav.makenav:tbasicnav;
begin
try;result:=self;style:=bnNav;onumber:=true;except;end;
end;
//## makenavlist ##
function tbasicnav.makenavlist:tbasicnav;
begin
try;result:=self;style:=bnNavlist;onumber:=true;except;end;
end;
//## makenavlist2 ##
function tbasicnav.makenavlist2:tbasicnav;
begin
try;result:=self;style:=bnNavlist;ofindname:=true;except;end;
end;
//## makenamelist ##
function tbasicnav.makenamelist:tbasicnav;
begin
try;result:=self;style:=bnNamelist;except;end;
end;
//## makefolder ##
function tbasicnav.makefolder:tbasicnav;
begin
try;result:=self;style:=bnFolder;except;end;
end;
//## makeopen ##
function tbasicnav.makeopen:tbasicnav;
begin
try;result:=self;style:=bnOpen;onumber:=true;except;end;
end;
//## makesave ##
function tbasicnav.makesave:tbasicnav;
begin
try;result:=self;style:=bnSave;onumber:=true;except;end;
end;
//## canprev ##
function tbasicnav.canprev:boolean;
begin
try;result:=(ihisname<>'') and zzok(ilist,7292) and his__canprev(ihisname);except;end;
end;
//## cannext ##
function tbasicnav.cannext:boolean;
begin
try;result:=(ihisname<>'') and zzok(ilist,8293) and his__cannext(ihisname);except;end;
end;
//## prev ##
function tbasicnav.prev:boolean;
var
   str1:string;
begin
try
result:=false;
if canprev then
   begin
   his__setactiveref(ihisname,ilist.pos,ilist.selstart);
   if his__prev(ihisname,str1,true) then
      begin
      imustfolder:=iprevnextcode+str1;
      result:=true;
      end;
   end;
except;end;
end;
//## next ##
function tbasicnav.next:boolean;
var
   str1:string;
begin
try
result:=false;
if cannext then
   begin
   his__setactiveref(ihisname,ilist.pos,ilist.selstart);
   if his__next(ihisname,str1,true) then
      begin
      imustfolder:=iprevnextcode+str1;
      result:=true;
      end;
   end;
except;end;
end;
//## _ontimer ##
procedure tbasicnav._ontimer(sender:tobject);
var
   v1,v2,int1,xnavcount,xfoldercount,xfilecount,xtotalcount:longint;
   str1,e:string;
   bol1,bol2,bol3,xnav,xfolders,xfiles,xmustreload:boolean;
   //## pfilter ##
   procedure pfilter;
   var
      int1:longint;
      str1:string;
   begin
   try
   //filter
   int1:=frcrange(findex,0,frcmin(fcount-1,0));
   if (int1>=0) and (int1<fcount) and (int1<=high(fcap)) and ((istyle=bnOpen) or (istyle=bnSave)) then
      begin
      //omasklist
      str1:=fmsk[int1];
      if not low__comparetext(str1,omasklist) then
         begin
         omasklist:=str1;
         xmustreload:=true;
         end;
      //filter.value
      if zzok(ifilter,7294) and (not low__comparetext(ifilter.value,fcap[int1])) then ifilter.value:=fcap[int1];
      end;
   except;end;
   end;
begin
try
//init
xmustreload:=false;

//.imustfolder
if (imustfolder<>'') then
   begin
   bol1:=(strcopy1(imustfolder,1,1)=iprevnextcode);
   xhisadd(imustfolder,0,0,not bol1);
   if bol1 then imustfolder:=strcopy1(imustfolder,2,length(imustfolder));
   if low__comparetext(imustfolder,'home') then ilistfolder:='' else ilistfolder:=asfoldernil(imustfolder);
   imustfolder:='';
   xmustreload:=true;
   end;
//.imustreload
if imustreload then
   begin
   imustreload:=false;
   xmustreload:=true;
   end;

//.itimer250
if (ms64>itimer250) or xmustreload then//"xmustreload" added - 28jul2021 -> fixed out-of-sync list (full list showed for 0.2sec before actual list was filtered)
   begin
   //init
   if zzok(ilist,7295) then ilist.oretainpos:=oretainpos;
   if zzok(ifav,7296)  then ifav.oretainpos:=oretainpos;//10mar2021

   //filter
   pfilter;

   //mask
   if low__setstr(ilastmask,omasklist) then xmustreload:=true;
   if low__setstr(ilastemask,oemasklist) then xmustreload:=true;
   if low__setstr(ilastemask_minmax,ominmax_emasklist) then xmustreload:=true;
   //toolbars
   if zzok(ibar,7297) and ibar.visible then xoff_toolbarsync(ibar);
   if zzok(ibut,7298) and ibut.visible then xoff_toolbarsync(ibut);

   //reset
   itimer250:=ms64+250;
   end;

//.reload
if xmustreload then
   begin
   //.listcore
   if zzok(ilist,7299) and (ilist.countx>=0) and zzok(ilistcore,7300) then
      begin
      //init
      int1:=istyle;
      xnav:=(int1=bnNav) or (int1=bnNavlist) or (int1=bnFolder) or (int1=bnOpen) or (int1=bnSave);
      xfolders:=(int1=bnNav) or (int1=bnNavlist) or (int1=bnFolder) or (int1=bnOpen) or (int1=bnSave);
      xfiles:=(int1=bnNav) or (int1=bnNavlist) or (int1=bnNamelist) or (int1=bnOpen) or (int1=bnSave);
      //get
      low__navlist3(iownerid,ilistcore,isortstyle,ilistfolder,omasklist,oemasklist,xnav,xfolders,xfiles,ominsize,omaxsize,ominmax_emasklist);//27sep2022, now sortable - 20feb2021
      low__navinfo(ilistcore,xnavcount,xfoldercount,xfilecount,xtotalcount);
      inavcount     :=xnavcount;
      ifoldercount  :=xfoldercount;
      ifilecount    :=xfilecount;
      itotalcount   :=xtotalcount;
      ilist.countx  :=xtotalcount;
      ilist.onumberfrom:=low__aorb(-1,inavcount+ifoldercount,onumber);//20mar2022
      ilist.paintnow;
      //position
      if low__setstr(ireloadref,xenhancednames(ilistfolder)) then
         begin
         v1:=0;
         v2:=0;
         if (ihisname<>'') then
            begin
            his__active2(ihisname,str1,v1,v2);
            end;
         ilist.pos:=v1;
         ilist.setsel(v2,1);
         end;
      //.folderID
      if low__setstr(ifolderidREF,ilistfolder) then low__iroll(ifolderid,1);//27sep2022
      end;
   //.favcore
   loadfav;
   end;

//.mustname
if (imustname<>'') then
   begin
   //init
   str1:=imustname;
   imustname:='';
   //filter -> update filter immediately as this affects how "iname.value" is set via "xfiltername()"
   pfilter;
   //get
   if ((istyle=bnOpen) or (istyle=bnSave) or ofindname) then
      begin
      if zzok(iname,7301) then iname.value:=xfiltername(str1,false);
      if zzok(ilist,7302) and ilist.xfindbycaption(str1,int1) then
         begin
         ilist.setsel(int1,1);
         ilist.pos:=int1;
         end;
      end;
   end;

//.ilastpreview
if (ilastpreview<>(canpreview and preview)) then
   begin
   ilastpreview:=(canpreview and preview);
   if (ipreviewlabel<>nil) then ipreviewlabel.visible:=ilastpreview;
   if (ipreviewbox<>nil)   then ipreviewbox.visible:=ilastpreview;
   gui.fullalignpaint;
   end;
//.preview
if (ms64>itimer100) then
   begin
   if (ipreviewbox<>nil) and (canpreview and preview) and ipreviewbox.visible then
      begin
      //is it a file?
      findinfoBrief(bol1,bol2,bol3);
      if bol3 then str1:=value else str1:='';
      //get
      if not low__comparetext(ilastpreviewfile,str1) then
         begin
         ilastpreviewfile:=str1;
         ipreviewbox.makeimageviewerfromfile(ilastpreviewfile,true);
         end;
      end
   else if (ipreviewbox<>nil) and (not canpreview) or (not preview) and (ilastpreviewfile<>'') then
      begin
      ilastpreviewfile:='';
      if (ipreviewbox<>nil) then ipreviewbox.makeimageviewerfromfile('',true);//reduce memory
      end;

   //previewlabel
   if (ipreviewlabel<>nil) and (ipreviewbox<>nil) and canpreview and preview then
      begin
      str1:='Preview'+low__insstr(' - '+ipreviewbox.imageviewerinfo,ipreviewbox.imageviewerinfo<>'');
      if (ipreviewlabel.text<>str1) then ipreviewlabel.text:=str1;
      end;

   //reset
   itimer100:=ms64+100;
   end;
except;end;
end;
//## _onpaint ##
procedure tbasicnav._onpaint(sender:tobject);
begin
try
//Does not need to paint anything as the child control "ilist" does all the necessary painting
//was: xparentcorners;
except;end;
end;
//## loadfav ##
procedure tbasicnav.loadfav;
var
   a:tstr8;
   p:longint;
   e:string;
begin
try
a:=nil;
if zzok(ifav,7303) and zzok(ifavcore,7304) then
   begin
   //get
   a:=bnew;
   low__fromfile(low__platfolder('settings')+'fav.txt',a,e);
   ifavcore.text:=low__limitlines(low__remdup2(a.text,true,false),ifavlimit);//11sep2021
   //.ifavteps
   if (ifavcore.count>=1) then
      begin
      tep__delall20(iownerid2);//delete any images done by use - 14apr2021
      ifavteps.atleast(ifavcore.count);
      for p:=0 to (ifavcore.count-1) do
      begin
      ifavteps.value[p]:=low__foldertep2(iownerid2,low__readportablefilename(ifavcore.value[p]));
      end;//p
      end;
   //sync
   ifav.countx:=ifavcore.count;
   ifav.paintnow;
   end;
except;end;
try;bfree(a);except;end;
end;
//## savefav ##
function tbasicnav.savefav(xdata:tstr8):boolean;
var
   e:string;
begin
try;result:=low__tofile(low__platfolder('settings')+'fav.txt',xdata,e);except;end;
end;
//## addfav ##
procedure tbasicnav.addfav(xfolder:string);
var//Note: xfolder can be a filename, so we must determine which it is so we can extract the folder - 10mar2021
   //Note: Assumes xfolder is a filename if there is a DOT after the last slash, else it's assumed to be a folder - 10mar2021
   a,b:tstr8;
   str1,e:string;
   p:longint;
begin
try
//defaults
a:=nil;
b:=nil;
//check
if (xfolder='') then exit;
//init
for p:=length(xfolder) downto 1 do
begin
if (strcopy1(xfolder,p,1)='/') or (strcopy1(xfolder,p,1)='\') then break
else if (strcopy1(xfolder,p,1)='.') then
   begin
   xfolder:=low__extractfilepath(xfolder);
   break;
   end;
end;//p
xfolder:=asfoldernil(xfolder);
//get
if zzok(ifav,7305) and zzok(ifavcore,7306) and (xfolder<>'') then
   begin
   xfolder:=low__makeportablefilename(xfolder);//make folder portable!!! - 11sep2021
   a:=bnew;
   b:=bnew;
   low__fromfile(low__platfolder('settings')+'fav.txt',b,e);
   str1:=b.text;
   a.text:=low__limitlines(low__remdup2(xfolder+low__insstr(rcode,str1<>'')+str1,true,false),ifavlimit);
   savefav(a);
   loadfav;
   end;
except;end;
try
bfree(a);
bfree(b);
except;end;
end;

//## tbasictick ################################################################
//## create ##
constructor tbasictick.create(xparent:tobject;xcaption:string);
begin
create2(xparent,true,xcaption);
end;
//## create2 ##
constructor tbasictick.create2(xparent:tobject;xstart:boolean;xcaption:string);
var
   int1,int2,p:longint;
   e:string;
begin
//self
satinc(satTick,1);
inherited create2(xparent,false);
//vars
itimer250:=ms64;
inormal:=true;
icaption:=xcaption;
ivalue:=false;
ibordersize:=0;
iref:='';
//defaults
clientheight:=20;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasictick.destroy;
begin
try
inherited destroy;
satinc(satTick,-1);
except;end;
end;
//## setvalue ##
procedure tbasictick.setvalue(x:boolean);
begin
try
if low__setbol(ivalue,x) then
   begin
   paintnow;
   xonvalue;
   end;
except;end;
end;
//## getalignwidth ##
function tbasictick.getalignwidth(xclientheight:longint):longint;
begin
try;result:=xpaintcalc(false);except;end;
end;
//## getalignheight ##
function tbasictick.getalignheight(xclientwidth:longint):longint;
begin
try;result:=frcmin((2*findbordersize)+low__instouch(largest(vifontheight,20),low__touchsmall),0);except;end;
end;
//## _ontimer ##
procedure tbasictick._ontimer(sender:tobject);
begin
try
if (ms64>itimer250) then
   begin
   xcheckref;
   itimer250:=ms64+250;
   end;
except;end;
end;
//## _onpaint ##
procedure tbasictick._onpaint(sender:tobject);
begin
try;xpaintcalc(true);except;end;
end;
//## xpaintcalc ##
function tbasictick.xpaintcalc(xmustpaint:boolean):longint;
const
   xpad1=5;
   xpad2=5;
var
   //infovars
   a:pvirtualinfo;
   cs,ci:trect;
   fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xenabled,xround,xnormal:boolean;
   //other
   xtep,xw,xh,dx,dy:longint;
   xtransparent,xsyscolors,xmouseinside,xvalue:boolean;
   str1,z,e:string;
begin
try
//defaults
result:=0;//for "getclientwidth"
//init
infovars(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);
xmouseinside:=mouseinside;
xvalue:=ivalue;
xtep:=low__t(xvalue);
//cls
if xmustpaint then lds2(cs,low__aorb(xback,xhover,xenabled and xmouseinside),clnone,xback,0,'',xround);
//image
dx:=findbordersize+xpad1;
if (xtep<>tepnone) then
   begin
   tepinfosys(xtep,xw,xh,xtransparent,xsyscolors);
   if xmustpaint then ldis(cs,dx,(ch-xh) div 2,xfont,xtep,xenabled and xmouseinside,not xenabled,xround);
   inc(dx,xw+xpad2);
   end;
//caption
z:=xlang(icaption);
dy:=(ch-fnH) div 2;
if xmustpaint then ldt2(cs,dx,dy,xfont,z,fn,xfeather,false,false,xenabled and xmouseinside,false,xround);
//frame
if xmustpaint and (xbordersize>=1) then ldf(cs,xborder,low__dc(xback,-20),xbordersize,nil,xround);
if xmustpaint then xparentcorners;
//return result
result:=dx+low__fonttextwidth2(fn,z)+xpad1+xbordersize;
except;end;
end;
//## _onnotify ##
function tbasictick._onnotify(sender:tobject):boolean;
begin
try
//not handled
result:=false;

//key
if (gui.key<>aknone) and (gui.key=akreturn) then
   begin
   result:=true;
   if enabled then value:=not value;
   end;
//mouse up -> mark as not handled so control beneath has full mouse support
if (not gui.mousedragging) and gui.mouseupstroke then
   begin
   if enabled then value:=not value;
   end;
//hover
if gui.mousemoved then
   begin
   xcheckref;
   end;

//external event override - 01mar2021
if assigned(fonnotify) then fonnotify(sender);
except;end;
end;
//## xcheckref ##
procedure tbasictick.xcheckref;
begin
try;if visible and low__setstr(iref,bnc(mouseinside)+pcrefsep+bnc(visible)) then paintnow;except;end;
end;

//## tbasicjump ################################################################
//## create ##
constructor tbasicjump.create(xparent:tobject;xcaption:string);
begin
create2(xparent,true,xcaption);
end;
//## create2 ##
constructor tbasicjump.create2(xparent:tobject;xstart:boolean;xcaption:string);
var
   int1,int2,p:longint;
   e:string;
begin
//self
//satinc(satEdit,1);
inherited create2(xparent,false);
//vars
ilastmousex:=minint;
inewref:=0;
ihoveref:=ms64;
itimer250:=ms64;
ipaintref:='';
fonclick:=nil;
imustpaint:=false;
ipos:=0;
ipert:=0;
ilen:=0;
ihoverpos:=0;
ihoverpert:=0;
ilasthoverpos:=0;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasicjump.destroy;
begin
try
//disconnect events
fonclick:=nil;
//destroy
inherited destroy;
//satinc(satEdit,-1);
except;end;
end;
//## getalignheight ##
function tbasicjump.getalignheight(xclientwidth:longint):longint;
begin
try;result:=frcmin(viFontheight*2,round((low__aorb(100,120,vitouch)/100)*40*vizoom))+(2*findbordersize);except;end;
end;
//## setparams ##
procedure tbasicjump.setparams(xpos,xlen:longint);//in milliseconds
begin
try
//range
xlen:=frcrange(xlen,0,maxint);
xpos:=frcrange(xpos,0,frcmin(xlen-1,0));
//get
if (xpos<>ipos) or (ilen<>xlen) then
   begin
   ilen:=xlen;
   ipos:=xpos;
   ipert:=low__makepertD0(xpos,xlen);
   if focused then xsyncpos;//required when FAST changes are required such when used as a jumpto panel for Music Player - 20feb2022
   imustpaint:=true;
   end;
except;end;
end;
//## _ontimer ##
procedure tbasicjump._ontimer(sender:tobject);
var
   xmustpaint:boolean;
begin
try
//defaults
xmustpaint:=false;

//inewpos
if (inewref<>0) and (ms64>=inewref) then
   begin
   gui.xfireevent(self,fonclick);//supports closelock - 03apr2021
   inewref:=0;
   end;

//hoverpos
if low__setint(ilasthoverpos,ihoverpos) or (focused and gui.mousedown) then
   begin
   ihoveref:=frcmin64(ms64+1000,ihoveref);
   xmustpaint:=true;
   end;

//timer250;
if (ms64>=itimer250) then
   begin
   if low__setstr(ipaintref,bnc(ihoveref>=ms64)) then xmustpaint:=true;
   //reset
   itimer250:=ms64+250;
   end;

//imustpaint
if imustpaint then
   begin
   imustpaint:=false;
   xmustpaint:=true;
   end;

//xmustpaint
if xmustpaint then paintnow;

except;end;
end;
//## _onpaint ##
procedure tbasicjump._onpaint(sender:tobject);
var
   //infovars
   a:pvirtualinfo;
   cs,ci:trect;
   fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xfont2,xback,xback2,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xenabled,xround,xnormal:boolean;
   //other
   v,p,jw,xhoverpos,xpos,xlen,dx,dy,tw,th:longint;
   str1:string;
begin
try
//init
//infovars(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xback,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);
infovars2(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xfont2,xback,xback2,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);
xhoverpos:=ihoverpos;
xpos:=ipos;
xlen:=frcmin(ilen,1);
jw:=frcmin(ci.right-ci.left+1-(2*xbordersize),1);

//cls
lds2(cs,xback2,xback,xback,0,vishadestyle,xround);

//xpos
dx:=ci.left+round((xpos/xlen)*jw);
v:=dx;
for p:=0 to (vizoom-1) do
begin
ldv(v,ci.top,ci.bottom,xfont,xround);
ldv(v+1,ci.top,ci.bottom,xfont,xround);
inc(v,2);
end;//p

//xhoverpos
if (ihoveref>=ms64) then
   begin
   dx:=ci.left+round((xhoverpos/xlen)*jw);
   v:=dx;
   for p:=0 to (vizoom-1) do
   begin
   ldv(v,ci.top,ci.bottom,xfont,xround);
   ldv(v+1,ci.top,ci.bottom,xfont,xround);
   inc(v,2);
   end;//p
   //caption
   str1:=low__uptime(xhoverpos+1,(xlen>=3600000),(xlen>=60000),true,true,#32);
   tw:=low__fonttextwidth2(fn,str1);
   th:=low__fontmaxh(fn);
   case (dx<=(cw div 2)) of
   true:ldt(ci,dx+10,ci.top+((ci.bottom-ci.top+1-th) div 2),xfont,str1,fn,xfeather,xround);
   false:ldt(ci,dx-tw-10,ci.top+((ci.bottom-ci.top+1-th) div 2),xfont,str1,fn,xfeather,xround);
   end;//case
   end;

//border
if (xbordersize>=1) then ldf(cs,xborder,low__dc(xback,-20),xbordersize,nil,xround);
except;end;
end;
//## _onnotify ##
function tbasicjump._onnotify(sender:tobject):boolean;
var
   xpos:longint;
   //## xsetpos ##
   procedure xsetpos(x:longint);
   begin
   ilastmousex:=minint;//disable
   ihoverpos:=frcrange(x,0,frcmin(ilen-1,0));
   ihoverpert:=low__makepertD0(frcrange(x,0,frcmin(ilen-1,0)),ilen);//06mar2022
   inewref:=ms64+500;
   ihoveref:=ms64+2000;
   paintnow;
   end;
begin
try
//not handled
result:=true;

//key
if (gui.key<>aknone) then
   begin
   xpos:=low__aorb(ipos,ihoverpos,inewref<>0);
   case gui.key of
   akhome:begin
      if enabled then xsetpos(0);
      end;
   akend:begin
      if enabled then xsetpos(len);
      end;
   akleft,akup:begin
      if enabled then xsetpos(xpos-500*low__aorb(1,4,gui.shiftok));
      end;
   akright,akdown:begin
      if enabled then xsetpos(xpos+500*low__aorb(1,4,gui.shiftok));
      end;
   akprev:begin
      if enabled then xsetpos(xpos-10000);
      end;
   aknext:begin
      if enabled then xsetpos(xpos+10000);
      end;
   end;//case
   end;

//mouse -> special note: "mousemovingfine" allows for 2px mouse wobble with no FALSE ON event - 27feb2022
if gui.mousemovingfine then
   begin
   ilastmousex:=mousex;
   xsyncpos;
   end;
if gui.mousedownstroke or gui.mouseupstroke or (gui.mousedown and gui.mousemovingfine) then
   begin
   inewref:=0;
   ilastmousex:=mousex;
   xsyncpos;
   gui.xfireevent(self,fonclick);//supports closelock - 03apr2021
   end;
except;end;
end;
//## xsyncpos ##
procedure tbasicjump.xsyncpos;//20feb2022
begin
try
if (ilastmousex>minint) then
   begin
   ihoverpos:=frcrange(round((ilastmousex/clientwidth)*ilen),0,frcmin(ilen-1,0));//10mar2021
   ihoverpert:=low__makepertD0(ilastmousex,clientwidth);//06mar2022
   end;
except;end;
end;

//## tbasicedit ################################################################
//## create ##
constructor tbasicedit.create(xparent:tobject;xcaption:string);
begin
create2(xparent,true,xcaption);
end;
//## create2 ##
constructor tbasicedit.create2(xparent:tobject;xstart:boolean;xcaption:string);
var
   int1,int2,p:longint;
   e:string;
begin
//self
satinc(satEdit,1);
inherited create2(xparent,false);
//vars
omoreoptions:=true;
ocanshowmenu:=true;
idropstatic:=false;
olimit:=maxint;
oreadonly:=false;
opassword:=false;
oborder2:=false;
iundodata:='';
iundoref:=0;//0=not set, 1=adding, 2=deleting, 3=swapping
iundodataOK:=false;
ireveal:=false;
iprogress:=0;
ibutarea1:=rect(0,0,-1,-1);
ibutarea2:=rect(0,0,-1,-1);
itep:=tepnone;
itep2:=tepnone;
itep2b:=tepnone;
iimgw:=0;
iimgw2:=0;
iimgh:=0;
iimgh2:=0;
iidleref:=ms64;
itimer250:=ms64;
itimerslow:=ms64;
iflash:=false;
inormal:=true;
icaption:=xcaption;
ititle:='';
ivalue:='';
ibordersize:=1;
iref:='';
fonclick2:=nil;
fonclick1:=nil;
fonchange:=nil;//13mar2022
onshowpass:=nil;//19jun2022
//defaults
clientheight:=20;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasicedit.destroy;
begin
try
//disconnect events
fonclick2:=nil;
fonclick1:=nil;
//destroy
inherited destroy;
satinc(satEdit,-1);
except;end;
end;
//## canundo ##
function tbasicedit.canundo:boolean;
begin
try;result:=(not oreadonly) and iundodataOK;except;end;
end;
//## canundo ##
function tbasicedit.undo:boolean;
var
   x:string;
begin
try
//defaults
result:=false;
//check
if not canundo then exit;
//get
x:=value;
if (olimit>=1) then value:=strcopy1(iundodata,1,olimit);//enforce limit - 19jun2022
iundodata:=x;
iundoref:=0;
except;end;
end;
//## undoclear ##
function tbasicedit.undoclear:boolean;
begin
try
result:=true;
iundodata:='';
iundodataOK:=false;
except;end;
end;
//## xundoautofill ##
function tbasicedit.xundoautofill(xref:longint):boolean;//pass-thru proc
begin//xref: 0=not set, 1=adding, 2=deleting, 3=swapping (paste, insert, replace etc)
try
result:=true;//always TRUE - 18jun2022
//range
xref:=frcrange(xref,0,4);
//get
if (xref<>iundoref) then
   begin
   iundoref:=xref;
   xundofill;
   end;
except;end;
end;
//## xundofill ##
procedure tbasicedit.xundofill;
begin
try
iundodata:=ivalue;
iundodataOK:=true;
except;end;
end;
//## settitle ##
procedure tbasicedit.settitle(x:string);
begin
try
if ((x='') and (ititle<>'')) or ((x<>'') and (ititle='')) then
   begin
   ititle:=x;
   alignpaintallnow;
   end
else if low__setstr(ititle,x) then paintnow;
except;end;
end;
//## canclearpassword ##
function tbasicedit.canclearpassword:boolean;
begin
try;result:=(not oreadonly) and opassword and ((ivalue<>'') or iundodataOK);except;end;
end;
//## clearpassword ##
function tbasicedit.clearpassword:boolean;
begin
try
result:=true;
if canclearpassword and gui.popquery('Clear password?') then
   begin
   value:='';
   undoclear;
   end;
except;end;
end;
//## canpastepassword ##
function tbasicedit.canpastepassword:boolean;
begin
try;result:=(not oreadonly) and opassword and low__canpastetxt;except;end;
end;
//## pastepassword ##
function tbasicedit.pastepassword:boolean;
var
   str1:string;
begin
try
//check
result:=false;
//get
if canpastepassword and low__pastetxt2(str1) then
   begin
   xundofill;
   value:=str1;
   result:=true;
   end;
except;end;
end;
//## showmenuFill ##
procedure tbasicedit.showmenuFill(xstyle:string;xmenudata:tstr8;var ximagealign:longint;var xmenuname:string);
var
   xcanedit,xcancopy,xcanpaste,xreadonly:boolean;
begin
try
//check
if zznil(xmenudata,2352) then exit;
xmenuname:='edit.1';
//checkers

//init
xreadonly:=oreadonly;
xcanedit:=(ivalue<>'') and (not xreadonly);
xcancopy:=low__cancopytxt and (ivalue<>'');
xcanpaste:=(not xreadonly) and low__canpastetxt;

//get
if not xreadonly then low__menuitem2(xmenudata,tepundo20,'Undo','Undo last changes','edit.undo',100,akctrlU,canundo);
if not xreadonly then low__menuitem2(xmenudata,tepcut20,'Cut','Cut text to clipboard','edit.cuttxt',100,akctrlT,xcancopy and (not xreadonly));
low__menuitem2(xmenudata,tepcopy20,'Copy','Copy text to clipboard','edit.copytxt',100,akctrlC,xcancopy);
if not xreadonly then
   begin
   low__menuitem2(xmenudata,teppaste20,'Replace','Replace with text from clipboard','edit.paste',100,akctrlP,xcanpaste and (not xreadonly));
   low__menuitem2(xmenudata,teppaste20,'Paste After','Paste text from clipboard after current text','edit.pasteafter',100,akNone,xcanpaste and (not xreadonly));
   if not opassword then low__menuitem2(xmenudata,tepclose20,'Delete All','Clear all text','edit.clear',100,akctrlD,xcanedit);
   end;
//.additional menu - 31mar2021
if opassword then
   begin
   low__menusep(xmenudata);
   low__menuitem2(xmenudata,tep__yes(ireveal),ntranslate('Show Password'),'Ticked: Show password characters','edit.togglepass',100,aknone,true);
   low__menuitem2(xmenudata,tepClose20,ntranslate('Clear Password'),'Remove password and clear undo','edit.clearpass',100,aknone,xcanedit or iundodataOK);
   end;
if (not xreadonly) and omoreoptions then
   begin
   low__menusep(xmenudata);
   low__menuitem2(xmenudata,tepUpper20,ntranslate('Upper Case'),'Make text upper case - ABCD','edit.upper',100,akctrlR,xcanedit);
   low__menuitem2(xmenudata,tepLower20,ntranslate('Lower Case'),'Make text lower case - abcd','edit.lower',100,akctrlL,xcanedit);
   low__menuitem2(xmenudata,tepName20,ntranslate('Name Case'),'Make text name case - Abcd','edit.name',100,akctrlN,xcanedit);
   low__menuitem2(xmenudata,tepNew20,ntranslate('Remove html brackets'),'Remove html brackets "<" and ">" from text','edit.rem<>',100,aknone,xcanedit);
   low__menuitem2(xmenudata,tepNew20,ntranslate('Remove Spaces'),'Remove spaces from text','edit.remspace',100,aknone,xcanedit);
   low__menuitem2(xmenudata,tepNew20,ntranslate('Remove Tabs'),'Remove tabs from text','edit.remtab',100,aknone,xcanedit);
   low__menuitem2(xmenudata,tepNew20,ntranslate('Remove Binary'),'Remove binary characters (ASCII #0..#31) from text','edit.rembin',100,aknone,xcanedit);
   end;
except;end;
end;
//## showmenuClick ##
function tbasicedit.showmenuClick(sender:tobject;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean;
label
   skipend;
var
   str1,e:string;
   //## xcanpaste ##
   function xcanpaste:boolean;
   begin
   result:=(not oreadonly) and low__canpastetxt;
   end;
   //## xcancopy ##
   function xcancopy:boolean;
   begin
   result:=(ivalue<>'');
   end;
begin
try
//handled
result:=true;
e:='';
//information
//.cut
if (xcode2='edit.cuttxt') then
   begin
   if xcancopy then
      begin
      if (not low__copytxt2(ivalue)) and gec__taskfailed(e) then goto skipend;
      xundoautofill(2);
      value:='';
      end;
   end
//.undo
else if (xcode2='edit.undo') then undo
//.copy
else if (xcode2='edit.copytxt') then
   begin
   if xcancopy and (not low__copytxt2(ivalue)) and gec__taskfailed(e) then goto skipend;
   end
//.paste
else if (xcode2='edit.paste') then
   begin
   if xcanpaste then
      begin
      if (not low__pastetxt2(str1)) and gec__taskfailed(e) then goto skipend;
      xundofill;
      value:=str1;
      end;
   end
//.pasteafter
else if (xcode2='edit.pasteafter') then
   begin
   if xcanpaste then
      begin
      if (not low__pastetxt2(str1)) and gec__taskfailed(e) then goto skipend;
      if (str1<>'') then
         begin
         xundoautofill(1);
         value:=value+str1;
         end;
      end;
   end
//.clear
else if (xcode2='edit.clear') then
   begin
   if (not oreadonly) and (value<>'') then
      begin
      xundofill;
      value:='';
      end;
   end
//.optional menu items
else if (xcode2='edit.clearpass') then clearpassword
else if (xcode2='edit.flush') then
   begin
   if not oreadonly then
      begin
      value:='';
      undoclear;
      end;
   end
else if (xcode2='edit.togglepass') then
   begin
   if not oreadonly then
      begin
      ireveal:=not ireveal;//19jun2022
      xshowpass;
      end;
   end
else if (xcode2='edit.showpass') then
   begin
   if not oreadonly then
      begin
      ireveal:=true;
      xshowpass;
      end;
   end
else if (xcode2='edit.hidepass') then
   begin
   if not oreadonly then
      begin
      ireveal:=false;
      xshowpass;
      end;
   end
else if (xcode2='edit.delete') then
   begin
   if (not oreadonly) and (ivalue<>'') and xundoautofill(2) then value:='';
   end
else if (xcode2='edit.upper') then
   begin
   if (not oreadonly) and (ivalue<>'') and xundoautofill(4) then value:=low__uppercase(value);
   end
else if (xcode2='edit.lower') then
   begin
   if (not oreadonly) and (ivalue<>'') and xundoautofill(4) then value:=low__lowercase(value);
   end
else if (xcode2='edit.name') then
   begin
   if (not oreadonly) and (ivalue<>'') and xundoautofill(4) then value:=low__asname(value);
   end
else if (xcode2='edit.remspace') then
   begin
   if (not oreadonly) and (ivalue<>'') and xundoautofill(4) then value:=low__remcharb(value,#32)
   end
else if (xcode2='edit.remtab') then
   begin
   if (not oreadonly) and (ivalue<>'') and xundoautofill(4) then value:=low__remcharb(value,#9);
   end
else if (xcode2='edit.rem<>') then
   begin
   if (not oreadonly) and (ivalue<>'') and xundoautofill(4) then value:=low__remcharb(low__remcharb(value,'<'),'>');
   end
else if (xcode2='edit.rembin') then
   begin
   if (not oreadonly) and (ivalue<>'') and xundoautofill(4) then value:=low__rembinaryb(value);
   end
//not handled
else result:=false;

skipend:
except;end;
try;if (e<>'') then gui.poperror(e);except;end;
end;
//## makeedit ##
procedure tbasicedit.makeedit;
begin
try
omoreoptions:=true;
ocanshowmenu:=true;
idropstatic:=false;
oreadonly:=false;
opassword:=false;
oborder2:=false;
tep2:=tepnone;
paintnow;
except;end;
end;
//## makepass ##
procedure tbasicedit.makepass;
begin
try
omoreoptions:=true;
ocanshowmenu:=true;
idropstatic:=false;
oreadonly:=false;
opassword:=true;
oborder2:=true;//false;
tep2:=tepRefresh20;
tep2b:=tepRefresh20;
buthelp2:='Show / hide password';
paintnow;
except;end;
end;
//## makedrop ##
procedure tbasicedit.makedrop;
begin
try
omoreoptions:=false;
ocanshowmenu:=true;
idropstatic:=false;
oreadonly:=false;
opassword:=false;
oborder2:=true;
tep2:=tepDown;
buthelp2:='Show list';
paintnow;
except;end;
end;
//## makedropstatic ##
procedure tbasicedit.makedropstatic;
begin
try
omoreoptions:=false;
ocanshowmenu:=false;
idropstatic:=true;
oreadonly:=true;
opassword:=false;
oborder2:=true;
tep2:=tepDown;
buthelp2:='Show list';
paintnow;
except;end;
end;
//## makeprogress ##
procedure tbasicedit.makeprogress;
begin
try
omoreoptions:=false;
ocanshowmenu:=false;
idropstatic:=false;
oreadonly:=true;
opassword:=false;
oborder2:=false;
tep2:=tepnone;
paintnow;
except;end;
end;
//## settep ##
procedure tbasicedit.settep(x:longint);
var
   bol1,bol2:boolean;
begin
try
if low__setint(itep,x) then
   begin
   tepinfo(itep,false,iimgw,iimgh,bol1,bol2);
   paintnow;
   end;
except;end;
end;
//## settep2 ##
procedure tbasicedit.settep2(x:longint);
var
   bol1,bol2:boolean;
begin
try
if low__setint(itep2,x) then
   begin
   tepinfo(itep2,false,iimgw2,iimgh2,bol1,bol2);
   paintnow;
   end;
except;end;
end;
//## settep2b ##
procedure tbasicedit.settep2b(x:longint);
begin
try;itep2b:=x;except;end;
end;
//## setvalue ##
procedure tbasicedit.setvalue(x:string);
begin
try
//filter
x:=low__firstnbl2(x);
//.enforce length limit
if (olimit>=1) then x:=strcopy1(x,1,olimit);
//get
if low__setstr(ivalue,x) then
   begin
   xnotidle;
   paintnow;
   xchanged;
   end;
except;end;
end;
//## xchanged ##
procedure tbasicedit.xchanged;
begin
try;if assigned(fonchange) then fonchange(self);except;end;
end;
//## xshowpass ##
procedure tbasicedit.xshowpass;
begin
try;if assigned(fonshowpass) then fonshowpass(self);except;end;
end;
//## setprogress ##
procedure tbasicedit.setprogress(x:single);
begin
try
if (x<0) then x:=0 else if (x>100) then x:=100;
if (x<>iprogress) then
   begin
   iprogress:=x;
   paintnow;
   end;
except;end;
end;
//## xtitleheight ##
function tbasicedit.xtitleheight:longint;
begin
try;if (ititle<>'') then result:=vifontheight else result:=0;except;end;
end;
//## getalignheight ##
function tbasicedit.getalignheight(xclientwidth:longint):longint;//03mar2022
var
   xzoom,int1:longint;
begin
try
xzoom:=vizoom;
int1:=systepHeight20*xzoom;//default TEP height with zoom
if ((iimgh*xzoom)>int1)         then int1:=iimgh*xzoom;
if ((iimgh2*xzoom)>int1)        then int1:=iimgh2*xzoom;
if (vifontheight>int1)          then int1:=vifontheight;//already zoomed
result:=frcmin((2*findbordersize)+low__instouch(int1,low__touchsmall)+xtitleheight,0);
except;end;
end;
//## _ontimer ##
procedure tbasicedit._ontimer(sender:tobject);
begin
try
if (ms64>itimer250) then
   begin
   xcheckref;
   itimer250:=ms64+250;
   end;
if (ms64>itimerslow) then
   begin
   iflash:=not iflash;
   xcheckref;
   itimerslow:=ms64+600;
   end;
except;end;
end;
//## _onpaint ##
procedure tbasicedit._onpaint(sender:tobject);
label
   skiptext;
var
   //infovars
   a:pvirtualinfo;
   cs,ci:trect;
   fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xfont2,xback,xback2,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xenabled,xround,xnormal:boolean;
   //other
   pa,ta:trect;
   shiftby,tmp1,ah,atitleheight,xpad0,xpad1,xpad2,xzoom,xtep,xtep2,xtep2b,p,xw,xh,int1,int2,int3,xtextheight,tw,dx2,dx,dy:longint;
   xmousedown,xtransparent,xsyscolors,bol1,ashowcursor,xmouseinside:boolean;
   str1,xvalue,xcap,xtitle,z,e:string;
   xprogress:single;
begin
try
//init
xtitle:=ititle;
atitleheight:=xtitleheight;
xzoom:=vizoom;
xpad0:=2*xzoom;//left image margin
xpad1:=5*xzoom;
xpad2:=5*xzoom;
shiftby:=2*xzoom;//space to shift down and to right when "down" or "marked"
//infovars(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);

infovars2(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xfont2,xback,xback2,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);

//var xinfo:pvirtualinfo;var xclientspace,xclientinner:trect;var fn,fb,fnH,fbH,fnbH,xclientwidth,xclientheight,xfont,xfontdisable,xfont2,xback,xback2,xborder,xhover,xfontheight,xfeather,xbordersize:longint;var xenabled,xround,xnormal:boolean);
ah:=ch-atitleheight;
ashowcursor:=xshowcursor;
xmousedown:=gui.mousedown;
xmouseinside:=mouseinside;
xprogress:=iprogress;
xhover:=low__aorb(a.disable,a.hover,xenabled);
xtep:=itep;
xtep2:=itep2;
xtep2b:=itep2b;//14jun2022
xvalue:=ivalue;
//.reveal password mode
if opassword and (xvalue<>'') then
   begin
   if (xtep2<>tepnone) then bol1:=(not ireveal) else bol1:=(not (gui.mousedown and gui.mouseleft and focused));
    if bol1 then
      begin
      for p:=0 to (length(xvalue)-1) do xvalue[p+stroffset]:='*';
      end;
   end;
xcap:=icaption;
ta:=rect(xbordersize,xbordersize,cw-1-xbordersize,ch-1-xbordersize);//start out using entire area, and gradually reduce to exact dimensions
//cls
//if (atitleheight=0) then
//lds(cs,xback,xround);
lds3(true,cs,xback,xback2,clnone,0,vishadestyle,xround,true);//27mar2021

//title
if (atitleheight>=1) then
   begin
   dy:=(ch-fnH) div 2;
   ldt(ta,ta.left,dy,low__dc(xback,70),z,fn,xfeather,false);
   end;
//image - left
dx:=xbordersize+xpad0;
if (xtep<>tepnone) then
   begin
   tepinfosys(xtep,xw,xh,xtransparent,xsyscolors);
   if (xprogress>=1) then lds2(rect(ta.left,ta.top,dx+xw+xpad2,ta.bottom),xhover,clnone,clnone,0,'h12',false);
   ldis(ci,dx,atitleheight+((ah-xh) div 2),xfont,xtep,false,not xenabled,xround);
   ibutarea1:=rect(xbordersize,0,xw+xpad2,ch-1);
   inc(dx,xw+xpad2);
   end
else ibutarea1:=rect(0,0,-1,-1);
//image2 - right
if oborder2 then int3:=low__instouch(xpad1,low__touchsmall) else int3:=0;
dx2:=cw-1-frcmin(xbordersize,0)-low__insint(xpad1,int3<=0);
if (xtep2<>tepnone) then
   begin
   //Special Note: Force fit the button snug when zoom=1, else space it out from border when zoom>=2 - 19mar2021
   tepinfosys(xtep2,xw,xh,xtransparent,xsyscolors);
   dec(dx2,xw-1+(2*int3));
   ibutarea2:=rect(dx2,xbordersize-low__insint(1,xzoom<=1)+atitleheight,dx2+int3+xw-1+int3+low__insint(1,xzoom<=1),ch-1-xbordersize+low__insint(1,xzoom<=1));//rect(dx2-xpad2,0,dx2+int3,ch-1);
   if (int3>=1) then
      begin
      tmp1:=low__aorb(clnone,xhover,low__xyinarea(mousex,mousey,ibutarea2));
      ldso2(ibutarea2,xborder,xborder,tmp1,low__dc(tmp1,-10),clnone,0,vishadestyle,xround);
      end;
   ldis(ci,dx2+int3+low__insint(shiftby,xmousedown),low__insint(shiftby,xmousedown)+atitleheight+((ah-xh) div 2),xfont,low__aorb(xtep2,xtep2b,ireveal and (xtep2b<>tepNone)),false,not xenabled,xround);
   dec(dx2,xpad2);
   end
else ibutarea2:=rect(0,0,-1,-1);
//text init
ta.left:=dx;
ta.right:=dx2;
if (ta.right<=ta.left) then goto skiptext;
//progress bar
if (xprogress>=1) then
   begin
   pa:=ta;
   if (xtep=tepnone)  then pa.left:=xbordersize;
   int1               :=low__aorb(ta.right,cw-1-xbordersize,xtep2=tepnone);
   pa.right:=frcrange(trunc((xprogress/100)*int1),ta.left,int1);
   if (xprogress>=1) then lds2(pa,xhover,clnone,clnone,0,'h12',false);
   end;
//title
if (xtitle<>'') then
   begin
   z:=xlang(xtitle);
   dy:=xbordersize;
   ldt(ta,ta.left,dy,xfont,z,fn,xfeather,false);
   end;
//caption
if (xvalue='') and (xcap<>'') then
   begin
   z:=xlang(xcap);
//was:   dy:=(ch-fnH) div 2;
   dy:=atitleheight+((ah-fnH) div 2);
   ldt(ta,ta.left,dy,low__dc(xback,70),z,fn,xfeather,false);
   end;
//value
int2:=0;
tw:=0;
if (xvalue<>'') then
   begin
//was:   dy:=(ch-fnH) div 2;
   dy:=atitleheight+((ah-fnH) div 2);
   tw:=low__fonttextwidth2(fn,xvalue);
   int1:=(ta.right-ta.left)+1;
   if (tw>int1) then int2:=-(tw-int1);
   ldt(ta,ta.left+int2,dy,xfont,xvalue,fn,xfeather,false);
   end;
//cursor
if ashowcursor then
   begin
   for p:=0 to (xzoom-1) do ldv(ta.left+tw+int2+p,xbordersize+1+atitleheight+1,ch-1-xbordersize-2,xfont,xround);
   end;
skiptext:
//frame - special note: fills in outside corner areas with "xback" -> requires when progress is >=1 as it is square and the control/frame may be round, thus the outside corner area must be filled with "xback" to erase and overlap from the square progress shading - 13apr2020
if (xbordersize>=1) then ldf2(cs,xborder,xback,xback,xbordersize,0,'',nil,xround);
xparentcorners;
except;end;
end;
//## _onshortcut ##
function tbasicedit._onshortcut(sender:tobject):boolean;//01mar2022
var
   xcode2:string;
begin//store shortcut so we can transmitt it to our host form later (once we've closed the menu) - 02apr2020
try
//defaults
result:=false;
xcode2:='';
//get
case gui.key of
akctrlU:xcode2:='edit.undo';//19jun2022
akctrlT:xcode2:='edit.cuttxt';//01mar2022
akctrlC:xcode2:='edit.copytxt';//01mar2022
akctrlP:xcode2:='edit.paste';
akctrlD:if not opassword then xcode2:='edit.clear';
akctrlR:xcode2:='edit.upper';
akctrlL:xcode2:='edit.lower';
akctrlN:xcode2:='edit.name';
end;//case
//set
if (xcode2<>'') then
   begin
   result:=true;
   showmenuClick(self,'',100,xcode2,clnone);
   end;
except;end;
end;
//## _onnotify ##
function tbasicedit._onnotify(sender:tobject):boolean;
var
   a:tpoint;
   bol1:boolean;
begin
try
//not handled
result:=false;
//key
if (gui.key<>aknone) then
   begin
   result:=true;
   if enabled and (not oreadonly) then
      begin
      case gui.key of
      0..255:if xundoautofill(1) then value:=value+char(gui.key);
      aktab:if xundoautofill(1) then value:=value+#9;
      //was: akdelete:value:='';// BUT mum likes both delete keys to delete ONE char at a time rather than clear the entire line of text - 20mar2021
      akdelete,akback:if (ivalue<>'') and xundoautofill(2) then value:=strcopy1(value,1,length(value)-1);
      end;//case
      end;
   end;
//mouse
if gui.mouseupstroke and enabled then
   begin
   a:=mousedownxy;
   if      low__ptinarea(a,ibutarea2) then
      begin
      if assigned(fonclick2) then gui.xfireevent(self,fonclick2)//supports closelock - 03apr2021
      else if opassword then
         begin
         ireveal:=not ireveal;
         xshowpass;
         end;
      end
   else if low__ptinarea(a,ibutarea1) and assigned(fonclick1) then gui.xfireevent(self,fonclick1)//supports closelock - 03apr2021
   else if idropstatic then
      begin
      if assigned(fonclick2) then gui.xfireevent(self,fonclick2);//supports closelock - 03apr2021
      end
   //double click show/hide for password only - 24sep2022
   else if gui.mousedbclick and opassword then
      begin
      ireveal:=not ireveal;
      xshowpass;
      end;
   end;
//.up/down stroke
if gui.mousedownstroke or gui.mouseupstroke or gui.mousemoved then xcheckref;
if gui.mousedownstroke or gui.mousedown or gui.mouseupstroke then xnotidle;
//.help
if gui.mousemoved and (not gui.mousedown) then
   begin
   //get
   a:=mousemovexy;
   if low__ptinarea(a,ibutarea1) then help2:=ibuthelp
   else if low__ptinarea(a,ibutarea2) then help2:=ibuthelp2
   else help2:='';//revert back to "help"
   end;
//showmenu - 20mar2021
if mustshowmenu then
   begin
   showmenu;
   result:=true;
   end;
//external event override - 01mar2021
if assigned(fonnotify) then fonnotify(sender);
except;end;
end;
//## xcheckref ##
procedure tbasicedit.xcheckref;
begin
try;if visible and low__setstr(iref,bnc(opassword)+pcrefsep+bnc(ireveal)+pcrefsep+bnc(opassword and gui.mousedownstroke and focused)+pcrefsep+bnc(opassword and gui.mouseupstroke)+pcrefsep+bnc(oborder2)+pcrefsep+bnc(oborder2 and low__ptinarea(mousemovexy,ibutarea2))+pcrefsep+bnc(xshowcursor)+pcrefsep+bnc(focused)+pcrefsep+bnc(mouseinside)+pcrefsep+bnc(visible)+pcrefsep+bnc(enabled)) then paintnow;except;end;
end;
//## xshowcursor ##
function tbasicedit.xshowcursor:boolean;
begin
try;result:=enabled and (not oreadonly) and focused and ((iidleref>=ms64) or iflash);except;end;
end;
//## xnotidle ##
procedure tbasicedit.xnotidle;
begin
try;iidleref:=ms64+750;except;end;
end;

//## tbasictitle ###############################################################
//## create ##
constructor tbasictitle.create(xparent:tobject;xlarge,xlabel:boolean;xcaption:string);
begin
create2(xparent,true,xlarge,xlabel,xcaption);
end;
//## create2 ##
constructor tbasictitle.create2(xparent:tobject;xstart,xlarge,xlabel:boolean;xcaption:string);
begin
//self
satinc(satTitle,1);
inherited create2(xparent,false);
//vars
itimer250:=ms64;
case xlabel of
true:begin
   ilabel:=true;
   inormal:=true;
   ibordersize:=0;
   end;
false:begin
   ilabel:=false;
   inormal:=false;
   ibordersize:=1;
   end;
end;
itext:=xcaption;
iinforef:='';
olarge:=xlarge;
//controls
clientheight:=20;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasictitle.destroy;
begin
try
inherited destroy;
satinc(satTitle,-1);
except;end;
end;
//## _ontimer ##
procedure tbasictitle._ontimer(sender:tobject);
var
   xmustpaint:boolean;
begin
try
//defaults
xmustpaint:=false;

//.itimer250
if (ms64>itimer250) then
   begin
   //control info
   if low__setstr(iinforef,bnc(olarge)+pcrefsep+bnc(inormal)+pcrefsep+bnc(ilabel)) then
      begin
      xmustpaint:=true;
      end;
   //reset
   itimer250:=ms64+250;
   end;

//paint
if xmustpaint then paintnow;
except;end;
end;
//## xtitleheight ##
function tbasictitle.xtitleheight:longint;//text height
begin
try
case ilabel of
true:result:=vifontheight;
false:result:=low__aorb(vititleheight,vititleheight2,olarge);
end;
except;end;
end;
//## getalignheight ##
function tbasictitle.getalignheight(xclientwidth:longint):longint;//07sep2020
var
   int1:longint;
begin
//was: try;result:=(2*findbordersize)+low__aorb(20,32,olarge);except;end;
try
int1:=0;
if not ilabel then
   begin
   int1:=low__aorb(20,32,olarge);
   if vitouch then int1:=frcmin(int1,low__aorb(low__touchsmall,low__touchnormal,olarge));
   end;
result:=(2*findbordersize)+frcmin(xtitleheight,int1);
except;end;
end;
//## settext ##
procedure tbasictitle.settext(x:string);
begin
try;if low__setstr(itext,x) then paintnow;except;end;
end;
//## _onpaint ##
procedure tbasictitle._onpaint(sender:tobject);
var
   //infovars
   a:pvirtualinfo;
   cs,ci:trect;
   fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xenabled,xround,xnormal:boolean;
   //other
   xenhanced:boolean;
   dx,dh,fc:longint;
begin
try
//init
xenhanced:=vienhanced;
infovars(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);
dh:=frcmin(ch-(2*xbordersize),1);
//.font
case ilabel of
false:fc:=low__font1(a.fontname,-xtitleheight,true);
true:fc:=fn;
end;

//cls
case xenhanced of
true:lds2(cs,low__dc(xback,-10),xback,xback,0,'g50',xround);
false:lds2(cs,xback,xback,xback,0,vishadestyle,xround);
end;

//text
dx:=xbordersize+5;
ldt(ci,dx,ci.top+((dh-low__fontmaxh(fc)) div 2),xfont,itext,fc,xfeather,xround);//up 1px - 24feb2021

//frame
if (xbordersize>=1) then ldf2(cs,xborder,xborder,clnone,xbordersize,0,'',nil,xround);
xparentcorners;
except;end;
end;

//## tbasicinfo ################################################################
//## create2 ##
constructor tbasicinfo.create2(xparent:tobject;xstart:boolean);
var
   p:longint;
begin
//self
satinc(satInfo,1);
inherited create2(xparent,false);
//vars
ibordersize:=1;
irowpad:=3;
ocolwidth:=200;//for "vifontheight=16" -> scale as required
oautoheight:=false;
orowlimit:=5;//minint..0=mo limit, 1..N=maximum limit
ominheight:=0;
iinforef:='';
ititle:='';
ihead:='';
itext:='';
idataid:=0;
inormal:=true;
itimer250:=ms64;
//controls
clientheight:=1;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasicinfo.destroy;
begin
try
inherited destroy;
satinc(satInfo,-1);
except;end;
end;
//## _ontimer ##
procedure tbasicinfo._ontimer(sender:tobject);
var
   xmustpaint:boolean;
begin
try
//defaults
xmustpaint:=false;

//.itimer250
if (ms64>itimer250) then
   begin
   //control info
   if low__setstr(iinforef,bnc(inormal)+pcrefsep+inttostr(idataid)) then
      begin
      xmustpaint:=true;
      end;
   //reset
   itimer250:=ms64+250;
   end;

//paint
if xmustpaint then paintnow;
except;end;
end;
//## getalignheight ##
function tbasicinfo.getalignheight(xclientwidth:longint):longint;
var
   xrowpad2,int1,xcount:longint;
begin
try
case (orowlimit>=1) of
true:begin
   xcount:=orowlimit;
   result:=2*findbordersize;
   xrowpad2:=2*irowpad;
   //.title
   if (xcount>=1) and (ititle<>'') then
      begin
      int1:=low__font1(info.fontname,-frcmin(round(info.fnH*1.5),5),true);//bold
      inc(result,low__fontmaxh(int1)+xrowpad2);
      dec(xcount);
      end;
   //.head
   if (xcount>=1) and (ihead<>'') then
      begin
      inc(result,info.fnH+xrowpad2);
      dec(xcount);
      end;
   //.rows
   if (xcount>=1) then inc(result,xcount*(info.fnH+xrowpad2));
   end;
false:result:=frcmin(frcmin(clientheight,ominheight),0);
end;//case
except;end;
end;
//## _onpaint ##
procedure tbasicinfo._onpaint(sender:tobject);
const
   xcolpad=5;
var
   //infovars
   a:pvirtualinfo;
   cs,ci:trect;
   fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xenabled,xround,xnormal:boolean;
   //other
   xrowpad,xrowlimit,fc,xcolwidth,xback2,dx,dy:longint;
   xautoheight,xrowalt:boolean;
   //## xdrawline ##
   function xdrawline(xfontindex,dfontheight:longint;xtext:string;xcol,xcol2,xlinelimit:longint;xonecol,xbold:boolean):boolean;
   label
      redo;
   var
      xdata,v1,v2:tstr8;
      da:trect;
      xrowh,th,yoff,int1,xcount,p,xpos:longint;
      bol1:boolean;
   begin
   try
   //defaults
   xdata:=nil;
   v1:=nil;
   v2:=nil;
   //check
   if (xtext='') then exit;
   //get
   xdata:=bnewstr(xtext);
   v1:=bnew;
   v2:=bnew;
   bol1:=false;
   xcount:=0;
   xpos:=0;
   yoff:=0;
   xrowh:=-1;
   th:=0;
   redo:
   if low__nextline0(xdata,v1,xpos) then
      begin
      //split
      if (v1.count>=1) then
         begin
         v2.clear;
         int1:=0;
         if (xrowh=-1) then
            begin
            th:=dfontheight;
            xrowh:=th+(2*xrowpad);
            end;
         //v1 -> v1 + v2
         for p:=0 to (v1.count-1) do if (v1.pbytes[p]=9) then
            begin
            v2.add2(v1,p+1,v1.count);
            v1.del(p,v1.count);
            break;
            end;//p
         //v2 -> v2 + throw-away
         if (v2.count>=1) then
            begin
            for p:=0 to (v2.count-1) do if (v2.pbytes[p]=9) then
               begin
               v2.del(p,v2.count);
               break;
               end;//p
            end;
         //background
         if (v1.count>=1) or (v2.count>=1) then
            begin
            int1:=low__aorb(xcol,xcol2,bol1);
            if (int1<>clnone) then
               begin
               da:=rect(ci.left,dy,ci.right,dy+xrowh-1);
               if (da.bottom>ci.bottom) then da.bottom:=ci.bottom;
               lds(da,int1,xround);
               end;
          end;
         //col1
         da.left:=xbordersize+xcolpad;
         da.right:=frcmax(low__aorb(da.left+xcolwidth,cw-1-xbordersize,xonecol),ci.right);
         da.top:=dy;
         da.bottom:=dy+xrowh-1;
         if (v1.count>=1) and (da.right>da.left) then ldt4(da,da.left,da.top+((xrowh-th) div 2),xfont,v1,xfontindex,xfeather,xbold,false,false,false,xround);
         //col2
         if not xonecol then
            begin
            da.left:=da.right+xcolpad;
            da.right:=cw-1-xbordersize;
            da.top:=dy;
            da.bottom:=dy+xrowh-1;
            if (v2.count>=1) and (da.right>da.left) then ldt4(da,da.left,da.top+((xrowh-th) div 2),xfont,v2,xfontindex,xfeather,xbold,false,false,false,xround);
            end;
         //inc y
         if (v1.count>=1) or (v2.count>=1) then
            begin
            inc(dy,xrowh);
            bol1:=not bol1;
            end;
         end;
      //inc
      inc(xcount);
      if (xcount<xlinelimit) and (dy<=ch) then goto redo;
      end;
   except;end;
   try
   bfree(xdata);
   bfree(v1);
   bfree(v2);
   except;end;
   end;
begin
try
//init
infovars(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);
xrowpad:=irowpad;
xcolwidth:=low__vifontscale(frcmin(ocolwidth,10));
xback2:=low__dc(xback,10);
dy:=xbordersize;
//cls
lds2(cs,xback,clnone,xback,0,'',xround);
//title
if (ititle<>'') then
   begin
   fc:=low__font0(a.fontname,-frcmin(round(fnH*1.4),5));//larger enough not to need bold
   xdrawline(fc,low__fontmaxh(fc),ititle,a.highlight,xback,1,true,false);
   end;
//head
if (ihead<>'') then xdrawline(fb,fbH,ihead,xback,xback,1,false,false);
//text
xrowalt:=false;
if (itext<>'') then xdrawline(fn,fnH,itext,xback2,xback,maxint,false,false);
//frame
if (xbordersize>=1) then ldo(cs,xborder,xround);
xparentcorners;
except;end;
end;
//## setdata ##
procedure tbasicinfo.setdata(xtitle,xhead,xtext:string);
begin
try
if (xtitle<>ititle) or (xhead<>ihead) or (xtext<>itext) then
   begin
   ititle:=xtitle;
   ihead:=xhead;
   itext:=xtext;
   low__iroll(idataid,1);
   end;
except;end;
end;
//## settitle ##
procedure tbasicinfo.settitle(x:string);
begin
try;setdata(x,ihead,itext);except;end;
end;
//## sethead ##
procedure tbasicinfo.sethead(x:string);
begin
try;setdata(ititle,x,itext);except;end;
end;
//## settext ##
procedure tbasicinfo.settext(x:string);
begin
try;setdata(ititle,ihead,x);except;end;
end;

//## tbasicstatus ##############################################################
//## create2 ##
constructor tbasicstatus.create2(xparent:tobject;xstart:boolean);
var
   p:longint;
begin
//self
inherited create2(xparent,false);
//vars
inormal:=false;
ibordersize:=3;
itimer250:=ms64;
ipause:=false;
ilastflash:=false;
iflashcount:=0;
for p:=0 to high(icellwidth) do
begin
icellref[p]:='';
icellwidth[p]:=0;
icellpert[p]:=0;
icelltext[p]:='';
icellflash[p]:=false;
end;//p
//controls
clientheight:=20;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasicstatus.destroy;
begin
try
inherited destroy;
except;end;
end;
//## _ontimer ##
procedure tbasicstatus._ontimer(sender:tobject);
var
   xmustpaint:boolean;
   int1,p:longint;
   str1:string;
   bol1:boolean;
begin
try
//defaults
xmustpaint:=false;

//.itimer250
if (ms64>itimer250) then
   begin
   //cellref
   if not ipause then
      begin
      bol1:=false;
      for p:=0 to high(icellwidth) do
      begin
      str1:=inttostr(icellwidth[p])+#7+icelltext[p];
      if (str1<>icellref[p]) then
         begin
         icellref[p]:=str1;
         bol1:=true;
         end;
      end;//p
      if bol1 then xmustpaint:=true;
      end;
   //control info
   if low__setstr(iinforef,inttostr(iflashcount)+pcrefsep+bnc(inormal)+pcrefsep+inttostr(findbordersize)+pcrefsep+inttostr(vifontheight)) then//29dec2021
      begin
      //was: if ((align=altop) or (align=albottom)) then height:=getalignheight;
      xmustpaint:=true;
      end;
   //reset
   itimer250:=ms64+250;
   end;

//.flash support
if (iflashcount>=1) and (ilastflash<>sysflash) then
   begin
   ilastflash:=sysflash;
   xmustpaint:=true;
   end;

//paint
if xmustpaint then paintnow;
except;end;
end;
//## getalignheight ##
function tbasicstatus.getalignheight(xclientwidth:longint):longint;
begin
try;result:=frcmin((2*findbordersize)+4+vifontheight,0);except;end;
end;
//## _onpaint ##
procedure tbasicstatus._onpaint(sender:tobject);
const
   sp=3;
var
   //infovars
   a:pvirtualinfo;
   cs,ci:trect;
   xsepwidth,dcellwidth,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xflash,xenabled,xround,xnormal:boolean;
   //other
   da,pa:trect;
   dcol0,dcol1,dcol2,p2,px,xzoom,xlast,dx,dy,p:longint;
   dpert:double;
   dflash,dround:boolean;
   //## xcellwidth ##
   function xcellwidth(x:longint):longint;
   begin
   result:=icellwidth[x];
   if (result>=1) then result:=frcmin(round(icellwidth[x]*xzoom*vifontwidthratio),1);
   end;
begin
try
//init
xzoom:=vizoom;
infovars(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);
//cls
case vienhanced of
true:lds2(cs,low__dc(xback,10),xback,clnone,0,'g50',xround);
false:lds2(cs,xback,xback,clnone,0,vishadestyle,xround);//21feb2021
end;
xflash:=(iflashcount>=1) and ilastflash;
xsepwidth:=2*xzoom;

//find last
for p:=high(icellwidth) downto 0 do
begin
xlast:=p;
if (icellwidth[p]>=1) then break;
end;//p
//text
dx:=xbordersize+1+sp;
px:=xbordersize;
dy:=(ch-fnH) div 2;
for p:=0 to high(icellwidth) do if (icellwidth[p]>=1) or (icelltext[0]<>'') or (icellpert[p]>0) then
   begin
   //init
   dflash:=icellflash[p] and xflash;
   dcellwidth:=xcellwidth(p);
   dpert:=icellpert[p];
   da.left:=dx;
   if ((p=0) and (dcellwidth<=0)) or (p=xlast) then da.right:=cw-1-xbordersize else da.right:=frcmin(dx+dcellwidth-1-sp,dx);
   da.right:=frcmax(da.right,cs.right-xbordersize);
   da.top:=xbordersize;
   da.bottom:=ch-1-xbordersize;
   //get
   //.progress bar
   if (dpert>0) then
      begin
      pa:=da;
      pa.left:=px;
      pa.right:=frcrange(pa.left+round((pa.right-pa.left)*(dpert/100)),px,da.right);
      dround:=xround;
      if dround then
         begin
         if ((da.right-da.left)<low__cornerMaxwidth) then dround:=false
         else if (pa.right<=(pa.left+low__cornerMaxwidth)) then dround:=false
         else if (pa.right>=(da.right-low__cornerMaxwidth)) then dround:=false;
         end;
      //.flash
      case dflash of
      false:begin
         dcol0:=xfont;
         dcol1:=low__dc(xback,50);
         dcol2:=xback;
         end;
      true:begin
         dcol0:=xback;
         dcol1:=low__dc(xfont,35);
         dcol2:=low__dc(xfont,10);
         end;
      end;//case
      //.fill first 3px with square to make it look good
      if dround then lds2(rect(pa.left,pa.top,pa.left+low__cornerMaxwidth,pa.bottom),dcol1,dcol2,clnone,0,vishadestyle,false);

      //.because FLASH progress bar uses xback color as the text color we need to fill the background with a modified text color to give sufficent contrast - 29dec2021
      if dflash then lds2(rect(dx,pa.top,da.right,pa.bottom),low__dc(dcol2,-20),low__dc(dcol2,0),clnone,0,vishadestyle,dround);//21feb2021

      //.round or square shade progress bar - 07jul2021
      lds2(pa,dcol1,dcol2,clnone,0,vishadestyle,dround);//21feb2021
      //.text
      ldt(da,da.left,dy,dcol0,icelltext[p],fn,xfeather,false);//flash support - 29dec2021
      end
   else if dflash then
      begin
      pa:=da;
      pa.left:=px;
      //.background
      lds2(pa,xfont,xfont,clnone,0,vishadestyle,false);//flash support - 29dec2021
      //.text
      ldt(da,da.left,dy,xback,icelltext[p],fn,xfeather,false);//flash support - 29dec2021
      end
   else//normal
      begin
      ldt(da,da.left,dy,xfont,icelltext[p],fn,xfeather,false);
      end;

   //vertical dividers -> 2px wide
   px:=da.right;
   if (xbordersize>=1) and (p<xlast) and (xsepwidth>=1) then
      begin
      for p2:=1 to xsepwidth do ldv(da.right+p2-1,xbordersize,ch-1-xbordersize,xborder,xround);
      px:=da.right+xsepwidth;
      end;
   //inc
   inc(dx,dcellwidth+xsepwidth);
   end;
//frame
if (xbordersize>=1) then ldf(cs,xborder,low__dc(xback,-20),xbordersize,nil,xround);
except;end;
end;
//## xcellok ##
function tbasicstatus.xcellok(x:longint):boolean;
begin
try;result:=(x>=0) and (x<=high(icellwidth));except;end;
end;
//## setcelltext ##
procedure tbasicstatus.setcelltext(x:longint;y:string);
begin
try;if xcellok(x) then icelltext[x]:=y;except;end;
end;
//## getcelltext ##
function tbasicstatus.getcelltext(x:longint):string;
begin
try;if xcellok(x) then result:=icelltext[x] else result:='';except;end;
end;
//## setcellwidth ##
procedure tbasicstatus.setcellwidth(x,y:longint);
begin
try;if xcellok(x) then icellwidth[x]:=frcrange(y,0,999999);except;end;
end;
//## getcellwidth ##
function tbasicstatus.getcellwidth(x:longint):longint;
begin
try;if xcellok(x) then result:=icellwidth[x] else result:=0;except;end;
end;
//## setcellpert ##
procedure tbasicstatus.setcellpert(x:longint;y:double);
begin
try
if (y<0) then y:=0 else if (y>100) then y:=100;
if xcellok(x) and (icellpert[x]<>y) then
   begin
   icellpert[x]:=y;
   paintnow;
   end;
except;end;
end;
//## getcellpert ##
function tbasicstatus.getcellpert(x:longint):double;
begin
try;if xcellok(x) then result:=icellpert[x] else result:=0;except;end;
end;
//## setcellflash ##
procedure tbasicstatus.setcellflash(x:longint;y:boolean);
begin
try
if xcellok(x) and (icellflash[x]<>y) then
   begin
   icellflash[x]:=y;
   if y then inc(iflashcount) else iflashcount:=frcmin(iflashcount-1,0);
   paintnow;
   end;
except;end;
end;
//## getcellflash ##
function tbasicstatus.getcellflash(x:longint):boolean;
begin
try;if xcellok(x) then result:=icellflash[x] else result:=false;except;end;
end;

//## tbasictoolbar #############################################################
//xxxxxxxxxxxxxxxxxxxxxxxxxxxx//tttttttttttttttttttttttttttt
//## create2 ##
constructor tbasictoolbar.create2(xparent:tobject;xstart:boolean);
var
   p:longint;
begin
//self
inherited create2(xparent,false);
//options
//.title support
otitle:=false;
olarge:=false;
//.other
oclickthru:=false;
ominrows:=0;
oequalwidths:=false;
omarkcleanly:=true;
ocountdown:=true;
ocountdown_dlgcheck:=true;
oautoheight:=true;
orighttoleft:=false;
oasbuttons:=false;
owrap:=true;
oindex:=-1;
ocode:=0;
ocode2:='';
otepcolor:=clnone;
//vars
fonclick:=nil;
fonclick2:=nil;
ilastfindbycode2:=-1;//07mar2021
imustlink:=false;
istyle:=0;
irowpad:=0;
irowcount:=1;
idownindex:=-1;
ifocusindex:=-1;
ihoverindex:=-1;
ibuttonpad:=5;
ibuttonvpad:=2;
ovpad:=0;
iinforef:='';
inormal:=false;
iaddcount:=0;
itepheight:=systepHeight20;
ibordersize:=2;//looks better than 3 - 17mar2021
icountdown1000:=ms64;
itimer500:=ms64;
itimer250:=ms64;
itimer100:=ms64;
iflash:=false;
ilastflash:=sysflash;
ipause:=false;
for p:=0 to high(icap) do
begin
icanarea[p]:=false;
iarea[p]:=rect(0,0,0,0);
iusex[p]:=0;
ialign[p]:=0;
iw[p]:=0;
ih[p]:=0;
isize[p]:=0;
ipert[p]:=0;
icap[p]:='';
ican[p]:=true;
itep[p]:=tepnone;
icode[p]:=0;
icode2[p]:='';
ibuthelp[p]:='';
iref[p]:='';
ienableds[p]:=false;
ivisibles[p]:=false;
imarked[p]:=false;
ihighlight[p]:=false;
iflasher[p]:=false;
iimgright[p]:=false;
ibutpad[p]:=false;
icountdown[p]:=0;//off
end;//p

//controls
clientheight:=20;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasictoolbar.destroy;
begin
try
//disconnect timer
timer:=false;
fonclick:=nil;
fonclick2:=nil;
//self
inherited destroy;
except;end;
end;
//## marktab ##
procedure tbasictoolbar.marktab(xname:string;xmark:boolean);//11sep2021
begin
try
bhighlight2[xname]:=xmark;
bflash2[xname]:=xmark;
except;end;
end;
//## xaddoptions ##
procedure tbasictoolbar.xaddoptions;
begin
try;xaddoptions2('');except;end;
end;
//## xaddoptions2 ##
procedure tbasictoolbar.xaddoptions2(xcmd:string);
begin
try;add('Options',tepoptions20,0,low__udv(xcmd,scOptions),'Show Options | Adjust coloring, font size and various settings');except;end;
end;
//## xaddhelp ##
procedure tbasictoolbar.xaddhelp;
begin
try;add('Help',tephelp20,0,scHelp,'Show / Hide Built-in Help');except;end;//24jul2021
end;
//## xaddabout ##
procedure tbasictoolbar.xaddabout;
begin
try;add('About',tepAbout20,0,scAbout,'Show About');except;end;
end;
//## xaddsplash ##
procedure tbasictoolbar.xaddsplash;
begin
try;add('Splash',tepAbout20,0,scSplash,'Show Splash');except;end;
end;
//## xaddmixer ##
procedure tbasictoolbar.xaddmixer;//07mar2022
begin
try;add('Mixer',tepVol20,0,scMixer,'Show Mixer');except;end;
end;
//## xaddmax ##
procedure tbasictoolbar.xaddmax;//15mar2022
begin
try;add('Max',tepMax20,0,scMax,'Toggle Full Screen mode');except;end;
end;
//## xaddonTop ##
procedure tbasictoolbar.xaddonTop;//15mar2022
begin
try;hcsadd('On Top',tepOntop20,0,scOntop,'Toggle On Top',0);except;end;
end;
//## getparentpage ##
function tbasictoolbar.getparentpage:string;
label
   redo;
var
   a:tbasiccontrol;
begin
try
//defaults
result:='';
//get
a:=self;
redo:
if      zzok(a,7307) and (a is tbasicscroll) then result:=(a as tbasicscroll).page
else if zzok(a,7308) then
   begin
   a:=a.parent;
   goto redo;
   end;
except;end;
end;
//## setparentpage ##
procedure tbasictoolbar.setparentpage(x:string);
label
   redo;
var
   b:array[0..maxcore] of boolean;
   a,pa:tbasiccontrol;
   p:longint;
   xmustlink:boolean;
begin
try
xmustlink:=false;
a:=self;
//clear
for p:=0 to high(b) do b[p]:=false;

//standard page handler -> OUR parent is assumed to control the PLUS page display -> but when columns are used
redo:
if      zzok(a,7310) and (a is tbasicscroll) then
   begin
   if not low__comparetext((a as tbasicscroll).page,x) then
      begin
      (a as tbasicscroll).page:=x;
      b[a.coreindex]:=true;
      xmustlink:=true;
      end;
   end
else if zzok(a,7311) then
   begin
   a:=a.parent;
   goto redo;
   end;

//dedicated PLUS handler -> sniff out ALL page handlers that support PLUS based pages and set them SYSTEM WIDE, regardless of their parent, rootwin, etc - 28jun2022
if low__comparetext(strcopy1(x,1,length(scPlus)),scPlus) then
   begin
   //find the base handlers "tbasicscroll" controls and fire them off individually
   for p:=0 to (gui.corecount-1) do
   begin
   if gui.xinuse(p) then
      begin
      a:=gui.core[p];
      if (a<>nil) and (a.opagename<>'') and low__comparetext(strcopy1(a.opagename,1,length(scPlus)),scPlus) then
         begin
         pa:=a.parent;
         if (pa<>nil) and gui.xinuse(pa.coreindex) and (pa is tbasicscroll) and (not b[pa.coreindex]) then
            begin
            b[pa.coreindex]:=true;
            (pa as tbasicscroll).page:=x;
            xmustlink:=true;
            end;
         end;
      end;
   end;//p
   end;
//xmustlink
if xmustlink then imustlink:=true;
except;end;
end;
//## xrowheight ##
function tbasictoolbar.xrowheight:longint;
begin
try;result:=(frcmin(ovpad,0)*vizoom)+largest(largest(itepheight*vizoom,vifontheight),low__insint(low__touchsmall,vitouch))+(irowpad*vizoom)+low__insint(2*ibuttonvpad*vizoom,oasbuttons);except;end;
end;
//## xrowcount ##
function tbasictoolbar.xrowcount:longint;
begin
try;result:=frcmin(low__aorb(1,irowcount,owrap),1);except;end;
end;
//## setstyle ##
procedure tbasictoolbar.setstyle(x:longint);
begin
try;istyle:=frcrange(x,0,2);except;end;
end;
//## _ontimer ##
procedure tbasictoolbar._ontimer(sender:tobject);
var
   xmustalign,xmustpaint:boolean;
   int1,p:longint;
   xpp,str1:string;
   xonce,xmustcount,bol1:boolean;
   a,b:tbasiccontrol;
begin
try
//defaults
xmustalign:=false;
xmustpaint:=false;
xmustcount:=false;

//flash
if (sysflash<>ilastflash) then
   begin
   ilastflash:=sysflash;
   if (xflashcount=0) then
      begin
      if low__setbol(iflash,false) then xmustpaint:=true;
      end
   else
      begin
      iflash:=sysflash;
      xmustpaint:=true;
      end;
   end;

//.itimer250
if (ms64>itimer250) or imustlink then
   begin
   //imustlink
   imustlink:=false;

   //countdown
   if (ms64>=icountdown1000) then
      begin
      xmustcount:=enabled and ocountdown and (not ipause);
      icountdown1000:=ms64+1000;
      end;

   //cellref
   if not ipause then
      begin
      bol1:=false;
      xpp:=parentpage;
      xonce:=true;
      for p:=0 to high(icap) do
      begin
      //countdown
      if xmustcount and ienableds[p] and ivisibles[p] and (icountdown[p]>=1) then
         begin
         //.once only
         if xonce then
            begin
            xonce:=false;
            if xmustcount and ocountdown_dlgcheck then//might be time consuming -> do only ONCE and only when we have 1 or MORE countdowns to process - 05sep2020
               begin
               gui.xdlg(a);
               xwindow(b);
               if (zzok(a,7312) and (a<>b)) then xmustcount:=false;
               end;
            end;
         //.mustcount
         if xmustcount then
            begin
            icountdown[p]:=frcmin(icountdown[p]-1,0);
            //.auto trigger click event for link/button
            if (icountdown[p]=0) then xclickbutton(p);
            end;
         end;
      //special internally managed links
      if (icode2[p]<>'') and low__comparetext(strcopy1(icode2[p],1,length(scpage)),scpage) then imarked[p]:=low__comparetext(strcopy1(icode2[p],length(scpage)+1,length(icode2[p])),xpp);
      //refs
      str1:=inttostr(ialign[p])+pcrefsep+inttostr(isize[p])+pcrefsep+bnc(ican[p])+bnc(ihighlight[p])+bnc(ienableds[p])+pcrefsep+bnc(ivisibles[p])+pcrefsep+bnc(iflasher[p])+bnc(imarked[p])+pcrefsep+bnc(ibutpad[p])+bnc(iimgright[p])+pcrefsep+inttostr(itep[p])+pcrefsep+inttostr(length(icap[p]))+pcrefsep+icap[p]+pcrefsep+inttostr(icountdown[p])+pcrefsep+inttostr(length(ibuthelp[p]))+pcrefsep+ibuthelp[p];
      if (str1<>iref[p]) then
         begin
         iref[p]:=str1;
         bol1:=true;
         end;
      end;//p
      if bol1 then
         begin
         xmustalign:=true;
         xmustpaint:=true;
         end;
      end;
   //control info
   if low__setstr(iinforef,inttostr(istyle)+pcrefsep+bnc(vitouch)+bnc(ocountdown)+bnc(orighttoleft)+pcrefsep+bnc(oasbuttons)+pcrefsep+bnc(viround)+pcrefsep+bnc(owrap)+pcrefsep+bnc(enabled)+pcrefsep+bnc(inormal)+pcrefsep+inttostr(findbordersize)+pcrefsep+inttostr(vifontheight)+pcrefsep+inttostr(itepheight)+pcrefsep+inttostr(irowpad)+pcrefsep+inttostr(xrowcount)+pcrefsep+inttostr(ibuttonpad)+pcrefsep+inttostr(frcmin(ovpad,0))+pcrefsep+inttostr(ibuttonvpad)+low__insstr(bnc(olarge)+caption,otitle)) then
      begin
      xmustalign:=true;
      xmustpaint:=true;
      end;
   //reset
   itimer250:=ms64+250;
   end;

//.itimer500
if (ms64>itimer500) then
   begin
   //special built-in system links - 15mar2022
   if xfindbycode2b(scMixer,int1) then benabled[int1]:=low__canshowvol;//07mar2022
   if xfindbycode2b(scOntop,int1) then
      begin
      bhighlight[int1]:=viontop;
      bflash[int1]:=viontop;
      end;
   if xfindbycode2b(scMax,int1) then bmarked[int1]:=gui.fullscreen;
   //reset
   itimer500:=ms64+500;
   end;

//paint
alignpaintnow__heightcheck(xmustalign,xmustpaint,clientwidth);
except;end;
end;
//## xflashcount ##
function tbasictoolbar.xflashcount:longint;
var
   p:longint;
begin
try
result:=0;
for p:=0 to high(icap) do if icanarea[p] and ivisibles[p] and (xcapok(p) or xtepok(p)) and iflasher[p] then inc(result);
except;end;
end;
//## xfind ##
function tbasictoolbar.xfind(sx,sy:longint):longint;
var
   p:longint;
begin
try
//defaults
result:=-1;
//find
for p:=0 to high(icap) do if icanarea[p] and ivisibles[p] and (xcapok(p) or xtepok(p)) then
   begin
   if (sx>=iarea[p].left) and (sx<=iarea[p].right) and (sy>=iarea[p].top) and (sy<=iarea[p].bottom) then
      begin
      result:=p;
      break;
      end;
   end;//p
except;end;
end;
//## xfindbycode ##
function tbasictoolbar.xfindbycode(xcode:longint):longint;
var
   p:longint;
begin
try
//defaults
result:=-1;
//find
for p:=0 to high(icap) do if (xcode=icode[p]) and (xcapok2(p) or xtepok2(p)) then
   begin
   result:=p;
   break;
   end;
except;end;
end;
//## xfindbycodeb ##
function tbasictoolbar.xfindbycodeb(xcode:longint;var xindex:longint):boolean;
begin
try;result:=false;xindex:=xfindbycode(xcode);result:=(xindex>=0);except;end;
end;
//## xfindbycode2 ##
function tbasictoolbar.xfindbycode2(xcode2:string):longint;
var
   p:longint;
begin
try
//defaults
result:=-1;
//ultra-fast
if (ilastfindbycode2>=0) and (ilastfindbycode2<=high(icap)) and low__comparetext(xcode2,icode2[ilastfindbycode2]) and (xcapok2(ilastfindbycode2) or xtepok2(ilastfindbycode2)) then
   begin
   result:=ilastfindbycode2;
   exit;
   end;
//find                       //icanarea[p] and
for p:=0 to high(icap) do if low__comparetext(xcode2,icode2[p]) and (xcapok2(p) or xtepok2(p)) then
   begin
   result:=p;
   break;
   end;
//store:ultra-fast
ilastfindbycode2:=result;
except;end;
end;
//## xfindbycode2b ##
function tbasictoolbar.xfindbycode2b(xcode2:string;var xindex:longint):boolean;
begin
try;result:=false;xindex:=xfindbycode2(xcode2);result:=(xindex>=0);except;end;
end;
//## xfindbycodes ##
function tbasictoolbar.xfindbycodes(xcode:longint;xcode2:string):longint;
var
   p:longint;
begin
try
//defaults
result:=-1;
//find
for p:=0 to high(icap) do if icanarea[p] and (xcode=icode[p]) and (xcode2=icode2[p]) and (xcapok(p) or xtepok(p)) then
   begin
   result:=p;
   break;
   end;
except;end;
end;
//## _onnotify ##
function tbasictoolbar._onnotify(sender:tobject):boolean;
var
   xclickindex,int1:longint;
   xmustreset,xmustpaint:boolean;
begin
try
//defaults
result:=false;//not handled
xmustpaint:=false;
xmustreset:=false;
xclickindex:=-1;
//focus
if gui.mousedown and (not gui.mousewasdown) then
   begin
   int1:=xfind(mousedownxy.x,mousedownxy.y);
   if (int1<>idownindex) then
      begin
      if (int1>=0) and (not ienableds[int1]) then int1:=-1;
      idownindex:=int1;
      xmustpaint:=true;
      end;
   end;
//hover
int1:=xfind(mousemovexy.x,mousemovexy.y);
if (int1<>ihoverindex) then
   begin
   ihoverindex:=int1;
   //was:if enabled and xok(int1) and ienableds[int1] then screen.cursor:=crHandpoint else screen.cursor:=crDefault;
   xmustpaint:=true;
   end;
//mouse up
if (not gui.mousedown) and gui.mousewasdown then
   begin
   //click + reset + paint
   xclickindex:=idownindex;
   idownindex:=-1;//release the button -> prevents painting of button down action whilst another dialog is ontop - 05sep2020
   xmustpaint:=true;
   end;

//help
if gui.mousemoved and (not gui.mousedown) then
   begin
   if xok(int1) then help2:=ibuthelp[int1] else help2:='';
   end;

//xmustpaint
if xmustpaint then paintnow;
except;end;
//click the button
try
if (xclickindex>=0) and enabled and xok(xclickindex) and ienableds[xclickindex] and ivisibles[xclickindex] and gui.mouseleft and (not gui.mousedragging) then
   begin
   xmustreset:=true;
   xclickbutton(xclickindex);
   end;
except;end;
try
//external event override - 01mar2021
if assigned(fonnotify) then fonnotify(sender);
//xmustreset -> resets AND repaints the toolbar after a click event -> removes highlight text color in some color schemes restoring the toolbar back to pre-click visuals - 20mar2022
if xmustreset then
   begin
   idownindex:=-1;
   ihoverindex:=-1;
   paintnow;
   end;
except;end;
end;
//## xclickbutton ##
procedure tbasictoolbar.xclickbutton(xindex:longint);
var
   a:tbasiccontrol;
   xmustclick:boolean;
   //## xclicks ##
   procedure xclicks;
   begin
   gui.closelock;//prevent shutdown of system while proc in use - 03apr2021
   try
   if assigned(fonclick) then fonclick(self);
   if assigned(fonclick2) then fonclick2(self,'',ocode,ocode2,otepcolor);
   except;end;
   gui.closeunlock;
   end;
begin
try
if enabled and xok(xindex) and ienableds[xindex] and ivisibles[xindex] then
   begin
   xmustclick:=false;
   oindex:=xindex;
   ocode:=bcode[xindex];
   ocode2:=bcode2[xindex];
   otepcolor:=clnone;//not used
   //special internally managed "code2" links
   if      low__comparetext(strcopy1(ocode2,1,length(scpage)),scpage) then parentpage:=strcopy1(ocode2,length(scpage)+1,length(ocode2))//"page:" - 22apr2020
   else if low__comparetext(strcopy1(ocode2,1,length(scdlg)),scdlg) then
      begin
      if gui.xdlg(a) then
         begin
         a.ocode:=ocode;
         a.ocode2:=strcopy1(ocode2,length(scdlg)+1,length(ocode2));
         a.visible:=false;
         end;
      end
   //.sys:options -> show options
   else if low__comparetext(ocode2,scoptions) then gui.xshowoptions
   //.sys:help -> show help
   else if low__comparetext(ocode2,schelp) then gui.xshowhelp
   //.sys:about -> show about
   else if low__comparetext(ocode2,scabout) then gui.xshowabout
   //.sys:splash -> show splash
   else if low__comparetext(ocode2,scsplash) then gui.xshowsplash
   //.sys:mixer -> show mixer
   else if low__comparetext(ocode2,scmixer) then low__showvol
   //.sys:ontop -> toggle ontop
   else if low__comparetext(ocode2,scontop) then
      begin
      syssettings.b['ontop']:=not syssettings.b['ontop'];
      viSyncandsave;
      end
   //.sys:max -> toggle full screen
   else if low__comparetext(ocode2,scmax) then gui.fullscreen:=not gui.fullscreen//15mar2022
   //.event
   else xmustclick:=true;

   //click events
   if xmustclick or oclickthru then xclicks;//19jun2022
   end;
except;end;
end;
//## xcapok ##
function tbasictoolbar.xcapok(xindex:longint):boolean;
begin
try;result:=((istyle=0) or (istyle=2)) and xok(xindex) and ivisibles[xindex] and (icap[xindex]<>'');except;end;
end;
//## xcapok2 ##
function tbasictoolbar.xcapok2(xindex:longint):boolean;
begin
try;result:=((istyle=0) or (istyle=2)) and xok(xindex) and (icap[xindex]<>'');except;end;
end;
//## xtepok ##
function tbasictoolbar.xtepok(xindex:longint):boolean;
begin
try;result:=((istyle=0) or (istyle=1)) and xok(xindex) and ivisibles[xindex] and (iw[xindex]>=1) and (ih[xindex]>=1) and (itep[xindex]<>tepnone);except;end;
end;
//## xtepok2 ##
function tbasictoolbar.xtepok2(xindex:longint):boolean;
begin
try;result:=((istyle=0) or (istyle=1)) and xok(xindex) and (iw[xindex]>=1) and (ih[xindex]>=1) and (itep[xindex]<>tepnone);except;end;
end;
//## maketitle ##
function tbasictoolbar.maketitle(xcap:string):tbasictoolbar;
begin
try;result:=maketitle3(xcap,false,false);except;end;
end;
//## maketitle2 ##
function tbasictoolbar.maketitle2(xcap:string;xlarge:boolean):tbasictoolbar;
begin
try;result:=maketitle3(xcap,xlarge,false);except;end;
end;
//## maketitle3 ##
function tbasictoolbar.maketitle3(xcap:string;xlarge,xright:boolean):tbasictoolbar;
begin
try;result:=self;otitle:=true;olarge:=xlarge;orighttoleft:=xright;ibordersize:=1;caption:=xcap;except;end;
end;
//## xtitleheight ##
function tbasictoolbar.xtitleheight:longint;
begin
try
case (not otitle) of
true:result:=vifontheight;
false:result:=low__aorb(vititleheight,vititleheight2,olarge);
end;
except;end;
end;
//## getalignheight ##
function tbasictoolbar.getalignheight(xclientwidth:longint):longint;
var
   xrows,xshift,int1:longint;
begin
try
//init
xclientwidth:=frcmin(xclientwidth,1);
if oautoheight then xpaintcalc(self,xclientwidth,false);
//get
xrows:=frcmin(low__aorb(1,xrowcount,oautoheight),1);
xrows:=frcmin(xrows,ominrows);//04sep2021
xshift:=2*vizoom;
//.normal toolbar
result:=frcmin((2*findbordersize)+(xrows*xrowheight)+(frcmin(xrows-1,0)*xshift),0);
//.title toolbar
if otitle then
   begin
   int1:=low__aorb(20,32,olarge);
   if vitouch then int1:=frcmin(int1,low__aorb(low__touchsmall,low__touchnormal,olarge));
   result:=frcmin((2*findbordersize)+int1,result);
   end;
except;end;
end;
//## _onpaint ##
procedure tbasictoolbar._onpaint(sender:tobject);
begin
try;xpaintcalc(sender,clientwidth,true);except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxx//ttttttttttttttttttttttttttt
//## xpaintcalc ##
procedure tbasictoolbar.xpaintcalc(sender:tobject;xclientwidth:longint;xmustpaint:boolean);//08mar2021, 21feb2021, 23apr2020
label
   skipdone,skipend,redo,redoEqualscan;
var
   //infovars
   a:pvirtualinfo;
   barea,cs,ci:trect;
   fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xfont2,xback,xback2,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xonce,xenabled,xround,xnormal:boolean;
   //other
   pa:trect;
   sp,pad1,pad2,shiftby:longint;
   xequalwidth,xmaxwidth,xfontcol,xzoom,caw,cah,xcapwidth,dback,fc,xtep,xfonthover,xdisablefont,xbutpadding,xbutwidth,xrowh,arowcount,xstyle,xdownoffset,dx,dy,yteb,ycap,sx,xtepheight,xtebcount,bw,bh,int1,int1b,int2,int2b,int3,int4,xlast,p:longint;
   str1,e:string;
   xhighlight,xcolorise,xflash,xenhanced,xtitle,xmouseleft,xbutpad,ximgright,xwrap,xrighttoleft,xasbuttons,xscan,atep,acap,xdown,xhavefocus,bol1,bol2:boolean;
   //## xmap ##
   function xmap(x:longint):longint;
   begin
   case xrighttoleft of
   true:result:=cw-sx-xbutwidth+(x-sx)+(2*xcapwidth);
   false:result:=x;
   end;//case
   end;
   //## dx0 ##
   function dx0:longint;
   begin
   result:=ci.left+low__insint(pad1,not xasbuttons);
   end;
   //## __bmaxwidth ##
   function __bmaxwidth:longint;
   begin
   result:=isize[p];
   if (result>0) then result:=round(result*vifontwidthratio)//fixed -> but scales width ZOOM and Fontsize - 30may2021
   else if (result<0) then result:=round((-result/100)*caw);//percentage
   end;
   //## bmaxwidth ##
   function bmaxwidth:longint;
   begin
   result:=isize[p];
   if (result>0) then result:=round(result*vifontwidthratio)//fixed -> but scales width ZOOM and Fontsize - 30may2021
   else if (result<0) then result:=round((-result/100)*caw);//percentage
   //equalwidths
   if (xequalwidth>=1) and (isize[p]=0) then result:=xequalwidth;
   end;
   //## xscanwrap ##
   function xscanwrap:boolean;
      procedure xnewline;
      begin
      xscan:=false;
      inc(dy,xrowh+shiftby);
      inc(yteb,xrowh+shiftby);
      inc(ycap,xrowh+shiftby);
      inc(arowcount);
      sx:=dx0;
      dx:=sx;
      xonce:=false;//30may2021
      end;
   begin
   result:=false;
   if xscan then//fixed - 08mar2021
      begin
      //button width
      result:=true;
      //.size
      xbutwidth:=dx-sx+1;
      //no wrap -> single line only
      if not xwrap then
         begin
         xscan:=false;
         dx:=sx;
         end
      else if (icap[p]='+') then
         begin
         if xonce then xnewline else result:=false;
         end
      //scan is ok -> no need to wrap -> go back and draw item -> never wrap the first LINK on the toolbar hence "xonce" to detect past 1st item status - 08mar2021
      else if (dx<ci.right) or (not xonce) then
         begin
         xscan:=false;
         dx:=sx;
         end
      //scan past end of control -> need to wrap to next row
      else xnewline;
      end;
   end;
   //## ximgh ##
   function ximgh(xindex:longint):longint;
   begin
   result:=xzoom*ih[p];
   end;
   //## ximgw ##
   function ximgw(xindex:longint):longint;
   begin
   result:=xzoom*iw[p];
   end;
   //## xcap ##
   function xcap(xindex:longint):string;
   begin
   result:=icap[xindex];
   if ocountdown and (icountdown[xindex]>=1) then result:=result+' - '+low__thousands64(icountdown[xindex])+'s';//05sep2020
   end;
begin
try
//defaults
xequalwidth:=0;
arowcount:=1;
xenhanced:=vienhanced;
xzoom    :=vizoom;
sp       :=2*xzoom;
pad1     :=4*xzoom;//space between image and caption (if both present)
pad2     :=10*xzoom;//space between last item and next item
shiftby  :=2*xzoom;//space to shift down and to right when "down" or "marked"

//init
//infovars(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xback,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);
infovars2(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xfont2,xback,xback2,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);

//.use system supplied "clientwidth" to properly calculate width/height - 23apr2020
if not xmustpaint then
   begin
   cw:=frcmin(xclientwidth,0);
   ci.right:=ci.left+cw-1-(2*xbordersize);//fixed, wasn't taking into account the "2*xbordersize" and thus was not in sync - 08mar2021
   end;
if (cw<=0) or (ch<=0) then goto skipend;

fc:=fn;
caw:=cw-(2*xbordersize);//clientarea width (excludes bordersize)
cah:=ch-(2*xbordersize);//clientarea height (excludes bordersize)
xcapwidth:=0;
xtitle:=otitle;
xmouseleft:=gui.mouseleft;
xbutpadding:=ibuttonpad*xzoom;//20mar2021
xasbuttons:=oasbuttons;
xrighttoleft:=orighttoleft;
xtebcount:=0;
xstyle:=istyle;
xrowh:=xrowheight;
xwrap:=owrap;
xtepheight:=itepheight*xzoom;
xdisablefont:=a.disablefont;
xflash:=iflash;
xonce:=false;
xcolorise:=vicoloriseimages;
//was: if xasbuttons then xfonthover:=xfont else xfonthover:=xhover;
xfonthover:=a.fonthighlight;
//was: if xenabled and (not low__cv(xfonthover,xback,90)) then xfonthover:=low__dc(xfonthover,90);

//cls
//was: if xmustpaint then lds2(cs,xback,low__dc(xback,10),xback,0,'',xround);
if xmustpaint then
   begin
   case xtitle and xenhanced of
   true:lds2(cs,low__dc(xback,-10),xback,xback,0,'g50',xround);//match title background exactly - 11oct2020
   false:lds2(cs,xback2,xback,xback,0,vishadestyle,xround);
   end;
   end;//if

//caption -> optional -> 11oct2020
str1:=caption;
if (str1<>'') then
   begin
   fc:=low__font1(a.fontname,-xtitleheight,true);
   //was: int1:=1+((cah-low__fontmaxh(fc)) div 2);
   int1:=(cah-low__fontmaxh(fc)) div 2;//lines up perfectly with a "tbasictitle" - 26mar2022
   xcapwidth:=(5*xzoom)+low__fonttextwidth2(fc,str1)+(5*xzoom);//5px horizontal pad - zomed - 20mar2021
   if xmustpaint then ldt2(ci,ci.left+5,ci.top+int1,xfont,str1,fc,xfeather,false,false,false,false,xround);
   //shift links/buttons to right by width of caption
   cw:=frcmin(cw-xcapwidth,0);
   ci.left:=frcmax(ci.left+xcapwidth,ci.right);
   end;

//check
if (cw<=0) then goto skipdone;//10oct2020

//find last
for p:=high(icap) downto 0 do
begin
xlast:=p;
if xcapok(p) or xtepok(p) then break;
end;

//find equalwidth -> works for buttons with "size=0" -> as their natural width -> 02jun2021
if oequalwidths then
   begin
   bol1:=true;
redoEqualscan:
   //.shrink padding
   if not bol1 then
      begin
      pad1     :=1*xzoom;//space between image and caption (if both present)
      pad2     :=3*xzoom;//space between last item and next item
      xbutpadding:=round(ibuttonpad*0.75)*xzoom;//20mar2021
      end;

   //scan #1
   for p:=0 to high(icap) do if (isize[p]=0) then
      begin
      //init
      int1:=0;
      atep:=xtepok(p);
      acap:=xcapok(p);
      ximgright:=iimgright[p];
      xbutpad:=ibutpad[p];
      //inc
      if atep and acap then inc(int1,pad1);//padding between image and text
      inc(int1,pad2);
      if atep then inc(int1,iw[p]);
      if acap and (icap[p]<>'+') and (icap[p]<>'-') then inc(int1,low__fonttextwidth2(fn,xcap(p)));
      //get
      if (int1>xequalwidth) then xequalwidth:=int1;
      end;//p

   //.scan #2 - based on rows
   if (ominrows>=1) then
      begin
      int1:=0;//max number of items in a row
      int2:=0;
      int3:=0;//pixels taken up by non-equal sized buttons
      int4:=0;//button with largest caption in pixels
      for p:=0 to high(icap) do
      begin
      if (isize[p]<>0) then inc(int3,__bmaxwidth)
      else
         begin
         //init
         atep:=xtepok(p);
         acap:=xcapok(p);
         xbutpad:=false;//ibutpad[p];
         //get
         if acap then
            begin
            if (icap[p]='+') then
               begin
               if (int2>int1) then int1:=int2;
               int2:=0;
               end
            else if (icap[p]='-') then inc(int3,pad2)//21sep2021
            else if (icap[p]<>'-') then
               begin
               inc(int2);
               int4:=largest(int4,low__fonttextwidth2(fn,icap[p]));
               if atep and acap then inc(int3,pad1);//padding between image and text
               end;
            end;
         end;
      end;//p
      //.finalise
      if (int2>int1) then int1:=int2;
      //.xequalwidth based on percentage calculated -> more adjustable and pleasant on the eye - 21sep2021
      xequalwidth:=frcmin(frcmin(caw-int3,0) div int1,1);
      //.check
      if bol1 then
         begin
         bol1:=false;
         if (xequalwidth<int4) then goto redoEqualscan;
         end;
      end;

   end;

//xtebcount
for p:=0 to high(icap) do if xtepok(p) then inc(xtebcount);

//vars
dx:=dx0;
case xmustpaint of
false:dy:=xbordersize;
true:dy:=xbordersize+frcmin( (cah-(irowcount*(xrowh+shiftby))) div 2,0);//rowcount etc should already be calculated
end;//case
yteb:=dy+((xrowh-xtepheight) div 2);
ycap:=dy+((xrowh-fnH) div 2);
//draw
for p:=0 to high(icap) do
begin
dback:=clnone;
xtep:=itep[p];
atep:=xtepok(p);
acap:=xcapok(p);
ximgright:=iimgright[p];
xbutpad:=ibutpad[p];
xscan:=true;//was: owrap or xasbuttons;//need to know "area width" before we can draw the button shade and/or wrap to the next line
sx:=dx;
xbutwidth:=0;
redo:
if xscan then
   begin
   xmaxwidth:=bmaxwidth;
   xbutwidth:=0;
   end;

if acap and (icap[p]='-') then
   begin
   //draw
   if xrighttoleft then inc(dx,pad2);//compensate for change in alignment direction
   if (not xscan) and xmustpaint then ldv2(xmap(dx),dy,dy+xrowh,xborder,true,xround);//no dotted - 26sep2022
   if not xrighttoleft then inc(dx,pad2);//compensate for change in alignment direction
   //wrapscan
   if xscanwrap then goto redo;
   icanarea[p]:=false;
   end
else if acap and (icap[p]='+') then//invisible -> breaks to new line
   begin
   if xscanwrap then goto redo;
   icanarea[p]:=false;
   end
else if acap and (icap[p]='*') then//visible but NOT counted - horizontal line at bottom of current line
   begin
   if xmustpaint then ldh2(1,cw-2,dy+xrowh+2,xborder,true,false);//dotted
   icanarea[p]:=false;
   end
else if atep or acap then
   begin
   //init
   xhavefocus:=(p=ihoverindex) or (gui.mousedown and (p=idownindex));
   xdown:=xmouseleft and (gui.mousedown and (p=idownindex)) or imarked[p];
   if xdown then xdownoffset:=shiftby else xdownoffset:=0;
   xhighlight:=ihighlight[p];
   //get
   //.background color/border
   if xmustpaint and (not xscan) then
      begin
      //init
      int1:=clnone;
      int2:=clnone;
      //links
      if (not xasbuttons) and (not xhighlight) then
         begin
         if enabled and ienableds[p] and (xdown or xhighlight) and (not omarkcleanly) then int2:=a.highlight;
         end
      //buttons
      else if not ienableds[p] then
         begin
         int1:=a.disableborder;
         int2:=clnone;
         end
      else if xhavefocus then
         begin
         int1:=xhover;
         int2:=a.highlight;
         end
      else
         begin
         int1:=xborder;
         if enabled and (xdown or xhighlight) then int2:=a.highlight;
         end;

      //set
//was:if (int1<>clnone) or (int2<>clnone) then ldso(rect(xmap(1+dx+xdownoffset),1+dy+xdownoffset-1,xmap(dx+xdownoffset+xbutwidth-1),dy+xdownoffset-1+xrowh),int1,int2,xround);
      if (int1<>clnone) or (int2<>clnone) or (ipert[p]>=1) then
         begin                                                  //was: -20 on 06oct2020
         if (int2<>clnone) and vienhanced then int2b:=low__dc(int2,-10) else int2b:=int2;
         dback:=int2;
         int1b:=int1;
         if xenhanced then int1b:=low__dc(int1,-40);
//was:   ldso2(rect(xmap(1+dx+xdownoffset),1+dy+xdownoffset-1,xmap(dx+xdownoffset+xbutwidth-1),dy+xdownoffset-1+xrowh),int1,int1,int2b,int2,clnone,0,vishadestyle,xround);
//was: 07jul2021:         ldso2(rect(xmap(1+dx+xdownoffset),1+dy+xdownoffset-1,xmap(dx+xdownoffset+xbutwidth-1),dy+xdownoffset-1+xrowh),int1,int1b,int2b,int2,clnone,0,vishadestyle,xround);
         //.optional progress bar
         if (ipert[p]>=1) then
            begin
            pa:=rect(xmap(1+dx+xdownoffset),1+dy+xdownoffset-1,xmap(dx+xdownoffset+xbutwidth-1),dy+xdownoffset-1+xrowh);
            pa.right:=frcrange(pa.left+round((pa.right-pa.left)*(ipert[p]/100)),pa.left,pa.right);
            lds2(pa,low__dc(xback,50),xback,clnone,0,vishadestyle,xround);//21feb2021
            end
         else ldso2(rect(xmap(1+dx+xdownoffset),1+dy+xdownoffset-1,xmap(dx+xdownoffset+xbutwidth-1),dy+xdownoffset-1+xrowh),int1,int1b,int2b,int2,clnone,0,vishadestyle,xround);
         end;
      end;

   //.align
   if not xscan then
      begin
      inc(dx,iusex[p]);
      end;
   //.font color
   case ienableds[p] of
   true:if xenabled and ienableds[p] and (xhavefocus or xhighlight) then xfontcol:=xfonthover else xfontcol:=xfont;
   false:xfontcol:=xdisablefont;
   end;//case

   //.realtime "font" color check -> prevents MOST collisions - 11oct2020
   if (dback<>clnone) then xfontcol:=low__ecv(xfontcol,dback,20);
   //.leading button pad
   if xasbuttons or xbutpad then inc(dx,xbutpadding);

   //-- left aligned tep (tep+cap) ---------------------------------------------
   //.image -> required "buffer=true" to work
   if (not ximgright) and atep then
      begin                              //flash support 24feb2021
      if xmustpaint and (not xscan) and ((not xflash) or (not iflasher[p])) then ldis2(ci,xmap(dx+xdownoffset),yteb+xdownoffset,xfontcol,low__aorb(clnone,xback,xcolorise),xtep,xenabled and ienableds[p] and xhavefocus,(not xenabled) or (not ienableds[p]),xround);
      inc(dx,ximgw(p));
      end;
   //.padding
   if (not ximgright) and atep and acap then inc(dx,pad1);//padding between image and text

   //- caption -----------------------------------------------------------------
   if acap then
      begin
      //draw caption + countdown caption - 05sep2020
      str1:=xcap(p);
      if (not xscan) and xmustpaint then ldt2(ci,xmap(dx+xdownoffset),ycap+xdownoffset,xfontcol,str1,fn,xfeather,false,false,xenabled and ienableds[p] and (xhavefocus or (xdown and omarkcleanly)),false,xround);
      inc(dx,low__fonttextwidth2(fn,str1));

{Not required/not needed - 21sep2021
      barea:=ci;
      if (isize[p]=0) and (xequalwidth>=1) then
          begin
          barea.left:=sx;
          barea.right:=sx+xequalwidth;
          barea.top:=ci.top;
          barea.bottom:=ci.bottom;
          end;
      if (not xscan) and xmustpaint then ldt2(barea,xmap(dx+xdownoffset),ycap+xdownoffset,xfontcol,str1,fn,xfeather,false,false,xenabled and ienableds[p] and (xhavefocus or (xdown and omarkcleanly)),false,xround);
      if (isize[p]=0) and (xequalwidth>=1) then inc(dx,frcmax(low__fonttextwidth2(fn,str1),xequalwidth)) else inc(dx,low__fonttextwidth2(fn,str1));
{}//yyyyyyyyyyyyy
      end;

   //-- right aligned tep (cap+tep) --------------------------------------------
   //.padding
   if ximgright and atep and acap then inc(dx,pad1);//padding between image and text
   //.image -> required "buffer=true" to work
   if ximgright and atep then
      begin
      if xmustpaint and (not xscan) then ldis2(ci,xmap(dx+xdownoffset),yteb+xdownoffset,xfontcol,low__aorb(clnone,xback,xcolorise),xtep,xenabled and ienableds[p] and xhavefocus,(not xenabled) or (not ienableds[p]),xround);
      inc(dx,ximgw(p));
      end;

   //-- other ------------------------------------------------------------------
   //.trailing button pad
   if xasbuttons or xbutpad then inc(dx,xbutpadding);
   //.xmaxwidth
   int1:=dx;
   if (dx<(sx+1+xmaxwidth)) then dx:=sx+1+xmaxwidth;

   //.align -> only possible if xmaxwidth is LARGER than actual space used
   case ialign[p] of
   1:iusex[p]:=(dx-int1) div 2;//center
   2:iusex[p]:=dx-int1;//right
   else iusex[p]:=0;
   end;

   //wrapscan
   if xscanwrap then goto redo;

   //map area
   iarea[p].left:=xmap(sx);
   iarea[p].right:=xmap(dx);
   iarea[p].top:=dy;
   iarea[p].bottom:=dy+xrowh-1;
   icanarea[p]:=ican[p];//30may2021
   xonce:=true;
   //trailing padding space
   inc(dx,pad2);
   end
else icanarea[p]:=false;
end;//p

//frame
skipdone:
if xmustpaint and (xbordersize>=1) then ldf(cs,xborder,low__dc(xback,-20),xbordersize,nil,xround);
if xmustpaint then xparentcorners;
skipend:
//rowcount
irowcount:=frcmin(arowcount,1);
except;end;
end;
//## sadd ##
function tbasictoolbar.sadd(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;xsize,xalign:longint):longint;
begin
try;result:=cadd4(xcap,xtep,xcode,xcode2,xhelp,true,true,false,false,0,xsize,xalign);except;end;
end;
//## csadd ##
function tbasictoolbar.csadd(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;xsize:longint):longint;
begin
try;result:=cadd4(xcap,xtep,xcode,xcode2,xhelp,true,true,false,false,0,xsize,taC);except;end;
end;
//## hcsadd ##
function tbasictoolbar.hcsadd(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;xsize:longint):longint;//highlighter with button padding - 05jun2021
begin
try;result:=cadd4(xcap,xtep,xcode,xcode2,xhelp,true,true,false,true,0,xsize,taC);except;end;
end;
//## rsadd ##
function tbasictoolbar.rsadd(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;xsize:longint):longint;
begin
try;result:=cadd4(xcap,xtep,xcode,xcode2,xhelp,true,true,false,false,0,xsize,taR);except;end;
end;
//## lsadd ##
function tbasictoolbar.lsadd(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;xsize:longint):longint;
begin
try;result:=cadd4(xcap,xtep,xcode,xcode2,xhelp,true,true,false,false,0,xsize,taL);except;end;
end;
//## add ##
function tbasictoolbar.add(xcap:string;xtep,xcode:longint;xcode2,xhelp:string):longint;
begin
try;result:=cadd4(xcap,xtep,xcode,xcode2,xhelp,true,true,false,false,0,0,0);except;end;
end;
//## add2 ##
function tbasictoolbar.add2(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;ximgright:boolean):longint;
begin
try;result:=cadd4(xcap,xtep,xcode,xcode2,xhelp,true,true,ximgright,false,0,0,0);except;end;
end;
//## add3 ##
function tbasictoolbar.add3(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;xenabled,xvisible,ximgright:boolean):longint;
begin
try;result:=cadd4(xcap,xtep,xcode,xcode2,xhelp,xenabled,xvisible,ximgright,false,0,0,0);except;end;
end;
//## cadd ##
function tbasictoolbar.cadd(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;xcountdown:longint):longint;
begin
try;result:=cadd4(xcap,xtep,xcode,xcode2,xhelp,true,true,false,false,xcountdown,0,0);except;end;
end;
//## cadd2 ##
function tbasictoolbar.cadd2(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;ximgright:boolean;xcountdown:longint):longint;
begin
try;result:=cadd4(xcap,xtep,xcode,xcode2,xhelp,true,true,ximgright,false,xcountdown,0,0);except;end;
end;
//## cadd3 ##
function tbasictoolbar.cadd3(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;xenabled,xvisible,ximgright:boolean;xcountdown:longint):longint;
begin
try;result:=cadd4(xcap,xtep,xcode,xcode2,xhelp,xenabled,xvisible,ximgright,false,xcountdown,0,0);except;end;
end;
//## cadd4 ##
function tbasictoolbar.cadd4(xcap:string;xtep,xcode:longint;xcode2,xhelp:string;xenabled,xvisible,ximgright,xbutpad:boolean;xcountdown,xsize,xalign:longint):longint;
var
   bol1,bol2:boolean;
begin
try
//defaults
result:=-1;
//check
if not xok(iaddcount) then exit;
//get
icap[iaddcount]:=xcap;
if (xtep<>itep[iaddcount]) then
   begin
   itep[iaddcount]:=xtep;
   tepinfo(xtep,false,iw[iaddcount],ih[iaddcount],bol1,bol2);
   end;
isize[iaddcount]         :=xsize;//30may2021
ialign[iaddcount]        :=frcrange(xalign,0,2);//0=L, 1=C, 2=R
icountdown[iaddcount]    :=xcountdown;
icode[iaddcount]         :=xcode;
icode2[iaddcount]        :=xcode2;
ibuthelp[iaddcount]      :=xhelp;
ican[iaddcount]          :=true;
ienableds[iaddcount]     :=xenabled;
ivisibles[iaddcount]     :=xvisible;
ihighlight[iaddcount]    :=false;
iimgright[iaddcount]     :=ximgright;
ibutpad[iaddcount]       :=xbutpad;//05jun2021
ipert[iaddcount]         :=0;//07jul2021

result:=iaddcount;
//inc
inc(iaddcount);
except;end;
end;
//## clear ##
procedure tbasictoolbar.clear;//22sep2020
var
   p:longint;
begin
try
iaddcount:=0;
for p:=0 to high(icap) do
begin
icanarea[p]:=false;
iarea[p]:=rect(0,0,0,0);
iusex[p]:=0;
ialign[p]:=0;
iw[p]:=0;
ih[p]:=0;
icap[p]:='';
isize[p]:=0;//30may2021
ipert[p]:=0;//07jul2021
itep[p]:=tepnone;
icode[p]:=0;
icode2[p]:='';
ibuthelp[p]:='';
iref[p]:='';
ienableds[p]:=false;
ivisibles[p]:=false;
imarked[p]:=false;
ican[p]:=true;
ihighlight[p]:=false;
iimgright[p]:=false;
ibutpad[p]:=false;
icountdown[p]:=0;//off
end;//p
except;end;
end;
//## addsep ##
function tbasictoolbar.addsep:longint;
begin
try;result:=add3('-',tepnone,0,'','',true,true,false);except;end;
end;
//## addsep2 ##
function tbasictoolbar.addsep2(xcode2:string):longint;
begin
try;result:=add3('-',tepnone,0,xcode2,'',true,true,false);except;end;
end;
//## addhline ##
function tbasictoolbar.addhline:longint;//draw horizontal line under current line - 26sep2022
begin
try;result:=add3('*',tepnone,0,'','',true,true,false);except;end;
end;
//## newline ##
function tbasictoolbar.newline:longint;//05jun2021
begin
try;result:=add3('+',tepnone,0,'','',true,true,false);except;end;
end;
//## xok ##
function tbasictoolbar.xok(x:longint):boolean;
begin
try;result:=(x>=0) and (x<=high(icap));except;end;
end;
//## setcap ##
procedure tbasictoolbar.xsetcap(x:longint;y:string);
begin
try;if xok(x) then icap[x]:=y;except;end;
end;
//## getcap ##
function tbasictoolbar.xgetcap(x:longint):string;
begin
try;if xok(x) then result:=icap[x] else result:='';except;end;
end;
//## settep ##
procedure tbasictoolbar.xsettep(x:longint;y:longint);
var
   bol1,bol2:boolean;
begin
try
if xok(x) and (y<>itep[x]) then
   begin
   itep[x]:=y;
   tepinfo(itep[x],false,iw[x],ih[x],bol1,bol2);
   end;
except;end;
end;
//## gettep ##
function tbasictoolbar.xgettep(x:longint):longint;
begin
try;if xok(x) then result:=itep[x] else result:=tepnone;except;end;
end;
//## setsize ##
procedure tbasictoolbar.xsetsize(x:longint;y:longint);
begin
try;if xok(x) and (y<>isize[x]) then isize[x]:=y;except;end;
end;
//## getsize ##
function tbasictoolbar.xgetsize(x:longint):longint;
begin
try;if xok(x) then result:=isize[x] else result:=0;except;end;
end;
//## setpert ##
procedure tbasictoolbar.setpert(x:longint;y:double);
begin
try
if (y<0) then y:=0 else if (y>100) then y:=100;
if xok(x) and (y<>ipert[x]) then
   begin
   ipert[x]:=y;
   paintnow;
   end;
except;end;
end;
//## getpert ##
function tbasictoolbar.getpert(x:longint):double;
begin
try;if xok(x) then result:=ipert[x] else result:=0;except;end;
end;
//## setalign ##
procedure tbasictoolbar.xsetalign(x:longint;y:longint);
begin
try
y:=frcrange(y,0,2);
if xok(x) and (y<>ialign[x]) then ialign[x]:=y;
except;end;
end;
//## getalign ##
function tbasictoolbar.xgetalign(x:longint):longint;
begin
try;if xok(x) then result:=ialign[x] else result:=0;except;end;
end;
//## setcountdown ##
procedure tbasictoolbar.xsetcountdown(x,y:longint);//05sep2020
begin
try;if xok(x) then icountdown[x]:=frcmin(y,0);except;end;
end;
//## getcountdown ##
function tbasictoolbar.xgetcountdown(x:longint):longint;
begin
try;if xok(x) then result:=icountdown[x] else result:=0;except;end;
end;
//## setcode ##
procedure tbasictoolbar.xsetcode(x,y:longint);
begin
try;if xok(x) then icode[x]:=y;except;end;
end;
//## getcode ##
function tbasictoolbar.xgetcode(x:longint):longint;
begin
try;if xok(x) then result:=icode[x] else result:=0;except;end;
end;
//## setcode2 ##
procedure tbasictoolbar.xsetcode2(x:longint;y:string);
begin
try;if xok(x) then icode2[x]:=y;except;end;
end;
//## getcode2 ##
function tbasictoolbar.xgetcode2(x:longint):string;
begin
try;if xok(x) then result:=icode2[x] else result:='';except;end;
end;
//## sethelp ##
procedure tbasictoolbar.xsethelp(x:longint;y:string);
begin
try;if xok(x) then ibuthelp[x]:=y;except;end;
end;
//## gethelp ##
function tbasictoolbar.xgethelp(x:longint):string;
begin
try;if xok(x) then result:=ibuthelp[x] else result:='';except;end;
end;
//## setvisibles ##
procedure tbasictoolbar.xsetvisibles(x:longint;y:boolean);
begin
try;if xok(x) then ivisibles[x]:=y;except;end;
end;
//## getvisibles ##
function tbasictoolbar.xgetvisibles(x:longint):boolean;
begin
try;if xok(x) then result:=ivisibles[x] else result:=false;except;end;
end;
//## setenableds ##
procedure tbasictoolbar.xsetenableds(x:longint;y:boolean);
begin
try;if xok(x) then ienableds[x]:=y;except;end;
end;
//## getenableds ##
function tbasictoolbar.xgetenableds(x:longint):boolean;
begin
try;if xok(x) then result:=ienableds[x] else result:=false;except;end;
end;
//## setmarked ##
procedure tbasictoolbar.xsetmarked(x:longint;y:boolean);
begin
try;if xok(x) then imarked[x]:=y;except;end;
end;
//## getmarked ##
function tbasictoolbar.xgetmarked(x:longint):boolean;
begin
try;if xok(x) then result:=imarked[x] else result:=false;except;end;
end;
//## setflash ##
procedure tbasictoolbar.xsetflash(x:longint;y:boolean);
begin
try;if xok(x) then iflasher[x]:=y;except;end;
end;
//## getflash ##
function tbasictoolbar.xgetflash(x:longint):boolean;
begin
try;if xok(x) then result:=iflasher[x] else result:=false;except;end;
end;
//## sethighlight ##
procedure tbasictoolbar.xsethighlight(x:longint;y:boolean);//15mar2022
begin
try;if xok(x) then ihighlight[x]:=y;except;end;
end;
//## gethighlight ##
function tbasictoolbar.xgethighlight(x:longint):boolean;
begin
try;if xok(x) then result:=ihighlight[x] else result:=false;except;end;
end;
//## xsetimgright ##
procedure tbasictoolbar.xsetimgright(x:longint;y:boolean);
begin
try;if xok(x) then iimgright[x]:=y;except;end;
end;
//## xgetimgright ##
function tbasictoolbar.xgetimgright(x:longint):boolean;
begin
try;if xok(x) then result:=iimgright[x] else result:=false;except;end;
end;
//## xsetbutpad ##
procedure tbasictoolbar.xsetbutpad(x:longint;y:boolean);
begin
try;if xok(x) then ibutpad[x]:=y;except;end;
end;
//## xgetbutpad ##
function tbasictoolbar.xgetbutpad(x:longint):boolean;
begin
try;if xok(x) then result:=ibutpad[x] else result:=false;except;end;
end;
//## visref ##
function tbasictoolbar.visref:string;//05jun2021
var
   p:longint;
begin
try
setlength(result,high(ivisibles)+1);
for p:=0 to high(ivisibles) do if ivisibles[p] then result[p+stroffset]:='1' else result[p+stroffset]:='0';
except;end;
end;
//by code2 names ---------------------------------------------------------------
//## setbutpad2 ##
procedure tbasictoolbar.xsetbutpad2(x:string;y:boolean);
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then ibutpad[int1]:=y;except;end;
end;
//## getbutpad2 ##
function tbasictoolbar.xgetbutpad2(x:string):boolean;
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then result:=ibutpad[int1] else result:=false;except;end;
end;
//## setvisible2 ##
procedure tbasictoolbar.xsetvisible2(x:string;y:boolean);
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then ivisibles[int1]:=y;except;end;
end;
//## getvisible2 ##
function tbasictoolbar.xgetvisible2(x:string):boolean;
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then result:=ivisibles[int1] else result:=false;except;end;
end;
//## setflash2 ##
procedure tbasictoolbar.xsetflash2(x:string;y:boolean);
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then iflasher[int1]:=y;except;end;
end;
//## getflash2 ##
function tbasictoolbar.xgetflash2(x:string):boolean;
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then result:=iflasher[int1] else result:=false;except;end;
end;
//## setmarked2 ##
procedure tbasictoolbar.xsetmarked2(x:string;y:boolean);
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then imarked[int1]:=y;except;end;
end;
//## getmarked2 ##
function tbasictoolbar.xgetmarked2(x:string):boolean;
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then result:=imarked[int1] else result:=false;except;end;
end;
//## sethighlight2 ##
procedure tbasictoolbar.xsethighlight2(x:string;y:boolean);
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then ihighlight[int1]:=y;except;end;
end;
//## gethighlight2 ##
function tbasictoolbar.xgethighlight2(x:string):boolean;
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then result:=ihighlight[int1] else result:=false;except;end;
end;
//## setenabled2 ##
procedure tbasictoolbar.xsetenabled2(x:string;y:boolean);
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then ienableds[int1]:=y;except;end;
end;
//## getenabled2 ##
function tbasictoolbar.xgetenabled2(x:string):boolean;
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then result:=ienableds[int1] else result:=false;except;end;
end;
//## setcan2 ##
procedure tbasictoolbar.xsetcan2(x:string;y:boolean);
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then ican[int1]:=y;except;end;
end;
//## getcan2 ##
function tbasictoolbar.xgetcan2(x:string):boolean;
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then result:=ican[int1] else result:=false;except;end;
end;
//## setcap2 ##
procedure tbasictoolbar.xsetcap2(x:string;y:string);
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then icap[int1]:=y;except;end;
end;
//## getcap2 ##
function tbasictoolbar.xgetcap2(x:string):string;
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then result:=icap[int1] else result:='';except;end;
end;
//## xsettep2 ##
procedure tbasictoolbar.xsettep2(x:string;y:longint);
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then xsettep(int1,y);except;end;
end;
//## gettep2 ##
function tbasictoolbar.xgettep2(x:string):longint;
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then result:=itep[int1] else result:=tepNone;except;end;
end;
//## xsetimgright2 ##
procedure tbasictoolbar.xsetimgright2(x:string;y:boolean);
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then iimgright[int1]:=y;except;end;
end;
//## xgetimgright2 ##
function tbasictoolbar.xgetimgright2(x:string):boolean;
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then result:=iimgright[int1] else result:=false;except;end;
end;
//## setsize2 ##
procedure tbasictoolbar.xsetsize2(x:string;y:longint);
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then isize[int1]:=y;except;end;
end;
//## getsize2 ##
function tbasictoolbar.xgetsize2(x:string):longint;
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then result:=isize[int1] else result:=0;except;end;
end;
//## setpert2 ##
procedure tbasictoolbar.xsetpert2(x:string;y:double);
var
   int1:longint;
begin
try
if (y<0) then y:=0 else if (y>100) then y:=100;
if xfindbycode2b(x,int1) and (ipert[int1]<>y) then
   begin
   ipert[int1]:=y;
   paintnow;
   end;
except;end;
end;
//## getpert2 ##
function tbasictoolbar.xgetpert2(x:string):double;
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then result:=ipert[int1] else result:=0;except;end;
end;
//## setalign2 ##
procedure tbasictoolbar.xsetalign2(x:string;y:longint);
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then ialign[int1]:=frcrange(y,0,2);except;end;
end;
//## getalign2 ##
function tbasictoolbar.xgetalign2(x:string):longint;
var
   int1:longint;
begin
try;if xfindbycode2b(x,int1) then result:=ialign[int1] else result:=0;except;end;
end;

//## tbasicmenu ################################################################
//xxxxxxxxxxxxxxxxxxxxxxxxxxxx//mmmmmmmmmmmmmmmmmmmm
//## create2 ##
constructor tbasicmenu.create2(xparent:tobject;xstart:boolean);
var
   p:longint;
begin
//self
satinc(satMenu,1);
inherited create2(xparent,false);
//options
imanysel1:=0;
imanysel2:=0;
onumberfrom:=-1;
onumberfrom2:=-1;
onumberfrom3:=-1;
iwasflashing:=false;
iflashing:=false;//true=one or more visible items requires flash support
ilastflash:=sysflash;
ohoverunderline:=true;
olisthover:=false;
icountx:=-1;//off -> set to "0..N" via "makelistx()" to use a realtime list -> items source via external proc in realtime - 22sep2020
ireloadid:=viloadid;
oautoreload:=false;
oloadfromname:='';//off
oautoclose:=true;
ocode:=0;
ocode2:='';
otepcolor:=clnone;
orowcount:=0;
oautoheight:=true;
oautowidth:=true;
ofast:=false;
orows:=false;
ostyle:=lsmenu;
okeepopen:=false;
//vars
icandrag:=false;
fonclick:=nil;
ilist:=bnew;
ilistcount:=0;
itep:=tepnone;
iselstart:=0;
iselcount:=0;
ipos:=0;
idata:=bnew;
icount:=0;
ihoverindex:=-1;
inormal:=true;
irowpad:=2;
irowheight:=20;
ibordersize:=1;
ipad:=5;
imaxindentwidth:=0;
imaxtepwidth:=0;
imaxtepheight:=0;
imaxcapwidth:=0;
imaxtitcapwidth:=0;
imaxttitepwidth:=0;
imaxcutwidth:=0;//shortcut -> e.g "CTRL+S"
idownpos:=0;
idownindex:=0;
ilastitemindex:=-99;
//controls
iv:=tbasicscrollbar.create(self);
iv.overtical:=true;
iv.ofullhandling:=false;//allow our "_onnotify()" to handle the sensitive parts of scrolling and navigation etc - 04apr2020
iv.onpos:=_onpos;
//defaults
clientheight:=20;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasicmenu.destroy;
begin
try
//disconnect timer
timer:=false;
//disconnect events
fonclick:=nil;
//self
inherited destroy;
//controls
freeobj(@idata);
freeobj(@ilist);
//sat
satinc(satMenu,-1);
except;end;
end;
//## xfindbycode2 ##
function tbasicmenu.xfindbycode2(xfindval:string;var xindex:longint):boolean;
label
   skipend;
var
   xtab,xtep,xtepcolor,xcode,xshortcut,xindent,p,xcount:longint;
   xcaption,xcaplabel,xhelp,xcode2:string;
   xflash,xenabled,xtitle,xsep:boolean;
begin
try
//defaults
result:=false;
xindex:=0;
xcount:=icount;
//check
if (xcount<=0) then goto skipend;
//find
for p:=0 to (xcount-1) do if xgetitem(p,xtab,xtep,xtepcolor,xcaption,xcaplabel,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep) and low__comparetext(xfindval,xcode2) then
   begin
   xindex:=p;
   result:=true;
   break;
   end;
skipend:
except;end;
end;
//## xfindbycaption2 ##
function tbasicmenu.xfindbycaption2(xfindval:string):longint;
begin
try;xfindbycaption(xfindval,result);except;end;
end;
//## xfindbycaption ##
function tbasicmenu.xfindbycaption(xfindval:string;var xindex:longint):boolean;
label
   skipend;
var
   xtab,xtep,xtepcolor,xcode,xshortcut,xindent,p,xcount:longint;
   xcaption,xcaplabel,xhelp,xcode2:string;
   xflash,xenabled,xtitle,xsep:boolean;
begin
try
//defaults
result:=false;
xindex:=0;
xcount:=icount;
//check
if (xcount<=0) then goto skipend;
//find
for p:=0 to (xcount-1) do if xgetitem(p,xtab,xtep,xtepcolor,xcaption,xcaplabel,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep) and low__comparetext(xfindval,xcaption) then
   begin
   xindex:=p;
   result:=true;
   break;
   end;
skipend:
except;end;
end;
//## xfindnext ##
function tbasicmenu.xfindnext(xfindpart:string;var xindex:longint):boolean;//06oct2020
label
   skipend;
var
   xlen,xtab,xtep,xtepcolor,xcode,xshortcut,xindent,i,p,xcount:longint;
   xcaption,xcaplabel,xhelp,xcode2:string;
   xflash,xenabled,xtitle,xsep:boolean;
begin
try
//defaults
result:=false;
xindex:=0;
xcount:=icount;
//check
if (xcount<=0) then goto skipend;
xlen:=length(xfindpart);
if (xlen<=0) then goto skipend;
//find
p:=frcmin(selstart,0)+1;
if (p>=xcount) then p:=0;

for i:=0 to (xcount-1) do
begin
if xgetitem(p,xtab,xtep,xtepcolor,xcaption,xcaplabel,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep) and low__comparetext(xfindpart,strcopy1(xcaplabel,1,xlen)) then
   begin
   xindex:=p;
   result:=true;
   break;
   end;
//inc
inc(p);
if (p>=xcount) then p:=0;
end;//p
skipend:
except;end;
end;
//## reload ##
procedure tbasicmenu.reload;
var
   int1:longint;
begin
try
if (oloadfromname<>'') then
   begin
   if not xfindbycode2(sfromname(oloadfromname),int1) then int1:=0;
   setsel(int1,1);
   if (int1<vpos1) or (int1>vpos2) then pos:=int1;
   end;
except;end;
end;
//## makemenu ##
procedure tbasicmenu.makemenu;
begin
try
icountx:=-1;//turn of "listx" override mode - 22sep2020
ofast:=false;
ostyle:=lsmenu;
orows:=false;
okeepopen:=false;
except;end;
end;
//## makelist ##
procedure tbasicmenu.makelist;
begin
try
icountx:=-1;//turn off "listx" override mode - 22sep2020
ofast:=false;
ostyle:=lslist;
orows:=true;
okeepopen:=true;
except;end;
end;
//## makelistx ##
procedure tbasicmenu.makelistx(xcount:longint);
begin
try
ofast:=true;
ostyle:=lslist;
orows:=true;
okeepopen:=true;
icountx:=frcmin(xcount,0);//must be 0..N to override internal data block - 22sep2020
setdata(nil);//dump previous data and set list to "xcount" items
except;end;
end;
//## setcountx ##
procedure tbasicmenu.setcountx(x:longint);
begin
try
icountx:=frcmin(x,0);
setdata(nil);//dump previous data and set list to "xcount" items
except;end;
end;
//## makemany ##
procedure tbasicmenu.makemany;
begin
try
icountx:=-1;//turn of "listx" override mode - 22sep2020
ofast:=false;
ostyle:=lsmany;
orows:=true;
okeepopen:=true;
except;end;
end;
//## makepoplist ##
procedure tbasicmenu.makepoplist;
begin
try
icountx:=-1;//turn of "listx" override mode - 22sep2020
ofast:=false;
ostyle:=lslist;
orows:=true;
okeepopen:=false;
except;end;
end;
//## makepopmany ##
procedure tbasicmenu.makepopmany;
begin
try
icountx:=-1;//turn of "listx" override mode - 22sep2020
ofast:=false;
ostyle:=lsmany;
orows:=true;
okeepopen:=false;
except;end;
end;
//## xsetclientarea ##
function tbasicmenu.xsetclientarea(a:trect):boolean;
var
   int1:longint;
begin
try
inherited xsetclientarea(a);
//iv
int1:=scount;
iv.setparams(pos,0,int1);
iv.visible:=(int1>=1);
except;end;
end;
//## _onpos ##
procedure tbasicmenu._onpos(sender:tobject);
begin
try;if (iv.pos<>pos) then pos:=iv.pos;except;end;
end;
//## setpos ##
procedure tbasicmenu.setpos(x:longint);
begin
try
x:=frcrange(x,0,frcmin(scount,0));//scount is the difference of screen capacity to required capacity -> no need to shrink by "-1"
if low__setint(ipos,x) then paintnow;
if (iv.pos<>ipos) then iv.pos:=ipos;
except;end;
end;
//## sethoverindex ##
procedure tbasicmenu.sethoverindex(x:longint);
begin
try
x:=frcrange(x,-1,frcmin(icount-1,0));
if low__setint(ihoverindex,x) then paintnow;
except;end;
end;
//## setdata ##
procedure tbasicmenu.setdata(x:tstr8);//08jun2021
label
   skipend,done,redo;
const
   xnilval='(..nil..)';//unicode safe
var
   a:pvirtualinfo;
   int1,int2,int3,int4,xcode,xshortcut,xindent,xcount,xlasttep,xtep,xtepcolor,p,h1,w0,w1,w2,w3,w4,w5:longint;
   str1,xlasttitcap,xlastcap,xlastcut,xcaption,xhelp,xcode2:string;
   bol1,bol2,xflash,xenabled,xtitle,xsep:boolean;
begin
try
//check
block(x);
//init
w0:=0;
w1:=0;
h1:=0;
w2:=0;
w3:=0;
w4:=0;
w5:=0;
//check
if (icountx>=0) then goto done;
if zznil(x,2352) or idata.same(x) then goto skipend;
//init continued
a:=info;
xcount:=low__menucount(x);
if (xcount<=0) or ofast then goto done;

//get
xlastcap:=xnilval;
xlasttep:=minint;//trigger a check even for "xtep=<nil>"
xlastcut:=xnilval;
xlasttitcap:=xnilval;
p:=0;
redo:
if (p<xcount) and low__menuget(x,p,xtep,xtepcolor,xcaption,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep) then
   begin
   //.indent
   if (xindent>w0) then w0:=xindent;
   //.tep
   if low__setint(xlasttep,xtep) then
      begin
      tepinfo(xtep,false,int1,int2,bol1,bol2);//aw,ah
      if (int1>w1) then w1:=int1;
      if (int2>h1) then h1:=int2;
      if xtitle and (xtep<>tepnone) then w5:=w1;//always same as normal items BUT is only set if a title uses a tep image - 29mar2020
      end;
   //.caption
   case xtitle of
   true:begin
      if (xcaption<>'') and low__setstr(xlasttitcap,xcaption) then
         begin
         int1:=low__fonttextwidth2(a.fb,xcaption);//fixed - was "a.fn" - 08jun2021
         if (int1>w4) then w4:=int1;
         end;
      end;
   false:begin
      if (xcaption<>'') and low__setstr(xlastcap,xcaption) then
         begin
         int1:=low__fonttextwidth2(a.fn,xcaption);
         if (int1>w2) then w2:=int1;
         end;
      end;
   end;//case
   //.shortcut
   if (not xtitle) and (xshortcut<>aknone) and low__akstr(xshortcut,str1) and low__setstr(xlastcut,str1) then
      begin
      int1:=low__fonttextwidth2(a.fn,str1);
      if (int1>w3) then w3:=int1;
      end;
   //loop
   inc(p);
   goto redo;
   end;

//set
done:
ihoverindex:=-1;
if (icountx>=0) then
   begin
   idata.replace:=nil;
   if low__setint(icount,icountx) then alignnow;
   end
else
   begin
   idata.replace:=x;//takes a copy
   if low__setint(icount,xcount) then alignnow;
   end;

//.reset position - 04oct2020
if oretainpos then ipos:=frcrange(ipos,0,frcmin(icount-1,0)) else ipos:=0;
imaxindentwidth:=w0;
imaxtepwidth:=w1;
imaxtepheight:=h1;
imaxcapwidth:=w2;
imaxcutwidth:=w3;
imaxtitcapwidth:=w4;
imaxttitepwidth:=w5;
iselstart:=frcrange(iselstart,0,frcmin(xcount-1,0));
iselcount:=frcrange(iselcount,0,xcount);
paintnow;
skipend:
except;end;
try;bunlockautofree(x);except;end;
end;
//## setselstart ##
procedure tbasicmenu.setselstart(x:longint);
begin
try;if xsetsel(x,iselcount) then paintnow;except;end;
end;
//## setselcount ##
procedure tbasicmenu.setselcount(x:longint);
begin
try;if xsetsel(iselstart,x) then paintnow;except;end;
end;
//## setsel ##
function tbasicmenu.setsel(xselstart,xselcount:longint):boolean;
begin
try;if xsetsel(xselstart,xselcount) then paintnow;except;end;
end;
//## getitemindex ##
function tbasicmenu.getitemindex:longint;
begin
try;result:=iselstart;except;end;
end;
//## setitemindex ##
procedure tbasicmenu.setitemindex(x:longint);
var
   bol1:boolean;
begin
try
bol1:=xsetsel(x,1);
if (x<pos) then
   begin
   pos:=x;
   bol1:=false;
   end
else if (x>(pos+vcount-1)) then
   begin
   pos:=x-vcount+1;
   bol1:=false;
   end;
if bol1 then paintnow;
except;end;
end;
//## xsetsel ##
function tbasicmenu.xsetsel(xselstart,xselcount:longint):boolean;
begin
try
result:=false;
if (ostyle<lsmany) then xselcount:=1;
if low__setint(iselstart,frcrange(xselstart,0,frcmin(icount-1,0))) then result:=true;
if low__setint(iselcount,frcrange(xselcount,0,icount)) then result:=true;
except;end;
end;
//## xrowheight ##
function tbasicmenu.xrowheight:longint;
begin
try;result:=low__instouch(largest(largest(irowheight*vizoom,imaxtepheight*vizoom),vifontheight)+(irowpad*vizoom),low__touchsmall);except;end;
end;
//## xrowcount ##
function tbasicmenu.xrowcount:longint;
begin
try;result:=frcmin(icount,1);except;end;
end;
//## getalignheight ##
function tbasicmenu.getalignheight(xclientwidth:longint):longint;
begin
try
case true of//oautoheight of
true:result:=(2*findbordersize)+(frcmax(xrowcount,low__aorb(xrowcount,orowcount,orowcount>=1))*xrowheight);
false:result:=frcmin(frcmin(clientheight,ominheight*vizoom),0);
end;
except;end;
end;
//## getalignwidth ##
function tbasicmenu.getalignwidth(xclientheight:longint):longint;
var
   xmaxtepwidth,xmaxttitepwidth,xzoom,int1,int2,int3:longint;
begin
try
case oautowidth of
true:begin
   //.xzoom
   xzoom:=vizoom;
   xmaxttitepwidth:=imaxttitepwidth*xzoom;
   xmaxtepwidth:=imaxtepwidth*xzoom;
   //.scrollbar width
   int3:=iv.getalignwidth(0);
   //.normal menu item
   int1:=(ipad*vizoom)+(imaxindentwidth*vizoom)+(xmaxtepwidth*vizoom)+low__insint(ipad*vizoom,xmaxtepwidth>=1)+imaxcapwidth+low__insint(2*ipad*vizoom,imaxcutwidth>=1)+imaxcutwidth+(ipad*vizoom)+int3;
   //.title menu item (different width of tep's and also bold text) - 29mar2020
   int2:=(ipad*vizoom)+(imaxindentwidth*vizoom)+(xmaxttitepwidth*vizoom)+low__insint((ipad*vizoom),xmaxttitepwidth>=1)+imaxtitcapwidth+(ipad*vizoom)+int3;
   result:=largest(int1,int2);
   end;
false:result:=frcmin(frcmin(clientwidth,ominwidth*vizoom),0);
end;
except;end;
end;
//## _onalign ##
procedure tbasicmenu._onalign(sender:tobject);
var
   ci:trect;
begin
try
ci:=clientinner;
case iv.overtical of
true:iv.xsetclientarea(rect(ci.right-(iv.getalignwidth(0)-1),ci.top,ci.right,ci.bottom));
false:iv.xsetclientarea(rect(ci.left,ci.top,ci.right,ci.top+iv.getalignheight(0)-1));//this mode is for debug purposes only - 04apr2020
end;
except;end;
end;
//## _ontimer ##
procedure tbasicmenu._ontimer(sender:tobject);
var
   xdir,int1:longint;
   xmustpaint:boolean;
begin
try
//defaults
xmustpaint:=false;
//reload - 07sep2020
if oautoreload and (ireloadid<>viloadid) and (not visyncing) and (not gui.mousedown) then
   begin
   ireloadid:=viloadid;
   reload;
   end;
//flash
if (sysflash<>ilastflash) then
   begin
   ilastflash:=sysflash;
   if iflashing or iwasflashing then xmustpaint:=true;
   end;
//wound scroller - 28sep2022
if xwound_mustpaint(pos,round(xrowheight*0.3),int1,xdir) then
   begin
   if (int1<>pos) then pos:=int1;
   xwound_autooff(pos,xdir,0,count-1);
   end;

//mustpaint
if xmustpaint then paintnow;
except;end;
end;
//## xfindb ##
function tbasicmenu.xfindb(sx,sy:longint):longint;
begin
try;xfind(sx,sy,result);except;end;
end;
//## xfind ##
function tbasicmenu.xfind(sx,sy:longint;var xindex:longint):boolean;//07apr2020
var
   xi,y1,y2,i,p:longint;
   a:tint4;
   xmany:boolean;
begin
try
//defaults
result:=false;
xindex:=-1;
xmany:=(ostyle>=lsmany);
//find
for p:=(ilistcount-1) downto 0 do
begin
i:=(p*12);//0-based
//.xindex
a.bytes[0]:=ilist.pbytes[i+0];
a.bytes[1]:=ilist.pbytes[i+1];
a.bytes[2]:=ilist.pbytes[i+2];
a.bytes[3]:=ilist.pbytes[i+3];
xi:=a.val;
//.y1
a.bytes[0]:=ilist.pbytes[i+4];
a.bytes[1]:=ilist.pbytes[i+5];
a.bytes[2]:=ilist.pbytes[i+6];
a.bytes[3]:=ilist.pbytes[i+7];
y1:=a.val;
//.y2
a.bytes[0]:=ilist.pbytes[i+8];
a.bytes[1]:=ilist.pbytes[i+9];
a.bytes[2]:=ilist.pbytes[i+10];
a.bytes[3]:=ilist.pbytes[i+11];
y2:=a.val;
//xmany -> using a "many" list we should always return a valid itemindex even when not in proper range -> for accurate selstart..selcount handling - 07apr2020
if xmany then
   begin
   if (xindex=-1) then xindex:=xi
   else if (sy<y2) then xindex:=xi;
   end;
//get
if (sy>=y1) and (sy<=y2) and (sx<iv.left) then
   begin
   xindex:=xi;
   result:=true;
   break;
   end;
end;//p

//dbstatus(34,'menu.find>'+inttostr(sx)+' x '+inttostr(sy)+'__'+inttostr(xindex)+'<<'+ms64str);
except;end;
end;
//## xgetval2 ##
function tbasicmenu.xgetval2(xindex:longint):string;//03mar2022
begin
try;xgetval(xindex,result);except;end;
end;
//## xgetval ##
function tbasicmenu.xgetval(xindex:longint;var xvalue:string):boolean;
var
   xtab,xtep,xtepcolor:longint;
   xcaplabel,xhelp,xcode2:string;
   xcode,xshortcut,xindent:longint;
   xflash,xenabled,xtitle,xsep:boolean;
begin
try;result:=xgetitem(xindex,xtab,xtep,xtepcolor,xvalue,xcaplabel,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep);except;end;
end;
//## xgetitem ##
function tbasicmenu.xgetitem(xindex:longint;var xtab,xtep,xtepcolor:longint;var xcaption,xcaplabel,xhelp,xcode2:string;var xcode,xshortcut,xindent:longint;var xflash,xenabled,xtitle,xsep:boolean):boolean;//20mar2022
begin
try
//defaults
result:=false;
xtab:=otab;
xtepcolor:=clnone;//20mar2022
xtep:=tepNone;
xcaption:='';
xcaplabel:='';
xhelp:='';
xcode2:='';
xcode:=0;
xshortcut:=aknone;
xindent:=0;
xenabled:=false;
xtitle:=false;
xsep:=false;
xflash:=false;
//check
if (xindex<0) or (xindex>=icount) then exit;
//get
if (icountx>=0) then
   begin
   xenabled:=true;
   if assigned(fongetitem) then fongetitem(self,xindex,xtab,xtep,xtepcolor,xcaption,xcaplabel,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep)
   else
      begin
      xcaption:='??'+inttostr(xindex)+'??';
      xtep:=tepNew20;
      end;
   result:=true;
   end
else
   begin
   result:=low__menuget(idata,xindex,xtep,xtepcolor,xcaption,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep);
   end;
//set
if (xcaplabel='') then xcaplabel:=xcaption;//27mar2022
except;end;
end;
//## _onshortcut ##
function tbasicmenu._onshortcut(sender:tobject):boolean;
begin//store shortcut so we can transmitt it to our host form later (once we've closed the menu) - 02apr2020
try
result:=true;
gui.popshortcut:=gui.key;
//.close form if the form is a popup related control -> popup menu etc
//was: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx if gui.opopupcontrol then gui.showclose(mrcancel);
except;end;
end;
//## _onnotify ##
function tbasicmenu._onnotify(sender:tobject):boolean;
var
   int1,xkey,xnewhoverindex:longint;
   xmustpaint:boolean;
   xcaption,xcaplabel,xhelp,xcode2:string;
   xtab,xtep,xtepcolor,xcode,xshortcut,xindent:longint;
   xclickonce,bol1,xkeyok,xflash,xenabled,xtitle,xsep:boolean;
   //## xselect ##
   procedure xselect;//list support
   var
      int1,int2:longint;
   begin
   if (ostyle=lsmenu) or ((gui.mousedownstroke and gui.mouseleft and ((ostyle<=lsmany) or (not icandrag)) ) or (xkeyok and (not gui.shiftok)) ) then
      begin
      if xsetsel(ihoverindex,1) then xmustpaint:=true;
      end
   else if (ostyle>lsmany) and ( (gui.mousedown and gui.mouseleft and (not icandrag)) or (xkeyok and gui.shiftok) ) then
      begin
      int1:=smallest(ihoverindex,idownindex);
      int2:=largest(ihoverindex,idownindex);
      if xsetsel(int1,(int2-int1+1)) then xmustpaint:=true;
      end;
   end;
   //## xclick ##
   procedure xclick;
   begin
   //fire click event
   if (ihoverindex>=0) and xgetitem(ihoverindex,xtab,xtep,xtepcolor,xcaption,xcaplabel,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep) and xenabled and (not xtitle) then
      begin
      if (ostyle=lsmenu) or (iselcount<=0) or (gui.key=akspace) then xselect;//list support
      ocode:=xcode;
      ocode2:=xcode2;
      otepcolor:=xtepcolor;
      //.fire click event
      if xclickonce then
         begin
         //once only
         xclickonce:=false;
         //events
         gui.closelock;//prevent shutdown of system while proc in use - 03apr2021
         try
         if assigned(fonclick) then fonclick(self);
         if assigned(fondbclick) and gui.mousedbclick then fondbclick(self);
         //autoclose form - optional - 14aug2020
         if oautoclose then gui.xcloseok(self);
         except;end;
         gui.closeunlock;
         end;
      end;
   end;
   //## xselectrangeADD ##
   procedure xselectrangeADD;
   var
     int1,int2,s,c:longint;
     bol1,bol2:boolean;
   begin
   //check
   if (ostyle<>lsmany) then exit;
   //get
   int1:=imanysel1;
   int2:=imanysel2;
   bol1:=low__setint(int1,int2);
   bol2:=low__setint(int2,itemindex);
   //set
   if low__setint(ilastitemindex,itemindex) or (focused and gui.mousedbclick) then//don't change highlight/itemindex when "double clicking" -> vital for stable switching between disk drives and folders etc inside a "tbasicnav" list - 28sep2022
      begin
      imanysel1:=int1;
      imanysel2:=int2;
      if xkeyok then xsetsel(itemindex,1);//required for keyboard syncing - 28sep2022
      xmustpaint:=true;
      end
   else
      begin
      xselectrange(imanysel1,imanysel2);
      ilastitemindex:=-99;
      xmustpaint:=true;
      end;
   end;
begin
try
//defaults
result:=true;//handled
xclickonce:=true;
xmustpaint:=false;
xnewhoverindex:=maxint;//off
xkeyok:=false;
if gui.mousedownstroke then icandrag:=(ostyle<=lsmany);//was: or (mousex>=(round(0.5*iv.left)));
//wheel
if (gui.wheel<>0) then
   begin
   pos:=pos-gui.wheel;
   notidle;
   xwound_wheel(gui.wheel*70);
   end;

//key
xkey:=gui.key;
if (xkey<>aknone) then
   begin
   case xkey of
   akhome:begin
      notidle;
      pos:=0;
      xnewhoverindex:=0;
      xkeyok:=true;
      end;
   akend:begin
      notidle;
      pos:=count;
      xnewhoverindex:=frcmin(count-1,0);
      xkeyok:=true;
      end;
   akleft,akup:begin
      notidle;
{//was:
      if      (iselstart>(pos+vcount-1)) then xnewhoverindex:=frcmin(pos+vcount-1,0)
      else if (iselstart<pos) then xnewhoverindex:=pos
      else if (iselstart>pos) then xnewhoverindex:=iselstart-1
      else
         begin
         pos:=pos-1;
         xnewhoverindex:=pos;
         end;
{}
      if      (ihoverindex>(pos+vcount-1)) then xnewhoverindex:=frcmin(pos+vcount-1,0)
      else if (ihoverindex<pos) then xnewhoverindex:=pos
      else if (ihoverindex>pos) then xnewhoverindex:=ihoverindex-1
      else
         begin
         pos:=pos-1;
         xnewhoverindex:=pos;
         end;
      xkeyok:=true;
      end;
   akright,akdown,aktab:begin
      notidle;
{was:
      if      (iselstart>(pos+vcount-1)) then xnewhoverindex:=frcmin(pos+vcount-1,0)
      else if (iselstart<pos) then xnewhoverindex:=pos
      else if (iselstart<(pos+vcount-1)) then xnewhoverindex:=iselstart+1
      else
         begin
         pos:=pos+1;
         xnewhoverindex:=pos+frcmin(vcount-1,0);
         end;
{}
      if      (ihoverindex>(pos+vcount-1)) then xnewhoverindex:=frcmin(pos+vcount-1,0)
      else if (ihoverindex<pos) then xnewhoverindex:=pos
      else if (ihoverindex<(pos+vcount-1)) then xnewhoverindex:=ihoverindex+1
      else
         begin
         pos:=pos+1;
         xnewhoverindex:=pos+frcmin(vcount-1,0);
         end;
      xkeyok:=true;
      end;
   akprev:begin
      notidle;
      if (ihoverindex<>pos) then xnewhoverindex:=pos
      else
         begin
         pos:=pos-vcount;
         xnewhoverindex:=pos;
         end;
      xkeyok:=true;
      end;
   aknext:begin
      notidle;
      if (ihoverindex<>(pos+frcmin(vcount-1,0))) then xnewhoverindex:=pos+frcmin(vcount-1,0)
      else
         begin
         pos:=pos+vcount;
         xnewhoverindex:=pos+frcmin(vcount-1,0);
         end;
      xkeyok:=true;
      end;
   akreturn,akspace:begin
      notidle;
      xkeyok:=true;
      xclick;
      xselectrangeADD;
      end;
   else
      begin
      if (ostyle>=lslist) and (xkey>=akspace) and xfindnext(char(xkey),int1) then
         begin
         notidle;
         xsetsel(int1,1);
         if (int1<vpos1) or (int1>vpos2) then pos:=int1;
         ihoverindex:=int1;
         xclick;
         xselectrangeADD;
         xmustpaint:=true;
         end;
      end;
   end;//case
   end;

//hover - 24jul2021
if (not gui.mousedragging) and (not gui.mousewasdown) and (gui.wheel=0) and (gui.key=aknone) then xnewhoverindex:=xfindb(mousemovexy.x,mousemovexy.y);

//xnewhoverindex
if (xnewhoverindex<>maxint) then
   begin
   xenabled:=false;
   case xok(xnewhoverindex) of
   true:begin
      xgetitem(xnewhoverindex,xtab,xtep,xtepcolor,xcaption,xcaplabel,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep);
      help2:=xhelp;
      end;
   false:help2:='';//revert back to "help" - 07sep2020
   end;
   if (xnewhoverindex<>ihoverindex) then
      begin
      ihoverindex:=xnewhoverindex;
      //was:if xok(xnewhoverindex) and xenabled and (not xtitle) then screen.cursor:=crHandpoint else screen.cursor:=crDefault;
      if (ostyle=lsmenu) or ohoverunderline then xmustpaint:=true;//22feb2022 - reduce unnecessary repaints when an "info list" e.g. a status panel in mode "lslist" -> hover is not used for anything so no need to paint the screen
      end;
   end;

//mouse down
if gui.mousedownstroke or (gui.key=akshift) then
   begin
   idownpos:=pos;
   idownindex:=frcrange(ihoverindex,0,frcmin(icount-1,0));
   end;

//list support
if (xnewhoverindex<>maxint) then
   begin
   xselect;
   //.listclick
   if xkeyok and (ostyle>=lslist) then
      begin
      notidle;
      xclick;
      end;
   end;

//mouse move
if gui.mousedown and gui.mousedragging and icandrag then
   begin
   notidle;
   pos:=idownpos+((gui.screendownxy.y-gui.screenmovexy.y) div xrowheight);
   end;

//mouse up - wound support - 04oct2022
if gui.mouseupstroke and icandrag and gui.mousedragging and gui.mouseleft then xwound_mousevert(3000,true);

//mouse up
if gui.mouseupstroke and ((not gui.mousedragging) or (not icandrag) ) and gui.mouseleft then
   begin
   xselectrangeADD;
   pos:=idownpos;//FIXED: Keyboard highlight mismatch/misbehaviour -> used to show Options window, select first frame in "Frame" and then key down, but keyboard highlight would JUMP to the original highlight item when window first displayed - 26feb2022
   notidle;
   xclick;
   end;

//showmenu
autoshowmenu;

//xmustpaint
if xmustpaint then paintnow;

//external event override - 01mar2021
if assigned(fonnotify) then fonnotify(sender);
except;end;
end;
//## canselectrange ##
function tbasicmenu.canselectrange:boolean;//28sep2022
begin
try;result:=(ostyle=lsmany) and (imanysel1<>imanysel2);except;end;
end;
//## selectrange ##
procedure tbasicmenu.selectrange;
begin
try;if canselectrange then xselectrange(imanysel1,imanysel2);except;end;
end;
//## selectoff ##
procedure tbasicmenu.selectoff;
begin
try
imanysel1:=-1;
imanysel2:=-1;
ilastitemindex:=-2;
except;end;
end;
//## xselectrange ##
procedure tbasicmenu.xselectrange(x1,x2:longint);
begin
try;xsetsel(smallest(x1,x2),largest(x1,x2)-smallest(x1,x2)+1);except;end;
end;
//## setdownindex ##
procedure tbasicmenu.setdownindex(x:longint);
begin
try;idownindex:=frcrange(x,0,frcmin(icount-1,0));except;end;
end;
//## vcount ##
function tbasicmenu.vcount:longint;//visible count
begin
try;result:=frcmin((frcmin(clientheight,1)-(2*frcmin(findbordersize,0))) div xrowheight,1);except;end;
end;
//## vpos1 ##
function tbasicmenu.vpos1:longint;//first visible item
begin
try;result:=frcrange(pos,0,frcmin(icount-1,0));except;end;
end;
//## vpos2 ##
function tbasicmenu.vpos2:longint;//last visible item
begin
try;result:=frcrange(pos+frcmin(vcount-1,0),0,frcmin(icount-1,0));except;end;
end;
//## scount ##
function tbasicmenu.scount:longint;//scroll count
begin
try;result:=frcmin(icount-vcount,0);except;end;
end;
//## xok ##
function tbasicmenu.xok(x:longint):boolean;
begin
try;result:=(x>=0) and (x<icount);except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxx//mmmmmmmmmmmmmmmmmmmmmmm
//## _onpaint ##
procedure tbasicmenu._onpaint(sender:tobject);
label
   redo;
const
   xpad=5;
   //color modes
   mnor=0;
   mdis=1;
   mhov=2;
var
   //infovars
   a:pvirtualinfo;
   cs,ci:trect;
   fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xenabled,xround,xnormal:boolean;
   //other
   b:pvirtualinfo;
   ra:trect;
   xteptmp,ximagealign,xzoom,xfonthighlight,xtab,dback,xtep,xtepcolor,findex,fcol,th,xmaxcutwidth,xmaxindentwidth,xmaxtepwidth,xmaxcapwidth,int1,int2,int3,int4,vc,xcode,xshortcut,xindent,rh,p,dx,dy:longint;
   str1,str2,xcaption,xcaplabel,xhelp,xcode2:string;
   xmarkrow,bol1,bol2,xcolorise,xflashON,xflash,xflashing,funderline,xrowbol,xrows,xtitle,xsep:boolean;
   xstyle:byte;
   xlist:tstr8;
   v:byte;
   //## xrowback ##
   procedure xrowback(xmode,x:longint;dround,xframe,xlock:boolean);//optionally draws row background color
   var
      xhover,bol1:boolean;
   begin
   //defaults
   bol1:=false;
   xhover:=false;
   //init
   if (xmode=mdis) then//was: (x=a.disable) then
      begin
      bol1:=true;
      end
   else if (xmode=mhov) then //was: (x=a.hover) then
      begin
      xhover:=true;
      bol1:=true;
      if xrows and xrowbol then x:=low__dc(x,10);
      if xrows and (not xlock) then xrowbol:=not xrowbol;
      end
   else if xrows then
      begin
      if xrowbol then
         begin
         x:=low__dc(x,10);
         bol1:=true;
         end;
      if not xlock then xrowbol:=not xrowbol;
      end;
   //get
   if bol1 then
      begin
      //Note: "xhover" line below has not been tested on all menu modes - 18aug2020
      if xhover and vienhanced then lds2(rect(xbordersize,dy,cw-1-xbordersize,dy+rh-1),low__dc(x,-10),x,clnone,0,vishadestyle,dround)
      else if xframe then ldso(rect(xbordersize,dy,cw-1-xbordersize,dy+rh-1),x,clnone,dround)
      else           ldso(rect(xbordersize,dy,cw-1-xbordersize,dy+rh-1),clnone,x,dround);
      //dback
      dback:=x;
      end;
   end;
begin
try
//defaults
xlist:=nil;
xflashing:=false;
xflashON:=not sysflash;
xcolorise:=vicoloriseimages;
//init
infovars(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xback,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);
b:=@vititle;
th:=fnbH;//18apr2020
xtab:=otab;//24feb2021
xstyle:=ostyle;
xrows:=orows;
xrowbol:=false;
cw:=frcmin(cw-low__insint(iv.clientwidth,iv.visible),1);//adjust down to exclude scrollbar width
rh:=xrowheight;
dy:=xbordersize;
vc:=vcount;//visible count
xlist:=bnew;
findex:=fn;
fcol:=xfont;
if enabled then xfonthighlight:=info.fonthighlight else xfonthighlight:=xfont;
dback:=clnone;
funderline:=false;
//.system widths -> for debug purposes, paint proc can adapt these values if too small OR if not set - 28mar2020
xzoom:=vizoom;
//note: for lists (with very long datasets, we can't calc imaxtepheight, so we have to assume 20?)
xmaxindentwidth:=frcmin(imaxindentwidth,0);
xmaxtepwidth:=frcmin(imaxtepwidth,0)*xzoom;
xmaxcapwidth:=frcmin(imaxcapwidth,0);
xmaxcutwidth:=frcmin(imaxcutwidth,0);
ximagealign:=frcrange(oimagealign,0,iaMax);
xmarkrow:=false;

//cls
lds(cs,xback,xround);//need to adhere to roundness - fixed 13apr2020
//get
p:=frcrange(ipos,0,frcmin(icount-vc,0));//restrict scroll range
redo:
dx:=xbordersize+xpad;
if (p>=0) and (p<icount) and (dy<=(ch-1-xbordersize)) and xgetitem(p,xtab,xtep,xtepcolor,xcaption,xcaplabel,xhelp,xcode2,xcode,xshortcut,xindent,xflash,xenabled,xtitle,xsep) then
   begin
   //init
   findex:=fn;
   fcol:=xfont;
   dback:=clnone;
   funderline:=false;
   if xflash then xflashing:=true;//tell system we need flashing support - 25mar2021
   //ra
   ra:=rect(xbordersize,dy,cw-1-xbordersize,dy+rh-1);
   //show highlight/disabled etc
   if xtitle then//now round - 07oct2020
      begin
      findex:=fb;
      fcol:=b.font;
      ldso(rect(xbordersize,dy,cw-1-xbordersize,dy+rh-1),b.border,b.background,xround);
      xrowbol:=false;
      end
   else if not xenabled then
      begin
      fcol:=a.disablefont;
      ldso(rect(xbordersize,dy,cw-1-xbordersize,dy+rh-1),clnone,a.disable,false);
      end
   else if (xstyle=lsmenu) and (p=ihoverindex) then
      begin
      //was: fcol=xfont
      fcol:=xfonthighlight;
      funderline:=ohoverunderline;
      xrowback(mhov,xhover,xround,false,false);
      end
   else if (xstyle>=lslist) and (p>=iselstart) and (p<(iselstart+iselcount)) then
      begin
//was:if (p=idownindex) then fcol:=xfonthighlight;//09mar2021
//was but this lead to BAD rendering of multi-selection highlights, so, simple is best!:if (p=iselstart) then fcol:=xfonthighlight;//09mar2021
      fcol:=xfonthighlight;//09mar2021
      if (p=idownindex) and (xstyle=lsmany) then funderline:=ohoverunderline;//underline the focused item but ONLY in a multi-item selection
      xrowback(mhov,xhover,xround,false,false);
      end
   else if (xstyle=lslist) and (p=ihoverindex) then//no hover highlight for lsmany - 07apr2020
      begin
      fcol:=xfont;
      //fcol:=xfonthighlight;
      funderline:=ohoverunderline;
      case olisthover of
      false:xrowback(mnor,xback,false,false,false);
      true:begin
         xrowback(mhov,low__ecv(xback,xhover,10),false,false,true);
         xrowback(mhov,xhover,xround,true,false);//list "frame" hover highlight
         end;
      end;//case
      end
   else if xrows then xrowback(mnor,xback,false,false,false);

   //.xmarkrow
   xmarkrow:=(ostyle=lsmany) and ((p=imanysel1) or (p=imanysel2)) and (imanysel1<>imanysel2) and (not xtitle);//for "select to here" visual markings - 28sep2022

   //fcol - 11oct2020
   if (dback<>clnone) then fcol:=low__ecv(fcol,dback,20);

   //indent
   if (xindent>xmaxindentwidth) then xmaxindentwidth:=xindent;
   inc(dx,xindent);
   //tep
   if (xtep<>tepnone) then
      begin
      tepinfosys(xtep,int1,int2,bol1,bol2);//aw,ah
      case ximagealign of
      iaLeft:xteptmp:=0;
      iaCenter:xteptmp:=frcmin((xmaxtepwidth-int1) div 2,0);
      iaRight:xteptmp:=frcmin(xmaxtepwidth-int1,0);
      else xteptmp:=0;
      end;//case
      if (not xflash) or xflashON then
         begin
         case (xtepcolor<>clnone) of//fixed 13apr2021, 26mar2021
         true:ldis2(ra,dx+xteptmp,dy+((rh-int2) div 2),xtepcolor,xborder,xtep,(p=ihoverindex) and (xstyle=lsmenu) and xenabled and (not xtitle),not xenabled,xround);
         false:ldis2(ra,dx+xteptmp,dy+((rh-int2) div 2),fcol,low__aorb(clnone,low__aorb(dback,xback,dback=clnone),xcolorise),xtep,(p=ihoverindex) and (xstyle=lsmenu) and xenabled and (not xtitle),not xenabled,xround);
         end;//case
         end;
      if (int1>xmaxtepwidth) then xmaxtepwidth:=int1;
      end;

   //caption
   if (not xtitle) or (xtep<>tepnone) then inc(dx,xmaxtepwidth+low__insint(xpad,xmaxtepwidth>=1));

   str1:=low__udv(xcaplabel,xcaption);
   if (str1<>'') then
      begin
      //.onumberfrom - use carefully - 20mar2022
      if (not xtitle) then
         begin
         if      (onumberfrom3>=0) and (p>=onumberfrom3) then str1:=low__64(p-onumberfrom3+1)+'. '+str1
         else if (onumberfrom2>=0) and (p>=onumberfrom2) then str1:=low__64(p-onumberfrom2+1)+'. '+str1
         else if (onumberfrom>=0)  and (p>=onumberfrom)  then str1:=low__64(p-onumberfrom+1)+'. '+str1;
         end;
      ldtTAB2(xtab,ra,dx,dy+((rh-th) div 2),fcol,str1,findex,xfeather,false,false,funderline,false,xround);
      int1:=low__fonttextwidthTAB2(xtab,findex,str1);
      if (not xtitle) and (int1>xmaxcapwidth) then xmaxcapwidth:=int1;
      end;

   //row marker - 28sep2022
//was:   if xmarkrow then lds(rect(cw-1-xbordersize-xpad-10,dy+2,cw-1-xbordersize-xpad-3,dy+rh-3),fcol,true);
   if xmarkrow then
      begin
      int3:=low__aorb(tepDown,tepUp,p>=largest(imanysel1,imanysel2));
      tepinfosys(int3,int1,int2,bol1,bol2);//aw,ah
      ldis2(ra,cw-1-xbordersize-xpad-int1-2,dy+((rh-int2) div 2),fcol,fcol,int3,(p=ihoverindex) and (xstyle=lsmenu) and xenabled and (not xtitle),not xenabled,xround);
      end;

   //hover and click item list
   xlist.addint4(p);
   xlist.addint4(dy);
   xlist.addint4(dy+rh);

   //shortcut - left align within it's column - 13apr2020
   if (not xtitle) then
      begin
      inc(dx,xmaxcapwidth);
      if low__akstr(xshortcut,str2) and (str2<>'') then ldt2(rect(dx,dy,cw-1-xbordersize,dy+rh-1),cw-1-xbordersize-xpad-largest(xmaxcutwidth,low__fonttextwidth2(findex,str2)),dy+((rh-th) div 2),fcol,str2,findex,xfeather,false,false,funderline,false,xround);
      end;

   //sep
   if xsep then ldh(ra.left,ra.right,ra.bottom,xborder,xround);

   //next row
   inc(dy,rh);
   //loop
   inc(p);
   goto redo;
   end;

//draw border -> by default a menu has no border and instead relies on the underlying form for a border - 04apr2020
//Menu needs softening as it butts up against many other common controls -> this helps lighten the butt joins - 17mar2021
if (xbordersize>=1) then ldf(cs,xborder,low__dc(xback,-20),xbordersize,nil,xround);//26feb2022
xparentcorners;

//merge into existing list
if (xlist.count>=1) then
   begin
   if (xlist.count>ilist.count) then ilist.setlen(xlist.count);

   //was: for p:=0 to (xlist.count-1) do ilist.pbytes[p]:=xlist.pbytes[p];
   //faster - 22apr2022
   for p:=0 to (xlist.count-1) do
   begin
   v:=xlist.pbytes[p];
   ilist.pbytes[p]:=v;
   end;//p
   end;
ilistcount:=xlist.count div 12;
//flash support
iwasflashing:=iflashing;
iflashing:=xflashing;
except;end;
try;bfree(xlist);except;end;
end;

//## tbasicbreak ###############################################################
//## create ##
constructor tbasicbreak.create(xparent:tobject;xheight:longint);
begin
create2(xparent,true,xheight);
end;
//## create2 ##
constructor tbasicbreak.create2(xparent:tobject;xstart:boolean;xheight:longint);
begin
//self
inherited create2(xparent,false);
//vars
iheight:=frcmin(xheight,0);
ibordersize:=0;
inormal:=true;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasicbreak.destroy;
begin
try
inherited destroy;
except;end;
end;
//## getalignheight ##
function tbasicbreak.getalignheight(xclientwidth:longint):longint;
begin
try;result:=frcmin(iheight,ominheight);except;end;
end;
//## _onpaint ##
procedure tbasicbreak._onpaint(sender:tobject);
begin
try
//do nothing
except;end;
end;

//## tbasicint #################################################################
//xxxxxxxxxxxxxxxxxxxxxxxxxxxx//iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
//## create ##
constructor tbasicint.create(xparent:tobject);
begin
create2(xparent,true);
end;
//## create2 ##
constructor tbasicint.create2(xparent:tobject;xstart:boolean);
begin
//self
inherited create2(xparent,false);
//vars
itimer500:=ms64;
itimer250:=ms64;
ireloadid:=viloadid;
oshowdef:=true;
oshow2:=true;
oautoreload:=false;
oloadfromname:='';//off
idownstyle:='';//none
idownval:=0;
ibordersize:=1;
inormal:=true;
ilastval:=minint;//28jul2021
imin:=0;
imax:=0;
idef:=0;
ival:=0;
ipaintid:=0;
ivalid:=0;
ilastpaintid:=0;
ilastvalid:=0;
omorecap:='';
olesscap:='';
omorecap2:='';
olesscap2:='';
odefcap:='';
omore:=1;
oless:=-1;
omore2:=10;
oless2:=-10;
ovalshow:=true;
ovalmultiplier:=1;
ovalunit:='';
ovalstyle:='';//05jul2021
xnorects;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasicint.destroy;
begin
try
inherited destroy;
except;end;
end;
//## makeZoom10k ##
procedure tbasicint.makeZoom10k;
begin
try
ovalstyle:='zoom10k';
omore2:=100;
oless2:=-100;
omore:=10;
oless:=-10;
oshow2:=true;
except;end;
end;
//## makeFps10 ##
procedure tbasicint.makeFps10;
begin
try
ovalstyle:='fps10';
omore2:=10;
oless2:=-10;
omore:=1;
oless:=-1;
oshow2:=true;
except;end;
end;
//## makemidivol ##
procedure tbasicint.makemidivol;
begin
try;makevol(made_midivol);except;end;
end;
//## makewavevol ##
procedure tbasicint.makewavevol;
begin
try;makevol(made_wavevol);except;end;
end;
//## makevol ##
procedure tbasicint.makevol(xmade:longint);//12nov2022
const
   defVol=100;//12nov2022, was 50% - 01mar2022
begin
try
//range
if (xmade<>made_wavevol) and (xmade<>made_midivol) then xmade:=made_midivol;
//get
omade:=xmade;
onreadwriteval:=__onvol;
omore:=1;
oless:=-1;
omore2:=10;
oless2:=-10;
caption:='Volume';
help:='Set volume level';
oshow2:=true;
ovalunit:='%';
odefcap:=inttostr(defVol)+'%';//12nov2022, 01mar2022
case xmade of
made_midivol:setparams(0,200,defVol,mid_vol);
made_wavevol:setparams(0,100,defVol,wav_vol);
end;//case
except;end;
end;
//## __onvol ##
procedure tbasicint.__onvol(sender:tobject;var xval:longint;xwrite:boolean);
begin
try
case omade of
made_midivol:if xwrite then mid_setvol(xval) else xval:=mid_vol;
made_wavevol:if xwrite then wav_setvol(xval) else xval:=wav_vol;
end;//case

if low__setint(ival,xval) then
   begin
   low__iroll(ipaintid,1);
   end;
except;end;
end;
//## reload ##
procedure tbasicint.reload;
begin
try;if (oloadfromname<>'') then setparams3(imin,imax,idef,ival,oloadfromname);except;end;
end;
//## setdef ##
procedure tbasicint.setdef(xdef:longint);
begin
try;setparams3(min,max,xdef,val,'');except;end;
end;
//## setparams ##
procedure tbasicint.setparams(xmin,xmax,xdef,xval:longint);
begin
try;setparams3(xmin,xmax,xdef,xval,'');except;end;
end;
//## setparams3 ##
procedure tbasicint.setparams3(xmin,xmax,xdef,xval:longint;xloadfromname:string);
begin
try
//range
if (xmin>xmax) then low__swapint(xmin,xmax);
xdef:=frcrange(xdef,xmin,xmax);
xval:=frcrange(xval,xmin,xmax);
//xloadfromname -> overrides "xval" and sets "oloadfromname" in one go - 07sep2020
if (xloadfromname<>'') then
   begin
   oloadfromname:=xloadfromname;
   xval:=frcrange(ifromname(xloadfromname),xmin,xmax);
   end;
//set
if (xmin<>imin) or (xmax<>imax) or (xdef<>idef) or (xval<>readval) then
   begin
   imin:=xmin;
   imax:=xmax;
   idef:=xdef;
   if (readval<>xval) then
      begin
      writeval(xval);
      if assigned(fonvalue2) then fonvalue2(self,readval);//26feb2021
      low__iroll(ivalid,1);
      end;
   low__iroll(ipaintid,1);
   end;
except;end;
end;
//## xnorects ##
procedure tbasicint.xnorects;
begin
try
iamore:=nilrect;
ialess:=nilrect;
iamore2:=nilrect;
ialess2:=nilrect;
iadef:=nilrect;
iabar:=nilrect;
except;end;
end;
//## setval ##
procedure tbasicint.setval(xval:longint);
begin
try;setparams(imin,imax,idef,xval);except;end;
end;
//## writeval ##
procedure tbasicint.writeval(xval:longint);
begin
try
xval:=frcrange(xval,imin,imax);
if assigned(fonreadwriteval) then fonreadwriteval(self,xval,true) else ival:=xval;
except;end;
end;
//## readval ##
function tbasicint.readval:longint;
begin
try
result:=idef;
if assigned(fonreadwriteval) then fonreadwriteval(self,result,false) else result:=ival;
result:=frcrange(result,imin,imax);
except;end;
end;
//## _ontimer ##
procedure tbasicint._ontimer(sender:tobject);
var
   xmustpaint:boolean;
   v8:comp;
begin
try
xmustpaint:=false;

//reload - 07sep2020
if oautoreload and (ireloadid<>viloadid) and (not visyncing) and ((not focused) or (not gui.mousedown)) then
   begin
   ireloadid:=viloadid;
   reload;
   end;

//valid
if (ilastvalid<>ivalid) then
   begin
   ilastvalid:=ivalid;
   xonvalue;
   end;
//paintid
if (ilastpaintid<>ipaintid) then
   begin
   ilastpaintid:=ipaintid;
   xmustpaint:=true;
   end;

//readval
if (ms64>=itimer250) then
   begin
   if ((not focused) or (not gui.mousedown)) and (not visyncing) and assigned(fonreadwriteval) and low__setint(ilastval,readval) then
      begin
      val:=readval;
      xmustpaint:=true;//fixed - 28jul2021
      end;
   if low__setstr(ilastvalunit,ovalunit) then xmustpaint:=true;
   itimer250:=ms64+250;
   end;

//auto-click when mouse/tap is held down - 09mar2022
v8:=gui.mousedowntime;
if (v8>=2000) then
   begin
   if (ms64>=itimer500) then
      begin
      if (idownstyle='more')       then val:=val+omore
      else if (idownstyle='more2') then val:=val+omore2
      else if (idownstyle='less')  then val:=val+oless
      else if (idownstyle='less2') then val:=val+oless2;
      //reset
      if      (v8<=7000)  then itimer500:=ms64+300
      else if (v8<=20000) then itimer500:=ms64+100
      else                     itimer500:=ms64+50;
      end;
   end
else itimer500:=ms64+1;

//xmustpaint
if xmustpaint then paintnow;
except;end;
end;
//## getalignheight ##
function tbasicint.getalignheight(xclientwidth:longint):longint;
begin
try;result:=frcmin((2*vilineheight)+(2*frcmin(findbordersize,1)),ominheight*vizoom);except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxx//iiiiiiiiiiiiiiiiiiii
//## zname ##
function tbasicint.zname(n:string):string;
var
   xdec:longint;
   //## xfilter ##
   procedure xfilter(xprecap,xcap:string;xval:longint);
   begin
   result:=xcap;
   if (result='') then
      begin
      if (ovalstyle='fps10') then result:=xprecap+curdec(xval/10,1,false)
      else if low__comparetext(ovalstyle,'speed10K') then result:=xprecap+curdec(xval/100,low__aorb(1,2,low__posn(xval)<100),false)
      else if low__comparetext(ovalstyle,'zoom10K') then result:=xprecap+curdec(xval/100,low__aorb(1,2,low__posn(xval)<100),false)
      else result:=xprecap+inttostr(xval);
      //auto trim ".0" or  ".10" or  ".100"
      result:=low__trimdec(result);
      end;
   end;
begin
try
//defaults
result:='';
//init
n:=low__lowercase(n);
xdec:=0;
if (ovalstyle='fps10') then xdec:=1;
//get
if      (n='more2') then xfilter('+',omorecap2,omore2)
else if (n='less2') then xfilter('',olesscap2,oless2)
else if (n='more')  then xfilter('+',omorecap,omore)
else if (n='less')  then xfilter('',olesscap,oless)
else if (n='def')   then xfilter('',odefcap,idef);
except;end;
end;
//## _onpaint ##
procedure tbasicint._onpaint(sender:tobject);
var//Supports enhanced shading
   //infovars
   a:pvirtualinfo;
   cs,ci:trect;
   fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xfont2,xback,xback2,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xautoclick,xenabled,xround,xnormal:boolean;
   //other
   vsp,xlineheight,xval,xzoom,hsp,sp,xcapright,p,int0,int1,int2,int3,dx,dy:longint;
   xtouch:boolean;
   da,da2:trect;
   z:string;
   cur1:currency;
   //## xlink ##
   function xlink(xname:string;zdraw,zhighlight:boolean):trect;
   var//Note: zcap is an optional override - 07jul2021
      int1,atw,tw:longint;
      z:string;
   begin
   //check
   if (not oshowdef) and (xname='def') then exit;//03mar2022
   //get
   z:=#32+zname(xname)+low__insstr(ovalunit,(xname='def') and (odefcap=''))+#32;
   tw:=low__fonttextwidth2(fn,z);
   atw:=tw;
   if xtouch then tw:=frcmin(tw,32*xzoom);//extra-wide buttons for touch screens - 03mar2022
   dec(dx,tw+hsp);
   int1:=xlineheight-(2*vsp);
   result:=rect(dx,dy,dx+tw,dy+int1);
   if zdraw then
      begin
      //.highlight
      zhighlight:=low__comparetext(idownstyle,xname);
      if zhighlight and xautoclick then zhighlight:=sysflash;
      //.cls
      lds3(true,result,low__aorb(xback,xfont,zhighlight),low__aorb(xback2,xfont2,zhighlight),clnone,0,vishadestyle,xround,true);//27mar2021
      //.text
      ldt(ci,dx+((tw-atw) div 2),dy+((int1-fnH) div 2),low__aorb(xfont,xback,zhighlight),z,fn,xfeather,xround);
      //.area
      if      (xname='more2') then iamore2:=result
      else if (xname='less2') then ialess2:=result
      else if (xname='more')  then iamore:=result
      else if (xname='less')  then ialess:=result
      else if (xname='def')   then iadef:=result;
      end;
   dec(dx,hsp);
   end;
   //## xlinks ##
   function xlinks(zstyle:longint;zdraw:boolean):boolean;
   begin
   //defaults
   result:=false;
   //init
   dx:=ci.right;
   //style
   case zstyle of
   0:begin//small+def+large
      if oshow2 then
         begin
         xlink('more2',zdraw,false);
         xlink('less2',zdraw,false);
         end;
      xlink('def',zdraw,false);
      xlink('more',zdraw,false);
      xlink('less',zdraw,false);
      end;
   1:begin//small+def
      xlink('def',zdraw,false);
      xlink('more',zdraw,false);
      xlink('less',zdraw,false);
      end;
   2:begin//small
      xlink('more',zdraw,false);
      xlink('less',zdraw,false);
      end;
   3:begin//def
      xlink('def',zdraw,false);
      end;
   end;//case
   //successful
   result:=(dx>xcapright);
   end;
begin
try
//init
xval:=val;
xzoom:=vizoom;
sp:=2*xzoom;
xlineheight:=vilineheight;
vsp:=vilinevsp;//2 per line
hsp:=sp;
infovars2(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xfont2,xback,xback2,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);
xtouch:=vitouch;

//cls
//old: lds(cs,xback,false);
//was: lds2(cs,xback2,xback,clnone,0,'g50',false);
lds3(true,cs,xback2,xback,clnone,0,vishadestyle,xround,true);//03mar2022
xautoclick:=(gui.mousedowntime>=2000);

//caption
xcapright:=ci.left+5;
z:=caption;
if ovalshow then
   begin
   if low__comparetext(ovalstyle,'msfps') then
      begin
      cur1:=xval*ovalmultiplier;
      if (cur1<=0) then cur1:=1;
      z:=z+#32+curdec(1000/cur1,2,false)+' fps';
      end
   else if low__comparetext(ovalstyle,'fps10') then
      begin
      cur1:=xval*ovalmultiplier;
      if (cur1<=0) then cur1:=1;
      z:=z+#32+curdec(cur1/10,1,false)+' fps';
      end
   else if low__comparetext(ovalstyle,'speed10K') then
      begin
      cur1:=xval*ovalmultiplier;
      if (cur1<=0) then cur1:=1;
      z:=z+#32+curdec(cur1/100,2,false)+' %';
      end
   else if low__comparetext(ovalstyle,'zoom10K') then
      begin
      cur1:=xval*ovalmultiplier;
      if (cur1<=0) then cur1:=1;
      z:=z+#32+curdec(cur1/100,2,false)+' %';
      end
   else if low__comparetext(ovalstyle,'h:m') then//28feb2022
      begin
      int1:=(xval div 60);
      z:=z+#32+low__digpad11(int1,1)+':'+low__digpad11(xval-(int1*60),2);
      end
   else if assigned(fonvalcap) then fonvalcap(self,z)//28feb2022
   else z:=z+#32+low__thousands64(round(xval*ovalmultiplier))+ovalunit;
   end;
if (z<>'') then
   begin
   ldt(ci,xcapright,ci.top,xfont,z,fn,xfeather,xround);
   inc(xcapright,low__fonttextwidth2(fn,z)+2);
   end;
//links
xnorects;
dy:=ci.top+1;
for p:=0 to 3 do if xlinks(p,false) then
   begin
   xlinks(p,true);
   break;
   end;
//bar
da.left:=ci.left+(2*xzoom);
da.right:=ci.right-(2*xzoom);
da.top:=ci.bottom-1-(xlineheight-(2*vsp));
da.bottom:=ci.bottom-1-vsp;
int0:=frcmin(da.right-da.left+1,1);
int1:=frcmin(imax-imin,1);
int2:=xval-imin;
int3:=frcrange(round(int0*(int2/int1)),0,int0);
da2:=da;
da2.right:=da2.left+frcmin(int3-1,0);
lds3(false,da2,xfont,xfont2,clnone,0,vishadestyle,xround,true);//29mar2021
ldo3(false,da,xfont,xfont2,clnone,0,vishadestyle,xround,true);
iabar:=da;
//frame
if (xbordersize>=1) then ldf(cs,xborder,low__dc(xback,-20),xbordersize,nil,xround);
xparentcorners;
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxx//iiiiiiiiiiiiiiiiiiii
//## _onnotify ##
function tbasicint._onnotify(sender:tobject):boolean;
var
   dp:tpoint;
   int1,int2,dx,dy:longint;
begin
try
//defaults
result:=false;

//wheel
if (gui.wheel<>0) then
   begin
   if enabled then
      begin
      val:=val-gui.wheel;
      result:=true;//own the wheel
      end;
   end;

//key
if (gui.key<>aknone) then
   begin
   case gui.key of
   akhome:begin
      if enabled then val:=imin;
      result:=true;
      end;
   akend:begin
      if enabled then val:=imax;
      result:=true;
      end;
   akleft,akup:begin
      if enabled then val:=val-1;
      result:=true;
      end;
   akright,akdown:begin
      if enabled then val:=val+1;
      result:=true;
      end;
   akprev:begin
      if enabled then val:=val+oless2;
      result:=true;
      end;
   aknext:begin
      if enabled then val:=val+omore2;
      result:=true;
      end;
   end;//case
   end;

//mouse down
if gui.mousedownstroke then
   begin
   dp:=mousedownxy;
   idownval:=val;
   if low__withinrect2(dp,iadef) then idownstyle:='def'
   else if low__withinrect2(dp,iamore) then idownstyle:='more'
   else if low__withinrect2(dp,iamore2) then idownstyle:='more2'
   else if low__withinrect2(dp,ialess) then idownstyle:='less'
   else if low__withinrect2(dp,ialess2) then idownstyle:='less2'
   else idownstyle:='bar';
   //paint
   paintnow;
   end;

//mouse move
if gui.mousedown and gui.mousemoved and (not gui.mousedownstroke) then
   begin
   if (idownstyle='bar') then
      begin
      int1:=mousexy.x-mousedownxy.x;
      int2:=round((int1/frcmin(clientwidth,1))*(imax-imin+1));
      val:=idownval+int2;
      end;
   end;

//mouse up
if gui.mouseupstroke then
   begin
   if (idownstyle='def') then val:=idef
   else if (idownstyle='more') then val:=val+omore
   else if (idownstyle='more2') then val:=val+omore2
   else if (idownstyle='less') then val:=val+oless
   else if (idownstyle='less2') then val:=val+oless2;
   //reset
   if (idownstyle<>'') then
      begin
      idownstyle:='';
      paintnow;
      end;
   end;

//external event override - 01mar2021
if assigned(fonnotify) then fonnotify(sender);
except;end;
end;

//## tbasicset #################################################################
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxx//oooooooooooooooooooooooooooo
//## create ##
constructor tbasicset.create(xparent:tobject);
begin
create2(xparent,true);
end;
//## create2 ##
constructor tbasicset.create2(xparent:tobject;xstart:boolean);
var
   p:longint;
begin
//self
inherited create2(xparent,false);
//vars
itimer250:=ms64;
ireloadid:=viloadid;
oautoreload:=false;
ovpad:=0;
for p:=0 to high(icaps) do
begin
icaps[p]:='';
inams[p]:='';
ihlps[p]:='';
ivisb[p]:=true;
iloadfromnames[p]:='';
end;//p
idownindex:=-1;
ibordersize:=1;
inormal:=true;
idef:=0;
ival:=0;
ipaintid:=0;
ivalid:=0;
ilastpaintid:=0;
ilastvalid:=0;
icount:=0;
ilastcount:=0;
iitemsperline:=0;//no limit => all items on one line only - 28aug2020
ilastval:=0;
xnorects;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasicset.destroy;
begin
try
inherited destroy;
except;end;
end;
//## ysetval ##
procedure tbasicset.ysetval(xval:longint);
var
   v:tbasicset_valarray;
   a:tint4;
   p:longint;
begin
try
if assigned(fonreadwriteval) then
   begin
   //get
   a.val:=xval;
   for p:=0 to high(icaps) do v[p]:=(p in a.bits);
   fonreadwriteval(self,v,true);
   end
else ival:=xval;
except;end;
end;
//## ygetval ##
function tbasicset.ygetval:longint;
var
   v:tbasicset_valarray;
   a:tint4;
   p:longint;
begin
try
//defaults
result:=idef;
//get
if assigned(fonreadwriteval) then
   begin
   //get
   for p:=0 to high(icaps) do v[p]:=false;
   fonreadwriteval(self,v,false);
   //set
   a.val:=0;
   for p:=0 to high(icaps) do if v[p] then include(a.bits,p);
   result:=a.val;
   end
else result:=ival;
except;end;
end;
//## setitemsperline ##
procedure tbasicset.setitemsperline(x:longint);
begin
try;setparams2(idef,yval,x);except;end;
end;
//## reload ##
procedure tbasicset.reload;
var
   p:longint;
begin
try;for p:=0 to high(iloadfromnames) do if (iloadfromnames[p]<>'') and (icaps[p]<>'') then xset3(p,icaps[p],inams[p],ihlps[p],vals[p],iloadfromnames[p]);except;end;
end;
//## setparams ##
procedure tbasicset.setparams(xdef,xval:longint);
begin
try;setparams2(xdef,xval,iitemsperline);except;end;
end;
//## setparams2 ##
procedure tbasicset.setparams2(xdef,xval,xitemsperline:longint);
begin
try
//range
xitemsperline:=frcrange(xitemsperline,0,100);
//set
if (xdef<>idef) or (xval<>yval) or (xitemsperline<>iitemsperline) then
   begin
   idef:=xdef;
   if (yval<>xval) then
      begin
      yval:=xval;
      low__iroll(ivalid,1);
      end;
   iitemsperline:=xitemsperline;
   low__iroll(ipaintid,1);
   end;
except;end;
end;
//## xnorects ##
procedure tbasicset.xnorects;
var
   p:longint;
begin
try;for p:=0 to high(icaps) do irecs[p]:=nilrect;except;end;
end;
//## setval ##
procedure tbasicset.setval(xval:longint);
begin
try;setparams(idef,xval);except;end;
end;
//## _ontimer ##
procedure tbasicset._ontimer(sender:tobject);
var
   xmustalign,xmustpaint:boolean;
begin
try
//defaults
xmustalign:=false;
xmustpaint:=false;

//reload - 07sep2020
if oautoreload and (ireloadid<>viloadid) and (not visyncing) and ((not focused) or (not gui.mousedown)) then
   begin
   ireloadid:=viloadid;
   reload;
   end;

//valid
if (ilastvalid<>ivalid) then
   begin
   ilastvalid:=ivalid;
   xonvalue;
   end;
//alignid
if (ilastitemsperline<>iitemsperline) or (ilastcount<>icount) then
   begin
   ilastitemsperline:=iitemsperline;
   ilastcount:=icount;
   xmustalign:=true;
   end;
//paintid
if (ilastpaintid<>ipaintid) then
   begin
   ilastpaintid:=ipaintid;
   xmustpaint:=true;
   end;
//mustpaint
if (ms64>=itimer250) then
   begin
   if assigned(onreadwriteval) and (not visyncing) and ((not focused) or (not gui.mousedown)) and low__setint(ilastval,val) then xmustpaint:=true;
   itimer250:=ms64+250;
   end;

//xmustpaint
if xmustalign then alignnow;
if xmustpaint then paintnow;
except;end;
end;
//## linecount ##
function tbasicset.linecount:longint;
begin
try
result:=1;
if (iitemsperline>=1) then
   begin
   result:=icount div iitemsperline;
   if ((result*iitemsperline)<>icount) then inc(result);
   end;
except;end;
end;
//## getalignheight ##
function tbasicset.getalignheight(xclientwidth:longint):longint;
begin
try;result:=frcmin( ((1+linecount)*vilineheight)+((2+ovpad)*frcmin(findbordersize,1)),ominheight*vizoom);except;end;
end;
//## xsynccount ##
procedure tbasicset.xsynccount;
var
   p,int1:longint;
begin
try
int1:=0;
for p:=0 to high(icaps) do if (length(icaps[p])>=1) then inc(int1);
icount:=int1;
except;end;
end;
//## xset ##
procedure tbasicset.xset(xindex:longint;xcap,xnam,xhlp:string;xval:boolean);
begin
try;xset3(xindex,xcap,xnam,xhlp,xval,'');except;end;
end;
//## xset3 ##
procedure tbasicset.xset3(xindex:longint;xcap,xnam,xhlp:string;xval:boolean;xloadfromname:string);
begin
try
if (xindex>=0) and (xindex<=high(icaps)) then
   begin
   if (xloadfromname<>'') then xval:=bfromname(xloadfromname);
   icaps[xindex]:=xcap;
   inams[xindex]:=xnam;
   ihlps[xindex]:=xhlp;
   iloadfromnames[xindex]:=xloadfromname;
   vals[xindex]:=xval;
   xsynccount;
   end;
except;end;
end;
//## getcaps ##
function tbasicset.getcaps(xindex:longint):string;
begin
try;result:='';if (xindex>=0) and (xindex<=high(icaps)) then result:=icaps[xindex];except;end;
end;
//## setcaps ##
procedure tbasicset.setcaps(xindex:longint;xval:string);
begin
try
if (xindex>=0) and (xindex<=high(icaps)) and (xval<>icaps[xindex]) then
   begin
   icaps[xindex]:=xval;
   xsynccount;
   low__iroll(ipaintid,1);
   end;
except;end;
end;
//## getnams ##
function tbasicset.getnams(xindex:longint):string;
begin
try;result:='';if (xindex>=0) and (xindex<=high(icaps)) then result:=inams[xindex];except;end;
end;
//## setnams ##
procedure tbasicset.setnams(xindex:longint;xval:string);
begin
try
if (xindex>=0) and (xindex<=high(icaps)) and (xval<>inams[xindex]) then
   begin
   inams[xindex]:=xval;
   low__iroll(ipaintid,1);
   end;
except;end;
end;
//## getvisb ##
function tbasicset.getvisb(xindex:longint):boolean;//31jul2021
begin
try;result:=false;if (xindex>=0) and (xindex<=high(ivisb)) then result:=ivisb[xindex];except;end;
end;
//## setvisb ##
procedure tbasicset.setvisb(xindex:longint;xval:boolean);
begin
try
if (xindex>=0) and (xindex<=high(ivisb)) and (xval<>ivisb[xindex]) then
   begin
   ivisb[xindex]:=xval;
   low__iroll(ipaintid,1);
   end;
except;end;
end;
//## getvals ##
function tbasicset.getvals(xindex:longint):boolean;
var
   a:tint4;
begin
try
result:=false;
if (xindex>=0) and (xindex<=high(icaps)) then
   begin
   a.val:=yval;
   result:=(xindex in a.bits);
   end;
except;end;
end;
//## setvals ##
procedure tbasicset.setvals(xindex:longint;xval:boolean);
var
   a:tint4;
   bol1:boolean;
begin
try
if (xindex>=0) and (xindex<=high(icaps)) then
   begin
   a.val:=yval;
   bol1:=(xindex in a.bits);
   if (bol1<>xval) then
      begin
      if xval then include(a.bits,xindex) else exclude(a.bits,xindex);
      val:=a.val;
      end;
   end;
except;end;
end;
//## findname ##
function tbasicset.findname(xname:string;var xindex:longint):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
xindex:=0;
//check
if (xname='') then exit;
//find
for p:=0 to high(inams) do
begin
if (inams[p]<>'') and low__comparetext(xname,inams[p]) then
   begin
   xindex:=p;
   result:=true;
   break;
   end;
end;//p
except;end;
end;
//## getvals2 ##
function tbasicset.getvals2(xname:string):boolean;
var
   xindex:longint;
begin
try;result:=findname(xname,xindex) and vals[xindex];except;end;
end;
//## setvals2 ##
procedure tbasicset.setvals2(xname:string;xval:boolean);
var
   xindex:longint;
begin
try;if findname(xname,xindex) then vals[xindex]:=xval;except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxx//ooooooooooooooooooooooo
//## viscount ##
function tbasicset.viscount:longint;
var
   p:longint;
begin
try
result:=0;
for p:=0 to (icount-1) do if ivisb[p] then inc(result);
except;end;
end;
//## _onpaint ##
procedure tbasicset._onpaint(sender:tobject);
var//Supports enhanced shading
   //infovars
   a:pvirtualinfo;
   v:tint4;
   cs,ci:trect;
   vcount,dcount,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xfont2,xback,xback2,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xenabled,xround,xnormal:boolean;
   //other
   int1,vsp,xzoom,hsp,xlineheight,xlinecount,xcount,xsetwidth,xcapright,p,dx,dy:longint;
   z:string;
   //## xlink ##
   function xlink(zindex:longint;zdraw:boolean):trect;
   var
      tw:longint;
      z:string;
      zhighlight:boolean;
   begin
   //defaults
   result:=nilrect;
   //check
   z:=icaps[zindex];
   if (z='') then exit;
   //get
   z:=#32+z+#32;
   tw:=low__fonttextwidth2(fn,z);
   int1:=xlineheight-(2*vsp);
   result:=rect(dx,dy+vsp,dx+xsetwidth-1,dy+int1);
   if zdraw then
      begin
      //.highlight
      zhighlight:=(zindex in v.bits);
      //.cls
      lds3(true,result,low__aorb(xback,xfont,zhighlight),low__aorb(xback2,xfont2,zhighlight),clnone,0,vishadestyle,xround,true);//27mar2021
      //.text
      ldt(result,dx+((xsetwidth-tw) div 2),dy+vsp+((int1-fnH) div 2),low__aorb(xfont,xback,zhighlight),z,fn,xfeather,xround);
      end;
   end;
begin
try
//init
xzoom:=vizoom;
hsp:=2*xzoom;
infovars2(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xfont2,xback,xback2,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);

//.xcount + xsetwidth
vsp:=vilinevsp;
xlineheight:=vilineheight;
v.val:=yval;
xlinecount:=linecount;
xcount:=low__aorb(icount,itemsperline,itemsperline>=1);
vcount:=low__aorb(viscount,itemsperline,itemsperline>=1);
xsetwidth:=frcmin( (ci.right-ci.left+1-((vcount+1)*hsp)) div frcmin(vcount,1),1);

//cls
//lds(cs,xback,false);
//was: lds2(cs,xback2,xback,clnone,0,'g50',false);
//was: lds2(cs,xback2,xback,clnone,0,'g50',xround);
lds3(true,cs,xback2,xback,clnone,0,vishadestyle,xround,true);//03mar2022

//caption
xcapright:=ci.left+(5*xzoom);
z:=caption;
if (z<>'') then
   begin
   ldt(ci,xcapright,ci.top,xfont,z,fn,xfeather,xround);
   inc(xcapright,low__fonttextwidth2(fn,z)+hsp);
   end;
//links
dx:=ci.left+hsp;
dy:=ci.bottom-(xlinecount*xlineheight)+vsp-1;
dcount:=1;
for p:=0 to high(icaps) do
begin
if (icaps[p]<>'') and ivisb[p] then
   begin
   irecs[p]:=xlink(p,true);
   inc(dx,xsetwidth+hsp);
   inc(dcount);
   if (dcount>xcount) then
      begin
      dcount:=1;
      dx:=ci.left+hsp;
      inc(dy,xlineheight);
      end;
   end
else irecs[p]:=nilrect;
end;//p

//frame
if (xbordersize>=1) then ldf(cs,xborder,low__dc(xback,-20),xbordersize,nil,xround);
xparentcorners;
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxx//ooooooooooooooooooooooo
//## _onnotify ##
function tbasicset._onnotify(sender:tobject):boolean;
var
   p:longint;
   //## xfinditem ##
   function xfinditem(s:tpoint;var xindex:longint):boolean;
   var
      p:longint;
   begin
   result:=false;
   xindex:=-1;
   for p:=0 to high(icaps) do if (icaps[p]<>'') and low__withinrect2(s,irecs[p]) then
      begin
      xindex:=p;
      result:=true;
      break;
      end;
   end;
begin
try
//defaults
result:=false;

//wheel
if (gui.wheel<>0) then
   begin
   //not used: if enabled then val:=val-gui.wheel;
   end;

//key
if (gui.key<>aknone) then
   begin
//   case gui.key of
//   end;//case
   end;

//mouse down
if gui.mousedownstroke then
   begin
   xfinditem(mousedownxy,idownindex);
   paintnow;
   end;

//help
if gui.mousemoved and (not gui.mousedown) then
   begin
   if xfinditem(mousexy,p) then help2:=ihlps[p] else help2:='';
   end;
   
//mouse up
if gui.mouseupstroke then
   begin
   if (idownindex>=0) and (idownindex<=high(icaps)) then vals[idownindex]:=not vals[idownindex];
   //reset
   if (idownindex>=0) then
      begin
      idownindex:=-1;
      paintnow;
      end;
   end;

//external event override - 01mar2021
if assigned(fonnotify) then fonnotify(sender);
except;end;
end;

//## tbasicsel #################################################################
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//llllllllllllllllllll
//## create ##
constructor tbasicsel.create(xparent:tobject);
begin
create2(xparent,true);
end;
//## create2 ##
constructor tbasicsel.create2(xparent:tobject;xstart:boolean);
var
   p:longint;
begin
//self
inherited create2(xparent,false);
//vars
iwasselected:=false;
ireloadid:=viloadid;
itimer500:=ms64;
oboldhead:=false;
omididevice:=false;
oautoreload:=false;
oloadfromname:='';//off
ovalueclick:=false;
for p:=0 to high(icaps) do
begin
istrs[p]:='';
icaps[p]:='';
inams[p]:='';
ihlps[p]:='';
end;//p
icount:=0;
ilastitemsperline:=0;
ilastcount:=0;
iitemsperline:=0;
idownindex:=-1;
ibordersize:=1;
inormal:=true;
idef:=0;
ival:=0;
imax:=0;
ipaintid:=0;
ivalid:=0;
ilastpaintid:=0;
ilastvalid:=0;
xnorects;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasicsel.destroy;
begin
try
inherited destroy;
except;end;
end;
//## makemididevice ##
function tbasicsel.makemididevice:tbasicsel;
var
   p:longint;
begin
try
//defaults
result:=self;//pass-thru
//.devicelist
help:='Select midi playback device';
for p:=0 to frcmax((mid_devicelimit-1),19) do xadd('-',inttostr(p),low__aorbstr('Midi Mapper','Midi Device #'+inttostr(p),p>=1));
xsyncmididevice(true);
omididevice:=true;
except;end;
end;
//## makewavedevice ##
function tbasicsel.makewavedevice:tbasicsel;
var
   p:longint;
begin
try
//defaults
result:=self;//pass-thru
//.devicelist
help:='Select wave playback device';
for p:=0 to frcmax((wav_devicelimit-1),19) do xadd('-',inttostr(p),low__aorbstr('Wave Mapper','Wave Device #'+inttostr(p),p>=1));
xsyncwavedevice(true);
owavedevice:=true;
except;end;
end;
//## xsyncmididevice ##
procedure tbasicsel.xsyncmididevice(xforce:boolean);
var
   str1,str2:string;
   int1:longint;
   //## xdevicelist ##
   procedure xdevicelist;
   var
      i,p2,p:longint;
      iok:boolean;
      xname,str1,str2:string;
   begin
   try
   //init
   i:=val;
   iok:=mid_deviceok(i);
   xname:='';
   //fill list GUI
   for p:=0 to max do
   begin
   if (p>=1) and (not mid_deviceok(p)) then
      begin
      str1:='-';
      str2:='';
      end
   else
      begin
      str1:=low__aorbstr('Map',inttostr(p),p>=1);
      str2:=mid_devicename(p,'');//allow nil
      end;
   if not low__comparetext(caps[p],str1) then caps[p]:=str1;
   if not low__comparetext(strs[p],str2) then strs[p]:=str2;//12may2021
   //find left
   if (not iok) and (i>=1) then
      begin
      for p2:=(i-1) downto 0 do if mid_deviceok(p2) then
         begin
         val:=p2;
         iok:=true;
         break;
         end;
      end;
   //find right
   if (not iok) and (i<max) then
      begin
      for p2:=(i+1) to max do if mid_deviceok(p2) then
         begin
         val:=p2;
         iok:=true;
         break;
         end;
      end;
   end;//p2
   except;end;
   end;
begin
try
//init
if (vimidideviceNew>=0) then
   begin
   val:=vimidideviceNew;
   vimidideviceNew:=-1;//off
   end;
//sync device list
if xforce or (low__inputidle_nomove>=1000) then xdevicelist;
//get
int1:=frcrange(val,0,99);
if visyssettingsloaded and low__setint(vimididevice,int1) and (int1<>syssettings.i['mididevice']) then
   begin
   syssettings.i['mididevice']:=int1;
   viSyncandsave;
   end;
if (not gui.mousedown) and (vimididevice<>mid_deviceindex) then mid_setdeviceindex(vimididevice);
//set
str1:=mid_devicename(val,'');
str2:='Playback Device'+low__insstr(': ',str1<>'')+str1;
if not low__comparetext(caption,str2) then caption:=str2;
except;end;
end;
//## xsyncwavedevice ##
procedure tbasicsel.xsyncwavedevice(xforce:boolean);
var
   str1,str2:string;
   int1:longint;
   //## xdevicelist ##
   procedure xdevicelist;
   var
      i,p2,p:longint;
      iok:boolean;
      xname,str1,str2:string;
   begin
   try
   //init
   i:=val;
   iok:=wav_deviceok(i);
   xname:='';
   //fill list GUI
   for p:=0 to max do
   begin
   if (p>=1) and (not wav_deviceok(p)) then
      begin
      str1:='-';
      str2:='';
      end
   else
      begin
      str1:=low__aorbstr('Map',inttostr(p),p>=1);
      str2:=wav_devicename(p,'');//allow nil
      end;
   if not low__comparetext(caps[p],str1) then caps[p]:=str1;
   if not low__comparetext(strs[p],str2) then strs[p]:=str2;//12may2021
   //find left
   if (not iok) and (i>=1) then
      begin
      for p2:=(i-1) downto 0 do if wav_deviceok(p2) then
         begin
         val:=p2;
         iok:=true;
         break;
         end;
      end;
   //find right
   if (not iok) and (i<max) then
      begin
      for p2:=(i+1) to max do if wav_deviceok(p2) then
         begin
         val:=p2;
         iok:=true;
         break;
         end;
      end;
   end;//p2
   except;end;
   end;
begin
try
//init
if (viwavedeviceNew>=0) then
   begin
   val:=viwavedeviceNew;
   viwavedeviceNew:=-1;//off
   end;
//sync device list
if xforce or (low__inputidle_nomove>=1000) then xdevicelist;
//get
int1:=frcrange(val,0,99);
if visyssettingsloaded and low__setint(viwavedevice,int1) and (int1<>syssettings.i['wavedevice']) then
   begin
   syssettings.i['wavedevice']:=int1;
   viSyncandsave;
   end;
if (not gui.mousedown) and (viwavedevice<>wav_deviceindex) then wav_setdeviceindex(viwavedevice);
//set
str1:=wav_devicename(val,'');
str2:='Playback Device'+low__insstr(': ',str1<>'')+str1;
if not low__comparetext(caption,str2) then caption:=str2;
except;end;
end;
//## settep ##
procedure tbasicsel.settep(x:longint);
begin
try;if low__setint(itep,x) then paintnow;except;end;
end;
//## reload ##
procedure tbasicsel.reload;
begin
try;if (oloadfromname<>'') then setparams3(idef,ival,iitemsperline,oloadfromname);except;end;
end;
//## findname ##
function tbasicsel.findname(xnam:string;var xindex:longint):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
xindex:=0;
//find
for p:=0 to high(inams) do
begin
if low__comparetext(inams[p],xnam) then
   begin
   xindex:=p;
   result:=true;
   break;
   end
else if (icaps[p]='') then break;
end;//p
except;end;
end;
//## setitemsperline ##
procedure tbasicsel.setitemsperline(x:longint);
begin
try;setparams2(idef,ival,x);except;end;
end;
//## setparams ##
procedure tbasicsel.setparams(xdef,xval:longint);
begin
try;setparams2(xdef,xval,iitemsperline);except;end;
end;
//## setparams2 ##
procedure tbasicsel.setparams2(xdef,xval,xitemsperline:longint);
begin
try;setparams3(xdef,xval,xitemsperline,'');except;end;
end;
//## setparams3 ##
procedure tbasicsel.setparams3(xdef,xval,xitemsperline:longint;xloadfromname:string);
var
   n:string;
   p:longint;
begin
try
//range
xval:=frcrange(xval,0,imax);
xitemsperline:=frcrange(xitemsperline,0,100);
//xloadfromname -> overrides "xval" and sets "oloadfromname" in one go - 07sep2020
if (xloadfromname<>'') then
   begin
   oloadfromname:=xloadfromname;
   n:=sfromname(xloadfromname);
   for p:=0 to high(inams) do
   begin
   if low__comparetext(inams[p],n) then
      begin
      xval:=p;
      break;
      end
   else if (icaps[p]='') then break;
   end;//p
   end;
//set
if (xdef<>idef) or (xval<>ival) or (xitemsperline<>iitemsperline) then
   begin
   idef:=xdef;
   if (readval<>xval) then
      begin
      writeval(xval);
      low__iroll(ivalid,1);
      end;
   iitemsperline:=xitemsperline;
   low__iroll(ipaintid,1);
   end;
except;end;
end;
//## xnorects ##
procedure tbasicsel.xnorects;
var
   p:longint;
begin
try;for p:=0 to high(icaps) do irecs[p]:=nilrect;except;end;
end;
//## setval ##
procedure tbasicsel.setval(xval:longint);
begin
try;setparams(idef,xval);except;end;
end;
//## writeval ##
procedure tbasicsel.writeval(xval:longint);
begin
try
if assigned(fonreadwriteval) then
   begin
   xval:=frcrange(xval,0,imax);
   fonreadwriteval(self,xval,true);
   end;
ival:=frcrange(xval,0,imax);
except;end;
end;
//## readval ##
function tbasicsel.readval:longint;
begin
try
result:=ival;
if assigned(fonreadwriteval) then fonreadwriteval(self,result,false);
result:=frcrange(result,0,imax);
except;end;
end;
//## _ontimer ##
procedure tbasicsel._ontimer(sender:tobject);
var
   xmustalign,xmustpaint:boolean;
begin
try
//defaults
xmustalign:=false;
xmustpaint:=false;

//reload - 07sep2020
if oautoreload and (ireloadid<>viloadid) and (not visyncing) and ((not focused) or (not gui.mousedown)) then
   begin
   ireloadid:=viloadid;
   reload;
   end;

//valid
if (ilastvalid<>ivalid) then
   begin
   ilastvalid:=ivalid;
   xonvalue;
   end;

//timer500
if (ms64>=itimer500) then
   begin
   //get
   if      omididevice then xsyncmididevice(false)//05mar2022
   else if owavedevice then xsyncwavedevice(false);

   //reset
   itimer500:=ms64+500;
   end;


//alignid
if (ilastitemsperline<>iitemsperline) or (ilastcount<>icount) then
   begin
   ilastitemsperline:=iitemsperline;
   ilastcount:=icount;
   xmustalign:=true;
   end;
//paintid
if (ilastpaintid<>ipaintid) then
   begin
   ilastpaintid:=ipaintid;
   xmustpaint:=true;
   end;
//xmustpaint
if xmustalign then alignnow;
if xmustpaint then paintnow;
except;end;
end;
//## linecount ##
function tbasicsel.linecount:longint;
begin
try
result:=1;
if (iitemsperline>=1) then
   begin
   result:=icount div iitemsperline;
   if ((result*iitemsperline)<>icount) then inc(result);
   end;
except;end;
end;
//## getalignheight ##
function tbasicsel.getalignheight(xclientwidth:longint):longint;
begin
try;result:=frcmin( ((1+linecount)*vilineheight)+(2*frcmin(findbordersize,1)),ominheight*vizoom);except;end;
end;
//## xclear ##
procedure tbasicsel.xclear;
var
   p:longint;
begin
try
for p:=0 to high(icaps) do
begin
istrs[p]:='';
icaps[p]:='';
inams[p]:='';
ihlps[p]:='';
end;//p
val:=0;
xsynccount;
except;end;
end;
//## xadd ##
procedure tbasicsel.xadd(xcap,xnam,xhlp:string);
begin
try;xadd2(xcap,xnam,xhlp,'');except;end;
end;
//## xadd2 ##
procedure tbasicsel.xadd2(xcap,xnam,xhlp,xstr:string);
var
   p:longint;
begin
try
for p:=0 to high(icaps) do if (icaps[p]='') then
   begin
   istrs[p]:=xstr;//12may2021
   icaps[p]:=xcap;
   inams[p]:=xnam;//07sep2020
   ihlps[p]:=xhlp;
   break;
   end;
xsynccount;
except;end;
end;
//## xsynccount ##
procedure tbasicsel.xsynccount;
var
   p,int1,int2:longint;
begin
try
int1:=0;
int2:=0;
for p:=0 to high(icaps) do if (length(icaps[p])>=1) then
   begin
   inc(int1);
   int2:=p;
   end;
icount:=int1;
imax:=int2;
except;end;
end;
//## getcaps ##
function tbasicsel.getcaps(xindex:longint):string;
begin
try;result:='';if (xindex>=0) and (xindex<=high(icaps)) then result:=icaps[xindex];except;end;
end;
//## setcaps ##
procedure tbasicsel.setcaps(xindex:longint;xval:string);
begin
try
if (xindex>=0) and (xindex<=high(icaps)) and (xval<>icaps[xindex]) then
   begin
   icaps[xindex]:=xval;
   xsynccount;
   low__iroll(ipaintid,1);
   end;
except;end;
end;
//## getnams ##
function tbasicsel.getnams(xindex:longint):string;
begin
try;result:='';if (xindex>=0) and (xindex<=high(icaps)) then result:=inams[xindex];except;end;
end;
//## setnams ##
procedure tbasicsel.setnams(xindex:longint;xval:string);
begin
try;if (xindex>=0) and (xindex<=high(icaps)) and (xval<>inams[xindex]) then inams[xindex]:=xval;except;end;
end;
//## gethlps ##
function tbasicsel.gethlps(xindex:longint):string;//13mar2022
begin
try;result:='';if (xindex>=0) and (xindex<=high(icaps)) then result:=ihlps[xindex];except;end;
end;
//## sethlps ##
procedure tbasicsel.sethlps(xindex:longint;xval:string);
begin
try;if (xindex>=0) and (xindex<=high(icaps)) and (xval<>ihlps[xindex]) then ihlps[xindex]:=xval;except;end;
end;
//## getstrs ##
function tbasicsel.getstrs(xindex:longint):string;
begin
try;result:='';if (xindex>=0) and (xindex<=high(icaps)) then result:=istrs[xindex];except;end;
end;
//## setstrs ##
procedure tbasicsel.setstrs(xindex:longint;xval:string);
begin
try;if (xindex>=0) and (xindex<=high(icaps)) and (xval<>istrs[xindex]) then istrs[xindex]:=xval;except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxx//llllllllllllllllllllllllllllllllll
//## _onpaint ##
procedure tbasicsel._onpaint(sender:tobject);
const//Supports enhanced shading
   hsp=2;
var
   //infovars
   a:pvirtualinfo;
   v:longint;
   cs,ci:trect;
   fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xfont2,xback,xback2,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xenabled,xround,xnormal:boolean;
   //other
   vsp,xzoom,int1,int2,xtep,dcount,xlineheight,xlinecount,xcount,xsetwidth,xcapright,p,dx,dy:longint;
   bol1,bol2,xcolorise:boolean;
   z:string;
   //## xlink ##
   function xlink(zindex:longint;zdraw:boolean):trect;
   const
      hsp=2;
   var
      int1,tw:longint;
      z:string;
      zhighlight:boolean;
   begin
   //defaults
   result:=nilrect;
   //check
   z:=icaps[zindex];
   if (z='') then exit;
   //get
   z:=#32+z+#32;
   tw:=low__fonttextwidth2(fn,z);
   int1:=xlineheight-(2*vsp);
   result:=rect(dx,dy+vsp,dx+xsetwidth-1,dy+int1);
   if zdraw then
      begin
      //.highlight
      zhighlight:=(zindex=v);
      //.cls
      lds3(true,result,low__aorb(xback,xfont,zhighlight),low__aorb(xback2,xfont2,zhighlight),clnone,0,vishadestyle,xround,true);
      //.text
      ldt(result,dx+((xsetwidth-tw) div 2),dy+vsp+((int1-fnH) div 2),low__aorb(xfont,xback,zhighlight),z,fn,xfeather,xround);
      end;
   end;
begin
try
//init
infovars2(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xfont2,xback,xback2,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);

//.xcount + xsetwidth
xzoom    :=vizoom;
vsp:=vilinevsp;
xlineheight:=vilineheight;
v:=ival;
xlinecount:=linecount;
xcount:=low__aorb(icount,itemsperline,itemsperline>=1);
xsetwidth:=frcmin( (ci.right-ci.left+1-((xcount+1)*hsp)) div frcmin(xcount,1),1);
xcolorise:=vicoloriseimages;
xtep:=itep;


//cls
//was: lds2(cs,xback2,xback,clnone,0,'g50',false);
//was: lds2(cs,xback2,xback,clnone,0,'g50',xround);
lds3(true,cs,xback2,xback,clnone,0,vishadestyle,xround,true);//18sep2022

//tep + caption
xcapright:=ci.left+5;
//.tep
if (xtep<>tepNone) then
   begin
   tepinfo(xtep,true,int1,int2,bol1,bol2);
   dy:=(xlineheight-int2) div 2;
   ldis2(ci,xcapright,ci.top+dy,xfont,low__aorb(clnone,xback,xcolorise),xtep,false,not xenabled,xround);
   inc(xcapright,int1+(4*xzoom));
   end;
//.caption
z:=caption;
if (z<>'') then
   begin
   ldt(ci,xcapright,ci.top,xfont,z,low__aorb(fn,fb,oboldhead),xfeather,xround);//12mar2022
   inc(xcapright,low__fonttextwidth2(low__aorb(fn,fb,oboldhead),z)+2);
   end;
//links
dx:=ci.left+hsp;
dy:=ci.bottom-(xlinecount*xlineheight)+vsp-1;
dcount:=1;
for p:=0 to high(icaps) do
begin
if (icaps[p]<>'') then
   begin
   irecs[p]:=xlink(p,true);
   //was: irecs[p].top:=0;
   inc(dx,xsetwidth+hsp);
   inc(dcount);
   if (dcount>xcount) then
      begin
      dcount:=1;
      dx:=ci.left+hsp;
      inc(dy,xlineheight);
      end;
   end
else irecs[p]:=nilrect;
end;//p

//frame
if (xbordersize>=1) then ldf(cs,xborder,low__dc(xback,-20),xbordersize,nil,xround);
xparentcorners;
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxx//lllllllllllllllllll
//## _onnotify ##
function tbasicsel._onnotify(sender:tobject):boolean;
var
   p:longint;
   //## xfinditem ##
   function xfinditem(s:tpoint;var xindex:longint):boolean;
   var
      p:longint;
   begin
   result:=false;
   xindex:=-1;
   for p:=0 to high(icaps) do if (icaps[p]<>'') and low__withinrect2(s,irecs[p]) then
      begin
      xindex:=p;
      result:=true;
      break;
      end;
   end;
begin
try
//defaults
result:=false;

//wheel
if (gui.wheel<>0) then
   begin
   if enabled then
      begin
      val:=val-gui.wheel;
      result:=true;//own the wheel!
      end;
   end;

//key
if (gui.key<>aknone) then
   begin
   case gui.key of
   akhome:begin
      if enabled then val:=0;
      result:=true;
      end;
   akend:begin
      if enabled then val:=imax;
      result:=true;
      end;
   akleft,akup:begin
      if enabled then val:=val-1;
      result:=true;
      end;
   akright,akdown:begin
      if enabled then val:=val+1;
      result:=true;
      end;
   akprev:begin
      if enabled then val:=val+1;
      result:=true;
      end;
   aknext:begin
      if enabled then val:=val+1;
      result:=true;
      end;
   end;//case
   end;

//mouse down
if gui.mousedownstroke then
   begin
   xfinditem(mousedownxy,idownindex);
   paintnow;
   end;

//mouse move
if gui.mousemoved and (not gui.mousedown) then
   begin
   if xfinditem(mousexy,p) then help2:=ihlps[p] else help2:='';
   end;

//mouse up
if gui.mouseupstroke then
   begin
   if (idownindex>=0) and (idownindex<=high(icaps)) then
      begin
      iwasselected:=(val=idownindex);
      val:=idownindex;
      end
   else iwasselected:=true;//use with "fonclick" to know if current item was previously selected or not - 26mar2022
   //reset
   if (idownindex>=0) then
      begin
      idownindex:=-1;
      paintnow;
      if ovalueclick then xonvalue;//29aug2021
      if assigned(fonclick) then fonclick(self);//07mar2022
      end;
   end;

//external event override - 01mar2021
if assigned(fonnotify) then fonnotify(sender);
except;end;
end;

//## tbasictea #################################################################
//xxxxxxxxxxxxxxxxxxxxxxxxxxxx//aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
//## create ##
constructor tbasictea.create(xparent:tobject);
begin
create2(xparent,true);
end;
//## create2 ##
constructor tbasictea.create2(xparent:tobject;xstart:boolean);
begin
//self
inherited create2(xparent,false);
//vars
odefault:=true;
odefaultmsg:='';
osyscolors:=false;
imanage_toolbar1:=nil;
imanage_toolbar2:=nil;
itimer500:=ms64;
ipadv1:=3;//space between top title and content
ipadh1:=20;
imaxw:=20;
imaxh:=20;
iminw:=64;//viewing purposes only
iminh:=64;
idata:=bnew;
iversion:=1;
iwidth:=0;
iheight:=0;
ibytes:=0;
itransparent:=false;
isyscolors:=false;
imustpaint:=false;
//.showmenu
showmenuFillINT:=xshowmenuFill;
showmenuClickINT:=xshowmenuClick;
ocanshowmenu:=true;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasictea.destroy;
begin
try
//unmanage
unmanage;
//vars
bfree(idata);
//self
inherited destroy;
except;end;
end;
//## manage ##
procedure tbasictea.manage(xtoolbar1,xtoolbar2:tbasictoolbar);
begin
try
imanage_toolbar1:=xtoolbar1;
imanage_toolbar2:=xtoolbar2;
except;end;
end;
//## unmanage ##
procedure tbasictea.unmanage;
begin
try;manage(nil,nil);except;end;
end;
//## xshowmenuFill ##
procedure tbasictea.xshowmenuFill(sender:tobject;xstyle:string;xmenudata:tstr8;var ximagealign:longint;var xmenuname:string);
var
   aw,ah,aSOD,aversion,aval1,aval2:longint;
   xcancopy,xcanpaste,atransparent,asyscolors:boolean;
begin
try
//check
if zznil(xmenudata,2354) then exit;
xmenuname:='tea.1';
low__teainfo2(idata,false,aw,ah,aSOD,aversion,aval1,aval2,atransparent,asyscolors);

//init
xcancopy:=(aw>=1) and (ah>=1);
xcanpaste:=low__canpasteimg;
//get
low__menutitle(xmenudata,tepnone,'Edit Options','Edit options');
low__menuitem2(xmenudata,tepCopy20,'Copy','Copy image to clipboard','tea.copy',100,aknone,xcancopy);
low__menuitem2(xmenudata,tepPaste20,'Paste','Paste image from clipboard with transparency','tea.pastebasic',100,aknone,xcanpaste);
low__menuitem2(xmenudata,tepPaste20,'Paste Solid','Paste image from clipboard without transparency','tea.pastesolid',100,aknone,xcanpaste);
if odefault then low__menuitem2(xmenudata,tepRefresh20,'Default Image...','Restore default image','tea.default',100,aknone,xcancopy);
low__menusep(xmenudata);
low__menuitem2(xmenudata,tep__yes(atransparent),'Transparent','Ticked: Draw image with transparent pixels - top-left pixel color used as transparent color | Not Ticked: Draw image without transparent pixels','tea.toggletrans',100,aknone,xcancopy);
if osyscolors then low__menuitem2(xmenudata,tep__yes(asyscolors),'System Colors','Ticked: Draw black image pixels (0,0,0) as current font color | Not Ticked: Draw image pixels normally','tea.togglesyscolors',100,aknone,xcancopy);
low__menutitle(xmenudata,tepnone,'File Options','File options');
low__menuitem2(xmenudata,tepOpen20,'Open','Open image from file','tea.open',100,aknone,true);
low__menuitem2(xmenudata,tepSave20,'Save As','Save image to file','tea.save',100,aknone,xcancopy);
except;end;
end;
//## xshowmenuClick ##
function tbasictea.xshowmenuClick(sender:tbasiccontrol;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean;
begin
try;result:=xcmd(self,xstyle,xcode,xcode2,clnone);except;end;
end;
//## xcmd ##
function tbasictea.xcmd(sender:tbasiccontrol;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean;
label
   skipend;
var
   e:string;
   a:tbasicimage;
   b:tstr8;
   aw,ah,aSOD,aversion,aval1,aval2:longint;
   atransparent,asyscolors:boolean;
   //## ainfo ##
   procedure ainfo;
   begin
   low__teainfo2(idata,false,aw,ah,aSOD,aversion,aval1,aval2,atransparent,asyscolors);
   end;
begin
try
//defaults
result:=true;//handled
a:=nil;
b:=nil;
e:=gecTaskfailed;
//get
if (xcode2='tea.menu') then showmenu
else if (xcode2='tea.default') then
   begin
   if (idata.len>=1) and gui.popquery('Restore default image?') then setdata(nil);
   end
else if (xcode2='tea.open') then
   begin
   if (sysfile_teaimg='') then sysfile_teaimg:=low__platimages+'Untitled';
   if gui.popopenimg(sysfile_teaimg,sysfile_teaimg_openfilter,'') then
      begin
      b:=bnew;
      if not low__fromfile(sysfile_teaimg,b,e) then goto skipend;
      a:=misimg32(1,1);
      if not misfromdata(a,b,e) then goto skipend;
      misonecell(a);//03may2022
      setimg(a,a.ai.transparent,a.ai.syscolors);//13apr2021
      end;
   end
else if (xcode2='tea.save') then
   begin
   if (sysfile_teaimg='') then sysfile_teaimg:=low__platimages+'Untitled';
   if gui.popsaveimg(sysfile_teaimg,'') then
      begin
      a:=misimg32(1,1);
      if not getimg(a) then goto skipend;
      b:=bnew;
      if not mistodata(a,b,sysfile_teaimg,e) then goto skipend;
      if not low__tofile(sysfile_teaimg,b,e) then goto skipend;
      end;
   end
else if (xcode2='tea.copy') then
   begin
   a:=misimg32(1,1);
   if not getimg(a) then goto skipend;
   if not low__copyimg(a,0) then goto skipend;
   end
else if (xcode2='tea.paste') then
   begin
   a:=misimg32(1,1);
   if not low__pasteimg(a) then goto skipend;
   if not setimg(a,a.ai.transparent,a.ai.syscolors) then goto skipend;
   end
else if (xcode2='tea.pastebasic') then
   begin
   a:=misimg32(1,1);
   if not low__pasteimg(a) then goto skipend;
   if not setimg(a,true,false) then goto skipend;
   end
else if (xcode2='tea.pastesolid') then
   begin
   a:=misimg32(1,1);
   if not low__pasteimg(a) then goto skipend;
   if not setimg(a,false,false) then goto skipend;
   end
else if (xcode2='tea.makesolid') or (xcode2='tea.maketrans') then
   begin
   ainfo;
   a:=misimg32(1,1);
   if not getimg(a) then goto skipend;
   if not setimg(a,(xcode2='tea.maketrans'),asyscolors) then goto skipend;
   end
else if (xcode2='tea.toggletrans') then
   begin
   ainfo;
   a:=misimg32(1,1);
   if not getimg(a) then goto skipend;
   if not setimg(a,not atransparent,asyscolors) then goto skipend;
   end
else if (xcode2='tea.togglesyscolors') then
   begin
   ainfo;
   a:=misimg32(1,1);
   if not getimg(a) then goto skipend;
   if not setimg(a,atransparent,not asyscolors) then goto skipend;
   end
else
   begin
   result:=false;
   end;
//successful
e:='';
skipend:
except;end;
try
freeobj(@a);
bfree(b);
if (e<>'') then gui.poperror(ntranslate(e));
except;end;
end;
//## settep ##
function tbasictea.settep(xindex:longint):boolean;
var
   a:tlistptr;
   b:tstr8;
   p:longint;
begin
try
//defaults
result:=false;
b:=nil;
//get
if tepfind(xindex,a) and (a.count>=1) and (a.bytes<>nil) then
   begin
   b:=bnew;
   for p:=0 to (a.count-1) do b.addbyt1(a.bytes[p]);
   result:=setdata(b);
   end;
except;end;
try;bfree(b);except;end;
end;
//## setdata ##
function tbasictea.setdata(xdata:tstr8):boolean;//13apr2021
label
   skipdone,skipend;
var
   a,d:tbasicimage;
   b:tstr8;
   aw,ah,aSOD,aversion,aval1,aval2:longint;
   atransparent,asyscolors:boolean;
   e:string;
   //## xsysblacks ##
   procedure xsysblacks;
   label
      skipend;
   var
      s:tbasicimage;
      sw,sh,sSOD,sversion,sval1,sval2:longint;
      stransparent,ssyscolors:boolean;
   begin
   try
   //defaults
   s:=nil;
   //check
   if (idata.len<=1) then exit;
   //init
   if (not low__teainfo2(idata,false,sw,sh,sSOD,sversion,sval1,sval2,stransparent,ssyscolors)) or (sw<1) or (sh<1) then goto skipend;
   //.check -> set to correct value so nothing to do -> skip it - 13apr2021
   if not osyscolors then ssyscolors:=false;
   if (ssyscolors=osyscolors) then goto skipend;
   //get
   s:=misimg32(1,1);
   if not low__teatoimg(idata.maplist,s,sw,sh) then goto skipend;//data -> s
   idata.clear;
   if not low__teamake2(s,true,stransparent,ssyscolors,sval1,sval2,idata,e) then goto skipend;//s -> data
   //update system info
   low__teainfo2(idata,false,aw,ah,aSOD,aversion,aval1,aval2,atransparent,asyscolors);
   skipend:
   except;end;
   try;freeobj(@s);except;end;
   end;
begin
try
//defaults
result:=false;
a:=nil;
d:=nil;
b:=nil;
aw:=0;
ah:=0;
atransparent:=true;
asyscolors:=true;
aversion:=1;
//restore default image
if zznil(xdata,2355) then
   begin
   idata.clear;
   goto skipdone;
   end;
//lock
if not block(xdata) then goto skipend;
//check
if (not low__teainfo2(xdata,false,aw,ah,aSOD,aversion,aval1,aval2,atransparent,asyscolors)) or (aw<1) or (ah<1) then goto skipend;
//get
//.within maxW and maxH dimensions
if (aw<=imaxW) and (ah<=imaxH) then
   begin
   idata.clear;
   idata.add(xdata);
   xsysblacks;
   result:=true;
   end;
//.scale to fit maxW and maxH
if not result then
   begin
   a:=misimg32(1,1);
   d:=misimg32(1,1);
   if not low__teatoimg(xdata.maplist,a,aw,ah) then goto skipend;//xdata -> a
   if not low__pasteimg3(d,a,true,imaxw,imaxh) then goto skipend;//a -> d (scaled to fit maxW and maxH)
   b:=bnew;
   if not low__teamake2(d,true,atransparent,asyscolors,aval1,aval2,b,e) then goto skipend;//d -> tea.data
   if (not low__teainfo2(b,false,aw,ah,aSOD,aversion,aval1,aval2,atransparent,asyscolors)) or (aw<1) or (ah<1) then goto skipend;//check tea.data
   //.within maxW and maxH dimensions
   if (aw<=imaxW) and (ah<=imaxH) then//set using tea.data
      begin
      idata.clear;
      idata.add(b);
      xsysblacks;
      result:=true;
      end;
   end;
//info
skipdone:
iwidth:=aw;
iheight:=ah;
ibytes:=idata.len;
iversion:=aversion;
itransparent:=atransparent;
isyscolors:=asyscolors;
skipend:
except;end;
try
bunlockautofree(xdata);
freeobj(@a);
freeobj(@d);
bfree(b);
//mustpaint
if result then imustpaint:=true;
except;end;
end;
//## getdata ##
function tbasictea.getdata(xdata:tstr8):boolean;
begin
try
//defaults
result:=false;
if block(xdata) then
   begin
   xdata.clear;
   xdata.add(idata);
   result:=true;
   end;
except;end;
try;bunlockautofree(xdata);except;end;
end;
//## setimg ##
function tbasictea.setimg(ximg:tobject;xtransparent,xsyscolors:boolean):boolean;
var
   a:tstr8;
   e:string;
begin
try
result:=false;
a:=bnew;
if not osyscolors then xsyscolors:=false;
result:=low__teamake2(ximg,true,xtransparent,xsyscolors,0,0,a,e) and setdata(a);
except;end;
try;bfree(a);except;end;
end;
//## getimg ##
function tbasictea.getimg(ximg:tobject):boolean;
var
   xw,xh:longint;
begin
try;result:=zzok(ximg,7313) and (ximg is tbasicimage) and low__teatoimg(idata.maplist,ximg as tbasicimage,xw,xh);except;end;
end;
//## gettext ##
function tbasictea.gettext:string;
begin
try;result:=idata.text;except;end;
end;
//## settext ##
procedure tbasictea.settext(x:string);
var
   a:tstr8;
begin
try
a:=nil;
a:=bnew;
a.text:=x;
setdata(a);
except;end;
try;bfree(a);except;end;
end;
//## setparams ##
procedure tbasictea.setparams(xmaxW,xmaxH:longint);
begin
try
//range
xmaxW:=frcrange(xmaxW,1,maxint);
xmaxH:=frcrange(xmaxH,1,maxint);
//get
if (imaxw<>xmaxw) or (imaxh<>xmaxh) then
   begin
   imaxw:=xmaxw;
   imaxh:=xmaxh;
   imustpaint:=true;
   end;
except;end;
end;
//## _ontimer ##
procedure tbasictea._ontimer(sender:tobject);
var
   xmustpaint:boolean;
begin
try
xmustpaint:=false;

//imustpaint
if imustpaint then
   begin
   xmustpaint:=true;
   imustpaint:=false;
   end;

//itimer500
if (ms64>=itimer500) then
   begin
   xsync;
   //reset
   itimer500:=ms64+500;
   end;

//xmustpaint
if xmustpaint then paintnow;
except;end;
end;
//## xsync ##
procedure tbasictea.xsync;
var
   xcancopy,xcanpaste:boolean;
begin
try
//manage - 13apr2021
if zzok(imanage_toolbar1,7314) or zzok(imanage_toolbar2,7315) then
   begin
   //init
   xcancopy:=(idata.len>=1);
   xcanpaste:=low__canpasteimg;
   //default
   if (imanage_toolbar1<>nil) then imanage_toolbar1.benabled2['tea.default']:=xcancopy;
   if (imanage_toolbar2<>nil) then imanage_toolbar2.benabled2['tea.default']:=xcancopy;
   //copy
   if (imanage_toolbar1<>nil) then imanage_toolbar1.benabled2['tea.copy']:=xcancopy;
   if (imanage_toolbar2<>nil) then imanage_toolbar2.benabled2['tea.copy']:=xcancopy;
   //paste
   if (imanage_toolbar1<>nil) then imanage_toolbar1.benabled2['tea.paste']:=xcanpaste;
   if (imanage_toolbar2<>nil) then imanage_toolbar2.benabled2['tea.paste']:=xcanpaste;
   //pastebasic
   if (imanage_toolbar1<>nil) then imanage_toolbar1.benabled2['tea.pastebasic']:=xcanpaste;
   if (imanage_toolbar2<>nil) then imanage_toolbar2.benabled2['tea.pastebasic']:=xcanpaste;
   //save
   if (imanage_toolbar1<>nil) then imanage_toolbar1.benabled2['tea.save']:=xcancopy;
   if (imanage_toolbar2<>nil) then imanage_toolbar2.benabled2['tea.save']:=xcancopy;
   end;
except;end;
end;
//## xtitleborder ##
function tbasictea.xtitleborder:longint;
begin
try;result:=0;except;end;
end;
//## xtitleheight ##
function tbasictea.xtitleheight:longint;
begin
try;result:=vititleheight;except;end;
end;
//## xtitleheight2 ##
function tbasictea.xtitleheight2:longint;
begin
try
result:=largest(20,xtitleheight);
if vitouch then result:=frcmin(result,low__touchsmall);
inc(result,2*xtitleborder);
except;end;
end;
//## getalignheight ##
function tbasictea.getalignheight(xclientwidth:longint):longint;
var
   xzoom,h1,h2:longint;
begin
try
//defaults
result:=0;
//get
xzoom:=vizoom;
h1:=xtitleheight2+(ipadv1*xzoom)+(vifontheight*5)+(2*xzoom);
h2:=vifontheight+(ipadv1*xzoom)+largest(xzoom*imaxH,xzoom*iminH)+(3*xzoom);
result:=largest(h1,h2)+(2*frcmin(findbordersize,1));
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxx//aaaaaaaaaaaaaaaaaaaaa
//## _onpaint ##
procedure tbasictea._onpaint(sender:tobject);
var//Supports enhanced shading
   //infovars
   a:pvirtualinfo;
   cs,ci:trect;
   fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xfont2,xback,xback2,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xenabled,xround,xnormal:boolean;
   //other
   int1,ftborder,ftback,ftbordersize,ftH2,ftH,ft,ftcolor,yoff,tmaxw,p,x1,x2,xpadv1,xpadh1,dx,dy,xzoom,xmaxw,xmaxh,aw,ah,aversion:longint;
   da:trect;
   z,zval:string;
   atransparent,asyscolors,xenhanced:boolean;
   //## xinfo ##
   function xinfo(x:longint;xval:boolean):string;
   begin
   result:='';
   case x of
   0:begin
      if xval then
         begin
         if (aw<=0) and (ah<=0) then result:=low__udv(odefaultmsg,'( Not in use )') else result:=low__64(aw)+'w x '+low__64(ah)+'h';
         end
      else result:='Dimensions';
      end;
   1:if xval then result:=low__aorbstr('No','Yes',atransparent) else result:='Transparent';
   2:if xval then result:=low__aorbstr('No','Yes',asyscolors) else result:='System Colors';
   3:if xval then result:=low__b(idata.len,true) else result:='Size';
   4:if xval then result:=low__64(aversion) else result:='Type';
   end;//case
   end;
begin
try
//init
xenhanced:=vienhanced;
xzoom:=vizoom;
xpadv1:=xzoom*ipadv1;
xpadh1:=xzoom*ipadh1;
xmaxH:=largest(iminh,imaxh);
xmaxW:=largest(iminw,imaxw);
aw:=iwidth;
ah:=iheight;
aversion:=iversion;
atransparent:=itransparent;
asyscolors:=isyscolors;
infovars2(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xfont2,xback,xback2,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);
//.title font
ftborder:=vititle.border;
ftback:=vititle.background;
ftbordersize:=xtitleborder;
ftH2:=xtitleheight2;//overal height
ftH:=xtitleheight;//font height
ft:=low__font1(vititle.fontname,-ftH,true);
ftcolor:=vititle.font;
yoff:=(ftH2-ftH) div 2;

//cls
//lds(cs,xback,false);
lds2(cs,xback2,xback,clnone,0,'g50',false);

//.title background and border
da:=rect(ci.left,ci.top,ci.right,ci.top+ftH2);
ldso3(true,da,ftborder,ftborder,ftback,ftback,clnone,0,'',xround,true);

//image
z:=low__udv(caption,'Image');
dx:=(xzoom*5);
x1:=dx+low__fonttextwidth2(fn,z)+xpadh1;
dy:=ci.top;
ldt(ci,dx+(1*xzoom),dy+yoff,ftcolor,z,ft,xfeather,xround);
da.left:=dx+xzoom;
da.top:=dy+ftH2+xpadv1;
da.bottom:=da.top+(xzoom*xmaxH)-1;
//.vericaly center smaller image view - 13apr2021
if ((da.bottom+2)<ci.bottom) then
   begin
   int1:=(ci.bottom-da.bottom) div 2;
   inc(da.top,int1);
   inc(da.bottom,int1);
   end;
da.right:=da.left+(xzoom*xmaxW)-1;
//.image frame
ldo(low__rectgrow(da,1),xborder,false);
x2:=da.right+xpadh1;
//.tea
ltea(false,false,true,da,da.left+(((xmaxW-aw) div 2)*xzoom),da.top+(((xmaxH-ah) div 2)*xzoom),low__aorb(clnone,xfont,asyscolors),idata,false,false,false);

//information
dy:=ci.top;
dx:=largest(x1,x2);
ldt(ci,dx+(1*xzoom),dy+yoff,ftcolor,'Information',ft,xfeather,xround);
inc(dy,ftH2+xpadv1);
//.tmaxw
tmaxw:=0;
for p:=0 to maxint do
begin
z:=xinfo(p,false);
if (z<>'') then tmaxw:=largest(tmaxw,low__fonttextwidth2(fn,z)) else break;
end;//p
inc(tmaxw,low__fontavew(fn)*5);

for p:=0 to maxint do
begin
z:=xinfo(p,false);
zval:=xinfo(p,true);
if (z='') then break;
//.z
ldt(ci,dx,dy,xfont,z,fn,xfeather,xround);
//.zval
ldt(ci,dx+tmaxw,dy,xfont,zval,fn,xfeather,xround);
//.inc-
inc(dy,fnH);
end;//p

//frame
if (xbordersize>=1) then ldf(cs,xborder,low__dc(xback,-20),xbordersize,nil,xround);
xparentcorners;
except;end;
end;
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxx//iiiiiiiiiiiiiiiiiiii
//## _onnotify ##
function tbasictea._onnotify(sender:tobject):boolean;
var
   dp:tpoint;
   int1,int2,dx,dy:longint;
begin
try
//defaults
result:=false;

//wheel
if (gui.wheel<>0) then
   begin
   if enabled then
      begin
//xxxxxxxx      val:=val-gui.wheel;
      result:=true;//own the wheel
      end;
   end;

//key
if (gui.key<>aknone) then
   begin
 {
   case gui.key of
   akhome:begin
      if enabled then val:=imin;
      result:=true;
      end;
   akend:begin
      if enabled then val:=imax;
      result:=true;
      end;
   akleft,akup:begin
      if enabled then val:=val-1;
      result:=true;
      end;
   akright,akdown:begin
      if enabled then val:=val+1;
      result:=true;
      end;
   akprev:begin
      if enabled then val:=val+oless2;
      result:=true;
      end;
   aknext:begin
      if enabled then val:=val+omore2;
      result:=true;
      end;
   end;//case
{}
   end;

//mouse down
{
if gui.mousedownstroke then
   begin
   dp:=mousedownxy;
   idownval:=val;
   if low__withinrect2(dp,iadef) then idownstyle:='def'
   else if low__withinrect2(dp,iamore) then idownstyle:='more'
   else if low__withinrect2(dp,iamore2) then idownstyle:='more2'
   else if low__withinrect2(dp,ialess) then idownstyle:='less'
   else if low__withinrect2(dp,ialess2) then idownstyle:='less2'
   else idownstyle:='bar';
   //paint
   paintnow;
   end;

//mouse move
if gui.mousedown and gui.mousemoved and (not gui.mousedownstroke) then
   begin
   if (idownstyle='bar') then
      begin
      int1:=mousexy.x-mousedownxy.x;
      int2:=round((int1/frcmin(clientwidth,1))*(imax-imin+1));
      val:=idownval+int2;
      end;
   end;

//mouse up
if gui.mouseupstroke then
   begin
   if (idownstyle='def') then val:=idef
   else if (idownstyle='more') then val:=val+omore
   else if (idownstyle='more2') then val:=val+omore2
   else if (idownstyle='less') then val:=val+oless
   else if (idownstyle='less2') then val:=val+oless2;
   //reset
   if (idownstyle<>'') then
      begin
      idownstyle:='';
      paintnow;
      end;
   end;
{}

if gui.mouseupstroke then
   begin
   autoshowmenu;
   end;

//external event override - 01mar2021
if assigned(fonnotify) then fonnotify(sender);
except;end;
end;

//## tbasiccolors ##############################################################
//## create ##
constructor tbasiccolors.create(xparent:tobject);
begin
create2(xparent,true);
end;
//## create2 ##
constructor tbasiccolors.create2(xparent:tobject;xstart:boolean);
var
   p:longint;
begin
//self
inherited create2(xparent,false);
//vars
foncolor:=nil;
foncolorchanged:=nil;
osyscolor:=false;
opopcolor:=true;//28feb2021
oshowcaps:=true;
otightblocks:=false;
oclicktouse:=false;
ilastsysname:='';
caption:='';
iitemsperline:=4;
idownindex:=-1;
ibordersize:=0;
inormal:=true;
ilastalignid:=-1;
ialignid:=0;
ilastpaintid:=-1;
ipaintid:=0;
imustwrite:=false;
clear;
//start
if xstart then start;
end;
//## destroy ##
destructor tbasiccolors.destroy;
begin
try
inherited destroy;
except;end;
end;
//## xreadfrom ##
procedure tbasiccolors.xreadfrom(xnormal,xtitle:pvirtualinfo;xmorecolors:pvirtualmorecolors);
begin
try
//normal
if (xnormal<>nil) then
   begin
   //.frame
   col1[cnframe]       :=xnormal.frame;
   col1[cnframe2]      :=xnormal.frame2;
   //.normal
   col1[cnback1]       :=xnormal.background;
   col1[cnborder1]     :=xnormal.border;
   col1[cnhigh1]       :=xnormal.highlight;
   col1[cnhover1]      :=xnormal.hover;
   col1[cntext1]       :=xnormal.font;
   col1[cntexthigh1]   :=xnormal.fonthighlight;
   col1[cntextdis1]    :=xnormal.disablefont;
   col1[cndis1]        :=xnormal.disable;
   col1[cndisbr1]      :=xnormal.disableborder;
   end;
//title
if (xtitle<>nil) then
   begin
   //.frame
   col1[cnframe]       :=xtitle.frame;
   col1[cnframe2]      :=xtitle.frame2;
   //.title
   col1[cnback2]       :=xtitle.background;
   col1[cnborder2]     :=xtitle.border;
   col1[cnhigh2]       :=xtitle.highlight;
   col1[cnhover2]      :=xtitle.hover;
   col1[cntext2]       :=xtitle.font;
   col1[cntexthigh2]   :=xtitle.fonthighlight;
   col1[cntextdis2]    :=xtitle.disablefont;
   col1[cndis2]        :=xtitle.disable;
   col1[cndisbr2]      :=xtitle.disableborder;
   end;
//xmorecolors
if (xmorecolors<>nil) then
   begin
   col1[cnsframe]      :=xmorecolors.frame;
   col1[cnstitle]      :=xmorecolors.title;
   col1[cnsstandard]   :=xmorecolors.standard;
   col1[cnsallinone]   :=xmorecolors.allinone;
   col1[cnsdark_light] :=xmorecolors.dark_light;
   col1[cnslight_dark] :=xmorecolors.light_dark;
   end;
except;end;
end;
//## xwriteto ##
procedure tbasiccolors.xwriteto(xnormal,xtitle:pvirtualinfo;xmorecolors:pvirtualmorecolors);
begin
try
//normal
if (xnormal<>nil) then
   begin
   //.frame
   xnormal.frame        :=col1[cnframe];
   xnormal.frame2       :=col1[cnframe2];
   //.normal
   xnormal.background   :=col1[cnback1];
   xnormal.border       :=col1[cnborder1];
   xnormal.highlight    :=col1[cnhigh1];
   xnormal.hover        :=col1[cnhover1];
   xnormal.font         :=col1[cntext1];
   xnormal.fonthighlight:=col1[cntexthigh1];
   xnormal.disablefont  :=col1[cntextdis1];
   xnormal.disable      :=col1[cndis1];
   xnormal.disableborder:=col1[cndisbr1];
   end;
//title
if (xtitle<>nil) then
   begin
   //.frame
   xtitle.frame         :=col1[cnframe];
   xtitle.frame2        :=col1[cnframe2];
   //.title
   xtitle.background    :=col1[cnback2];
   xtitle.border        :=col1[cnborder2];
   xtitle.highlight     :=col1[cnhigh2];
   xtitle.hover         :=col1[cnhover2];
   xtitle.font          :=col1[cntext2];
   xtitle.fonthighlight :=col1[cntexthigh2];
   xtitle.disablefont   :=col1[cntextdis2];
   xtitle.disable       :=col1[cndis2];
   xtitle.disableborder :=col1[cndisbr2];
   end;
//xmorecolors
if (xmorecolors<>nil) then
   begin
   xmorecolors.frame    :=col1[cnsframe];
   xmorecolors.title    :=col1[cnstitle];
   xmorecolors.standard :=col1[cnsstandard];
   xmorecolors.allinone :=col1[cnsallinone];
   xmorecolors.dark_light:=col1[cnsdark_light];
   xmorecolors.light_dark:=col1[cnslight_dark];
   end;
except;end;
end;
//## fromsys ##
procedure tbasiccolors.fromsys(xname:string);
var
   n:string;
   xnormal,xtitle:tvirtualinfo;
begin
try
low__setcolorsbyname(xname,@xnormal,@xtitle,@vimorecolors);
xreadfrom(@xnormal,@xtitle,@vimorecolors);
except;end;
end;
//## tosys ##
procedure tbasiccolors.tosys(xname:string;xautosync:boolean);
label
   skipend;
var
   c,b:tstr8;
   xdata,str1,f,n,e:string;
   int1,p:longint;
   bol1:boolean;
begin
try
//defaults
b:=nil;
c:=nil;
bol1:=false;

//check
n:=low__lowercase(xname);
if (n='') then exit;

//get
xdata:='';
for p:=0 to high(icaps) do if (icaps[p]<>'') and (istys[p]=0) then xdata:=low__setcolor2(xdata,iidxs[p],icols[p]);//istys=0=color, 1=title

//set
//.internal
if low__comparetext(strcopy1(n,1,7),'?custom') then
   begin
   int1:=frcrange(strint(strcopy1(n,8,length(n))),0,cnCustomLimit-1);
   str1:=syssettings.s['?custom'+inttostr(int1)];
   bol1:=low__setstr(str1,xdata);
   if bol1 then syssettings.s['?custom'+inttostr(int1)]:=str1;//store
   end
//.paste_and_use
else if low__comparetext(n,'?paste_and_use') then
   begin
   str1:=syssettings.s[n];
   bol1:=low__setstr(str1,xdata);
   if bol1 then syssettings.s[n]:=str1;//store
   end
//.file
else if (strcopy1(n,1,1)<>'?') then
   begin
   //init
   f:=low__platfolder('schemes')+xname+'.'+cnFileEXT;//no forced lowercase or uppercase on xname
   b:=bnew;
   c:=bnew;
   //get
   b.text:=xdata;
   if low__fromfile(f,c,e) then
      begin
      if not c.same(b) then bol1:=low__tofile(f,b,e);
      end;
   end
//.copy
else if (n='?copy') then
   begin
   low__copytxt2b(xdata);
   end
//.copy.hex
else if (n='?copy.hex') then//22jul2021
   begin
   low__copytxt2b(low__tocompactcolors(xdata));
   end
//.paste
else if (n='?paste') or (n='?paste.hex') then
   begin
   if  gui.popquery2('Replace current color scheme with clipboard color scheme?','','Replace',false) then data:=low__pastetxt2b;
   end
//.paste new
else if (n='?pastenew') or (n='?pastenew.hex') then
   begin
   if (sysfile_colorscheme='') then sysfile_colorscheme:=low__platfolder('schemes')+'Untitled.'+cnFileEXT;
   if gui.popsave(sysfile_colorscheme,pebcs,low__platfolder('schemes')) then
      begin
      b:=bnew;
      str1:=low__pastetxt2b;
      if not low__fromcompactcolors(str1,str1) then
         begin
         gui.poperror(gecUnknownformat);
         goto skipend;
         end;
      b.text:=str1;
      case low__tofile(sysfile_colorscheme,b,e) of
      false:gui.poperror(e);
      true:begin
         syssettings.value['colorname']:=remlastext(low__extractfilename(sysfile_colorscheme));//24jul2021
         visync;
         gui.xshowoptions_reload;
         end;
      end;//case
      end;
   end
//.paste use
else if (n='?pasteuse') or (n='?pasteuse.hex') or (n='?pasteuse2') or (n='?pasteuse2.hex') then
   begin
   str1:=low__pastetxt2b;
   int1:=0;
   if (n='?pasteuse2') or (n='?pasteuse2.hex') then int1:=10;//+10% brighter
   if not low__fromcompactcolors2(str1,int1,str1) then
      begin
      gui.poperror(gecUnknownformat);
      goto skipend;
      end;
   syssettings.value['colorname']:='?paste_and_use';
   syssettings.value['?paste_and_use']:=str1;
   if low__comparetext(ilastsysname,'?paste_and_use') then fromsys(ilastsysname);
   visync;
   gui.xshowoptions_reload;
   end
//.brighten / darken -> currently ONLY works with colorname="?paste_and_use" - 18sep2022
else if (n='?brighten') or (n='?brighten.hex') or (n='?darken') or (n='?darken.hex') then
   begin
   str1:=syssettings.value['?paste_and_use'];
   if low__fromcompactcolors2(str1,low__aorb(-10,10,(n='?brighten') or (n='?brighten.hex')),str1) then
      begin
      syssettings.value['?paste_and_use']:=str1;
      if low__comparetext(ilastsysname,'?paste_and_use') then fromsys(ilastsysname);
      visync;
      gui.xshowoptions_reload;
      end;
   end;

//sync
if xautosync and bol1 then visync;
skipend:
except;end;
try
freeobj(@b);
freeobj(@c);
except;end;
end;
//## getdata ##
function tbasiccolors.getdata:string;
var
   p:longint;
begin
try
result:='';
for p:=0 to high(icaps) do if (icaps[p]<>'') and (istys[p]=0) then low__setcolor2(result,iidxs[p],icols[p]);
except;end;
end;
//## setdata ##
procedure tbasiccolors.setdata(x:string);
var
   int1,p:longint;
   bol1:boolean;
begin
try
bol1:=false;
//filter
low__fromcompactcolors(x,x);//accepts both "col2" and "col3" formats and converts them into "col2"
//get
for p:=0 to high(icaps) do if (icaps[p]<>'') and (istys[p]=0) then
   begin
   if low__getcolor2(x,iidxs[p],int1) and low__setint(icols[p],int1) then bol1:=true;
   end;
if bol1 then
   begin
   xnewid(false,true);
   imustwrite:=true;
   end;
except;end;
end;
//## setitemsperline ##
procedure tbasiccolors.setitemsperline(x:longint);
begin
try;if low__setint(iitemsperline,frcrange(x,0,500)) then xnewid(true,true);except;end;
end;
//## getcap ##
function tbasiccolors.getcap(x:longint):string;
begin
try;if (x>=0) and (x<=high(icaps)) then result:=icaps[x] else result:='';except;end;
end;
//## setcap ##
procedure tbasiccolors.setcap(x:longint;xval:string);
begin
try;if (x>=0) and (x<=high(icaps)) and low__setstr(icaps[x],xval) then xnewid(true,true);except;end;
end;
//## getnam ##
function tbasiccolors.getnam(x:longint):string;
begin
try;if (x>=0) and (x<=high(icaps)) then result:=inams[x] else result:='';except;end;
end;
//## getidx ##
function tbasiccolors.getidx(x:longint):longint;
begin
try;if (x>=0) and (x<=high(icaps)) then result:=iidxs[x] else result:=0;except;end;
end;
//## setnam ##
procedure tbasiccolors.setnam(x:longint;xval:string);
begin
try;if (x>=0) and (x<=high(icaps)) then low__setstr(inams[x],xval);except;end;
end;
//## getcol ##
function tbasiccolors.getcol(x:longint):longint;
begin
try;if (x>=0) and (x<=high(icaps)) then result:=icols[x] else result:=0;except;end;
end;
//## xset ##
procedure tbasiccolors.xset(xindex,xval:longint);
var
   int1:longint;
begin
try;if findidx(xindex,int1) then icols[int1]:=xval;except;end;
end;
//## xspecial ##
procedure tbasiccolors.xspecial(xname,xstyle:string;xval:longint);
var
   f1,f2,tc,bc:longint;
   xframe1,xframe2,xback,xborder,xhigh,xhover,xtext,xtexthigh,xtextdis,xdis,xdisborder:longint;
begin
try
//init
xname:=low__lowercase(xname);
xstyle:=low__lowercase(xstyle);

//style
if (xstyle='dark') then
   begin
   //init
   f1         :=low__dc(xval,-80);
   f2         :=low__dc(xval,20);
   if (low__greyscale4(f1)>low__greyscale4(f2)) then low__swapint(f1,f2);
   bc         :=low__dc(xval,-40);
   tc         :=low__dc(xval,-120);
   //get
   xframe1    :=f1;
   xframe2    :=f2;
   xback      :=bc;
   xborder    :=low__dc(bc,-30);
   xhigh      :=low__dc(tc,20);
   xhover     :=low__dc(tc,20);
   xtext      :=tc;
   xtexthigh  :=low__dc(bc,50);
   xtextdis   :=low__dc(bc,-80);
   xdis       :=low__dc(bc,-40);
   xdisborder :=low__dc(bc,-50);
   end
else if (xstyle='light') then
   begin
   //init
   f1         :=low__dc(xval,-80);
   f2         :=low__dc(xval,20);
   if (low__greyscale4(f1)>low__greyscale4(f2)) then low__swapint(f1,f2);
   bc         :=low__dc(xval,30);
   tc         :=low__dc(xval,-120);
   //get
   xframe1    :=f1;
   xframe2    :=f2;
   xback      :=bc;
   xborder    :=low__dc(bc,-30);
   xhigh      :=low__dc(tc,10);
   xhover     :=low__dc(tc,10);
   xtext      :=tc;
   xtexthigh  :=low__dc(bc,30);
   xtextdis   :=low__dc(bc,-80);
   xdis       :=low__dc(bc,-40);
   xdisborder :=low__dc(bc,-50);
   end
else//normal
   begin
   //init
   f1         :=low__dc(xval,-80);
   f2         :=low__dc(xval,20);
   if (low__greyscale4(f1)>low__greyscale4(f2)) then low__swapint(f1,f2);
   bc         :=low__dc(xval,0);
   tc         :=low__dc(xval,-120);
   //get
   xframe1    :=f1;
   xframe2    :=f2;
   xback      :=bc;
   xborder    :=low__dc(bc,-30);
   xhigh      :=low__dc(tc,10);
   xhover     :=low__dc(tc,10);
   xtext      :=tc;
   xtexthigh  :=low__dc(bc,30);
   xtextdis   :=low__dc(bc,-80);
   xdis       :=low__dc(bc,-40);
   xdisborder :=low__dc(bc,-50);
   end;

//name
if (xname='frame') then
   begin
   xset(cnframe,xframe1);
   xset(cnframe2,xframe2);
   end
else if (xname='title') then
   begin
   xset(cnback2,xback);
   xset(cnBorder2,xborder);
   xset(cnHigh2,xhigh);
   xset(cnHover2,xhover);
   xset(cnText2,xtext);
   xset(cnTexthigh2,xtexthigh);
   xset(cnTextdis2,xtextdis);
   xset(cnDis2,xdis);
   xset(cnDisbr2,xdisborder);
   end
else if (xname='standard') then
   begin
   xset(cnback1,xback);
   xset(cnBorder1,xborder);
   xset(cnHigh1,xhigh);
   xset(cnHover1,xhover);
   xset(cnText1,xtext);
   xset(cnTexthigh1,xtexthigh);
   xset(cnTextdis1,xtextdis);
   xset(cnDis1,xdis);
   xset(cnDisbr1,xdisborder);
   end;
except;end;
end;
//## setcol ##
procedure tbasiccolors.setcol(x:longint;xval:longint);
begin
try;xsetcol(x,xval,false);except;end;
end;
//## setcol3 ##
procedure tbasiccolors.setcol3(x:longint;xval:longint);
begin
try;xsetcol(x,xval,true);except;end;
end;
//## xsetcol ##
procedure tbasiccolors.xsetcol(x:longint;xval:longint;xspecialoverride:boolean);
var
   f1,f2,b1,t1,b2,t2:longint;
begin
try
if (x>=0) and (x<=high(icaps)) and (low__setint(icols[x],xval) or (xspecialoverride and (iidxs[x]>=cnsSpecialstart))) then
   begin
   //special color handlers -> takes special color and spreads it to the corresponding sub-colors
   case iidxs[x] of
   cnsFrame:xspecial('frame','',xval);
   cnsTitle:xspecial('title','',xval);
   cnsStandard:xspecial('standard','',xval);
   cnsAllinone:begin
      xspecial('frame','',xval);
      xspecial('title','',xval);
      xspecial('standard','',xval);
      end;
   cnsDark_light:begin
      xspecial('frame','',xval);
      xspecial('title','dark',xval);
      xspecial('standard','light',xval);
      end;
   cnsLight_dark:begin
      xspecial('frame','',xval);
      xspecial('title','light',xval);
      xspecial('standard','dark',xval);
      end;
   end;//case
   //set
   xnewid(false,true);
   imustwrite:=true;
   end;
except;end;
end;
//## getcol2 ##
function tbasiccolors.getcol2(xname:string):longint;
var
   int1:longint;
begin
try;if findname(xname,int1) then result:=icols[int1] else result:=0;except;end;
end;
//## setcol2 ##
procedure tbasiccolors.setcol2(xname:string;xval:longint);
var
   int1:longint;
begin
try
if findname(xname,int1) and low__setint(icols[int1],xval) then
   begin
   xnewid(false,true);
   imustwrite:=true;
   end;
except;end;
end;
//## getcol1 ##
function tbasiccolors.getcol1(xidx:longint):longint;
var
   int1:longint;
begin
try;if findidx(xidx,int1) then result:=icols[int1] else result:=0;except;end;
end;
//## setcol1 ##
procedure tbasiccolors.setcol1(xidx:longint;xval:longint);
var
   int1:longint;
begin
try
if findidx(xidx,int1) and low__setint(icols[int1],xval) then
   begin
   xnewid(false,true);
   imustwrite:=true;
   end;
except;end;
end;
//## findname ##
function tbasiccolors.findname(xname:string;var xindex:longint):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
xindex:=0;
//check
if (xname='') then exit;
//find
for p:=0 to high(icaps) do if (icaps[p]<>'') and low__comparetext(xname,inams[p]) then
   begin
   xindex:=p;
   result:=true;
   break;
   end;//p
except;end;
end;
//## findidx ##
function tbasiccolors.findidx(xidx:longint;var xindex:longint):boolean;
var
   p:longint;
begin
try
//defaults
result:=false;
xindex:=0;
//find
for p:=0 to high(icaps) do if (icaps[p]<>'') and (xidx=iidxs[p]) then
   begin
   xindex:=p;
   result:=true;
   break;
   end;//p
except;end;
end;
//## clear ##
procedure tbasiccolors.clear;
var
   p:longint;
begin
try
for p:=0 to high(icaps) do
begin
istys[p]:=0;//0=color, 1=title
icaps[p]:='';
inams[p]:='';
iidxs[p]:=0;
ihlps[p]:='';
icols[p]:=0;
idefcols[p]:=0;
irecs[p]:=nilrect;
end;//p
icount:=0;
imax:=0;
xnewid(true,true);
except;end;
end;
//## addtitle ##
procedure tbasiccolors.addtitle(xcap,xhlp:string);
begin
try;xadd(1,xcap,'',xhlp,0,0,0);except;end;
end;
//## addcol ##
procedure tbasiccolors.addcol(xcap,xnam,xhlp:string);
begin
try;xadd(0,xcap,xnam,xhlp,0,0,0);except;end;
end;
//## addcol1 ##
procedure tbasiccolors.addcol1(xcap:string;xidx:longint;xhlp:string);
begin
try;xadd(0,xcap,'',xhlp,xidx,0,0);except;end;
end;
//## addcol2 ##
procedure tbasiccolors.addcol2(xcap,xnam,xhlp:string;xidx,xcol,xdefcol:longint);
begin
try;xadd(0,xcap,xnam,xhlp,xidx,xcol,xdefcol);except;end;
end;
//## xadd ##
procedure tbasiccolors.xadd(xstyle:longint;xcap,xnam,xhlp:string;xidx,xcol,xdefcol:longint);
var
   p:longint;
begin
try
for p:=0 to high(icaps) do if (length(icaps[p])=0) then
   begin
   istys[p]:=xstyle;
   icaps[p]:=xcap;
   inams[p]:=xnam;
   iidxs[p]:=xidx;
   ihlps[p]:=xhlp;
   icols[p]:=xcol;
   idefcols[p]:=xdefcol;
   xsynccount;
   break;
   end;
except;end;
end;
//## xnewid ##
procedure tbasiccolors.xnewid(xalign,xpaint:boolean);
begin
try
if xalign then low__iroll(ialignid,1);
if xpaint then low__iroll(ipaintid,1);
except;end;
end;
//## _ontimer ##
procedure tbasiccolors._ontimer(sender:tobject);
var
   xmustalign,xmustpaint:boolean;
begin
try
//defaults
xmustalign:=false;
xmustpaint:=false;

//sysref
if osyscolor and (not low__comparetext(ilastsysname,vicolorname)) then
   begin
   tosys(ilastsysname,false);
   ilastsysname:=vicolorname;
   fromsys(ilastsysname);
   imustwrite:=false;
   end;
//mustwrite
if imustwrite then
   begin
   imustwrite:=false;
   if osyscolor then tosys(ilastsysname,true);
   if assigned(foncolorchanged) then foncolorchanged(self);//15mar2022
   end;
//alignid
if (ilastalignid<>ialignid) then
   begin
   ilastalignid:=ialignid;
   xmustalign:=true;
   end;
//paintid
if (ilastpaintid<>ipaintid) then
   begin
   ilastpaintid:=ipaintid;
   xmustpaint:=true;
   end;
//xmustpaint
if xmustalign then alignnow;
if xmustpaint then paintnow;
except;end;
end;
//## linecount ##
function tbasiccolors.linecount:longint;
begin
try
result:=1;
if (iitemsperline>=1) then
   begin
   result:=icount div iitemsperline;
   if ((result*iitemsperline)<>icount) then inc(result);
   end;
except;end;
end;
//## lineheight ##
function tbasiccolors.lineheight:longint;//color palette
begin
try;result:=(2*vizoom)+frcmin(vifontheight,low__aorb(6*vizoom,low__touchsmall,vitouch));except;end;
end;
//## lineheight2 ##
function tbasiccolors.lineheight2:longint;//title
begin
//was: try;result:=(2*vizoom)+frcmin(vifontheight,22);except;end;
try;result:=(2*vizoom)+frcmin(vifontheight,20);except;end;
end;
//## getalignheight ##
function tbasiccolors.getalignheight(xclientwidth:longint):longint;
begin
try;result:=(2*frcmin(findbordersize,1))+xpaintcalc(false);except;end;
end;
//## xsynccount ##
procedure tbasiccolors.xsynccount;
var
   p,int1,int2:longint;
begin
try
int1:=0;
int2:=0;
for p:=0 to high(icaps) do if (length(icaps[p])>=1) then
   begin
   inc(int1);
   int2:=p;
   end;
icount:=int1;
imax:=int2;
except;end;
end;
//## makeadjustable ##
procedure tbasiccolors.makeadjustable;
begin
try;makeadjustable2(4);except;end;
end;
//## makeadjustable2 ##
procedure tbasiccolors.makeadjustable2(xitemsperline:longint);
begin
try
clear;
oshowcaps:=true;
osyscolor:=false;
opopcolor:=true;
otightblocks:=false;
oclicktouse:=false;
itemsperline:=frcmin(xitemsperline,1);
except;end;
end;
//## makesystem ##
procedure tbasiccolors.makesystem;
begin
try
//init
clear;
oshowcaps:=true;
osyscolor:=true;
opopcolor:=true;
otightblocks:=false;
oclicktouse:=false;
itemsperline:=2;
//.frame
addtitle('Frame Colors','Window frame colors');
addcol1('Frame',cnframe,'Frame color');
addcol1('Frame 2',cnframe2,'Frame color 2');
//.title
addtitle('Title Colors','Title colors');
addcol1('Background',cnback2,'Title background color');
addcol1('Border',cnborder2,'Title border color');
addcol1('Highlight',cnhigh2,'Title highlight color');
addcol1('Hover',cnhover2,'Title hover color');
addcol1('Text',cntext2,'Title text color');
addcol1('Text Highlight',cntexthigh2,'Title text highlight color');
addcol1('Text Disable',cntextdis2,'Title text disable color');
addcol1('Disable',cndis2,'Title disable color');
addcol1('Disable Border',cndisbr2,'Title disable border color');
//.standard
addtitle('Standard Colors','Standard colors');
addcol1('Background',cnback1,'Standard background color');
addcol1('Border',cnborder1,'Standard border color');
addcol1('Highlight',cnhigh1,'Standard highlight color');
addcol1('Hover',cnhover1,'Standard hover color');
addcol1('Text',cntext1,'Standard text color');
addcol1('Text Highlight',cntexthigh1,'Standard text highlight color');
addcol1('Text Disable',cntextdis1,'Standard text disable color');
addcol1('Disable',cndis1,'Standard disable color');
addcol1('Disable Border',cndisbr1,'Standard disable border color');
//.standard
addtitle('Special Color Generators','Color Generators');
addcol1('Frame',cnsFrame,'Select a single color and generate all Frame colors automatically');
addcol1('Title',cnsTitle,'Select a single color and generate all Title colors automatically');
addcol1('Standard',cnsStandard,'Select a single color and generate all Standard colors automatically');
addcol1('All in one',cnsAllinone,'Select a single color and generate all Frame, Title and Standard colors automatically');
addcol1('Dark + Light',cnsDark_light,'Select a single color and generate all Frame, Title (darker) and Standard (lighter) colors automatically');
addcol1('Light + Dark',cnsLight_dark,'Select a single color and generate all Frame, Title (lighter) and Standard (darker) colors automatically');
except;end;
end;
//## makestatic ##
procedure tbasiccolors.makestatic;
const
   xleft=true;
   xright=false;
var
   xval,xval2,xcount,p:longint;
   //## cadd ##
   function cadd(sshift,sr,sg,sb:longint;xrev:boolean):boolean;
   var
      dv,dr,dg,db:longint;
      //## xuseval ##
      function xuseval(x:longint):longint;
      begin
      if (x>=0) then result:=frcrange(x,0,255)
      else           result:=frcrange(round((-x*dv)/255),0,255);
      end;
   begin
   //defaults
   result:=false;
   //check
   if (xval=-1) then
      begin
      xval:=255;//init
      xval2:=70;
      end;
   if (xval2>255) then xval2:=255;
   if (xval<=70) then
      begin
      xval:=255;
      xval2:=70;
      exit;
      end;
   if xrev then dv:=xval2 else dv:=xval;
   //decide
   case sshift of
   1:begin
      dr:=sb;
      dg:=sr;
      db:=sg;
      end;
   2:begin
      dr:=sg;
      dg:=sb;
      db:=sr;
      end;
   else
      begin
      dr:=sr;
      dg:=sg;
      db:=sb;
      end;
   end;//case
   dr:=xuseval(dr);
   dg:=xuseval(dg);
   db:=xuseval(db);
   //get
   xadd(0,inttostr(xcount+1),inttostr(xcount+1),'Click to acquire color',0,low__rgb(dr,dg,db),0);
   inc(xcount);
   //dec
   dec(xval,25);
   inc(xval2,25);
   //successful
   result:=true;
   end;
begin
try
//init
clear;
oshowcaps:=false;
osyscolor:=false;
opopcolor:=false;
otightblocks:=true;
oclicktouse:=true;
iitemsperline:=16;
xcount:=0;
xval:=-1;//init

//red -> green -> blue
for p:=0 to 2 do
begin
//normal
while true do if not cadd(p,-255,0,0,xleft) then break;
while true do if not cadd(p,-255,-64,-64,xright) then break;
//128
while true do if not cadd(p,-255,-128,0,xleft) then break;
while true do if not cadd(p,-255,-128,-64,xright) then break;
//255
while true do if not cadd(p,-255,-255,0,xleft) then break;
while true do if not cadd(p,-255,-255,-64,xright) then break;
end;

//special
for p:=0 to 2 do
begin
while true do if not cadd(p,-128,-64,0,xleft) then break;
while true do if not cadd(p,-64,-128,0,xright) then break;
end;

while true do if not cadd(p,-128,-128,-128,xright) then break;

except;end;
end;
//## _onpaint ##
procedure tbasiccolors._onpaint(sender:tobject);
begin
try;xpaintcalc(true);except;end;
end;
//## xpaintcalc ##
function tbasiccolors.xpaintcalc(xmustpaint:boolean):longint;
const//Supports enhanced shading
   _hsp=2;
   _vsp=2;
var
   //infovars
   a:pvirtualinfo;
   v:longint;
   cs,ci:trect;
   hsp,vsp,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xfont2,xback,xback2,xborder,xhover,xfontheight,xfeather,xbordersize:longint;
   xenabled,xround,xnormal:boolean;
   //other
   b:trect;
   xzoom,int2,int1,xlaststyle,xlineheight,xlineheight2,dcount,xcount,xsetwidth,xcapright,p,dx,dy:longint;
   z:string;
   xtightblocks,xonce:boolean;
   //## xlink ##
   function xlink(zindex:longint):trect;
   var
      br,bc,tc,tw:longint;
      z:string;
      xtitle:boolean;
   begin
   //defaults
   result:=nilrect;
   //check
   z:=icaps[zindex];
   if (z='') then exit;
   xtitle:=(istys[zindex]=1);
   if xtitle and xtightblocks then exit;//don't draw titles when in xtightblocks mode
   //get
   z:=#32+z+#32;
   tw:=low__fonttextwidth2(fn,z);
   case xtitle of
   false:begin
      result:=rect(dx,dy,dx+xsetwidth-1,dy+xlineheight-1);
      if xtightblocks then
         begin
         if ((ci.right-result.right)<xsetwidth) then result.right:=ci.right;//stretch to far right -> no right rounding gap
         //no: looks bad: if ((ci.bottom-result.bottom)<xlineheight) then result.bottom:=ci.bottom;//stretch to far bottom -> no bottom rounding gap
         end;
      if xmustpaint then
         begin
         //init
         br:=xborder;
         bc:=icols[zindex];
         tc:=low__invert2b(bc,true);
         case xtightblocks of
         false:begin
            ldso(result,br,bc,viround);//color block
            if oshowcaps then ldt(result,dx+((xsetwidth-tw) div 2),dy+((xlineheight-fnH) div 2),tc,z,fn,xfeather,xround);//text
            end;
         true:begin                     //show the click
            ldso(result,low__aorb(bc,tc,oclicktouse and (zindex=idownindex)),bc,false);//color block
            end;
         end;//case
         end;
      end;
   true:begin//title
      result:=rect(ci.left,dy,ci.right,dy+xlineheight2-1);
      if xmustpaint then
         begin
         //init
         br:=low__aorb(vititle.disableborder,vititle.border,xenabled);
         bc:=low__aorb(vititle.disable,vititle.background,xenabled);
         tc:=low__aorb(vititle.disablefont,vititle.font,xenabled);
         //color block
         ldso(result,br,bc,viround);
         //text
         ldt(result,result.left+2,dy+((xlineheight2-fnH) div 2),tc,z,fb,xfeather,xround);
         end;
      end;
   end;//case
   end;
begin
try//Note: The "ostatic/otightblocks" were designed to present static colors on screen but has been halted due to it's
   //      unsatisfactory appearance for now - 02mar2021
//defaults
result:=0;
xzoom:=vizoom;

//init
infovars2(a,cs,ci,fn,fb,fnH,fbH,fnbH,cw,ch,xfont,xfontdisable,xfont2,xback,xback2,xborder,xhover,xfontheight,xfeather,xbordersize,xenabled,xround,xnormal);

//.xcount + xsetwidth
xtightblocks:=otightblocks;
hsp:=low__insint(_hsp*xzoom,not xtightblocks);
vsp:=low__insint(_vsp*xzoom,not xtightblocks);
xcount:=low__aorb(icount,itemsperline,itemsperline>=1);
xsetwidth:=frcmin( (ci.right-ci.left+1-((xcount+1)*hsp)) div frcmin(xcount,1),1);
if xtightblocks then
   begin
   int1:=0;
   for p:=0 to high(icaps) do if (icaps[p]<>'') and (istys[p]=0) then inc(int1);
   int2:=int1 div xcount;
   if ((int2*xcount)<>int1) then inc(int2);
   xlineheight:=(ci.bottom-ci.top+1) div int2;
   xlineheight2:=xlineheight;
   end
else
   begin
   xlineheight:=lineheight;//color palette
   xlineheight2:=lineheight2;//title
   end;
xlaststyle:=-1;
xonce:=true;

//cls
if xmustpaint then lds2(cs,xback2,xback,clnone,0,'g50',false);

//links
dx:=ci.left+hsp;
dy:=ci.top;
dcount:=0;
for p:=0 to high(icaps) do
begin
if (icaps[p]<>'') then
   begin
   if xonce and (istys[p]<>1) then inc(dy,vsp);
   inc(dcount);
   if (dcount>xcount) or ((istys[p]=1) and (xlaststyle=0)) or ((xlaststyle<>istys[p]) and (not xonce)) then
      begin
      dcount:=1;
      dx:=ci.left+hsp;
      inc(dy,low__aorb(xlineheight,xlineheight2,(xlaststyle=1))+vsp);
      if (istys[p]=1) and (xlaststyle<>1) then inc(dy,3);
      end;
   b:=xlink(p);
   if xmustpaint then irecs[p]:=b;
   inc(dx,xsetwidth+hsp);
   xlaststyle:=istys[p];
   xonce:=false;
   end
else
   begin
   if xmustpaint then irecs[p]:=nilrect;
   end;
end;//p

//frame
if xmustpaint and (xbordersize>=1) then ldf(cs,xborder,low__dc(xback,-20),xbordersize,nil,xround);
if xmustpaint then xparentcorners;

//return result
if (dy>=1) then result:=dy+xlineheight+vsp;
except;end;
end;
//## _onnotify ##
function tbasiccolors._onnotify(sender:tobject):boolean;
var
   int1,int2,p:longint;
   //## xfinditem ##
   function xfinditem(s:tpoint;var xindex:longint):boolean;
   var
      p:longint;
   begin
   result:=false;
   xindex:=-1;
   for p:=0 to high(icaps) do if (icaps[p]<>'') and low__withinrect2(s,irecs[p]) then
      begin
      xindex:=p;
      result:=true;
      break;
      end;
   end;
   //## xfinditem2 ##
   function xfinditem2(s:tpoint;var xindex:longint):boolean;
   var
      p:longint;
   begin
   result:=false;
   xindex:=-1;
   for p:=0 to high(icaps) do if (icaps[p]<>'') and (istys[p]=0) and low__withinrect2(s,irecs[p]) then
      begin
      xindex:=p;
      result:=true;
      break;
      end;
   end;
begin
try
//defaults
result:=false;

//mouse down
if gui.mousedownstroke then
   begin
   result:=true;
   xfinditem2(mousedownxy,idownindex);
   paintnow;
   end;

//mouse move
if gui.mousemoved and (not gui.mousedown) then
   begin
   result:=true;
   if xfinditem(mousexy,p) then help2:=ihlps[p] else help2:='';
   end;
if gui.mousemoved and gui.mousedown then
   begin
   result:=true;
   if opopcolor and (idownindex>=0) and (idownindex<=high(icaps)) and gui.mousedraggingout3(clientarea.left,clientarea.top,irecs[idownindex],true,true) then col[idownindex]:=low__capcolor(0,0,true);
   end;

//mouse up
if gui.mouseupstroke then
   begin
   result:=true;
   //reset
   if (idownindex>=0) then
      begin
      int1:=idownindex;
      idownindex:=-1;
      if oclicktouse and (int1>=0) and (not gui.mousewasdraggingout) and assigned(foncolor) then
         begin
         foncolor(self,icols[int1]);
         end
      else if opopcolor and (int1>=0) and (not gui.mousewasdraggingout) then
         begin
         int2:=col[int1];
         if gui.popcolor(int2) then col3[int1]:=int2;//25may2021, 25feb2021
         end;
      paintnow;
      end;
   end;

//external event override - 01mar2021
if assigned(fonnotify) then fonnotify(sender);
except;end;
end;

//## tmainhelp #################################################################
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx//hhhhhhhhhhhhhhhhhhhhhhhhhh
//## create ##
constructor tmainhelp.create2(xparent:tobject;xscroll,xstart:boolean);
var
   a:tstr8;
   e:string;
begin
inherited create2(xparent,false,false);//force "xscroll=false" - fixed 02aug2021
//** Information ***
//Use special insert tags to insert text and images using a txt or bwd document:
// [l] or [c] or [r] = align single line of text as left, center or right align
// [fa7]             = insert "programbanner2" image - 31may2021
// [banner]          = insert "programbanner" image
// [sep]             = insert "tepBanner" text image
// [*]               = insert "tepBullet" text image
// [programname]     = insert "programname" text
// [programversion]  = insert "programversion" text
// [programurl]      = insert program website url
// [programzip]      = insert program website zip
// [softwareurl      = insert software website url
// [vintageurl]      = insert vintage website url
// [beurl]           = insert portal address for Blaiz Enterprises
// [bename]          = insert Blaiz Enterprises name "BlaizEnterprises.com"
// [twitterurl]      = insert BE twitter url
// [facebookurl]     = insert BE facebook url
// [instagramurl]    = insert BE instagram url
// [t]               = mark as $claude.header1 and include as a help topic
// [h1]..[h5]        = mark as $claude.header1..5 and include as a help topic

//defaults
a:=nil;
//vars
bordersize:=0;
ibuildingcontrol:=true;
ifasttimer:=ms64;
itopics:=tdynamicstring.create;

//xhead.make_bare.caption:='Help';xhead.osmall:=true;
xtoolbar;
xtoolbar.add('Help Topics',tepbook20,0,'topics','Show Help Topics list');
xtoolbar.add('Menu',tepmenu20,0,'menu','Show menu');
xtoolbar.hcsadd('B/W',tepBW20,0,'bw','Switch between program colors and high-contrast black and white',0);
//was: xtoolbar.add('Smaller',tepless20,0,'smaller','Decrease text size');
//was: xtoolbar.add('Larger',tepmore20,0,'larger','Increase text size');
//xtoolbar.add('Text',tepless20,0,'smaller','Decrease text size');
//xtoolbar.add2('Size',tepmore20,0,'larger','Increase text size',true);
//xtoolbar.addsep;
xtoolbar.add('',tepless20,0,'smaller','Decrease text size');
xtoolbar.add2('',tepmore20,0,'larger','Increase text size',true);
xtoolbar.add('Hide',tepHide20,0,'closehelp','Hide Built-in Help');
xtoolbar.bvisible2['topics']:=false;//hide by default

//.text box
if not system_debug then acheck(programhelp,programhelp_check);//checker

a:=bnew;
a.aadd(programhelp);
if (anyformatb(a)='ZIP') then low__decompress(a,e);//zip support - 08jan2022
ibwp:=nbwp4(programname+' Help',a,wwsWindow,false,false,false,programhelp_mustransform,true);
ibwp.makeviewonly;
ibwp.core.onefontname:='$fontname';

//ibwp.bordersize:=0;
ibwp.oautoheight:=true;
ibwp.ousepagecolor:=true;
ibwp.claudesupport;
ibwp.wrap:=wwsWindow;
ibwp.wrapreadonly:=true;//lock in wrap mode - 12mar2021
ibwp.setfocus;
xhelptopics;


//write draft help to disk
//a:=bnew;ibwp.iogetbwd(a);low__tofile('c:\temp\'+programname+'-help-draft.bwd',a,e);showbasic('Draft help for '+programname+' written to disk');//xxxxxxxxxxxxxxxxxxxx

//events
xtoolbar.onclick:=__onclick;

//defaults
ibuildingcontrol:=false;
ocanshowmenu:=true;
//free
bfree(a);
//start
if xstart then start;//fixed - 02aug2021
end;
//## destroy ##
destructor tmainhelp.destroy;
begin
try
ibuildingcontrol:=true;
timer:=false;
inherited destroy;
freeobj(@itopics);
except;end;
end;
//## xsetroundstyle ##
procedure tmainhelp.xsetroundstyle(x:longint);//15mar2022
begin
try
xtoolbar.oroundstyle:=x;
ibwp.oroundstyle:=x;
except;end;
end;
//## showmenuFill ##
procedure tmainhelp.showmenuFill(xstyle:string;xmenudata:tstr8;var ximagealign:longint;var xmenuname:string);
var
   str1:string;
   int1,p:longint;
begin
try
//check
if zznil(xmenudata,2318) then exit;
xmenuname:='mainhelp.1';

if (xstyle='menu') then
   begin
   //edit
   low__menutitle(xmenudata,tepnone,'Edit Options','Edit Options');
   int1:=ximagealign;
   str1:=xmenuname;
   ibwp.showmenuFill('',xmenudata,int1,str1);
   //special mode
   if system_debug then low__menuitem2(xmenudata,tepcopy20,'Copy Document To Clipboard','Copy document to clipboard','bwp.copyallbwp',100,aknone,true);
   //settings
   low__menutitle(xmenudata,tepnone,'Settings','Settings');
   low__menuitem2(xmenudata,tepmore20,'Increase Text Size','Increase text size','larger',100,aknone,true);
   low__menuitem2(xmenudata,tepless20,'Decrease Text Size','Decrease text size','smaller',100,aknone,true);
   low__menuitem2(xmenudata,tep__yes(vihelp_bw),'High-Contrast Black and White','Ticked: Show help in high-contrast black and white','toggle.helpbw',100,aknone,true);
   low__menuitem2(xmenudata,tep__yes(vihelp_max),'Full Height Help','Toggle full height help display','helpmax.toggle',100,aknone,true);
   low__menuitem2(xmenudata,tephide20,'Hide Help','Hide Built-in Help','closehelp',100,aknone,true);
   end;
except;end;
end;
//## showmenuClick ##
function tmainhelp.showmenuClick(sender:tobject;xstyle:string;xcode:longint;xcode2:string;xtepcolor:longint):boolean;
begin
try
//handled
result:=true;

//information
if (xcode2='help') then gui.xshowhelp
else if (strcopy1(xcode2,1,4)='bwp.') then ibwp.showmenuClick(sender,xstyle,xcode,xcode2,xtepcolor)
else if (xcode2='closehelp') then low__showhelp(false)
else if (xcode2='smaller') then low__wordcore_str(ibwp.core^,'all','-')
else if (xcode2='larger') then low__wordcore_str(ibwp.core^,'all','+')
else if (xcode2='toggle.helpbw') then
   begin
   syssettings.b['help.bw']:=not syssettings.b['help.bw'];
   visyncandsave;
   end
else if (xcode2='helpmax.toggle') then
   begin
   syssettings.b['help.max']:=not vihelp_max;//18dec2021
   visyncandsave;
   end
//not handled
else result:=false;
except;end;
end;
//## xhelptopics ##
procedure tmainhelp.xhelptopics;
label
   skipend;
const
   llimit=20;
var
   xlast10,lcount,lp,p2,p,xlen:longint;
   c:twordcharinfo;
   ltopicok:boolean;
   xstr:tstr8;
begin
try
//defaults
xstr:=nil;
//check
if (not programhelp_showtopics) or zznil(itopics,2356) or zznil(ibwp,2357) or (ibwp.core=nil) then exit;
//clear
itopics.clear;
//init
xstr:=bnew;
xlen:=blen(ibwp.core.data);
if (xlen<=0) then goto skipend;
xlast10:=minint;
//get
lp:=1;
lcount:=0;
ltopicok:=false;
for p:=1 to xlen do
begin
if low__wordcore__charinfo(ibwp.core^,p,c) then
   begin
   if (c.cs=wc_t) then
      begin
      if (c.c=ss10) then
         begin
         xlast10:=p;
         //.include as a topic
         if ltopicok then
            begin
            xstr.clear;
            for p2:=lp to (p-1) do
            begin
            if not low__wordcore__charinfo(ibwp.core^,p2,c) then break;
            if (c.cs=wc_t) then xstr.addbyt1(ibwp.core^.data.pbytes[p2-1])
            else if (c.cs=wc_i) then xstr.addbyt1(ssSpace);
            end;//p2
            //.add topic
            itopics.value[itopics.count]:=inttostr(lp)+'|'+xstr.text;//start of topic + topic text - 03apr2021
            xstr.clear;
            end;
         lp:=p+1;
         lcount:=0;
         ltopicok:=false;
         end
      else
         begin
         inc(lcount);
         if (lcount<=llimit) and (not ltopicok) then
            begin
            if      programhelp_claudeheader1 and low__comparetext(ibwp.core.txtname[c.wid],'$claude.header1') then ltopicok:=true
            else if programhelp_claudeheader2 and low__comparetext(ibwp.core.txtname[c.wid],'$claude.header2') then ltopicok:=true
            else if programhelp_claudeheader3 and low__comparetext(ibwp.core.txtname[c.wid],'$claude.header3') then ltopicok:=true
            else if programhelp_claudeheader4 and low__comparetext(ibwp.core.txtname[c.wid],'$claude.header4') then ltopicok:=true
            else if programhelp_claudeheader5 and low__comparetext(ibwp.core.txtname[c.wid],'$claude.header5') then ltopicok:=true;
            end;
         end;
      end;
   end
else break;
end;//p
//set
xtoolbar.bvisible2['topics']:=(itopics.count>=1);
skipend:
except;end;
try;bfree(xstr);except;end;
end;
//## _ontimer ##
procedure tmainhelp._ontimer(sender:tobject);
var
   bol1:boolean;
begin
try
//.ifasttimer
if (ms64>=ifasttimer) then
   begin
   bol1:=vihelp_bw;
   ibwp.syscols:=not bol1;
   xtoolbar.bhighlight2['bw']:=bol1;
   xtoolbar.bflash2['bw']:=bol1;
   //reset
   ifasttimer:=ms64+200;
   end;
except;end;
end;
//## __onclick ##
procedure tmainhelp.__onclick(sender:tobject);
var
   xcode2,str1,n:string;
   xcode,xtepcolor,int1,xpos,v:longint;
   xonce:boolean;
   m:tstr8;
   //## xnexttopic ##
   function xnexttopic(var xtextpos:longint;var xtext:string):boolean;
   var
      xdata:string;
      xlen,p:longint;
   begin
   try
   //defaults
   result:=false;
   xtextpos:=1;
   xtext:='';
   //check
   if (xpos<0) then xpos:=0;
   if (xpos>=itopics.count) then exit;
   //init
   xdata:=itopics.value[xpos];
   xlen:=length(xdata);
   //get
   if (xlen>=2) then
      begin
      for p:=1 to xlen do if (strcopy1(xdata,p,1)='|') then
         begin
         xtextpos:=strint(strcopy1(xdata,1,p-1));
         xtext:=strcopy1(xdata,p+1,xlen);
         break;
         end;//p
      end;
   //inc
   inc(xpos);
   //successful
   result:=true;
   except;end;
   end;
begin
try
//defaults
m:=nil;
//check
if zznil(sender,2359) then exit;
//get
if (sender is tbasictoolbar) then
   begin
   //init
   n:=low__lowercase((sender as tbasictoolbar).ocode2);
   v:=(sender as tbasictoolbar).ocode;
   //get
   if (n='bw') then showmenuClick(sender,'',100,'toggle.helpbw',clnone)
   else if (n='closehelp') then low__showhelp(false)
   else if (n='smaller') then showmenuClick(sender,'',100,'smaller',clnone)
   else if (n='larger') then showmenuClick(sender,'',100,'larger',clnone)
   else if (n='menu') then showmenu2('menu')
   else if (n='topics') then
      begin
      //get
      m:=bnew;
      low__menuinit(m);
      low__menutitle(m,tepNone,'Help Topics','Select a help topic to view');
      xonce:=true;
      xpos:=0;
      while true do
      begin
      if xnexttopic(int1,str1) then
         begin
         if (str1<>'') then
            begin
            if xonce then
               begin
               xonce:=false;
               if (int1>1) then low__menuitem2(m,tepUp20,'Start of Help','Scroll to beginning of help','help.topic',100+1,aknone,true);
               end;
            low__menuitem2(m,tepHelpdoc20,str1,'Select help topic to view','help.topic',100+int1,aknone,true);
            end;
         end
      else break;
      end;
      low__menuend(m);
      //show
      if gui.popmenu2(pmNormal,iaNormal,m,'help.viewer',lslist,xcode,xcode2,xtepcolor) then
         begin
         if (xcode2='help.topic') then
            begin
            ibwp.vscrolltopos(xcode-100);
            ibwp.setfocus;//refocus the text box - 27apr2022
            end;
         end;
      end;
   end;
except;end;
try;bfree(m);except;end;
end;


initialization
  siInit;

finalization
  siHalt;

end.



